<Events startTimestamp="1576666505112" logVersion="1.0.0.201911281918">
  <Command __id="23357" _type="EclipseCommand" commandID="org.eclipse.ui.file.save" date="Fri Dec 20 08:54:26 EST 2019" starttimestamp="1576666505112" timestamp="183561304" />
  <DocumentChange __id="23414" _type="Insert" date="Fri Dec 20 08:57:09 EST 2019" docASTNodeCount="184" docActiveCodeLength="1396" docExpressionCount="142" docLength="1591" length="2" offset="929" starttimestamp="1576666505112" timestamp="183724722">
    <text><![CDATA[//]]></text>
  </DocumentChange>
  <DocumentChange __id="23415" _type="Insert" date="Fri Dec 20 08:57:09 EST 2019" docASTNodeCount="179" docActiveCodeLength="1337" docExpressionCount="138" docLength="1593" length="2" offset="959" starttimestamp="1576666505112" timestamp="183724724">
    <text><![CDATA[//]]></text>
  </DocumentChange>
  <Command __id="23426" _type="ShellCommand" date="Fri Dec 20 08:58:09 EST 2019" starttimestamp="1576666505112" timestamp="183784155" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="23428" _type="MoveCaretCommand" caretOffset="0" date="Fri Dec 20 08:58:41 EST 2019" docOffset="0" starttimestamp="1576666505112" timestamp="183816516" />
  <Command __id="23429" _type="MoveCaretCommand" caretOffset="394" date="Fri Dec 20 08:58:49 EST 2019" docOffset="394" starttimestamp="1576666505112" timestamp="183823914" />
  <Command __id="23430" _type="ShellCommand" date="Fri Dec 20 08:58:57 EST 2019" starttimestamp="1576666505112" timestamp="183832144" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="23431" _type="ShellCommand" date="Fri Dec 20 08:59:00 EST 2019" starttimestamp="1576666505112" timestamp="183835589" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="23432" _type="ShellCommand" date="Fri Dec 20 08:59:02 EST 2019" starttimestamp="1576666505112" timestamp="183837380" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="23427" _type="DiffBasedFileOpenCommand" date="Fri Dec 20 08:58:41 EST 2019" docASTNodeCount="1" docActiveCodeLength="496" docExpressionCount="0" docLength="520" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="183816195">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\sum_parallel_for_reduction.cpp]]></filePath>
    <diff><![CDATA[null]]></diff>
    <snapshot><![CDATA[#include <iostream>
#include <omp.h>

using namespace std;

//const int SIZE = 1000;
void printSumWithTimes(int sum, int start, int end);
void printNumThreads();
void recordThreadIndex(int index);
void sum_parallel_for_reduction(double* array, int size) {
	cout << "sum_parallel_for_reduction\n";

	double start = omp_get_wtime();

	double sum = 0;
    #pragma omp parallel for reduction(+:sum)

	for (int i = 0; i < size; i++)
		sum += array[i];

	double end = omp_get_wtime();

	printSumWithTimes(sum, start, end);

}
]]></snapshot>
  </Command>
  <Command __id="23433" _type="ShellCommand" date="Fri Dec 20 08:59:24 EST 2019" starttimestamp="1576666505112" timestamp="183859785" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="23435" _type="MoveCaretCommand" caretOffset="0" date="Fri Dec 20 08:59:32 EST 2019" docOffset="0" starttimestamp="1576666505112" timestamp="183867015" />
  <Command __id="23434" _type="DiffBasedFileOpenCommand" date="Fri Dec 20 08:59:31 EST 2019" docASTNodeCount="1" docActiveCodeLength="422" docExpressionCount="0" docLength="422" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="183866862">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\sum_parallel.cpp]]></filePath>
    <diff><![CDATA[null]]></diff>
    <snapshot><![CDATA[#include <iostream>
#include <omp.h>

using namespace std;

void printSumWithTimes(int sum, int start, int end);
void printNumThreads();
void recordThreadIndex(int index);
void sum_parallel(double* array, int size) {
	cout << "sum_parallel\n";

	double start = omp_get_wtime();

	double sum = 0;

	for (int i = 0; i < size; i++)
		sum += array[i];

	double end = omp_get_wtime();

	printSumWithTimes(sum, start, end);


}
]]></snapshot>
  </Command>
  <Command __id="23436" _type="MoveCaretCommand" caretOffset="296" date="Fri Dec 20 08:59:46 EST 2019" docOffset="296" starttimestamp="1576666505112" timestamp="183881637" />
  <Command __id="23438" _type="PasteCommand" date="Fri Dec 20 08:59:48 EST 2019" starttimestamp="1576666505112" timestamp="183883011" />
  <Command __id="23439" _type="MoveCaretCommand" caretOffset="296" date="Fri Dec 20 08:59:50 EST 2019" docOffset="296" starttimestamp="1576666505112" timestamp="183884925" />
  <Command __id="23441" _type="InsertStringCommand" date="Fri Dec 20 08:59:50 EST 2019" starttimestamp="1576666505112" timestamp="183885756" timestamp2="183885756">
    <data><![CDATA[	]]></data>
  </Command>
  <DocumentChange __id="23437" _type="Insert" date="Fri Dec 20 08:59:48 EST 2019" docASTNodeCount="1" docActiveCodeLength="443" docExpressionCount="0" docLength="443" length="21" offset="296" starttimestamp="1576666505112" timestamp="183883002">
    <text><![CDATA[#pragma omp parallel
]]></text>
  </DocumentChange>
  <DocumentChange __id="23440" _type="Insert" date="Fri Dec 20 08:59:50 EST 2019" docASTNodeCount="1" docActiveCodeLength="444" docExpressionCount="0" docLength="444" length="1" offset="296" starttimestamp="1576666505112" timestamp="183885744">
    <text><![CDATA[	]]></text>
  </DocumentChange>
  <Command __id="23442" _type="MoveCaretCommand" caretOffset="317" date="Fri Dec 20 08:59:52 EST 2019" docOffset="317" starttimestamp="1576666505112" timestamp="183887394" />
  <Command __id="23444" _type="EclipseCommand" commandID="org.eclipse.ui.edit.delete" date="Fri Dec 20 08:59:53 EST 2019" starttimestamp="1576666505112" timestamp="183888452" />
  <DocumentChange __id="23443" _type="Delete" date="Fri Dec 20 08:59:53 EST 2019" docASTNodeCount="1" docActiveCodeLength="443" docExpressionCount="0" docLength="443" endLine="15" length="1" offset="317" startLine="14" starttimestamp="1576666505112" timestamp="183888443">
    <text><![CDATA[
]]></text>
  </DocumentChange>
  <DocumentChange __id="23446" _type="Insert" date="Fri Dec 20 08:59:56 EST 2019" docASTNodeCount="1" docActiveCodeLength="445" docExpressionCount="0" docLength="445" length="2" offset="295" starttimestamp="1576666505112" timestamp="183891269">
    <text><![CDATA[
	]]></text>
  </DocumentChange>
  <Command __id="23445" _type="MoveCaretCommand" caretOffset="295" date="Fri Dec 20 08:59:55 EST 2019" docOffset="295" starttimestamp="1576666505112" timestamp="183890398" />
  <Command __id="23447" _type="InsertStringCommand" date="Fri Dec 20 08:59:56 EST 2019" starttimestamp="1576666505112" timestamp="183891276" timestamp2="183891276">
    <data><![CDATA[]]></data>
  </Command>
  <Command __id="23449" _type="EclipseCommand" commandID="org.eclipse.ui.file.save" date="Fri Dec 20 08:59:57 EST 2019" starttimestamp="1576666505112" timestamp="183892618" />
  <Command __id="23450" _type="ShellCommand" date="Fri Dec 20 09:00:01 EST 2019" starttimestamp="1576666505112" timestamp="183896216" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="23451" _type="ShellCommand" date="Fri Dec 20 09:00:46 EST 2019" starttimestamp="1576666505112" timestamp="183941831" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="23452" _type="ShellCommand" date="Fri Dec 20 09:01:11 EST 2019" starttimestamp="1576666505112" timestamp="183966137" type="ECLIPSE_LOST_FOCUS" />
  <DocumentChange __id="23506" _type="Insert" date="Fri Dec 20 09:02:15 EST 2019" docASTNodeCount="324" docActiveCodeLength="1992" docExpressionCount="214" docLength="1992" length="1" offset="983" starttimestamp="1576666505112" timestamp="184030588">
    <text><![CDATA[/]]></text>
  </DocumentChange>
  <Command __id="23546" _type="ShellCommand" date="Fri Dec 20 09:02:35 EST 2019" starttimestamp="1576666505112" timestamp="184050827" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="23547" _type="DiffBasedFileOpenCommand" date="Fri Dec 20 09:02:39 EST 2019" docASTNodeCount="1" docActiveCodeLength="496" docExpressionCount="0" docLength="520" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="184054593">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\sum_parallel_for_reduction.cpp]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"#include <iostream>¶#include <omp.h>¶¶using namespace std;¶¶//const int SIZE = 1000;¶void printSumWithTimes(int sum, int start, int end);¶void printNumThreads();¶void recordThreadIndex(int index);¶void sum_parallel_for_reduction(double* array, int size) {¶	cout << "sum_parallel_for_reduction\n";¶¶	double start = omp_get_wtime();¶¶	double sum = 0;¶    #pragma omp parallel for reduction(+:sum)¶¶	for (int i = 0; i < size; i++)¶		sum += array[i];¶¶	double end = omp_get_wtime();¶¶	printSumWithTimes(sum, start, end);¶¶}¶")]]]></diff>
  </Command>
  <Command __id="23549" _type="EclipseCommand" commandID="" date="Fri Dec 20 09:02:40 EST 2019" starttimestamp="1576666505112" timestamp="184055708" />
  <Command __id="23550" _type="EclipseCommand" commandID="" date="Fri Dec 20 09:02:40 EST 2019" starttimestamp="1576666505112" timestamp="184055819" />
  <Command __id="23552" _type="MoveCaretCommand" caretOffset="296" date="Fri Dec 20 09:03:08 EST 2019" docOffset="296" starttimestamp="1576666505112" timestamp="184083093" />
  <Command __id="23551" _type="DiffBasedFileOpenCommand" date="Fri Dec 20 09:03:08 EST 2019" docASTNodeCount="1" docActiveCodeLength="444" docExpressionCount="0" docLength="444" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="184082968">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\sum_parallel.cpp]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"#include <iostream>¶#include <omp.h>¶¶using namespace std;¶¶void printSumWithTimes(int sum, int start, int end);¶void printNumThreads();¶void recordThreadIndex(int index);¶void sum_parallel(double* array, int size) {¶	cout << "sum_parallel\n";¶¶	double start = omp_get_wtime();¶¶	double sum = 0;¶¶"), Diff(INSERT,"	#pragma omp parallel¶"), Diff(EQUAL,"	for (int i = 0; i < size; i++)¶		sum += array[i];¶¶	double end = omp_get_wtime();¶¶	printSumWithTimes(sum, start, end);¶¶¶}¶")]]]></diff>
    <snapshot><![CDATA[#include <iostream>
#include <omp.h>

using namespace std;

void printSumWithTimes(int sum, int start, int end);
void printNumThreads();
void recordThreadIndex(int index);
void sum_parallel(double* array, int size) {
	cout << "sum_parallel\n";

	double start = omp_get_wtime();

	double sum = 0;

	#pragma omp parallel
	for (int i = 0; i < size; i++)
		sum += array[i];

	double end = omp_get_wtime();

	printSumWithTimes(sum, start, end);


}
]]></snapshot>
  </Command>
  <Command __id="23553" _type="SelectTextCommand" caretOffset="370" date="Fri Dec 20 09:03:16 EST 2019" end="370" start="298" starttimestamp="1576666505112" timestamp="184091272" />
  <Command __id="23557" _type="EclipseCommand" commandID="org.eclipse.cdt.ui.edit.text.c.toggle.comment" date="Fri Dec 20 09:03:17 EST 2019" starttimestamp="1576666505112" timestamp="184092398" />
  <Command __id="23558" _type="MoveCaretCommand" caretOffset="375" date="Fri Dec 20 09:03:19 EST 2019" docOffset="375" starttimestamp="1576666505112" timestamp="184094177" />
  <Command __id="23560" _type="InsertStringCommand" date="Fri Dec 20 09:03:20 EST 2019" starttimestamp="1576666505112" timestamp="184094996" timestamp2="184094996">
    <data><![CDATA[]]></data>
  </Command>
  <Command __id="23562" _type="PasteCommand" date="Fri Dec 20 09:03:21 EST 2019" starttimestamp="1576666505112" timestamp="184095971" />
  <Command __id="23563" _type="MoveCaretCommand" caretOffset="376" date="Fri Dec 20 09:03:23 EST 2019" docOffset="376" starttimestamp="1576666505112" timestamp="184098865" />
  <Command __id="23565" _type="InsertStringCommand" date="Fri Dec 20 09:03:24 EST 2019" starttimestamp="1576666505112" timestamp="184099199" timestamp2="184099199">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="23567" _type="InsertStringCommand" date="Fri Dec 20 09:03:24 EST 2019" starttimestamp="1576666505112" timestamp="184099395" timestamp2="184099395">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="23569" _type="InsertStringCommand" date="Fri Dec 20 09:03:24 EST 2019" starttimestamp="1576666505112" timestamp="184099565" timestamp2="184099565">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="23571" _type="InsertStringCommand" date="Fri Dec 20 09:03:24 EST 2019" starttimestamp="1576666505112" timestamp="184099863" timestamp2="184099863">
    <data><![CDATA[ ]]></data>
  </Command>
  <DocumentChange __id="23554" _type="Insert" date="Fri Dec 20 09:03:17 EST 2019" docASTNodeCount="1" docActiveCodeLength="423" docExpressionCount="0" docLength="446" length="2" offset="297" starttimestamp="1576666505112" timestamp="184092385">
    <text><![CDATA[//]]></text>
  </DocumentChange>
  <DocumentChange __id="23555" _type="Insert" date="Fri Dec 20 09:03:17 EST 2019" docASTNodeCount="1" docActiveCodeLength="392" docExpressionCount="0" docLength="448" length="2" offset="321" starttimestamp="1576666505112" timestamp="184092388">
    <text><![CDATA[//]]></text>
  </DocumentChange>
  <DocumentChange __id="23556" _type="Insert" date="Fri Dec 20 09:03:17 EST 2019" docASTNodeCount="1" docActiveCodeLength="374" docExpressionCount="0" docLength="450" length="2" offset="355" starttimestamp="1576666505112" timestamp="184092389">
    <text><![CDATA[//]]></text>
  </DocumentChange>
  <DocumentChange __id="23559" _type="Insert" date="Fri Dec 20 09:03:20 EST 2019" docASTNodeCount="1" docActiveCodeLength="376" docExpressionCount="0" docLength="452" length="2" offset="375" starttimestamp="1576666505112" timestamp="184094989">
    <text><![CDATA[
	]]></text>
  </DocumentChange>
  <DocumentChange __id="23561" _type="Replace" date="Fri Dec 20 09:03:21 EST 2019" docASTNodeCount="1" docActiveCodeLength="550" docExpressionCount="0" docLength="626" endLine="18" insertionLength="175" int_docASTNodeCount="1" int_docActiveCodeLength="375" int_docExpressionCount="0" int_docLength="451" length="1" offset="376" startLine="18" starttimestamp="1576666505112" timestamp="184095953">
    <deletedText><![CDATA[	]]></deletedText>
    <insertedText><![CDATA[#pragma omp parallel
	{
		double local_sum = 0;
		
		#pragma omp for
		for(int i = 0; i < SIZE; i++)
			local_sum += array[i];
		
		#pragma omp critical
		sum += local_sum;
	}]]></insertedText>
  </DocumentChange>
  <DocumentChange __id="23564" _type="Insert" date="Fri Dec 20 09:03:24 EST 2019" docASTNodeCount="1" docActiveCodeLength="551" docExpressionCount="0" docLength="627" length="1" offset="376" starttimestamp="1576666505112" timestamp="184099181">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="23566" _type="Insert" date="Fri Dec 20 09:03:24 EST 2019" docASTNodeCount="1" docActiveCodeLength="552" docExpressionCount="0" docLength="628" length="1" offset="377" starttimestamp="1576666505112" timestamp="184099386">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="23568" _type="Insert" date="Fri Dec 20 09:03:24 EST 2019" docASTNodeCount="1" docActiveCodeLength="553" docExpressionCount="0" docLength="629" length="1" offset="378" starttimestamp="1576666505112" timestamp="184099549">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="23570" _type="Insert" date="Fri Dec 20 09:03:24 EST 2019" docASTNodeCount="1" docActiveCodeLength="554" docExpressionCount="0" docLength="630" length="1" offset="379" starttimestamp="1576666505112" timestamp="184099851">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="23574" _type="Replace" date="Fri Dec 20 09:03:40 EST 2019" docASTNodeCount="1" docActiveCodeLength="551" docExpressionCount="0" docLength="627" endLine="23" insertionLength="1" int_docASTNodeCount="1" int_docActiveCodeLength="550" int_docExpressionCount="0" int_docLength="626" length="4" offset="470" startLine="23" starttimestamp="1576666505112" timestamp="184115614">
    <deletedText><![CDATA[SIZE]]></deletedText>
    <insertedText><![CDATA[s]]></insertedText>
  </DocumentChange>
  <DocumentChange __id="23576" _type="Insert" date="Fri Dec 20 09:03:40 EST 2019" docASTNodeCount="1" docActiveCodeLength="552" docExpressionCount="0" docLength="628" length="1" offset="471" starttimestamp="1576666505112" timestamp="184115817">
    <text><![CDATA[i]]></text>
  </DocumentChange>
  <DocumentChange __id="23578" _type="Insert" date="Fri Dec 20 09:03:41 EST 2019" docASTNodeCount="1" docActiveCodeLength="553" docExpressionCount="0" docLength="629" length="1" offset="472" starttimestamp="1576666505112" timestamp="184116108">
    <text><![CDATA[z]]></text>
  </DocumentChange>
  <DocumentChange __id="23580" _type="Insert" date="Fri Dec 20 09:03:41 EST 2019" docASTNodeCount="1" docActiveCodeLength="554" docExpressionCount="0" docLength="630" length="1" offset="473" starttimestamp="1576666505112" timestamp="184116226">
    <text><![CDATA[z]]></text>
  </DocumentChange>
  <DocumentChange __id="23582" _type="Insert" date="Fri Dec 20 09:03:41 EST 2019" docASTNodeCount="1" docActiveCodeLength="555" docExpressionCount="0" docLength="631" length="1" offset="474" starttimestamp="1576666505112" timestamp="184116576">
    <text><![CDATA[e]]></text>
  </DocumentChange>
  <DocumentChange __id="23584" _type="Delete" date="Fri Dec 20 09:03:42 EST 2019" docASTNodeCount="1" docActiveCodeLength="554" docExpressionCount="0" docLength="630" endLine="23" length="1" offset="474" startLine="23" starttimestamp="1576666505112" timestamp="184117707">
    <text><![CDATA[e]]></text>
  </DocumentChange>
  <DocumentChange __id="23586" _type="Delete" date="Fri Dec 20 09:03:42 EST 2019" docASTNodeCount="1" docActiveCodeLength="553" docExpressionCount="0" docLength="629" endLine="23" length="1" offset="473" startLine="23" starttimestamp="1576666505112" timestamp="184117866">
    <text><![CDATA[z]]></text>
  </DocumentChange>
  <DocumentChange __id="23588" _type="Insert" date="Fri Dec 20 09:03:43 EST 2019" docASTNodeCount="1" docActiveCodeLength="554" docExpressionCount="0" docLength="630" length="1" offset="473" starttimestamp="1576666505112" timestamp="184118491">
    <text><![CDATA[e]]></text>
  </DocumentChange>
  <Command __id="23572" _type="MoveCaretCommand" caretOffset="471" date="Fri Dec 20 09:03:39 EST 2019" docOffset="471" starttimestamp="1576666505112" timestamp="184114690" />
  <Command __id="23573" _type="SelectTextCommand" caretOffset="474" date="Fri Dec 20 09:03:40 EST 2019" end="474" start="470" starttimestamp="1576666505112" timestamp="184114966" />
  <Command __id="23575" _type="InsertStringCommand" date="Fri Dec 20 09:03:40 EST 2019" starttimestamp="1576666505112" timestamp="184115622" timestamp2="184115622">
    <data><![CDATA[s]]></data>
  </Command>
  <Command __id="23577" _type="InsertStringCommand" date="Fri Dec 20 09:03:40 EST 2019" starttimestamp="1576666505112" timestamp="184115826" timestamp2="184115826">
    <data><![CDATA[i]]></data>
  </Command>
  <Command __id="23579" _type="InsertStringCommand" date="Fri Dec 20 09:03:41 EST 2019" starttimestamp="1576666505112" timestamp="184116120" timestamp2="184116120">
    <data><![CDATA[z]]></data>
  </Command>
  <Command __id="23581" _type="InsertStringCommand" date="Fri Dec 20 09:03:41 EST 2019" starttimestamp="1576666505112" timestamp="184116235" timestamp2="184116235">
    <data><![CDATA[z]]></data>
  </Command>
  <Command __id="23583" _type="InsertStringCommand" date="Fri Dec 20 09:03:41 EST 2019" starttimestamp="1576666505112" timestamp="184116589" timestamp2="184116589">
    <data><![CDATA[e]]></data>
  </Command>
  <Command __id="23585" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Fri Dec 20 09:03:42 EST 2019" starttimestamp="1576666505112" timestamp="184117712" />
  <Command __id="23587" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Fri Dec 20 09:03:42 EST 2019" starttimestamp="1576666505112" timestamp="184117872" />
  <Command __id="23589" _type="InsertStringCommand" date="Fri Dec 20 09:03:43 EST 2019" starttimestamp="1576666505112" timestamp="184118493" timestamp2="184118493">
    <data><![CDATA[e]]></data>
  </Command>
  <Command __id="23592" _type="EclipseCommand" commandID="org.eclipse.ui.file.save" date="Fri Dec 20 09:03:44 EST 2019" starttimestamp="1576666505112" timestamp="184119604" />
  <DocumentChange __id="23590" _type="Delete" date="Fri Dec 20 09:03:44 EST 2019" docASTNodeCount="1" docActiveCodeLength="552" docExpressionCount="0" docLength="628" endLine="25" length="2" offset="507" startLine="25" starttimestamp="1576666505112" timestamp="184119555">
    <text><![CDATA[		]]></text>
  </DocumentChange>
  <DocumentChange __id="23591" _type="Delete" date="Fri Dec 20 09:03:44 EST 2019" docASTNodeCount="1" docActiveCodeLength="550" docExpressionCount="0" docLength="626" endLine="21" length="2" offset="428" startLine="21" starttimestamp="1576666505112" timestamp="184119559">
    <text><![CDATA[		]]></text>
  </DocumentChange>
  <Command __id="23595" _type="DiffBasedFileOpenCommand" date="Fri Dec 20 09:03:59 EST 2019" docASTNodeCount="1" docActiveCodeLength="61671" docExpressionCount="0" docLength="61671" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="184134380">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\Debug\src\sum_parallel_for_local_var.o]]></filePath>
    <diff><![CDATA[null]]></diff>
    <snapshot><![CDATA[d†     ë  1      .text           0  ”  (è           P`.data                               @ PÀ.bss                               € PÀ.rdata              Ä              @ P@.xdata          0   ä              @ 0@.pdata          0      è         @ 0@.ctors             D  é         @ @À/4              u  L  "é      #   @ B/16             y  Á#              @ B/30             0   :'  €ê         @ B/45             Øµ  j'  ”ê         @ B/58             Ó	  BÝ  žê         @ B/70             (   ç              @ B/81                 =ç              @ P@/92                ]ç  ¨ê         @P@/117            ¸   mç  ²ê         @ @BUH‰åHƒì@H‰M‰UH�    H‹    è    è    fH~ÀH‰EèfïÀòEøÇEô    ‹Eô;E}6‹EôH˜H�Å    H‹EHÐò òMøòXÁòEø‹Eô‰Áè    ƒEôëÂè    fH~ÀH‰EàòEàò,ÈòEèò,ÐòEøò,ÀA‰È‰Áè    �HƒÄ@]ÃUH‰åHƒì H�    è    �HƒÄ ]ÃUH‰åHƒì ‰M‰Uƒ}u!�}ÿÿ  uH�    è    H�µÿÿÿè    �HƒÄ ]ÃUH‰åHƒì ºÿÿ  ¹   è­ÿÿÿ�HƒÄ ]Ã���sum_parallel_for_local_var
     rP  2P  2P  2P      ¸       ¸   Ó      Ó          -  $         q       GNU C++ 5.1.0 -mtune=generic -march=x86-64 -mthreads -g3 -O0 -fmessage-length=0 -fopenmp ..\src\sum_parallel_for_local_var.cpp D:\dewan_backup\C\MyOpenMPTraining\Debug         -              std  ­  __cxx11 ÚÚØ   @È  ‹?  �Ú  Žò  �  �4  ‘R  ’{  “˜  ”¹  •Ù  –ñ  —  ˜6  ™_  š„  ›µ  œÒ  ží     ¡-  ¢L  ¤r  §—  ª¼  ¬á  ®  °   ±D  ²b  ³€  ´Ÿ  µ½  ¶Ü  ·  ¸*  ¹N  ºr  »–  ¼Ç  ½å  ¿  Á:  ÂX  Ã{  ÄŸ  ÅÃ  ÆÛ  Çÿ  È#  ÉH  Êl  Ë‡  Ì¡  Í¿  ÎÞ  Ïý  Ð  ?  	m  
‘  __debug 0char_traits<char> éd  char_type ëþ  int_type ìs  	assign ò_ZNSt11char_traitsIcE6assignERcRKc   
à  
æ   ½  eq ö_ZNSt11char_traitsIcE2eqERKcS2_ ì  X  
æ  
æ   lt ú_ZNSt11char_traitsIcE2ltERKcS2_ ì  ‘  
æ  
æ   compare _ZNSt11char_traitsIcE7compareEPKcS2_y s  Û  
ô  
ô  
d   length _ZNSt11char_traitsIcE6lengthEPKc d    
ô   find 
_ZNSt11char_traitsIcE4findEPKcyRS1_ ô  Z  
ô  
d  
æ   move _ZNSt11char_traitsIcE4moveEPcPKcy ú  �  
ú  
ô  
d   copy _ZNSt11char_traitsIcE4copyEPcPKcy ú  à  
ú  
ô  
d   assign _ZNSt11char_traitsIcE6assignEPcyc ú  %  
ú  
d  
½   to_char_type _ZNSt11char_traitsIcE12to_char_typeERKi ½  l  
    Î  to_int_type  _ZNSt11char_traitsIcE11to_int_typeERKc Î  ¶  
æ   eq_int_type $_ZNSt11char_traitsIcE11eq_int_typeERKiS2_ ì    
   
    eof (_ZNSt11char_traitsIcE3eofEv Î  not_eof ,_ZNSt11char_traitsIcE7not_eofERKi Î  
     size_t Ä  5Î  6  7&  ptrdiff_t Å.  _Ios_Fmtflags �  9¾  _S_boolalpha _S_dec _S_fixed _S_hex _S_internal _S_left  _S_oct @_S_right €_S_scientific  _S_showbase  _S_showpoint  _S_showpos  _S_skipws  _S_unitbuf   _S_uppercase  @_S_adjustfield °_S_basefield J_S_floatfield _S_ios_fmtflags_end     _Ios_Openmode �  m)  _S_app _S_ate _S_bin _S_in _S_out _S_trunc  _S_ios_openmode_end     _Ios_Iostate �  •�  _S_goodbit  _S_badbit _S_eofbit _S_failbit _S_ios_iostate_end     _Ios_Seekdir �  »Ú  _S_beg  _S_cur _S_end _S_ios_seekdir_end     ios_base ú  Init S‹	  _S_refcount [8  _S_synced_with_stdio \ì  Init W_ZNSt8ios_base4InitC4Ev R	  X	  [   ~Init X_ZNSt8ios_base4InitD4Ev 	  [  s    fmtflags =˜  boolalpha @±	  ‹	  dec C±	  fixed F±	  hex I±	  internal N±	  left R±	   oct U±	  @right Y±	  €scientific \±	   showbase `±	   showpoint d±	   showpos g±	   skipws j±	   unitbuf m±	    uppercase q±	   @adjustfield t±	  °basefield w±	  Jfloatfield z±	  iostate ˆ)  badbit Œ  î
  eofbit �  failbit ”  goodbit —   openmode §¾  app ªj  J  ate ­j  binary ²j  in µj  out ¸j  trunc »j   seekdir Ç�  beg ÊØ   ¹  cur ÍØ  end ÐØ   	Ra  	Sc  	T?  	\r  	e‘  	h±  	iÊ  basic_ostream<char, std::char_traits<char> > w  _CharT þ  _Traits £   ostream 
�+  cout =_ZSt4cout w   __ioinit Jè   __gnu_cxx Ýæ  __cxx11 ÞÞ¾  ø?  m  ‘  __ops $,d  -‡  __numeric_traits_integer<int> 7Z  !    :L  !   ;L  !   ?Q  !   @L  "   s   __numeric_traits_integer<long unsigned int> 7Ä  !    :V  !   ;V  !   ?Q  !   @L  "   ¹   __numeric_traits_integer<char> 7!  !    :+  !   ;+  !   ?Q  !   @L  "   þ   __numeric_traits_integer<short int> 7ƒ  !    :â  !   ;â  !   ?Q  !   @L  "      #__numeric_traits_integer<long long int> 7!    :ç  !   ;ç  !   ?Q  !   @L  "   .    $__builtin_va_list þ  %char size_t #  %long long unsigned int %long long int wint_t jM  %short unsigned int wctype_t kM  %int %long int &þ  &’  %wchar_t %unsigned int %sizetype %long unsigned int lconv X-m  'decimal_point .†   'thousands_sep /†  'grouping 0†  'int_curr_symbol 1†  'currency_symbol 2†   'mon_decimal_point 3†  ('mon_thousands_sep 4†  0'mon_grouping 5†  8'positive_sign 6†  @'negative_sign 7†  H'int_frac_digits 8þ  P'frac_digits 9þ  Q'p_cs_precedes :þ  R'p_sep_by_space ;þ  S'n_cs_precedes <þ  T'n_sep_by_space =þ  U'p_sign_posn >þ  V'n_sign_posn ?þ  W &Î  %unsigned char _iobuf 0   '_ptr !†   '_cnt "s  '_base #†  '_flag $s  '_file %s  '_charbuf &s   '_bufsiz 's  $'_tmpfname (†  ( FILE *„  %short int (tm $ƒÈ  )tm_sec „s   )tm_min …s  )tm_hour †s  )tm_mday ‡s  )tm_mon ˆs  )tm_year ‰s  )tm_wday Šs  )tm_yday ‹s  )tm_isdst Œs    *mbstate_t ¨s  +btowc «?  ò  
s   +fgetwc |?    
   &  +fgetws …Œ  4  
Œ  
s  
   +fputwc ~?  R  
’  
   +fputws †s  p  
p  
   &v  ’  +fwide ºs  ˜  
  
s   ,fwprintf s  ¹  
  
p  - ,fwscanf òs  Ù  
  
p  - +getwc €?  ñ  
   .getwchar �?  +mbrlen ¬  %  
%  
  
0   &+  þ  &È  +mbrtowc ­  _  
Œ  
%  
  
0   +mbsinit »s  y  
y   &  È  +mbsrtowcs ®  ¯  
Œ  
¯  
  
0   &%  +putwc ‚?  Ò  
’  
   +putwchar ƒ?  í  
’   /swprintf :s    
Œ  
p  - ,swscanf Üs  -  
p  
p  - +ungetwc „?  L  
?  
   ,vfwprintf ,s  r  
  
p  
æ   ,vfwscanf s  —  
  
p  
æ   /vswprintf /s  ¼  
Œ  
p  
æ   ,vswscanf þs  á  
p  
p  
æ   ,vwprintf 3s    
p  
æ   ,vwscanf s     
p  
æ   +wcrtomb ¯  D  
†  
’  
0   +wcscat KŒ  b  
Œ  
p   +wcscmp Ms  €  
p  
p   +wcscoll js  Ÿ  
p  
p   +wcscpy NŒ  ½  
Œ  
p   +wcscspn O  Ü  
p  
p   +wcsftime •    
Œ  
  
p  
   &  $  +wcslen P  *  
p   +wcsncat RŒ  N  
Œ  
p  
   +wcsncmp Ss  r  
p  
p  
   +wcsncpy TŒ  –  
Œ  
p  
   +wcsrtombs °  Á  
†  
Á  
  
0   &p  +wcsspn X  å  
p  
p   ,wcstod     
p  
   %double &Œ  ,wcstof 1  1  
p  
   %float +wcstok ZŒ  X  
Œ  
p   +wcstol z  {  
p  
  
s   +wcstoul !¹  Ÿ  
p  
  
s   +wcsxfrm h  Ã  
Œ  
p  
   +wctob ±s  Û  
?   +wmemcmp ¶s  ÿ  
p  
p  
   +wmemcpy ·Œ  #  
Œ  
p  
   +wmemmove ¹Œ  H  
Œ  
p  
   +wmemset ´Œ  l  
Œ  
’  
   ,wprintf !s  ‡  
p  - ,wscanf çs  ¡  
p  - +wcschr LŒ  ¿  
p  
’   +wcspbrk VŒ  Þ  
p  
p   +wcsrchr WŒ  ý  
p  
’   +wcsstr YŒ    
p  
p   +wmemchr µŒ  ?  
p  
’  
   +wcstold ^  ^  
p  
   %long double +wcstoll ¼.  ‘  
p  
  
s   +wcstoull ½  ¶  
p  
  
s   %signed char __gnu_debug 7à  8˜   0½  0  %bool &  &½  0l  1setlocale P†  &  
s  
%   2localeconv Qm  _Atomic_word  s  s  ì  ¹  &è  wctrans_t ¦’  1iswctype ûs  ‘  
?  
c   1towctrans §?  ±  
?  
a   1wctrans ¨a  Ê  
%   1wctype ©c  â  
%     .  Í   3sum_parallel_for_local_var 	_Z26sum_parallel_for_local_varPdi         ¸       œ³  4array 	³  ‘ 4size 	s  ‘5start   ‘X5sum   ‘h5end   ‘P69       E       5i s  ‘d  &  7__tcf_0 ¸              œ8__static_initialization_and_destruction_0 Ó       <       œD  4__initialize_p s  ‘ 4__priority s  ‘ 7_GLOBAL__sub_I__Z26sum_parallel_for_local_varPdi              œ9œ  	        :$  _ZN9__gnu_cxx24__numeric_traits_integerIiE5__minE €€€€x;/  _ZN9__gnu_cxx24__numeric_traits_integerIiE5__maxE ÿÿÿ<¯  _ZN9__gnu_cxx24__numeric_traits_integerImE8__digitsE  <ö  _ZN9__gnu_cxx24__numeric_traits_integerIcE5__maxE :M  _ZN9__gnu_cxx24__numeric_traits_integerIsE5__minE €€~=X  _ZN9__gnu_cxx24__numeric_traits_integerIsE5__maxE ÿ:¯  _ZN9__gnu_cxx24__numeric_traits_integerIxE5__minE €€€€€€€€€>º  _ZN9__gnu_cxx24__numeric_traits_integerIxE5__maxE ÿÿÿÿÿÿÿ %™B  9:;  9 :;  : :;   :;   :;  :;   :;I  	.?:;n<  
 I  & I  .?:;nI<  .?:;nI<  . ?:;nI<  .?:;nI<  I:;  (   (   (   <  :;2   :;I?<  .?:;n2<d   I4  .?:;n2<d   :;I2   :;I?2<   :;I?2<  / I  / I  4 :;nI?<   4 :;I<  ! :;I?<  "/ I  #:;  $ I  %$ >  & I  ' :;I8  (:;  ) :;I8  * :;I  +.?:;I<  ,.:;I<  -   .. ?:;I<  /.:;I<  0 I  1.?:;I<  2. ?:;I<  3.?:;n@–B  4 :;I  54 :;I  6  7. 4@–B  8.4@–B  94 G  :4 Gn  ;4 Gn  <4 Gn  =4 Gn  >4 Gn   ,                     -                            __STDC__ 1  __cplusplus 199711L  __STDC_HOSTED__ 1  __GNUC__ 5  __GNUC_MINOR__ 1  __GNUC_PATCHLEVEL__ 0  __VERSION__ "5.1.0"  __ATOMIC_RELAXED 0  __ATOMIC_SEQ_CST 5  __ATOMIC_ACQUIRE 2  __ATOMIC_RELEASE 3  __ATOMIC_ACQ_REL 4  __ATOMIC_CONSUME 1  __pic__ 1  __PIC__ 1  __FINITE_MATH_ONLY__ 0  __SIZEOF_INT__ 4  __SIZEOF_LONG__ 4  __SIZEOF_LONG_LONG__ 8  __SIZEOF_SHORT__ 2  __SIZEOF_FLOAT__ 4  __SIZEOF_DOUBLE__ 8  __SIZEOF_LONG_DOUBLE__ 16  __SIZEOF_SIZE_T__ 8  __CHAR_BIT__ 8  __BIGGEST_ALIGNMENT__ 16  __ORDER_LITTLE_ENDIAN__ 1234  __ORDER_BIG_ENDIAN__ 4321  __ORDER_PDP_ENDIAN__ 3412  __BYTE_ORDER__ __ORDER_LITTLE_ENDIAN__  __FLOAT_WORD_ORDER__ __ORDER_LITTLE_ENDIAN__  __SIZEOF_POINTER__ 8  __GNUG__ 5  __SIZE_TYPE__ long long unsigned int  __PTRDIFF_TYPE__ long long int  __WCHAR_TYPE__ short unsigned int  __WINT_TYPE__ short unsigned int  __INTMAX_TYPE__ long long int  __UINTMAX_TYPE__ long long unsigned int  __CHAR16_TYPE__ short unsigned int  __CHAR32_TYPE__ unsigned int  __SIG_ATOMIC_TYPE__ int  __INT8_TYPE__ signed char  __INT16_TYPE__ short int  __INT32_TYPE__ int  __INT64_TYPE__ long long int  __UINT8_TYPE__ unsigned char  __UINT16_TYPE__ short unsigned int  __UINT32_TYPE__ unsigned int  __UINT64_TYPE__ long long unsigned int  __INT_LEAST8_TYPE__ signed char  __INT_LEAST16_TYPE__ short int  __INT_LEAST32_TYPE__ int  __INT_LEAST64_TYPE__ long long int  __UINT_LEAST8_TYPE__ unsigned char  __UINT_LEAST16_TYPE__ short unsigned int  __UINT_LEAST32_TYPE__ unsigned int  __UINT_LEAST64_TYPE__ long long unsigned int  __INT_FAST8_TYPE__ signed char  __INT_FAST16_TYPE__ short int  __INT_FAST32_TYPE__ int  __INT_FAST64_TYPE__ long long int  __UINT_FAST8_TYPE__ unsigned char  __UINT_FAST16_TYPE__ short unsigned int  __UINT_FAST32_TYPE__ unsigned int  __UINT_FAST64_TYPE__ long long unsigned int  __INTPTR_TYPE__ long long int  __UINTPTR_TYPE__ long long unsigned int  __has_include(STR) __has_include__(STR)  __has_include_next(STR) __has_include_next__(STR)  __GXX_WEAK__ 1  __DEPRECATED 1  __GXX_RTTI 1  __cpp_rtti 199711  __cpp_binary_literals 201304  __cpp_runtime_arrays 198712  __EXCEPTIONS 1  __cpp_exceptions 199711  __GXX_ABI_VERSION 1008  __SCHAR_MAX__ 0x7f  __SHRT_MAX__ 0x7fff  __INT_MAX__ 0x7fffffff  __LONG_MAX__ 0x7fffffffL  __LONG_LONG_MAX__ 0x7fffffffffffffffLL  __WCHAR_MAX__ 0xffff  __WCHAR_MIN__ 0  __WINT_MAX__ 0xffff  __WINT_MIN__ 0  __PTRDIFF_MAX__ 0x7fffffffffffffffLL  __SIZE_MAX__ 0xffffffffffffffffULL  __GLIBCXX_TYPE_INT_N_0 __int128  __GLIBCXX_BITSIZE_INT_N_0 128  __INTMAX_MAX__ 0x7fffffffffffffffLL  __INTMAX_C(c) c ## LL  __UINTMAX_MAX__ 0xffffffffffffffffULL  __UINTMAX_C(c) c ## ULL  __SIG_ATOMIC_MAX__ 0x7fffffff  __SIG_ATOMIC_MIN__ (-__SIG_ATOMIC_MAX__ - 1)  __INT8_MAX__ 0x7f  __INT16_MAX__ 0x7fff  __INT32_MAX__ 0x7fffffff  __INT64_MAX__ 0x7fffffffffffffffLL  __UINT8_MAX__ 0xff  __UINT16_MAX__ 0xffff  __UINT32_MAX__ 0xffffffffU  __UINT64_MAX__ 0xffffffffffffffffULL  __INT_LEAST8_MAX__ 0x7f  __INT8_C(c) c  __INT_LEAST16_MAX__ 0x7fff  __INT16_C(c) c  __INT_LEAST32_MAX__ 0x7fffffff  __INT32_C(c) c  __INT_LEAST64_MAX__ 0x7fffffffffffffffLL  __INT64_C(c) c ## LL  __UINT_LEAST8_MAX__ 0xff  __UINT8_C(c) c  __UINT_LEAST16_MAX__ 0xffff  __UINT16_C(c) c  __UINT_LEAST32_MAX__ 0xffffffffU  __UINT32_C(c) c ## U  __UINT_LEAST64_MAX__ 0xffffffffffffffffULL  __UINT64_C(c) c ## ULL  __INT_FAST8_MAX__ 0x7f  __INT_FAST16_MAX__ 0x7fff  __INT_FAST32_MAX__ 0x7fffffff  __INT_FAST64_MAX__ 0x7fffffffffffffffLL  __UINT_FAST8_MAX__ 0xff  __UINT_FAST16_MAX__ 0xffff  __UINT_FAST32_MAX__ 0xffffffffU  __UINT_FAST64_MAX__ 0xffffffffffffffffULL  __INTPTR_MAX__ 0x7fffffffffffffffLL  __UINTPTR_MAX__ 0xffffffffffffffffULL  __GCC_IEC_559 2  __GCC_IEC_559_COMPLEX 2  __FLT_EVAL_METHOD__ 0  __DEC_EVAL_METHOD__ 2  __FLT_RADIX__ 2  __FLT_MANT_DIG__ 24  __FLT_DIG__ 6  __FLT_MIN_EXP__ (-125)  __FLT_MIN_10_EXP__ (-37)  __FLT_MAX_EXP__ 128  __FLT_MAX_10_EXP__ 38  __FLT_DECIMAL_DIG__ 9  __FLT_MAX__ 3.40282346638528859812e+38F  __FLT_MIN__ 1.17549435082228750797e-38F  __FLT_EPSILON__ 1.19209289550781250000e-7F  __FLT_DENORM_MIN__ 1.40129846432481707092e-45F  __FLT_HAS_DENORM__ 1  __FLT_HAS_INFINITY__ 1  __FLT_HAS_QUIET_NAN__ 1  __DBL_MANT_DIG__ 53  __DBL_DIG__ 15  __DBL_MIN_EXP__ (-1021)  __DBL_MIN_10_EXP__ (-307)  __DBL_MAX_EXP__ 1024  __DBL_MAX_10_EXP__ 308  __DBL_DECIMAL_DIG__ 17  __DBL_MAX__ double(1.79769313486231570815e+308L)  __DBL_MIN__ double(2.22507385850720138309e-308L)  __DBL_EPSILON__ double(2.22044604925031308085e-16L)  __DBL_DENORM_MIN__ double(4.94065645841246544177e-324L)  __DBL_HAS_DENORM__ 1  __DBL_HAS_INFINITY__ 1  __DBL_HAS_QUIET_NAN__ 1  __LDBL_MANT_DIG__ 64  __LDBL_DIG__ 18  __LDBL_MIN_EXP__ (-16381)  __LDBL_MIN_10_EXP__ (-4931)  __LDBL_MAX_EXP__ 16384  __LDBL_MAX_10_EXP__ 4932  __DECIMAL_DIG__ 21  __LDBL_MAX__ 1.18973149535723176502e+4932L  __LDBL_MIN__ 3.36210314311209350626e-4932L  __LDBL_EPSILON__ 1.08420217248550443401e-19L  __LDBL_DENORM_MIN__ 3.64519953188247460253e-4951L  __LDBL_HAS_DENORM__ 1  __LDBL_HAS_INFINITY__ 1  __LDBL_HAS_QUIET_NAN__ 1  __DEC32_MANT_DIG__ 7  __DEC32_MIN_EXP__ (-94)  __DEC32_MAX_EXP__ 97  __DEC32_MIN__ 1E-95DF  __DEC32_MAX__ 9.999999E96DF  __DEC32_EPSILON__ 1E-6DF  __DEC32_SUBNORMAL_MIN__ 0.000001E-95DF  __DEC64_MANT_DIG__ 16  __DEC64_MIN_EXP__ (-382)  __DEC64_MAX_EXP__ 385  __DEC64_MIN__ 1E-383DD  __DEC64_MAX__ 9.999999999999999E384DD  __DEC64_EPSILON__ 1E-15DD  __DEC64_SUBNORMAL_MIN__ 0.000000000000001E-383DD  __DEC128_MANT_DIG__ 34  __DEC128_MIN_EXP__ (-6142)  __DEC128_MAX_EXP__ 6145  __DEC128_MIN__ 1E-6143DL  __DEC128_MAX__ 9.999999999999999999999999999999999E6144DL  __DEC128_EPSILON__ 1E-33DL  __DEC128_SUBNORMAL_MIN__ 0.000000000000000000000000000000001E-6143DL  __REGISTER_PREFIX__   __USER_LABEL_PREFIX__   __GNUC_GNU_INLINE__ 1  __NO_INLINE__ 1  __WCHAR_UNSIGNED__ 1  __GCC_HAVE_SYNC_COMPARE_AND_SWAP_1 1  __GCC_HAVE_SYNC_COMPARE_AND_SWAP_2 1  __GCC_HAVE_SYNC_COMPARE_AND_SWAP_4 1  __GCC_HAVE_SYNC_COMPARE_AND_SWAP_8 1  __GCC_ATOMIC_BOOL_LOCK_FREE 2  __GCC_ATOMIC_CHAR_LOCK_FREE 2  __GCC_ATOMIC_CHAR16_T_LOCK_FREE 2  __GCC_ATOMIC_CHAR32_T_LOCK_FREE 2  __GCC_ATOMIC_WCHAR_T_LOCK_FREE 2  __GCC_ATOMIC_SHORT_LOCK_FREE 2  __GCC_ATOMIC_INT_LOCK_FREE 2  __GCC_ATOMIC_LONG_LOCK_FREE 2  __GCC_ATOMIC_LLONG_LOCK_FREE 2  __GCC_ATOMIC_TEST_AND_SET_TRUEVAL 1  __GCC_ATOMIC_POINTER_LOCK_FREE 2  __GCC_HAVE_DWARF2_CFI_ASM 1  __PRAGMA_REDEFINE_EXTNAME 1  _OPENMP 201307  __SIZEOF_INT128__ 16  __SIZEOF_WCHAR_T__ 2  __SIZEOF_WINT_T__ 2  __SIZEOF_PTRDIFF_T__ 8  __amd64 1  __amd64__ 1  __x86_64 1  __x86_64__ 1  __SIZEOF_FLOAT80__ 16  __SIZEOF_FLOAT128__ 16  __ATOMIC_HLE_ACQUIRE 65536  __ATOMIC_HLE_RELEASE 131072  __k8 1  __k8__ 1  __code_model_medium__ 1  __MMX__ 1  __SSE__ 1  __SSE2__ 1  __FXSR__ 1  __SSE_MATH__ 1  __SSE2_MATH__ 1  __SEH__ 1  __stdcall __attribute__((__stdcall__))  __fastcall __attribute__((__fastcall__))  __thiscall __attribute__((__thiscall__))  __cdecl __attribute__((__cdecl__))  _stdcall __attribute__((__stdcall__))  _fastcall __attribute__((__fastcall__))  _thiscall __attribute__((__thiscall__))  _cdecl __attribute__((__cdecl__))  __GXX_MERGED_TYPEINFO_NAMES 0  __GXX_TYPEINFO_EQUALITY_INLINE 0  __MSVCRT__ 1  __MINGW32__ 1  _WIN32 1  __WIN32 1  __WIN32__ 1  WIN32 1  __WINNT 1  __WINNT__ 1  WINNT 1  _INTEGRAL_MAX_BITS 64  __MINGW64__ 1  __WIN64 1  __WIN64__ 1  WIN64 1  _WIN64 1  __declspec(x) __attribute__((x))  __DECIMAL_BID_FORMAT__ 1  _MT 1  _REENTRANT 1  _REENTRANT  "_GLIBCXX_IOSTREAM 1 &_GLIBCXX_CXX_CONFIG_H 1 "__GLIBCXX__ 20150422 +_GLIBCXX_PURE __attribute__ ((__pure__)) /_GLIBCXX_CONST __attribute__ ((__const__)) 3_GLIBCXX_NORETURN __attribute__ ((__noreturn__)) @_GLIBCXX_HAVE_ATTRIBUTE_VISIBILITY 0 G_GLIBCXX_VISIBILITY(V) _GLIBCXX_PSEUDO_VISIBILITY(V) N_GLIBCXX_USE_DEPRECATED 1 T_GLIBCXX_DEPRECATED  Y_GLIBCXX_ABI_TAG_CXX11 __attribute ((__abi_tag__ ("cxx11"))) e_GLIBCXX_CONSTEXPR  f_GLIBCXX_USE_CONSTEXPR const n_GLIBCXX14_CONSTEXPR  y_GLIBCXX_NOEXCEPT  z_GLIBCXX_USE_NOEXCEPT throw() {_GLIBCXX_THROW(_EXC) throw(_EXC) €_GLIBCXX_NOTHROW _GLIBCXX_USE_NOEXCEPT …_GLIBCXX_THROW_OR_ABORT(_EXC) (throw (_EXC)) •_GLIBCXX_EXTERN_TEMPLATE 1 Ì_GLIBCXX_USE_DUAL_ABI 1 Ô_GLIBCXX_USE_CXX11_ABI 1 à_GLIBCXX_NAMESPACE_CXX11 __cxx11:: á_GLIBCXX_BEGIN_NAMESPACE_CXX11 namespace __cxx11 { â_GLIBCXX_END_NAMESPACE_CXX11 } ã_GLIBCXX_DEFAULT_ABI_TAG _GLIBCXX_ABI_TAG_CXX11 í_GLIBCXX_INLINE_VERSION 0 —_GLIBCXX_BEGIN_NAMESPACE_VERSION  ˜_GLIBCXX_END_NAMESPACE_VERSION  ì_GLIBCXX_STD_A std ð_GLIBCXX_STD_C std ô_GLIBCXX_BEGIN_NAMESPACE_ALGO  ø_GLIBCXX_END_NAMESPACE_ALGO  ü_GLIBCXX_BEGIN_NAMESPACE_CONTAINER  €_GLIBCXX_END_NAMESPACE_CONTAINER  …_GLIBCXX_LONG_DOUBLE_COMPAT ‘_GLIBCXX_NAMESPACE_LDBL  ’_GLIBCXX_BEGIN_NAMESPACE_LDBL  “_GLIBCXX_END_NAMESPACE_LDBL  –_GLIBCXX_NAMESPACE_LDBL_OR_CXX11 _GLIBCXX_NAMESPACE_CXX11 —_GLIBCXX_BEGIN_NAMESPACE_LDBL_OR_CXX11 _GLIBCXX_BEGIN_NAMESPACE_CXX11 ˜_GLIBCXX_END_NAMESPACE_LDBL_OR_CXX11 _GLIBCXX_END_NAMESPACE_CXX11 ¡__glibcxx_assert(_Condition)  Ï_GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(A)  Ò_GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(A)  Ö_GLIBCXX_BEGIN_EXTERN_C extern "C" { ×_GLIBCXX_END_EXTERN_C } â_GLIBCXX_OS_DEFINES  '__GTHREAD_HIDE_WIN32API 1 ,NOMINMAX -NOMINMAX 1 2__USE_MINGW_ANSI_STDIO 3__USE_MINGW_ANSI_STDIO 1 8_GLIBCXX_PSEUDO_VISIBILITY_default  :_GLIBCXX_PSEUDO_VISIBILITY_hidden  <_GLIBCXX_PSEUDO_VISIBILITY(V) _GLIBCXX_PSEUDO_VISIBILITY_ ## V ?_GLIBCXX_HAVE_DOS_BASED_FILESYSTEM 1 D_GLIBCXX_NO_IOCTL 1 N_GLIBCXX_LLP64 1 T_GLIBCXX_THREAD_ATEXIT_WIN32 1 W_GTHREAD_USE_MUTEX_INIT_FUNC 1 å_GLIBCXX_CPU_DEFINES 1 ñ_GLIBCXX_WEAK_DEFINITION  ü_GLIBCXX_FAST_MATH 0 ƒ__N(msgid) (msgid) †min ‡max Ž_GLIBCXX_HAVE_ACOSF 1 ‘_GLIBCXX_HAVE_ACOSL 1 ”_GLIBCXX_HAVE_ASINF 1 —_GLIBCXX_HAVE_ASINL 1 �_GLIBCXX_HAVE_ATAN2F 1  _GLIBCXX_HAVE_ATAN2L 1 £_GLIBCXX_HAVE_ATANF 1 ¦_GLIBCXX_HAVE_ATANL 1 ¯_GLIBCXX_HAVE_CEILF 1 ²_GLIBCXX_HAVE_CEILL 1 µ_GLIBCXX_HAVE_COMPLEX_H 1 ¸_GLIBCXX_HAVE_COSF 1 »_GLIBCXX_HAVE_COSHF 1 ¾_GLIBCXX_HAVE_COSHL 1 Á_GLIBCXX_HAVE_COSL 1 Ê_GLIBCXX_HAVE_ECANCELED 1 Í_GLIBCXX_HAVE_ECHILD 1 Ü_GLIBCXX_HAVE_ENOSPC 1 è_GLIBCXX_HAVE_ENOTSUP 1 ë_GLIBCXX_HAVE_EOVERFLOW 1 î_GLIBCXX_HAVE_EOWNERDEAD 1 ñ_GLIBCXX_HAVE_EPERM 1 ô_GLIBCXX_HAVE_EPROTO 1 ú_GLIBCXX_HAVE_ETIMEDOUT 1 €_GLIBCXX_HAVE_EWOULDBLOCK 1 †_GLIBCXX_HAVE_EXPF 1 ‰_GLIBCXX_HAVE_EXPL 1 Œ_GLIBCXX_HAVE_FABSF 1 �_GLIBCXX_HAVE_FABSL 1 ’_GLIBCXX_HAVE_FENV_H 1 •_GLIBCXX_HAVE_FINITE 1 ž_GLIBCXX_HAVE_FLOAT_H 1 ¡_GLIBCXX_HAVE_FLOORF 1 ¤_GLIBCXX_HAVE_FLOORL 1 §_GLIBCXX_HAVE_FMODF 1 ª_GLIBCXX_HAVE_FMODL 1 ­_GLIBCXX_HAVE_FPCLASS 1 ³_GLIBCXX_HAVE_FREXPF 1 ¶_GLIBCXX_HAVE_FREXPL 1 ¹_GLIBCXX_HAVE_GETIPINFO 1 ¼_GLIBCXX_HAVE_GETS 1 ¿_GLIBCXX_HAVE_HYPOT 1 Â_GLIBCXX_HAVE_HYPOTF 1 Å_GLIBCXX_HAVE_HYPOTL 1 È_GLIBCXX_HAVE_ICONV 1 Ë_GLIBCXX_HAVE_IEEEFP_H 1 Î_GLIBCXX_HAVE_INT64_T 1 Ô_GLIBCXX_HAVE_INT64_T_LONG_LONG 1 ×_GLIBCXX_HAVE_INTTYPES_H 1 ã_GLIBCXX_HAVE_ISNAN 1 ì_GLIBCXX_HAVE_ISWBLANK 1 ò_GLIBCXX_HAVE_LDEXPF 1 õ_GLIBCXX_HAVE_LDEXPL 1 �_GLIBCXX_HAVE_LOCALE_H 1 �_GLIBCXX_HAVE_LOG10F 1 “_GLIBCXX_HAVE_LOG10L 1 –_GLIBCXX_HAVE_LOGF 1 ™_GLIBCXX_HAVE_LOGL 1 ¢_GLIBCXX_HAVE_MBSTATE_T 1 ¥_GLIBCXX_HAVE_MEMORY_H 1 ¨_GLIBCXX_HAVE_MODF 1 «_GLIBCXX_HAVE_MODFF 1 ®_GLIBCXX_HAVE_MODFL 1 ·_GLIBCXX_HAVE_POWF 1 º_GLIBCXX_HAVE_POWL 1 Æ_GLIBCXX_HAVE_SINCOS 1 É_GLIBCXX_HAVE_SINCOSF 1 Ì_GLIBCXX_HAVE_SINCOSL 1 Ï_GLIBCXX_HAVE_SINF 1 Ò_GLIBCXX_HAVE_SINHF 1 Õ_GLIBCXX_HAVE_SINHL 1 Ø_GLIBCXX_HAVE_SINL 1 Þ_GLIBCXX_HAVE_SQRTF 1 á_GLIBCXX_HAVE_SQRTL 1 ä_GLIBCXX_HAVE_STDALIGN_H 1 ç_GLIBCXX_HAVE_STDBOOL_H 1 ê_GLIBCXX_HAVE_STDINT_H 1 í_GLIBCXX_HAVE_STDLIB_H 1 ö_GLIBCXX_HAVE_STRINGS_H 1 ù_GLIBCXX_HAVE_STRING_H 1 ü_GLIBCXX_HAVE_STRTOF 1 ÿ_GLIBCXX_HAVE_STRTOLD 1 †_GLIBCXX_HAVE_SYMVER_SYMBOL_RENAMING_RUNTIME_SUPPORT 1 ˜_GLIBCXX_HAVE_SYS_PARAM_H 1 ¤_GLIBCXX_HAVE_SYS_STAT_H 1 ª_GLIBCXX_HAVE_SYS_TIME_H 1 ­_GLIBCXX_HAVE_SYS_TYPES_H 1 ¶_GLIBCXX_HAVE_S_ISREG 1 ¹_GLIBCXX_HAVE_TANF 1 ¼_GLIBCXX_HAVE_TANHF 1 ¿_GLIBCXX_HAVE_TANHL 1 Â_GLIBCXX_HAVE_TANL 1 Å_GLIBCXX_HAVE_TGMATH_H 1 È_GLIBCXX_HAVE_TLS 1 Ë_GLIBCXX_HAVE_UNISTD_H 1 Ñ_GLIBCXX_HAVE_VFWSCANF 1 Ô_GLIBCXX_HAVE_VSWSCANF 1 ×_GLIBCXX_HAVE_VWSCANF 1 Ú_GLIBCXX_HAVE_WCHAR_H 1 Ý_GLIBCXX_HAVE_WCSTOF 1 à_GLIBCXX_HAVE_WCTYPE_H 1 ¢_GLIBCXX_HAVE__FINITEF 1 Ò_GLIBCXX_HAVE__ISNANF 1 ¦	_GLIBCXX_ICONV_CONST  ª	LT_OBJDIR ".libs/" °	_GLIBCXX_PACKAGE_BUGREPORT "" ³	_GLIBCXX_PACKAGE_NAME "package-unused" ¶	_GLIBCXX_PACKAGE_STRING "package-unused version-unused" ¹	_GLIBCXX_PACKAGE_TARNAME "libstdc++" ¼	_GLIBCXX_PACKAGE_URL "" ¿	_GLIBCXX_PACKAGE__GLIBCXX_VERSION "version-unused" Ñ	STDC_HEADERS 1 ×	_GLIBCXX_ATOMIC_BUILTINS 1 Þ	_GLIBCXX_FULLY_DYNAMIC_STRING 1 á	_GLIBCXX_HAS_GTHREADS 1 ä	_GLIBCXX_HOSTED 1 õ	_GLIBCXX_STDIO_EOF -1 ø	_GLIBCXX_STDIO_SEEK_CUR 1 û	_GLIBCXX_STDIO_SEEK_END 2 þ	_GLIBCXX_SYMVER 1 „
_GLIBCXX_SYMVER_GNU 1 Ž
_GLIBCXX_USE_C99 1 “
_GLIBCXX_USE_C99_COMPLEX 1 ˜
_GLIBCXX_USE_C99_COMPLEX_TR1 1 œ
_GLIBCXX_USE_C99_CTYPE_TR1 1  
_GLIBCXX_USE_C99_FENV_TR1 1 ¤
_GLIBCXX_USE_C99_INTTYPES_TR1 1 ¨
_GLIBCXX_USE_C99_INTTYPES_WCHAR_T_TR1 1 ¬
_GLIBCXX_USE_C99_MATH 1 °
_GLIBCXX_USE_C99_MATH_TR1 1 ´
_GLIBCXX_USE_C99_STDINT_TR1 1 »
_GLIBCXX_USE_CLOCK_MONOTONIC 1 ¾
_GLIBCXX_USE_CLOCK_REALTIME 1 Â
_GLIBCXX_USE_DECIMAL_FLOAT 1 Å
_GLIBCXX_USE_FLOAT128 1 È
_GLIBCXX_USE_GETTIMEOFDAY 1 Î
_GLIBCXX_USE_INT128 1 Ñ
_GLIBCXX_USE_LFS 1 Ô
_GLIBCXX_USE_LONG_LONG 1 ×
_GLIBCXX_USE_NANOSLEEP 1 Ý
_GLIBCXX_USE_PTHREADS_NUM_PROCESSORS_NP 1 à
_GLIBCXX_USE_PTHREAD_RWLOCK_T 1 ç
_GLIBCXX_USE_SCHED_YIELD 1 ó
_GLIBCXX_USE_TMPNAM 1 ö
_GLIBCXX_USE_WCHAR_T 1 ù
_GLIBCXX_VERBOSE 1 ü
_GLIBCXX_X86_RDRAND 1 ÿ
_GTHREAD_USE_MUTEX_TIMEDLOCK 1 á_GLIBCXX_HAVE_FINITEF 1 âfinitef _finitef ±_GLIBCXX_HAVE_ISNANF 1 ²isnanf _isnanf '"_GLIBCXX_OSTREAM 1 &"_GLIBCXX_IOS 1 &
"_GLIBCXX_IOSFWD 1 '#_STRINGFWD_H 1 (,_MEMORYFWD_H 1 ($_GLIBCXX_POSTYPES_H 1 (,_INC_WCHAR  	_INC_CRTDEFS  
_INC__MINGW_H  _INC_CRTDEFS_MACRO  
__STRINGIFY(x) #x __MINGW64_STRINGIFY(x) __STRINGIFY(x) __MINGW64_VERSION_MAJOR 4 __MINGW64_VERSION_MINOR 0 __MINGW64_VERSION_RC 0 __MINGW64_VERSION_STR __MINGW64_STRINGIFY(__MINGW64_VERSION_MAJOR) "." __MINGW64_STRINGIFY(__MINGW64_VERSION_MINOR) __MINGW64_VERSION_STATE "stable" $__MINGW32_MAJOR_VERSION 3 %__MINGW32_MINOR_VERSION 11 /_ 0_ 1 4__MINGW_USE_UNDERSCORE_PREFIX 0 6_ C__MINGW_IMP_SYMBOL(sym) __imp_ ##sym D__MINGW_IMP_LSYMBOL(sym) __imp_ ##sym E__MINGW_USYMBOL(sym) sym F__MINGW_LSYMBOL(sym) _ ##sym b_M_AMD64 100 c_M_X64 100 Š__MINGW_EXTENSION �__MINGW_EXTENSION __extension__ ˜__C89_NAMELESS __MINGW_EXTENSION ™__C89_NAMELESSSTRUCTNAME  š__C89_NAMELESSSTRUCTNAME1  ›__C89_NAMELESSSTRUCTNAME2  œ__C89_NAMELESSSTRUCTNAME3  �__C89_NAMELESSSTRUCTNAME4  ž__C89_NAMELESSSTRUCTNAME5  Ÿ__C89_NAMELESSUNIONNAME   __C89_NAMELESSUNIONNAME1  ¡__C89_NAMELESSUNIONNAME2  ¢__C89_NAMELESSUNIONNAME3  £__C89_NAMELESSUNIONNAME4  ¤__C89_NAMELESSUNIONNAME5  ¥__C89_NAMELESSUNIONNAME6  ¦__C89_NAMELESSUNIONNAME7  §__C89_NAMELESSUNIONNAME8  «__GNU_EXTENSION __MINGW_EXTENSION °__MINGW_HAVE_ANSI_C99_PRINTF 1 ±__MINGW_HAVE_WIDE_C99_PRINTF 1 ²__MINGW_HAVE_ANSI_C99_SCANF 1 ³__MINGW_HAVE_WIDE_C99_SCANF 1 ¸__MINGW_POISON_NAME(__IFACE) __IFACE ##_layout_has_not_been_verified_and_its_declaration_is_most_likely_incorrect ¾__MSABI_LONG(x) x ## l Å__MINGW_GCC_VERSION (__GNUC__ * 10000 + __GNUC_MINOR__ * 100 + __GNUC_PATCHLEVEL__) Í__MINGW_GNUC_PREREQ(major,minor) (__GNUC__ > (major) || (__GNUC__ == (major) && __GNUC_MINOR__ >= (minor))) Ø__MINGW_MSC_PREREQ(major,minor) 0 ä__MINGW_ATTRIB_DEPRECATED_STR(X)  ç__MINGW_SEC_WARN_STR "This function or variable may be unsafe, use _CRT_SECURE_NO_WARNINGS to disable deprecation" ê__MINGW_MSVC2005_DEPREC_STR "This POSIX function is deprecated beginning in Visual C++ 2005, use _CRT_NONSTDC_NO_DEPRECATE to disable deprecation" î__MINGW_ATTRIB_DEPRECATED_MSVC2005 __MINGW_ATTRIB_DEPRECATED_STR(__MINGW_MSVC2005_DEPREC_STR) õ__MINGW_ATTRIB_DEPRECATED_SEC_WARN __MINGW_ATTRIB_DEPRECATED_STR(__MINGW_SEC_WARN_STR) û__MINGW_MS_PRINTF(__format,__args) __attribute__((__format__(ms_printf, __format,__args))) þ__MINGW_MS_SCANF(__format,__args) __attribute__((__format__(ms_scanf, __format,__args))) �__MINGW_GNU_PRINTF(__format,__args) __attribute__((__format__(gnu_printf,__format,__args))) „__MINGW_GNU_SCANF(__format,__args) __attribute__((__format__(gnu_scanf, __format,__args))) ‡__mingw_ovr Š__mingw_ovr inline __cdecl _INC_MINGW_SECAPI  _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES_MEMORY _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES  _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT !_CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_MEMORY "_CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES 0 #_CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES_MEMORY 0 $_CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES 0 %_CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT 0 &_CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_MEMORY 0 )__MINGW_CRT_NAME_CONCAT2(sym) ::sym ##_s E__CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_MEMORY_0_3_(__ret,__func,__type1,__attrib1,__arg1,__type2,__attrib2,__arg2,__type3,__attrib3,__arg3) _CRTIMP __ret __cdecl __func(__type1 * __attrib1 __arg1, __type2 __attrib2 __arg2, __type3 __attrib3 __arg3) __MINGW_ATTRIB_DEPRECATED_SEC_WARN; __LONG32 long "__stdcall $__stdcall  5__MINGW_IMPORT extern __attribute__ ((__dllimport__)) 8__USE_CRTIMP :__USE_CRTIMP 1 =_CRTIMP __attribute__ ((__dllimport__)) B__DECLSPEC_SUPPORTED  OUSE___UUIDOF 0 S_inline __inline W__CRT_INLINE inline d__MINGW_INTRIN_INLINE extern __inline__ __attribute__((__always_inline__,__gnu_inline__)) i__CRT__NO_INLINE j__CRT__NO_INLINE 1 o__UNUSED_PARAM(x)  †__restrict_arr  ‘__MINGW_ATTRIB_NORETURN __attribute__ ((__noreturn__)) ’__MINGW_ATTRIB_CONST __attribute__ ((__const__)) œ__MINGW_ATTRIB_MALLOC __attribute__ ((__malloc__)) �__MINGW_ATTRIB_PURE __attribute__ ((__pure__)) ª__MINGW_ATTRIB_NONNULL(arg) __attribute__ ((__nonnull__ (arg))) °__MINGW_ATTRIB_UNUSED __attribute__ ((__unused__)) ¶__MINGW_ATTRIB_USED __attribute__ ((__used__)) ·__MINGW_ATTRIB_DEPRECATED __attribute__ ((__deprecated__)) Á__MINGW_NOTHROW __attribute__ ((__nothrow__)) É__MINGW_ATTRIB_NO_OPTIMIZE __attribute__((__optimize__ ("0"))) Ï__MINGW_PRAGMA_PARAM(x) _Pragma (#x) Ö__MINGW_BROKEN_INTERFACE(x) __MINGW_PRAGMA_PARAM(message ("Interface " _CRT_STRINGIZE(x) " has unverified layout.")) Ü__MSVCRT_VERSION__ 0x0700 á_WIN32_WINNT 0x502 å_INT128_DEFINED  ç__int8 char è__int16 short é__int32 int ê__int64 long long ø__ptr32  ù__ptr64  û__unaligned  þ__w64  �__forceinline inline __attribute__((__always_inline__)) �__nothrow __declspec(nothrow) “_INC_VADEFS  	­MINGW_SDK_INIT  µ __MINGW_HAS_DXSDK 1 MINGW_HAS_DDRAW_H 1 MINGW_DDRAW_VERSION 7 ¶!MINGW_DDK_H  MINGW_HAS_DDK_H 1 _CRT_PACKING _CRT_PACKING 8 __GNUC_VA_LIST  _VA_LIST_DEFINED  (_ADDRESSOF(v) (&reinterpret_cast<const char &>(v)) 0_crt_va_start(v,l) __builtin_va_start(v,l) 1_crt_va_arg(v,l) __builtin_va_arg(v,l) 2_crt_va_end(v) __builtin_va_end(v) 3_crt_va_copy(d,s) __builtin_va_copy(d,s) –__CRT_STRINGIZE(_Value) #_Value —_CRT_STRINGIZE(_Value) __CRT_STRINGIZE(_Value) ›__CRT_WIDE(_String) L ## _String œ_CRT_WIDE(_String) __CRT_WIDE(_String)  _W64  §_CRTIMP_NOIA64 _CRTIMP ¬_CRTIMP2 _CRTIMP °_CRTIMP_ALTERNATIVE _CRTIMP ±_CRT_ALTERNATIVE_IMPORTED  µ_MRTIMP2 _CRTIMP ¾_DLL  Æ_MCRTIMP _CRTIMP Ê_CRTIMP_PURE _CRTIMP Î_PGLOBAL  Ò_AGLOBAL  Õ_SECURECRT_FILL_BUFFER_PATTERN 0xFD Ö_CRT_DEPRECATE_TEXT(_Text) __declspec(deprecated) Ù_CRT_INSECURE_DEPRECATE_MEMORY(_Replacement)  Ý_CRT_INSECURE_DEPRECATE_GLOBALS(_Replacement)  á_CRT_MANAGED_HEAP_DEPRECATE  å_CRT_OBSOLETE(_NewItem)  ñ_CONST_RETURN  öUNALIGNED __unaligned €_CRT_ALIGN(x) __attribute__ ((__aligned__ (x))) ‡__CRTDECL __cdecl Š_ARGMAX 100 �_TRUNCATE ((size_t)-1) ‘_CRT_UNUSED(x) (void)x µ_CRT_glob ¶_CRT_glob _dowildcard Æ__ANONYMOUS_DEFINED  Ç_ANONYMOUS_UNION __MINGW_EXTENSION È_ANONYMOUS_STRUCT __MINGW_EXTENSION Ê_UNION_NAME(x)  Ë_STRUCT_NAME(x)  ßDUMMYUNIONNAME  àDUMMYUNIONNAME1  áDUMMYUNIONNAME2  âDUMMYUNIONNAME3  ãDUMMYUNIONNAME4  äDUMMYUNIONNAME5  åDUMMYUNIONNAME6  æDUMMYUNIONNAME7  çDUMMYUNIONNAME8  èDUMMYUNIONNAME9  õDUMMYSTRUCTNAME  öDUMMYSTRUCTNAME1  ÷DUMMYSTRUCTNAME2  øDUMMYSTRUCTNAME3  ùDUMMYSTRUCTNAME4  úDUMMYSTRUCTNAME5  ‚__CRT_UUID_DECL(type,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) extern "C++" { template<> inline const GUID &__mingw_uuidof<type>() { static const IID __uuid_inst = {l,w1,w2, {b1,b2,b3,b4,b5,b6,b7,b8}}; return __uuid_inst; } template<> inline const GUID &__mingw_uuidof<type*>() { return __mingw_uuidof<type>(); } } �__uuidof(type) __mingw_uuidof<__typeof(type)>() _CRT_PACKING _CRT_PACKING 8 _CRTNOALIAS  _CRTRESTRICT   _SIZE_T_DEFINED  !size_t *_SSIZE_T_DEFINED  +ssize_t 5_RSIZE_T_DEFINED  9_INTPTR_T_DEFINED  ;__intptr_t_defined  <intptr_t F_UINTPTR_T_DEFINED  H__uintptr_t_defined  Iuintptr_t S_PTRDIFF_T_DEFINED  U_PTRDIFF_T_  Vptrdiff_t `_WCHAR_T_DEFINED  g_WCTYPE_T_DEFINED  i_WINT_T  p_ERRCODE_DEFINED  u_TIME32_T_DEFINED  z_TIME64_T_DEFINED  †_TIME_T_DEFINED  �_CRT_SECURE_CPP_NOTHROW throw() þ__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_0(__ret,__func,__dsttype,__dst)  ÿ__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1(__ret,__func,__dsttype,__dst,__type1,__arg1)  €__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2(__ret,__func,__dsttype,__dst,__type1,__arg1,__type2,__arg2)  �__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_3(__ret,__func,__dsttype,__dst,__type1,__arg1,__type2,__arg2,__type3,__arg3)  ‚__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_4(__ret,__func,__dsttype,__dst,__type1,__arg1,__type2,__arg2,__type3,__arg3,__type4,__arg4)  ƒ__DEFINE_CPP_OVERLOAD_SECURE_FUNC_1_1(__ret,__func,__type0,__arg0,__dsttype,__dst,__type1,__arg1)  „__DEFINE_CPP_OVERLOAD_SECURE_FUNC_1_2(__ret,__func,__type0,__arg0,__dsttype,__dst,__type1,__arg1,__type2,__arg2)  …__DEFINE_CPP_OVERLOAD_SECURE_FUNC_1_3(__ret,__func,__type0,__arg0,__dsttype,__dst,__type1,__arg1,__type2,__arg2,__type3,__arg3)  †__DEFINE_CPP_OVERLOAD_SECURE_FUNC_2_0(__ret,__func,__type1,__arg1,__type2,__arg2,__dsttype,__dst)  ‡__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1_ARGLIST(__ret,__func,__vfunc,__dsttype,__dst,__type1,__arg1)  ˆ__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2_ARGLIST(__ret,__func,__vfunc,__dsttype,__dst,__type1,__arg1,__type2,__arg2)  ‰__DEFINE_CPP_OVERLOAD_SECURE_FUNC_SPLITPATH(__ret,__func,__dsttype,__src)  �__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_0(__ret_type,__ret_policy,__decl_spec,__name,__dst_attr,__dst_type,__dst) __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_0_EX(__ret_type, __ret_policy, __decl_spec, __func_name, __func_name ##_s, __dst_attr, __dst_type, __dst) �__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1(__ret_type,__ret_policy,__decl_spec,__name,__dst_attr,__dst_type,__dst,__arg1_type,__arg1) __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2_EX(__ret_type, __ret_policy, __decl_spec, __func_name, __func_name ##_s, __dst_attr, __dst_type, __dst, __arg1_type, __arg1, __arg2_type, __arg2) ‘__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2(__ret_type,__ret_policy,__decl_spec,__name,__dst_attr,__dst_type,__dst,__arg1_type,__arg1,__arg2_type,__arg2) __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2_EX(__ret_type, __ret_policy, __decl_spec, __func_name, __func_name ##_s, __dst_attr, __dst_type, __dst, __arg1_type, __arg1, __arg2_type, __arg2) “__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_3(__ret_type,__ret_policy,__decl_spec,__name,__dst_attr,__dst_type,__dst,__arg1_type,__arg1,__arg2_type,__arg2,__arg3_type,__arg3) __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_3_EX(__ret_type, __ret_policy, __decl_spec, __func_name, __func_name ##_s, __dst_attr, __dst_type, __dst, __arg1_type, __arg1, __arg2_type, __arg2, __arg3_type, __arg3) •__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_4(__ret_type,__ret_policy,__decl_spec,__name,__dst_attr,__dst_type,__dst,__arg1_type,__arg1,__arg2_type,__arg2,__arg3_type,__arg3,__arg4_type,__arg4) __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_4_EX(__ret_type, __ret_policy, __decl_spec, __func_name, __func_name ##_s, __dst_attr, __dst_type, __dst, __arg1_type, __arg1, __arg2_type, __arg2, __arg3_type, __arg3, __arg4_type, __arg4) ž__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_0_EX(__ret_type,__ret_policy,__decl_spec,__name,__sec_name,__dst_attr,__dst_type,__dst)  Ÿ__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1_EX(__ret_type,__ret_policy,__decl_spec,__name,__sec_name,__dst_attr,__dst_type,__dst,__arg1_type,__arg1)   __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2_EX(__ret_type,__ret_policy,__decl_spec,__name,__sec_name,__dst_attr,__dst_type,__dst,__arg1_type,__arg1,__arg2_type,__arg2)  ¡__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_3_EX(__ret_type,__ret_policy,__decl_spec,__name,__sec_name,__dst_attr,__dst_type,__dst,__arg1_type,__arg1,__arg2_type,__arg2,__arg3_type,__arg3)  ¢__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_4_EX(__ret_type,__ret_policy,__decl_spec,__name,__sec_name,__dst_attr,__dst_type,__dst,__arg1_type,__arg1,__arg2_type,__arg2,__arg3_type,__arg3,__arg4_type,__arg4)  ²_TAGLC_ID_DEFINED  »_THREADLOCALEINFO  Ø__crt_typefix(ctype)  
"__USE_MINGW_STRTOX 1 WCHAR_MIN 0U WCHAR_MAX 0xffffU WEOF (wint_t)(0xFFFF) +_FILE_DEFINED  1_iob __iob_func() <_iob __iob_func() @stdin (&__iob_func()[0]) Astdout (&__iob_func()[1]) Bstderr (&__iob_func()[2]) C_STDSTREAM_DEFINED  H_FSIZE_T_DEFINED  z_wfinddata_t _wfinddata64i32_t {_wfinddatai64_t _wfinddata64_t }_wfindfirst _wfindfirst64i32 ~_wfindnext _wfindnext64i32 _wfindfirsti64 _wfindfirst64 €_wfindnexti64 _wfindnext64 ƒ_WFINDDATA_T_DEFINED  ‹NULL 0LL –_WConst_return _CONST_RETURN ™_CRT_CTYPEDATA_DEFINED  �__PCTYPE_FUNC __pctype_func() ¡__pctype_func() (* __MINGW_IMP_SYMBOL(_pctype)) ª_pctype (* __MINGW_IMP_SYMBOL(_pctype)) ±_CRT_WCTYPEDATA_DEFINED  ¸_wctype (* __MINGW_IMP_SYMBOL(_wctype)) ¿__pwctype_func() (* __MINGW_IMP_SYMBOL(_pwctype)) Ç_pwctype (* __MINGW_IMP_SYMBOL(_pwctype)) Î_UPPER 0x1 Ï_LOWER 0x2 Ð_DIGIT 0x4 Ñ_SPACE 0x8 Ó_PUNCT 0x10 Ô_CONTROL 0x20 Õ_BLANK 0x40 Ö_HEX 0x80 Ø_LEADBYTE 0x8000 Ù_ALPHA (0x0100|_UPPER|_LOWER) Ü_WCTYPE_DEFINED  Š_WDIRECT_DEFINED  •_WIO_DEFINED  «_WLOCALE_DEFINED  °_WEXEC_DEFINED  ¼_WSPAWN_DEFINED  È_CRT_WSYSTEM_DEFINED  Í_CRT_WCTYPE_NOINLINE ë_WCTYPE_INLINE_DEFINED  ð_INO_T_DEFINED  ø_DEV_T_DEFINED  ÿ#_OFF_T_DEFINED  _OFF_T_  _OFF64_T_DEFINED  _FILE_OFFSET_BITS_SET_OFFT  €$_fstat _fstat64i32 _fstati64 _fstat64 _stat _stat64i32 _stati64 _stat64 _wstat _wstat64i32 _wstati64 _wstat64 [__stat64 _stat64 \stat64 _stat64 ]fstat64 _fstat64 __STAT_DEFINED  ƒ_WSTAT_DEFINED  �_WCONIO_DEFINED  «_WSTDIO_DEFINED  Ì__mingw_ovr Î__mingw_ovr static __attribute__ ((__unused__)) __inline__ __cdecl Î_INC_SWPRINTF_INL  __mingw_ovr __mingw_ovr static __attribute__ ((__unused__)) __inline__ __cdecl å_CRT_WPERROR_DEFINED  êwpopen _wpopen ò_CRT_GETPUTWCHAR_NOINLINE õgetwchar() fgetwc(stdin) öputwchar(_c) fputwc((_c),stdout) ügetwc(_stm) fgetwc(_stm) ýputwc(_c,_stm) fputwc(_c,_stm) þ_putwc_nolock(_c,_stm) _fputwc_nolock(_c,_stm) ÿ_getwc_nolock(_c) _fgetwc_nolock(_c) ƒ_WSTDLIB_DEFINED  »_WSTDLIBP_DEFINED  É_WSTRING_DEFINED  õwcswcs wcsstr ‚_TM_DEFINED  ‘_WTIME_DEFINED  œ_INC_WTIME_INL  æ__MINGW_MBWC_CONVERT_DEFINED  ”%_INC_WCHAR_S  	–&0_GLIBCXX_CWCHAR 1 Dbtowc Efgetwc Ffgetws Gfputwc Hfputws Ifwide Jfwprintf Kfwscanf Lgetwc Mgetwchar Nmbrlen Ombrtowc Pmbsinit Qmbsrtowcs Rputwc Sputwchar Tswprintf Uswscanf Vungetwc Wvfwprintf Yvfwscanf [vswprintf ]vswscanf _vwprintf avwscanf cwcrtomb dwcscat ewcschr fwcscmp gwcscoll hwcscpy iwcscspn jwcsftime kwcslen lwcsncat mwcsncmp nwcsncpy owcspbrk pwcsrchr qwcsrtombs rwcsspn swcsstr twcstod vwcstof xwcstok ywcstol zwcstoul {wcsxfrm |wctob }wmemchr ~wmemcmp wmemcpy €wmemmove �wmemset ‚wprintf ƒwscanf íwcstold îwcstoll ïwcstoull ''__EXCEPTION__  &(_GLIBCXX_ATOMIC_LOCK_FREE_H 1 (#_CHAR_TRAITS_H 1 ')9_STL_ALGOBASE_H 1 <*%_FUNCTEXCEPT_H 1 (+_EXCEPTION_DEFINES_H 1 (__try try )__catch(X) catch(X) *__throw_exception_again throw =,!_CPP_TYPE_TRAITS_H 1 ÿ__INT_N(TYPE) template<> struct __is_integer<TYPE> { enum { __value = 1 }; typedef __true_type __type; }; template<> struct __is_integer<unsigned TYPE> { enum { __value = 1 }; typedef __true_type __type; }; š__INT_N >-_EXT_TYPE_TRAITS 1 ?_EXT_NUMERIC_TRAITS 1 +__glibcxx_signed(_Tp) ((_Tp)(-1) < 0) ,__glibcxx_digits(_Tp) (sizeof(_Tp) * __CHAR_BIT__ - __glibcxx_signed(_Tp)) /__glibcxx_min(_Tp) (__glibcxx_signed(_Tp) ? (_Tp)1 << __glibcxx_digits(_Tp) : (_Tp)0) 2__glibcxx_max(_Tp) (__glibcxx_signed(_Tp) ? (((((_Tp)1 << (__glibcxx_digits(_Tp) - 1)) - 1) << 1) + 1) : ~(_Tp)0) O__glibcxx_signed P__glibcxx_digits Q__glibcxx_min R__glibcxx_max T__glibcxx_floating(_Tp,_Fval,_Dval,_LDval) (std::__are_same<_Tp, float>::__value ? _Fval : std::__are_same<_Tp, double>::__value ? _Dval : _LDval) X__glibcxx_max_digits10(_Tp) (2 + __glibcxx_floating(_Tp, __FLT_MANT_DIG__, __DBL_MANT_DIG__, __LDBL_MANT_DIG__) * 643L / 2136) \__glibcxx_digits10(_Tp) __glibcxx_floating(_Tp, __FLT_DIG__, __DBL_DIG__, __LDBL_DIG__) ___glibcxx_max_exponent10(_Tp) __glibcxx_floating(_Tp, __FLT_MAX_10_EXP__, __DBL_MAX_10_EXP__, __LDBL_MAX_10_EXP__) …__glibcxx_floating †__glibcxx_max_digits10 ‡__glibcxx_digits10 ˆ__glibcxx_max_exponent10 @.9_STL_PAIR_H 1 ;/_MOVE_H 1 "0_CONCEPT_CHECK_H 1 /__glibcxx_function_requires(...)  0__glibcxx_class_requires(_a,_b)  1__glibcxx_class_requires2(_a,_b,_c)  2__glibcxx_class_requires3(_a,_b,_c,_d)  3__glibcxx_class_requires4(_a,_b,_c,_d,_e)  ›_GLIBCXX_MOVE(__val) (__val) œ_GLIBCXX_FORWARD(_Tp,__val) (__val) A1<_STL_ITERATOR_BASE_TYPES_H 1 B2<_STL_ITERATOR_BASE_FUNCS_H 1 A_GLIBCXX_DEBUG_MACRO_SWITCH_H 1 =_GLIBCXX_DEBUG_ASSERT(_Condition)  >_GLIBCXX_DEBUG_PEDASSERT(_Condition)  ?_GLIBCXX_DEBUG_ONLY(_Statement) ; @__glibcxx_requires_cond(_Cond,_Msg)  A__glibcxx_requires_valid_range(_First,_Last)  B__glibcxx_requires_non_empty_range(_First,_Last)  C__glibcxx_requires_sorted(_First,_Last)  D__glibcxx_requires_sorted_pred(_First,_Last,_Pred)  E__glibcxx_requires_sorted_set(_First1,_Last1,_First2)  F__glibcxx_requires_sorted_set_pred(_First1,_Last1,_First2,_Pred)  G__glibcxx_requires_partitioned_lower(_First,_Last,_Value)  H__glibcxx_requires_partitioned_upper(_First,_Last,_Value)  I__glibcxx_requires_partitioned_lower_pred(_First,_Last,_Value,_Pred)  J__glibcxx_requires_partitioned_upper_pred(_First,_Last,_Value,_Pred)  K__glibcxx_requires_heap(_First,_Last)  L__glibcxx_requires_heap_pred(_First,_Last,_Pred)  M__glibcxx_requires_nonempty()  N__glibcxx_requires_string(_String)  O__glibcxx_requires_string_len(_String,_Len)  P__glibcxx_requires_subscript(_N)  C3=_STL_ITERATOR_H 1 B4_PTR_TRAITS_H 1 š	_GLIBCXX_MAKE_MOVE_ITERATOR(_Iter) (_Iter) ›	_GLIBCXX_MAKE_MOVE_IF_NOEXCEPT_ITERATOR(_Iter) (_Iter) G_GLIBCXX_PREDEFINED_OPS_H 1 û_GLIBCXX_MOVE3(_Tp,_Up,_Vp) std::copy(_Tp, _Up, _Vp) ¯_GLIBCXX_MOVE_BACKWARD3(_Tp,_Up,_Vp) std::copy_backward(_Tp, _Up, _Vp) ))5#_LOCALE_FWD_H 1 (6%_GLIBCXX_CXX_LOCALE_H 1 )*_INC_LOCALE  7_INC_STDIO  "BUFSIZ 512 _NFILE _NSTREAM_ _NSTREAM_ 512 _IOB_ENTRIES 20 EOF (-1) ,_P_tmpdir "\\" -_wP_tmpdir L"\\" 0L_tmpnam (sizeof(_P_tmpdir) + 12) 7SEEK_CUR 1 8SEEK_END 2 9SEEK_SET 0 ;STDIN_FILENO 0 <STDOUT_FILENO 1 =STDERR_FILENO 2 ?FILENAME_MAX 260 @FOPEN_MAX 20 A_SYS_OPEN 20 BTMP_MAX 32767 U_iob __iob_func() c_FPOS_T_DEFINED  d_FPOSOFF h_FPOSOFF(fp) ((long)(fp)) x_IOREAD 0x0001 y_IOWRT 0x0002 {_IOFBF 0x0000 |_IOLBF 0x0040 }_IONBF 0x0004 _IOMYBUF 0x0008 €_IOEOF 0x0010 �_IOERR 0x0020 ‚_IOSTRG 0x0040 ƒ_IORW 0x0080 ˆ_TWO_DIGIT_EXPONENT 0x1 Â__MINGW_PRINTF_FORMAT Ã__MINGW_SCANF_FORMAT Ä__MINGW_PRINTF_FORMAT gnu_printf Å__MINGW_SCANF_FORMAT gnu_scanf ä__builtin_vsnprintf __mingw_vsnprintf å__builtin_vsprintf __mingw_vsprintf Ò_FILE_OFFSET_BITS_SET_FSEEKO  Þ_FILE_OFFSET_BITS_SET_FTELLO  í_CRT_PERROR_DEFINED  ópopen _popen ôpclose _pclose û_CRT_DIRECTORY_DEFINED  è_STDIO_DEFINED  ë_fgetc_nolock(_stream) (--(_stream)->_cnt >= 0 ? 0xff & *(_stream)->_ptr++ : _filbuf(_stream)) ì_fputc_nolock(_c,_stream) (--(_stream)->_cnt >= 0 ? 0xff & (*(_stream)->_ptr++ = (char)(_c)) : _flsbuf((_c),(_stream))) í_getc_nolock(_stream) _fgetc_nolock(_stream) î_putc_nolock(_c,_stream) _fputc_nolock(_c,_stream) ï_getchar_nolock() _getc_nolock(stdin) ð_putchar_nolock(_c) _putc_nolock((_c),stdout) ñ_getwchar_nolock() _getwc_nolock(stdin) ò_putwchar_nolock(_c) _putwc_nolock((_c),stdout) �P_tmpdir _P_tmpdir ‚SYS_OPEN _SYS_OPEN Æ_P_WAIT 0 Ç_P_NOWAIT 1 È_OLD_P_OVERLAY 2 É_P_NOWAITO 3 Ê_P_DETACH 4 Ë_P_OVERLAY 2 Í_WAIT_CHILD 0 Î_WAIT_GRANDCHILD 1 Ò_SPAWNV_DEFINED  ß8_INC_STDIO_S  	7á&!LC_ALL 0 "LC_COLLATE 1 #LC_CTYPE 2 $LC_MONETARY 3 %LC_NUMERIC 4 &LC_TIME 5 (LC_MIN LC_ALL )LC_MAX LC_TIME ,_LCONV_DEFINED  D_CONFIG_LOCALE_SWT  F_ENABLE_PER_THREAD_LOCALE 0x1 G_DISABLE_PER_THREAD_LOCALE 0x2 H_ENABLE_PER_THREAD_LOCALE_GLOBAL 0x10 I_DISABLE_PER_THREAD_LOCALE_GLOBAL 0x20 J_ENABLE_PER_THREAD_LOCALE_NEW 0x100 K_DISABLE_PER_THREAD_LOCALE_NEW 0x200 -_GLIBCXX_CLOCALE 1 0setlocale 1localeconv +_GLIBCXX_NUM_CATEGORIES 0 *9*:_INC_CTYPE  T_UPPER 0x1 U_LOWER 0x2 V_DIGIT 0x4 W_SPACE 0x8 Y_PUNCT 0x10 Z_CONTROL 0x20 [_BLANK 0x40 \_HEX 0x80 ^_LEADBYTE 0x8000 __ALPHA (0x0100|_UPPER|_LOWER) b_CTYPE_DEFINED  ¼MB_CUR_MAX ___mb_cur_max_func() Ã__mb_cur_max (* __MINGW_IMP_SYMBOL(__mb_cur_max)) Æ___mb_cur_max_func() (__mb_cur_max) É__chvalidchk(a,b) (__PCTYPE_FUNC[(a)] & (b)) Ê_chvalidchk_l(_Char,_Flag,_Locale) (!_Locale ? __chvalidchk(_Char,_Flag) : ((_locale_t)_Locale)->locinfo->pctype[_Char] & (_Flag)) Ë_ischartype_l(_Char,_Flag,_Locale) (((_Locale)!=NULL && (((_locale_t)(_Locale))->locinfo->mb_cur_max) > 1) ? _isctype_l(_Char,(_Flag),_Locale) : _chvalidchk_l(_Char,_Flag,_Locale)) Ì_isalpha_l(_Char,_Locale) _ischartype_l(_Char,_ALPHA,_Locale) Í_isupper_l(_Char,_Locale) _ischartype_l(_Char,_UPPER,_Locale) Î_islower_l(_Char,_Locale) _ischartype_l(_Char,_LOWER,_Locale) Ï_isdigit_l(_Char,_Locale) _ischartype_l(_Char,_DIGIT,_Locale) Ð_isxdigit_l(_Char,_Locale) _ischartype_l(_Char,_HEX,_Locale) Ñ_isspace_l(_Char,_Locale) _ischartype_l(_Char,_SPACE,_Locale) Ò_ispunct_l(_Char,_Locale) _ischartype_l(_Char,_PUNCT,_Locale) Ó_isalnum_l(_Char,_Locale) _ischartype_l(_Char,_ALPHA|_DIGIT,_Locale) Ô_isprint_l(_Char,_Locale) _ischartype_l(_Char,_BLANK|_PUNCT|_ALPHA|_DIGIT,_Locale) Õ_isgraph_l(_Char,_Locale) _ischartype_l(_Char,_PUNCT|_ALPHA|_DIGIT,_Locale) Ö_iscntrl_l(_Char,_Locale) _ischartype_l(_Char,_CONTROL,_Locale) ×_tolower(_Char) ((_Char)-'A'+'a') Ø_toupper(_Char) ((_Char)-'a'+'A') Ù__isascii(_Char) ((unsigned)(_Char) < 0x80) Ú__toascii(_Char) ((_Char) & 0x7f) û__iscsymf(_c) (isalpha(_c) || ((_c)=='_')) ü__iscsym(_c) (isalnum(_c) || ((_c)=='_')) ý__iswcsymf(_c) (iswalpha(_c) || ((_c)=='_')) þ__iswcsym(_c) (iswalnum(_c) || ((_c)=='_')) ÿ_iscsymf_l(_c,_p) (_isalpha_l(_c,_p) || ((_c)=='_')) €_iscsym_l(_c,_p) (_isalnum_l(_c,_p) || ((_c)=='_')) �_iswcsymf_l(_c,_p) (_iswalpha_l(_c,_p) || ((_c)=='_')) ‚_iswcsym_l(_c,_p) (_iswalnum_l(_c,_p) || ((_c)=='_')) Œisascii __isascii �toascii __toascii Žiscsymf __iscsymf �iscsym __iscsym -_GLIBCXX_CCTYPE 1 0isalnum 1isalpha 2iscntrl 3isdigit 4isgraph 5islower 6isprint 7ispunct 8isspace 9isupper :isxdigit ;tolower <toupper *#_IOS_BASE_H 1 ';_GLIBCXX_ATOMICITY_H 1 #<_GLIBCXX_GCC_GTHR_H  Œ_GLIBCXX_GTHREAD_USE_WEAK �_GLIBCXX_GTHREAD_USE_WEAK 0 ”=_GLIBCXX_GCC_GTHR_POSIX_H   __GTHREADS 1 !__GTHREADS_CXX0X 1 "><WIN_PTHREADS_H  >?@
_INC_STDDEF  _CRT_ERRNO_DEFINED  errno (*_errno()) _threadid (__threadid()) 1_STDDEF_H  2_STDDEF_H_  4_ANSI_STDDEF_H  6__STDDEF_H__  £__need_ptrdiff_t ð__need_size_t Ñ__need_wchar_t ŠNULL ŒNULL __null ™__need_NULL žoffsetof(TYPE,MEMBER) __builtin_offsetof (TYPE, MEMBER) ?A_INC_ERRNO  EPERM 1 ENOENT 2 ENOFILE ENOENT ESRCH 3 EINTR 4 EIO 5 ENXIO 6 E2BIG 7  ENOEXEC 8 !EBADF 9 "ECHILD 10 #EAGAIN 11 $ENOMEM 12 %EACCES 13 &EFAULT 14 'EBUSY 16 (EEXIST 17 )EXDEV 18 *ENODEV 19 +ENOTDIR 20 ,EISDIR 21 -ENFILE 23 .EMFILE 24 /ENOTTY 25 0EFBIG 27 1ENOSPC 28 2ESPIPE 29 3EROFS 30 4EMLINK 31 5EPIPE 32 6EDOM 33 7EDEADLK 36 8ENAMETOOLONG 38 9ENOLCK 39 :ENOSYS 40 ;ENOTEMPTY 41 ?_SECURECRT_ERRCODE_VALUES_DEFINED  @EINVAL 22 AERANGE 34 BEILSEQ 42 CSTRUNCATE 80 GEDEADLOCK EDEADLK LENOTSUP 129 REAFNOSUPPORT 102 VEADDRINUSE 100 ZEADDRNOTAVAIL 101 ^EISCONN 113 bENOBUFS 119 fECONNABORTED 106 jEALREADY 103 nECONNREFUSED 107 rECONNRESET 108 vEDESTADDRREQ 109 zEHOSTUNREACH 110 ~EMSGSIZE 115 ‚ENETDOWN 116 †ENETRESET 117 ŠENETUNREACH 118 ŽENOPROTOOPT 123 ’ENOTSOCK 128 –ENOTCONN 126 šECANCELED 105 žEINPROGRESS 112 ¢EOPNOTSUPP 130 ¦EWOULDBLOCK 140 ªEOWNERDEAD 133 ®EPROTO 134 ²EPROTONOSUPPORT 135 ·ETIMEDOUT 138 »ELOOP 114 ¿EPROTOTYPE 136 ÃEOVERFLOW 132 @B_INC_TYPES  :_PID_T_  Cpid_t I_MODE_T_  X_TIMESPEC_DEFINED  e_SIGSET_T_  BC_INC_PROCESS  %_CRT_TERMINATE_DEFINED  3abort S_CRT_SYSTEM_DEFINED  ‘P_WAIT _P_WAIT ’P_NOWAIT _P_NOWAIT “P_OVERLAY _P_OVERLAY ”OLD_P_OVERLAY _OLD_P_OVERLAY •P_NOWAITO _P_NOWAITO –P_DETACH _P_DETACH —WAIT_CHILD _WAIT_CHILD ˜WAIT_GRANDCHILD _WAIT_GRANDCHILD «_CRT_GETPID_DEFINED  CD_GCC_LIMITS_H_  "E_GCC_NEXT_LIMITS_H  D¨F	_INC_LIMITS  PATH_MAX 260 CHAR_BIT 8 SCHAR_MIN (-128) SCHAR_MAX 127 UCHAR_MAX 0xff CHAR_MIN SCHAR_MIN CHAR_MAX SCHAR_MAX MB_LEN_MAX 5 SHRT_MIN (-32768)  SHRT_MAX 32767 !USHRT_MAX 0xffffU "INT_MIN (-2147483647 - 1) #INT_MAX 2147483647 $UINT_MAX 0xffffffffU %LONG_MIN (-2147483647L - 1) &LONG_MAX 2147483647L 'ULONG_MAX 0xffffffffUL (LLONG_MAX 9223372036854775807ll )LLONG_MIN (-9223372036854775807ll - 1) *ULLONG_MAX 0xffffffffffffffffull ,_I8_MIN (-127 - 1) -_I8_MAX 127 ._UI8_MAX 0xffu 0_I16_MIN (-32767 - 1) 1_I16_MAX 32767 2_UI16_MAX 0xffffu 4_I32_MIN (-2147483647 - 1) 5_I32_MAX 2147483647 6_UI32_MAX 0xffffffffu 9LONG_LONG_MAX :LONG_LONG_MAX 9223372036854775807ll ;LONG_LONG_MIN <LONG_LONG_MIN (-LONG_LONG_MAX-1) =ULONG_LONG_MAX >ULONG_LONG_MAX (2ull * LONG_LONG_MAX + 1ull) A_I64_MIN (-9223372036854775807ll - 1) B_I64_MAX 9223372036854775807ll C_UI64_MAX 0xffffffffffffffffull GSIZE_MAX _UI64_MAX OSSIZE_MAX _I64_MAX _GCC_NEXT_LIMITS_H <_LIMITS_H___  ?CHAR_BIT @CHAR_BIT __CHAR_BIT__ HSCHAR_MIN ISCHAR_MIN (-SCHAR_MAX - 1) JSCHAR_MAX KSCHAR_MAX __SCHAR_MAX__ NUCHAR_MAX RUCHAR_MAX (SCHAR_MAX * 2 + 1) `CHAR_MIN aCHAR_MIN SCHAR_MIN bCHAR_MAX cCHAR_MAX SCHAR_MAX gSHRT_MIN hSHRT_MIN (-SHRT_MAX - 1) iSHRT_MAX jSHRT_MAX __SHRT_MAX__ mUSHRT_MAX qUSHRT_MAX (SHRT_MAX * 2 + 1) uINT_MIN vINT_MIN (-INT_MAX - 1) wINT_MAX xINT_MAX __INT_MAX__ {UINT_MAX |UINT_MAX (INT_MAX * 2U + 1U) €LONG_MIN �LONG_MIN (-LONG_MAX - 1L) ‚LONG_MAX ƒLONG_MAX __LONG_MAX__ †ULONG_MAX ‡ULONG_MAX (LONG_MAX * 2UL + 1UL) —LONG_LONG_MIN ˜LONG_LONG_MIN (-LONG_LONG_MAX - 1LL) ™LONG_LONG_MAX šLONG_LONG_MAX __LONG_LONG_MAX__ �ULONG_LONG_MAX žULONG_LONG_MAX (LONG_LONG_MAX * 2ULL + 1ULL) DG_INC_SIGNAL  
HWIN_PTHREADS_SIGNAL_H  pthread_sigmask(H,S1,S2) 0 _SIG_ATOMIC_T_DEFINED  NSIG 23 SIGINT 2 SIGILL 4 SIGABRT_COMPAT 6 SIGFPE 8 SIGSEGV 11 SIGTERM 15 SIGBREAK 21 SIGABRT 22 SIGABRT2 22 2SIG_DFL (__p_sig_fn_t)0 3SIG_IGN (__p_sig_fn_t)1 4SIG_GET (__p_sig_fn_t)2 5SIG_SGE (__p_sig_fn_t)3 6SIG_ACK (__p_sig_fn_t)4 7SIG_ERR (__p_sig_fn_t)-1 :_pxcptinfoptrs (*__pxcptinfoptrs()) FI_TIMEB_H_  3_TIMEB_DEFINED  Q_timeb __timeb64 |J_TIMEB_H_S  
IHK=WIN_PTHREADS_PTHREAD_COMPAT_H  AWINPTHREADS_INLINE inline BWINPTHREADS_ATTRIBUTE(X) __attribute__(X) CWINPTHREADS_SECTION(X) __section__(X) N__WINPTHREADS_VERSION_MAJOR 0 O__WINPTHREADS_VERSION_MINOR 5 P__WINPTHREADS_VERSION_PATCHLEVEL 0 S__WINPTHREADS_VERSION 0x00050000 \WINPTHREAD_API  bRWLS_PER_THREAD 8 qPTHREAD_CANCEL_DISABLE 0 rPTHREAD_CANCEL_ENABLE 0x01 tPTHREAD_CANCEL_DEFERRED 0 uPTHREAD_CANCEL_ASYNCHRONOUS 0x02 wPTHREAD_CREATE_JOINABLE 0 xPTHREAD_CREATE_DETACHED 0x04 zPTHREAD_EXPLICIT_SCHED 0 {PTHREAD_INHERIT_SCHED 0x08 }PTHREAD_SCOPE_PROCESS 0 ~PTHREAD_SCOPE_SYSTEM 0x10 €PTHREAD_DEFAULT_ATTR (PTHREAD_CANCEL_ENABLE) ‚PTHREAD_CANCELED ((void *) (intptr_t) 0xDEADBEEF) „_PTHREAD_NULL_THREAD ((pthread_t) 0) †PTHREAD_ONCE_INIT 0 ˆPTHREAD_DESTRUCTOR_ITERATIONS 256 ‰PTHREAD_KEYS_MAX (1<<20) ‹PTHREAD_MUTEX_NORMAL 0 ŒPTHREAD_MUTEX_ERRORCHECK 1 �PTHREAD_MUTEX_RECURSIVE 2 ŽPTHREAD_MUTEX_DEFAULT PTHREAD_MUTEX_NORMAL �PTHREAD_MUTEX_SHARED 1 ‘PTHREAD_MUTEX_PRIVATE 0 “PTHREAD_PRIO_NONE 0 ”PTHREAD_PRIO_INHERIT 8 •PTHREAD_PRIO_PROTECT 16 –PTHREAD_PRIO_MULT 32 —PTHREAD_PROCESS_SHARED 1 ˜PTHREAD_PROCESS_PRIVATE 0 šPTHREAD_MUTEX_FAST_NP PTHREAD_MUTEX_NORMAL ›PTHREAD_MUTEX_TIMED_NP PTHREAD_MUTEX_FAST_NP œPTHREAD_MUTEX_ADAPTIVE_NP PTHREAD_MUTEX_FAST_NP �PTHREAD_MUTEX_ERRORCHECK_NP PTHREAD_MUTEX_ERRORCHECK žPTHREAD_MUTEX_RECURSIVE_NP PTHREAD_MUTEX_RECURSIVE ¥PTHREAD_BARRIER_SERIAL_THREAD 1 ¨MAX_READ_LOCKS (INT_MAX - 1) «pthread_atfork(F1,F2,F3) 0 ®pthread_mutex_getprioceiling(M,P) ENOTSUP ¯pthread_mutex_setprioceiling(M,P) ENOTSUP °pthread_getcpuclockid(T,C) ENOTSUP ±pthread_attr_getguardsize(A,S) ENOTSUP ²pthread_attr_setgaurdsize(A,S) ENOTSUP Îpthread_cleanup_push(F,A) { const _pthread_cleanup _pthread_cup = {(F), (A), *pthread_getclean()}; __sync_synchronize(); *pthread_getclean() = (_pthread_cleanup *) &_pthread_cup; __sync_synchronize() Öpthread_cleanup_pop(E) (*pthread_getclean() = _pthread_cup.next, (E?_pthread_cup.func((pthread_once_t *)_pthread_cup.arg):0));} éSCHED_OTHER 0 êSCHED_FIFO 1 ëSCHED_RR 2 ìSCHED_MIN SCHED_OTHER íSCHED_MAX SCHED_RR ’PTHREAD_MUTEX_NORMAL 0 “PTHREAD_MUTEX_ERRORCHECK 1 ”PTHREAD_MUTEX_RECURSIVE 2 –GENERIC_INITIALIZER ((void *) (size_t) -1) —GENERIC_ERRORCHECK_INITIALIZER ((void *) (size_t) -2) ˜GENERIC_RECURSIVE_INITIALIZER ((void *) (size_t) -3) ™GENERIC_NORMAL_INITIALIZER ((void *) (size_t) -1) šPTHREAD_MUTEX_INITIALIZER (pthread_mutex_t)GENERIC_INITIALIZER ›PTHREAD_RECURSIVE_MUTEX_INITIALIZER (pthread_mutex_t)GENERIC_RECURSIVE_INITIALIZER œPTHREAD_ERRORCHECK_MUTEX_INITIALIZER (pthread_mutex_t)GENERIC_ERRORCHECK_INITIALIZER �PTHREAD_NORMAL_MUTEX_INITIALIZER (pthread_mutex_t)GENERIC_NORMAL_INITIALIZER žPTHREAD_DEFAULT_MUTEX_INITIALIZER PTHREAD_NORMAL_MUTEX_INITIALIZER ŸPTHREAD_COND_INITIALIZER (pthread_cond_t)GENERIC_INITIALIZER  PTHREAD_RWLOCK_INITIALIZER (pthread_rwlock_t)GENERIC_INITIALIZER ¡PTHREAD_SPINLOCK_INITIALIZER (pthread_spinlock_t)GENERIC_INITIALIZER ƒ__clockid_t_defined 1  SIG_BLOCK 0 £SIG_UNBLOCK 1 ¦SIG_SETMASK 2 ©LWIN_PTHREADS_UNISTD_H  P_POSIX_THREADS Q_POSIX_THREADS 200112L d_POSIX_READER_WRITER_LOCKS e_POSIX_READER_WRITER_LOCKS 200112L r_POSIX_SPIN_LOCKS s_POSIX_SPIN_LOCKS 200112L �_POSIX_BARRIERS ‚_POSIX_BARRIERS 200112L •_POSIX_THREAD_SAFE_FUNCTIONS –_POSIX_THREAD_SAFE_FUNCTIONS 200112L ¤_POSIX_TIMEOUTS ¥_POSIX_TIMEOUTS 200112L À_POSIX_CLOCK_SELECTION Á_POSIX_CLOCK_SELECTION 200112 Ñ_POSIX_SEMAPHORES Ò_POSIX_SEMAPHORES 200112 «_POSIX_THREAD_DESTRUCTOR_ITERATIONS ¬_POSIX_THREAD_DESTRUCTOR_ITERATIONS PTHREAD_DESTRUCTOR_ITERATIONS ®_POSIX_THREAD_KEYS_MAX ¯_POSIX_THREAD_KEYS_MAX PTHREAD_KEYS_MAX ±PTHREAD_THREADS_MAX ²PTHREAD_THREADS_MAX 2019 ´_POSIX_SEM_NSEMS_MAX µ_POSIX_SEM_NSEMS_MAX 256 ·SEM_NSEMS_MAX ¸SEM_NSEMS_MAX 1024 ©_GTHREAD_USE_MUTEX_INIT_FUNC «_GTHREAD_USE_MUTEX_INIT_FUNC 1 $_GTHREAD_USE_MUTEX_INIT_FUNC 1 ;__GTHREAD_HAS_COND 1 =__GTHREAD_MUTEX_INIT PTHREAD_MUTEX_INITIALIZER >__GTHREAD_MUTEX_INIT_FUNCTION __gthread_mutex_init_function ?__GTHREAD_ONCE_INIT PTHREAD_ONCE_INIT A__GTHREAD_RECURSIVE_MUTEX_INIT PTHREAD_RECURSIVE_MUTEX_INITIALIZER G__GTHREAD_COND_INIT PTHREAD_COND_INITIALIZER H__GTHREAD_TIME_INIT {0,0} K__GTHREAD_MUTEX_INIT `__gthrw2(name,name2,type)  a__gthrw_(name) name e__gthrw(name) __gthrw2(__gthrw_ ## name,name,name) $_GLIBCXX_ATOMIC_WORD_H 1 o_GLIBCXX_READ_MEM_BARRIER __asm __volatile ("":::"memory") r_GLIBCXX_WRITE_MEM_BARRIER __asm __volatile ("":::"memory") )M#_LOCALE_CLASSES_H 1 (N"_GLIBCXX_STRING 1 )O,_ALLOCATOR_H 1 .P_GLIBCXX_CXX_ALLOCATOR_H 1 !_NEW_ALLOCATOR_H 1 !Q#_NEW  4__allocator_base __gnu_cxx::new_allocator  __allocator_base ,R_OSTREAM_INSERT_H 1 $S _CXXABI_FORCED_H 1 0T9_STL_FUNCTION_H 1 èU9_BACKWARD_BINDERS_H 1 3V_GLIBCXX_RANGE_ACCESS_H 1 4W#_BASIC_STRING_H 1 (X_EXT_ALLOC_TRAITS_H 1 5Y(_BASIC_STRING_TCC 1 ÊZ#_LOCALE_CLASSES_TCC 1 ,["_GLIBCXX_STDEXCEPT 1 +\"_GLIBXX_STREAMBUF 1 Ò]#_STREAMBUF_TCC 1 ,^_BASIC_IOS_H 1 %_#_LOCALE_FACETS_H 1 '	2_INC_WCTYPE  [_UPPER 0x1 \_LOWER 0x2 ]_DIGIT 0x4 ^_SPACE 0x8 `_PUNCT 0x10 a_CONTROL 0x20 b_BLANK 0x40 c_HEX 0x80 e_LEADBYTE 0x8000 f_ALPHA (0x0100|_UPPER|_LOWER) 6_GLIBCXX_CWCTYPE 1 9iswalnum :iswalpha <iswblank >iswcntrl ?iswctype @iswdigit Aiswgraph Biswlower Ciswprint Diswpunct Eiswspace Fiswupper Giswxdigit Htowctrans Itowlower Jtowupper Kwctrans Lwctype (9)`0a_STREAMBUF_ITERATOR_H 1 8_GLIBCXX_NUM_FACETS 28 9_GLIBCXX_NUM_CXX11_FACETS 16 ?_GLIBCXX_NUM_UNICODE_FACETS 2 þbÛc_LOCALE_FACETS_TCC 1 „d_BASIC_IOS_TCC 1 þe#_OSTREAM_TCC 1 (f"_GLIBCXX_ISTREAM 1 ¦g#_ISTREAM_TCC 1 h_OMP_H 1 _LIBGOMP_OMP_LOCK_DEFINED 1 C__GOMP_NOTHROW throw ()  Ï	   s	  û      ../src C:/TDM-GCC-64/lib/gcc/x86_64-w64-mingw32/5.1.0/include/c++ C:/TDM-GCC-64/lib/gcc/x86_64-w64-mingw32/5.1.0/include/c++/x86_64-w64-mingw32/bits C:/TDM-GCC-64/lib/gcc/x86_64-w64-mingw32/5.1.0/include/c++/debug C:/TDM-GCC-64/lib/gcc/x86_64-w64-mingw32/5.1.0/include/c++/bits C:/TDM-GCC-64/lib/gcc/x86_64-w64-mingw32/5.1.0/include/c++/ext C:/TDM-GCC-64/x86_64-w64-mingw32/include C:/TDM-GCC-64/x86_64-w64-mingw32/include/sdks C:/TDM-GCC-64/x86_64-w64-mingw32/include/sec_api C:/TDM-GCC-64/lib/gcc/x86_64-w64-mingw32/5.1.0/include C:/TDM-GCC-64/x86_64-w64-mingw32/include/sys C:/TDM-GCC-64/lib/gcc/x86_64-w64-mingw32/5.1.0/include-fixed C:/TDM-GCC-64/x86_64-w64-mingw32/include/sec_api/sys C:/TDM-GCC-64/lib/gcc/x86_64-w64-mingw32/5.1.0/include/c++/backward  sum_parallel_for_local_var.cpp   iostream   cwchar   c++config.h   debug.h   char_traits.h   clocale   ios_base.h   cwctype   iosfwd   <built-in>    predefined_ops.h   new_allocator.h   numeric_traits.h   crtdefs.h   locale.h   wchar.h   swprintf.inl   atomic_word.h   wctype.h   os_defines.h   cpu_defines.h   ostream   ios   stringfwd.h   memoryfwd.h   postypes.h   _mingw.h   _mingw_mac.h   _mingw_secapi.h   vadefs.h   _mingw_directx.h   _mingw_ddk.h   _mingw_print_push.h   _mingw_off_t.h   _mingw_stat64.h   wchar_s.h 	  _mingw_print_pop.h   exception   atomic_lockfree_defines.h   stl_algobase.h   functexcept.h   exception_defines.h   cpp_type_traits.h   type_traits.h   stl_pair.h   move.h   concept_check.h   stl_iterator_base_types.h   stl_iterator_base_funcs.h   stl_iterator.h   ptr_traits.h   localefwd.h   c++locale.h   stdio.h   stdio_s.h 	  cctype   ctype.h   atomicity.h   gthr.h   gthr-default.h   pthread.h   stddef.h 
  stddef.h   errno.h   types.h   process.h   limits.h   syslimits.h   limits.h   signal.h   pthread_signal.h   timeb.h   timeb_s.h   pthread_compat.h   pthread_unistd.h   locale_classes.h   string   allocator.h   c++allocator.h   new   ostream_insert.h   cxxabi_forced.h   stl_function.h   binders.h   range_access.h   basic_string.h   alloc_traits.h   basic_string.tcc   locale_classes.tcc   stdexcept   streambuf   streambuf.tcc   basic_ios.h   locale_facets.h   ctype_base.h   streambuf_iterator.h   ctype_inline.h   locale_facets.tcc   basic_ios.tcc   ostream.tcc   istream   istream.tcc   omp.h 
    	        	å0Ø’ t ƒ & œkØ%0t‚P.Ö f0�Ptt‚ __min __max __digits _Value __is_signed GCC: (tdm64-1) 5.1.0                               ÿÿÿÿ x        $               ¸       A†C³Æ  $       ¸              A†CVÆ   $       Ó       <       A†CwÆ   $                    A†CYÆ                (       )    #   *    t   +       *    ­   ,    Ã       È   -    ó       ø   .      /        
       
              
       
              
       
            $   
    (   
    ,           
           µ   
    Å        É       %  "    0  "    ;  "    F  "    Q  "    �  "    š  "    ¥  "    °  "    »  "    ì  "    ÷  "      "      "      "    N  "    Y  "    d  "    o  "    z  "    °  "    »  "    Æ  "    Ñ  "    Ü  "    3  
    •  
    Â  
    ÿ  
    v  
    �                
            €	  
        0       &        
    D   &    H   
    l   &    p   
    ”   &    ˜   
    .file       þÿ  g    ‚                 ¡               °                                Ò                         __tcf_0 ¸           ë   Ó                   .text          -               .data                            .bss                            .rdata                          .xdata         0                 .pdata         0                .ctors                             L         u  #                 X      	   y                    f      
   0                    u         Øµ                   ‚         Ó	                   Ž         (                     ™                              ¤         ¸                    ±              Ã               û               	                               9               Q           atexit               i           s  .debug_info .debug_abbrev .debug_aranges .debug_macro .debug_line .debug_str .rdata$zzz .rdata$.refptr._ZSt4cout .debug_frame sum_parallel_for_local_var.cpp _ZStL8__ioinit _Z26sum_parallel_for_local_varPdi .rdata$.refptr._ZSt4cout _Z41__static_initialization_and_destruction_0ii _GLOBAL__sub_I__Z26sum_parallel_for_local_varPdi .debug_info .debug_abbrev .debug_aranges .debug_macro .debug_line .debug_str .rdata$zzz .debug_frame .refptr._ZSt4cout _ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc omp_get_wtime _Z17recordThreadIndexi _Z17printSumWithTimesiii _ZNSt8ios_base4InitD1Ev _ZNSt8ios_base4InitC1Ev _ZSt4cout ]]></snapshot>
  </Command>
  <Command __id="23596" _type="DiffBasedFileOpenCommand" date="Fri Dec 20 09:04:04 EST 2019" docASTNodeCount="1" docActiveCodeLength="550" docExpressionCount="0" docLength="626" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="184139530">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\sum_parallel.cpp]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"#include <iostream>¶#include <omp.h>¶¶using namespace std;¶¶void printSumWithTimes(int sum, int start, int end);¶void printNumThreads();¶void recordThreadIndex(int index);¶void sum_parallel(double* array, int size) {¶	cout << "sum_parallel\n";¶¶	double start = omp_get_wtime();¶¶	double sum = 0;¶¶"), Diff(INSERT,"//"), Diff(EQUAL,"	#pragma omp parallel¶"), Diff(INSERT,"//"), Diff(EQUAL,"	for (int i = 0; i < size; i++)¶"), Diff(INSERT,"//"), Diff(EQUAL,"		sum += array[i];"), Diff(INSERT,"¶    #pragma omp parallel¶	{¶		double local_sum = 0;¶¶		#pragma omp for¶		for(int i = 0; i < size; i++)¶			local_sum += array[i];¶¶		#pragma omp critical¶		sum += local_sum;¶	}"), Diff(EQUAL,"¶¶	double end = omp_get_wtime();¶¶	printSumWithTimes(sum, start, end);¶¶¶}¶")]]]></diff>
    <snapshot><![CDATA[#include <iostream>
#include <omp.h>

using namespace std;

void printSumWithTimes(int sum, int start, int end);
void printNumThreads();
void recordThreadIndex(int index);
void sum_parallel(double* array, int size) {
	cout << "sum_parallel\n";

	double start = omp_get_wtime();

	double sum = 0;

//	#pragma omp parallel
//	for (int i = 0; i < size; i++)
//		sum += array[i];
    #pragma omp parallel
	{
		double local_sum = 0;

		#pragma omp for
		for(int i = 0; i < size; i++)
			local_sum += array[i];

		#pragma omp critical
		sum += local_sum;
	}

	double end = omp_get_wtime();

	printSumWithTimes(sum, start, end);


}
]]></snapshot>
  </Command>
  <Command __id="23593" _type="SelectTextCommand" caretOffset="551" date="Fri Dec 20 09:03:48 EST 2019" end="551" start="380" starttimestamp="1576666505112" timestamp="184123486" />
  <Command __id="23594" _type="CopyCommand" date="Fri Dec 20 09:03:49 EST 2019" starttimestamp="1576666505112" timestamp="184124179" />
  <Command __id="23597" _type="SelectTextCommand" caretOffset="551" date="Fri Dec 20 09:04:04 EST 2019" end="551" start="380" starttimestamp="1576666505112" timestamp="184139767" />
  <Command __id="23599" _type="MoveCaretCommand" caretOffset="0" date="Fri Dec 20 09:04:10 EST 2019" docOffset="0" starttimestamp="1576666505112" timestamp="184145879" />
  <Command __id="23598" _type="DiffBasedFileOpenCommand" date="Fri Dec 20 09:04:10 EST 2019" docASTNodeCount="1" docActiveCodeLength="482" docExpressionCount="0" docLength="482" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="184145724">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\sum_parallel_for_local_var.cpp]]></filePath>
    <diff><![CDATA[null]]></diff>
    <snapshot><![CDATA[#include <iostream>
#include <omp.h>

using namespace std;

void printSumWithTimes (int sum, int start, int end);
void printNumThreads();
void recordThreadIndex(int index);
void sum_parallel_for_local_var(double* array, int size)
{
	cout << "sum_parallel_for_local_var\n";

	double start = omp_get_wtime();

	double sum = 0;

	for (int i = 0; i < size; i++) {
			sum += array[i];
			recordThreadIndex(i);
	}

	double end = omp_get_wtime();

	printSumWithTimes(sum, start, end);
	
}
]]></snapshot>
  </Command>
  <Command __id="23600" _type="SelectTextCommand" caretOffset="309" date="Fri Dec 20 09:04:20 EST 2019" end="407" start="309" starttimestamp="1576666505112" timestamp="184155486" />
  <Command __id="23607" _type="EclipseCommand" commandID="org.eclipse.cdt.ui.edit.text.c.toggle.comment" date="Fri Dec 20 09:04:21 EST 2019" starttimestamp="1576666505112" timestamp="184156556" />
  <Command __id="23608" _type="MoveCaretCommand" caretOffset="419" date="Fri Dec 20 09:04:23 EST 2019" docOffset="419" starttimestamp="1576666505112" timestamp="184158259" />
  <Command __id="23610" _type="InsertStringCommand" date="Fri Dec 20 09:04:23 EST 2019" starttimestamp="1576666505112" timestamp="184158732" timestamp2="184158732">
    <data><![CDATA[]]></data>
  </Command>
  <Command __id="23612" _type="PasteCommand" date="Fri Dec 20 09:04:24 EST 2019" starttimestamp="1576666505112" timestamp="184159557" />
  <Command __id="23613" _type="MoveCaretCommand" caretOffset="420" date="Fri Dec 20 09:04:27 EST 2019" docOffset="420" starttimestamp="1576666505112" timestamp="184162206" />
  <Command __id="23615" _type="InsertStringCommand" date="Fri Dec 20 09:04:27 EST 2019" starttimestamp="1576666505112" timestamp="184162590" timestamp2="184162590">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="23617" _type="InsertStringCommand" date="Fri Dec 20 09:04:27 EST 2019" starttimestamp="1576666505112" timestamp="184162807" timestamp2="184162807">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="23619" _type="InsertStringCommand" date="Fri Dec 20 09:04:28 EST 2019" starttimestamp="1576666505112" timestamp="184162987" timestamp2="184162987">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="23621" _type="InsertStringCommand" date="Fri Dec 20 09:04:28 EST 2019" starttimestamp="1576666505112" timestamp="184163176" timestamp2="184163176">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="23622" _type="SelectTextCommand" caretOffset="413" date="Fri Dec 20 09:04:32 EST 2019" end="413" start="393" starttimestamp="1576666505112" timestamp="184167008" />
  <Command __id="23623" _type="CopyCommand" date="Fri Dec 20 09:04:32 EST 2019" starttimestamp="1576666505112" timestamp="184167754" />
  <DocumentChange __id="23601" _type="Insert" date="Fri Dec 20 09:04:21 EST 2019" docASTNodeCount="1" docActiveCodeLength="466" docExpressionCount="0" docLength="484" length="2" offset="308" starttimestamp="1576666505112" timestamp="184156538">
    <text><![CDATA[//]]></text>
  </DocumentChange>
  <DocumentChange __id="23602" _type="Insert" date="Fri Dec 20 09:04:21 EST 2019" docASTNodeCount="1" docActiveCodeLength="466" docExpressionCount="0" docLength="486" length="2" offset="327" starttimestamp="1576666505112" timestamp="184156539">
    <text><![CDATA[//]]></text>
  </DocumentChange>
  <DocumentChange __id="23603" _type="Insert" date="Fri Dec 20 09:04:21 EST 2019" docASTNodeCount="1" docActiveCodeLength="433" docExpressionCount="0" docLength="488" length="2" offset="330" starttimestamp="1576666505112" timestamp="184156540">
    <text><![CDATA[//]]></text>
  </DocumentChange>
  <DocumentChange __id="23604" _type="Insert" date="Fri Dec 20 09:04:21 EST 2019" docASTNodeCount="1" docActiveCodeLength="414" docExpressionCount="0" docLength="490" length="2" offset="366" starttimestamp="1576666505112" timestamp="184156542">
    <text><![CDATA[//]]></text>
  </DocumentChange>
  <DocumentChange __id="23605" _type="Insert" date="Fri Dec 20 09:04:21 EST 2019" docASTNodeCount="1" docActiveCodeLength="390" docExpressionCount="0" docLength="492" length="2" offset="388" starttimestamp="1576666505112" timestamp="184156543">
    <text><![CDATA[//]]></text>
  </DocumentChange>
  <DocumentChange __id="23606" _type="Insert" date="Fri Dec 20 09:04:21 EST 2019" docASTNodeCount="1" docActiveCodeLength="388" docExpressionCount="0" docLength="494" length="2" offset="415" starttimestamp="1576666505112" timestamp="184156544">
    <text><![CDATA[//]]></text>
  </DocumentChange>
  <DocumentChange __id="23609" _type="Insert" date="Fri Dec 20 09:04:23 EST 2019" docASTNodeCount="1" docActiveCodeLength="390" docExpressionCount="0" docLength="496" length="2" offset="419" starttimestamp="1576666505112" timestamp="184158725">
    <text><![CDATA[
	]]></text>
  </DocumentChange>
  <DocumentChange __id="23611" _type="Replace" date="Fri Dec 20 09:04:24 EST 2019" docASTNodeCount="1" docActiveCodeLength="560" docExpressionCount="0" docLength="666" endLine="20" insertionLength="171" int_docASTNodeCount="1" int_docActiveCodeLength="389" int_docExpressionCount="0" int_docLength="495" length="1" offset="420" startLine="20" starttimestamp="1576666505112" timestamp="184159538">
    <deletedText><![CDATA[	]]></deletedText>
    <insertedText><![CDATA[#pragma omp parallel
	{
		double local_sum = 0;

		#pragma omp for
		for(int i = 0; i < size; i++)
			local_sum += array[i];

		#pragma omp critical
		sum += local_sum;
	}]]></insertedText>
  </DocumentChange>
  <DocumentChange __id="23614" _type="Insert" date="Fri Dec 20 09:04:27 EST 2019" docASTNodeCount="1" docActiveCodeLength="561" docExpressionCount="0" docLength="667" length="1" offset="420" starttimestamp="1576666505112" timestamp="184162579">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="23616" _type="Insert" date="Fri Dec 20 09:04:27 EST 2019" docASTNodeCount="1" docActiveCodeLength="562" docExpressionCount="0" docLength="668" length="1" offset="421" starttimestamp="1576666505112" timestamp="184162797">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="23618" _type="Insert" date="Fri Dec 20 09:04:28 EST 2019" docASTNodeCount="1" docActiveCodeLength="563" docExpressionCount="0" docLength="669" length="1" offset="422" starttimestamp="1576666505112" timestamp="184162976">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="23620" _type="Insert" date="Fri Dec 20 09:04:28 EST 2019" docASTNodeCount="1" docActiveCodeLength="564" docExpressionCount="0" docLength="670" length="1" offset="423" starttimestamp="1576666505112" timestamp="184163163">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="23625" _type="Insert" date="Fri Dec 20 09:04:36 EST 2019" docASTNodeCount="1" docActiveCodeLength="565" docExpressionCount="0" docLength="671" length="1" offset="522" starttimestamp="1576666505112" timestamp="184171850">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <Command __id="23624" _type="MoveCaretCommand" caretOffset="522" date="Fri Dec 20 09:04:36 EST 2019" docOffset="522" starttimestamp="1576666505112" timestamp="184171229" />
  <Command __id="23626" _type="InsertStringCommand" date="Fri Dec 20 09:04:36 EST 2019" starttimestamp="1576666505112" timestamp="184171856" timestamp2="184171856">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="23628" _type="InsertStringCommand" date="Fri Dec 20 09:04:38 EST 2019" starttimestamp="1576666505112" timestamp="184172912" timestamp2="184172912">
    <data><![CDATA[{]]></data>
  </Command>
  <DocumentChange __id="23627" _type="Insert" date="Fri Dec 20 09:04:38 EST 2019" docASTNodeCount="1" docActiveCodeLength="566" docExpressionCount="0" docLength="672" length="1" offset="523" starttimestamp="1576666505112" timestamp="184172900">
    <text><![CDATA[{]]></text>
  </DocumentChange>
  <DocumentChange __id="23630" _type="Insert" date="Fri Dec 20 09:04:40 EST 2019" docASTNodeCount="1" docActiveCodeLength="570" docExpressionCount="0" docLength="676" length="4" offset="550" starttimestamp="1576666505112" timestamp="184174888">
    <text><![CDATA[
			]]></text>
  </DocumentChange>
  <Command __id="23629" _type="MoveCaretCommand" caretOffset="550" date="Fri Dec 20 09:04:39 EST 2019" docOffset="550" starttimestamp="1576666505112" timestamp="184174445" />
  <Command __id="23631" _type="InsertStringCommand" date="Fri Dec 20 09:04:40 EST 2019" starttimestamp="1576666505112" timestamp="184174894" timestamp2="184174894">
    <data><![CDATA[]]></data>
  </Command>
  <Command __id="23633" _type="InsertStringCommand" date="Fri Dec 20 09:04:41 EST 2019" starttimestamp="1576666505112" timestamp="184176080" timestamp2="184176080">
    <data><![CDATA[}]]></data>
  </Command>
  <DocumentChange __id="23632" _type="Replace" date="Fri Dec 20 09:04:41 EST 2019" docASTNodeCount="1" docActiveCodeLength="570" docExpressionCount="0" docLength="676" endLine="27" insertionLength="3" int_docASTNodeCount="1" int_docActiveCodeLength="567" int_docExpressionCount="0" int_docLength="673" length="3" offset="551" startLine="27" starttimestamp="1576666505112" timestamp="184176058">
    <deletedText><![CDATA[			]]></deletedText>
    <insertedText><![CDATA[		}]]></insertedText>
  </DocumentChange>
  <DocumentChange __id="23635" _type="Insert" date="Fri Dec 20 09:04:43 EST 2019" docASTNodeCount="1" docActiveCodeLength="574" docExpressionCount="0" docLength="680" length="4" offset="550" starttimestamp="1576666505112" timestamp="184178657">
    <text><![CDATA[
			]]></text>
  </DocumentChange>
  <DocumentChange __id="23637" _type="Replace" date="Fri Dec 20 09:04:44 EST 2019" docASTNodeCount="1" docActiveCodeLength="594" docExpressionCount="0" docLength="700" endLine="27" insertionLength="23" int_docASTNodeCount="1" int_docActiveCodeLength="571" int_docExpressionCount="0" int_docLength="677" length="3" offset="551" startLine="27" starttimestamp="1576666505112" timestamp="184179475">
    <deletedText><![CDATA[			]]></deletedText>
    <insertedText><![CDATA[			recordThreadIndex(i)]]></insertedText>
  </DocumentChange>
  <Command __id="23634" _type="MoveCaretCommand" caretOffset="550" date="Fri Dec 20 09:04:43 EST 2019" docOffset="550" starttimestamp="1576666505112" timestamp="184178204" />
  <Command __id="23636" _type="InsertStringCommand" date="Fri Dec 20 09:04:43 EST 2019" starttimestamp="1576666505112" timestamp="184178665" timestamp2="184178665">
    <data><![CDATA[]]></data>
  </Command>
  <Command __id="23638" _type="PasteCommand" date="Fri Dec 20 09:04:44 EST 2019" starttimestamp="1576666505112" timestamp="184179482" />
  <Command __id="23640" _type="InsertStringCommand" date="Fri Dec 20 09:04:47 EST 2019" starttimestamp="1576666505112" timestamp="184182535" timestamp2="184182535">
    <data><![CDATA[;]]></data>
  </Command>
  <DocumentChange __id="23639" _type="Insert" date="Fri Dec 20 09:04:47 EST 2019" docASTNodeCount="1" docActiveCodeLength="595" docExpressionCount="0" docLength="701" length="1" offset="574" starttimestamp="1576666505112" timestamp="184182528">
    <text><![CDATA[;]]></text>
  </DocumentChange>
  <Command __id="23641" _type="MoveCaretCommand" caretOffset="308" date="Fri Dec 20 09:05:01 EST 2019" docOffset="308" starttimestamp="1576666505112" timestamp="184195967" />
  <Command __id="23643" _type="EclipseCommand" commandID="org.eclipse.cdt.ui.edit.text.c.toggle.comment" date="Fri Dec 20 09:05:02 EST 2019" starttimestamp="1576666505112" timestamp="184197121" />
  <DocumentChange __id="23642" _type="Delete" date="Fri Dec 20 09:05:02 EST 2019" docASTNodeCount="1" docActiveCodeLength="611" docExpressionCount="0" docLength="699" endLine="14" length="2" offset="308" startLine="14" starttimestamp="1576666505112" timestamp="184197105">
    <text><![CDATA[//]]></text>
  </DocumentChange>
  <Command __id="23644" _type="EclipseCommand" commandID="org.eclipse.ui.file.save" date="Fri Dec 20 09:05:03 EST 2019" starttimestamp="1576666505112" timestamp="184198253" />
  <Command __id="23646" _type="SelectTextCommand" caretOffset="551" date="Fri Dec 20 09:05:21 EST 2019" end="551" start="380" starttimestamp="1576666505112" timestamp="184215892" />
  <DocumentChange __id="23677" _type="Replace" date="Fri Dec 20 09:05:56 EST 2019" docASTNodeCount="1" docActiveCodeLength="454" docExpressionCount="0" docLength="454" endLine="17" insertionLength="24" int_docASTNodeCount="1" int_docActiveCodeLength="430" int_docExpressionCount="0" int_docLength="430" length="6" offset="352" startLine="17" starttimestamp="1576666505112" timestamp="184251585">
    <deletedText><![CDATA[record]]></deletedText>
    <insertedText><![CDATA[recordThreadIndex(index)]]></insertedText>
  </DocumentChange>
  <DocumentChange __id="23683" _type="Replace" date="Fri Dec 20 09:06:00 EST 2019" docASTNodeCount="1" docActiveCodeLength="450" docExpressionCount="0" docLength="450" endLine="17" insertionLength="1" int_docASTNodeCount="1" int_docActiveCodeLength="449" int_docExpressionCount="0" int_docLength="449" length="5" offset="370" startLine="17" starttimestamp="1576666505112" timestamp="184254937">
    <deletedText><![CDATA[index]]></deletedText>
    <insertedText><![CDATA[i]]></insertedText>
  </DocumentChange>
  <DocumentChange __id="23686" _type="Insert" date="Fri Dec 20 09:06:01 EST 2019" docASTNodeCount="1" docActiveCodeLength="451" docExpressionCount="0" docLength="451" length="1" offset="372" starttimestamp="1576666505112" timestamp="184256847">
    <text><![CDATA[;]]></text>
  </DocumentChange>
  <Command __id="23694" _type="SelectTextCommand" caretOffset="298" date="Fri Dec 20 09:07:53 EST 2019" end="376" start="298" starttimestamp="1576666505112" timestamp="184368031" />
  <Command __id="23696" _type="MoveCaretCommand" caretOffset="552" date="Fri Dec 20 09:08:06 EST 2019" docOffset="552" starttimestamp="1576666505112" timestamp="184381340" />
  <Command __id="23695" _type="DiffBasedFileOpenCommand" date="Fri Dec 20 09:08:06 EST 2019" docASTNodeCount="1" docActiveCodeLength="550" docExpressionCount="0" docLength="626" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="184381171">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\sum_parallel.cpp]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"#include <iostream>¶#include <omp.h>¶¶using namespace std;¶¶void printSumWithTimes(int sum, int start, int end);¶void printNumThreads();¶void recordThreadIndex(int index);¶void sum_parallel(double* array, int size) {¶	cout << "sum_parallel\n";¶¶	double start = omp_get_wtime();¶¶	double sum = 0;¶¶//	#pragma omp parallel¶//	for (int i = 0; i < size; i++)¶//		sum += array[i];¶    #pragma omp parallel¶	{¶		double local_sum = 0;¶¶		#pragma omp for¶		for(int i = 0; i < size; i++)¶			local_sum += array[i];¶¶		#pragma omp critical¶		sum += local_sum;¶	}¶¶	double end = omp_get_wtime();¶¶	printSumWithTimes(sum, start, end);¶¶¶}¶")]]]></diff>
  </Command>
  <Command __id="23697" _type="SelectTextCommand" caretOffset="377" date="Fri Dec 20 09:08:15 EST 2019" end="551" start="377" starttimestamp="1576666505112" timestamp="184390699" />
  <Command __id="23698" _type="SelectTextCommand" caretOffset="377" date="Fri Dec 20 09:08:15 EST 2019" end="551" start="377" starttimestamp="1576666505112" timestamp="184390699" />
  <Command __id="23700" _type="PasteCommand" date="Fri Dec 20 09:08:16 EST 2019" starttimestamp="1576666505112" timestamp="184391832" />
  <Command __id="23701" _type="MoveCaretCommand" caretOffset="376" date="Fri Dec 20 09:08:21 EST 2019" docOffset="376" starttimestamp="1576666505112" timestamp="184396060" />
  <Command __id="23702" _type="MoveCaretCommand" caretOffset="376" date="Fri Dec 20 09:08:21 EST 2019" docOffset="376" starttimestamp="1576666505112" timestamp="184396060" />
  <Command __id="23704" _type="InsertStringCommand" date="Fri Dec 20 09:08:21 EST 2019" starttimestamp="1576666505112" timestamp="184396515" timestamp2="184396515">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="23705" _type="InsertStringCommand" date="Fri Dec 20 09:08:21 EST 2019" starttimestamp="1576666505112" timestamp="184396515" timestamp2="184396515">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="23707" _type="InsertStringCommand" date="Fri Dec 20 09:08:21 EST 2019" starttimestamp="1576666505112" timestamp="184396733" timestamp2="184396733">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="23708" _type="InsertStringCommand" date="Fri Dec 20 09:08:21 EST 2019" starttimestamp="1576666505112" timestamp="184396733" timestamp2="184396733">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="23710" _type="InsertStringCommand" date="Fri Dec 20 09:08:22 EST 2019" starttimestamp="1576666505112" timestamp="184396955" timestamp2="184396955">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="23711" _type="InsertStringCommand" date="Fri Dec 20 09:08:22 EST 2019" starttimestamp="1576666505112" timestamp="184396955" timestamp2="184396955">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="23713" _type="InsertStringCommand" date="Fri Dec 20 09:08:22 EST 2019" starttimestamp="1576666505112" timestamp="184397302" timestamp2="184397302">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="23714" _type="InsertStringCommand" date="Fri Dec 20 09:08:22 EST 2019" starttimestamp="1576666505112" timestamp="184397302" timestamp2="184397302">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="23715" _type="MoveCaretCommand" caretOffset="531" date="Fri Dec 20 09:08:29 EST 2019" docOffset="531" starttimestamp="1576666505112" timestamp="184403915" />
  <Command __id="23716" _type="MoveCaretCommand" caretOffset="531" date="Fri Dec 20 09:08:29 EST 2019" docOffset="531" starttimestamp="1576666505112" timestamp="184403916" />
  <Command __id="23717" _type="SelectTextCommand" caretOffset="533" date="Fri Dec 20 09:08:29 EST 2019" end="533" start="529" starttimestamp="1576666505112" timestamp="184404114" />
  <Command __id="23718" _type="SelectTextCommand" caretOffset="533" date="Fri Dec 20 09:08:29 EST 2019" end="533" start="529" starttimestamp="1576666505112" timestamp="184404114" />
  <Command __id="23720" _type="InsertStringCommand" date="Fri Dec 20 09:08:30 EST 2019" starttimestamp="1576666505112" timestamp="184404953" timestamp2="184404953">
    <data><![CDATA[s]]></data>
  </Command>
  <Command __id="23721" _type="InsertStringCommand" date="Fri Dec 20 09:08:30 EST 2019" starttimestamp="1576666505112" timestamp="184404953" timestamp2="184404953">
    <data><![CDATA[s]]></data>
  </Command>
  <Command __id="23723" _type="InsertStringCommand" date="Fri Dec 20 09:08:30 EST 2019" starttimestamp="1576666505112" timestamp="184405188" timestamp2="184405188">
    <data><![CDATA[i]]></data>
  </Command>
  <Command __id="23724" _type="InsertStringCommand" date="Fri Dec 20 09:08:30 EST 2019" starttimestamp="1576666505112" timestamp="184405188" timestamp2="184405188">
    <data><![CDATA[i]]></data>
  </Command>
  <Command __id="23726" _type="InsertStringCommand" date="Fri Dec 20 09:08:30 EST 2019" starttimestamp="1576666505112" timestamp="184405403" timestamp2="184405403">
    <data><![CDATA[z]]></data>
  </Command>
  <Command __id="23727" _type="InsertStringCommand" date="Fri Dec 20 09:08:30 EST 2019" starttimestamp="1576666505112" timestamp="184405403" timestamp2="184405403">
    <data><![CDATA[z]]></data>
  </Command>
  <Command __id="23729" _type="InsertStringCommand" date="Fri Dec 20 09:08:30 EST 2019" starttimestamp="1576666505112" timestamp="184405762" timestamp2="184405762">
    <data><![CDATA[e]]></data>
  </Command>
  <Command __id="23730" _type="InsertStringCommand" date="Fri Dec 20 09:08:30 EST 2019" starttimestamp="1576666505112" timestamp="184405762" timestamp2="184405762">
    <data><![CDATA[e]]></data>
  </Command>
  <Command __id="23731" _type="MoveCaretCommand" caretOffset="531" date="Fri Dec 20 09:08:32 EST 2019" docOffset="531" starttimestamp="1576666505112" timestamp="184407141" />
  <Command __id="23732" _type="MoveCaretCommand" caretOffset="531" date="Fri Dec 20 09:08:32 EST 2019" docOffset="531" starttimestamp="1576666505112" timestamp="184407142" />
  <Command __id="23733" _type="SelectTextCommand" caretOffset="533" date="Fri Dec 20 09:08:32 EST 2019" end="533" start="529" starttimestamp="1576666505112" timestamp="184407358" />
  <Command __id="23734" _type="SelectTextCommand" caretOffset="533" date="Fri Dec 20 09:08:32 EST 2019" end="533" start="529" starttimestamp="1576666505112" timestamp="184407358" />
  <Command __id="23735" _type="CopyCommand" date="Fri Dec 20 09:08:33 EST 2019" starttimestamp="1576666505112" timestamp="184408580" />
  <Command __id="23736" _type="MoveCaretCommand" caretOffset="571" date="Fri Dec 20 09:08:35 EST 2019" docOffset="571" starttimestamp="1576666505112" timestamp="184409946" />
  <Command __id="23737" _type="MoveCaretCommand" caretOffset="571" date="Fri Dec 20 09:08:35 EST 2019" docOffset="571" starttimestamp="1576666505112" timestamp="184409946" />
  <Command __id="23738" _type="SelectTextCommand" caretOffset="572" date="Fri Dec 20 09:08:35 EST 2019" end="572" start="568" starttimestamp="1576666505112" timestamp="184410177" />
  <Command __id="23739" _type="SelectTextCommand" caretOffset="572" date="Fri Dec 20 09:08:35 EST 2019" end="572" start="568" starttimestamp="1576666505112" timestamp="184410177" />
  <Command __id="23741" _type="PasteCommand" date="Fri Dec 20 09:08:35 EST 2019" starttimestamp="1576666505112" timestamp="184410796" />
  <DocumentChange __id="23699" _type="Replace" date="Fri Dec 20 09:08:16 EST 2019" docASTNodeCount="1" docActiveCodeLength="755" docExpressionCount="0" docLength="831" endLine="28" insertionLength="380" int_docASTNodeCount="1" int_docActiveCodeLength="375" int_docExpressionCount="0" int_docLength="451" length="175" offset="376" startLine="18" starttimestamp="1576666505112" timestamp="184391803">
    <deletedText><![CDATA[    #pragma omp parallel
	{
		double local_sum = 0;

		#pragma omp for
		for(int i = 0; i < size; i++)
			local_sum += array[i];

		#pragma omp critical
		sum += local_sum;
	}]]></deletedText>
    <insertedText><![CDATA[#pragma omp parallel
	{
		double local_sum = 0;
		
		int rank = omp_get_thread_num();
		int threads = omp_get_num_threads();
		
		int start_index = (SIZE/threads)*rank;
		int end_index = (SIZE/threads)*(rank+1);
		
		if(rank==threads-1)
			end_index=SIZE;
		
		for(int i = start_index; i < end_index; i++)
			local_sum += array[i];
		
		#pragma omp critical
		sum += local_sum;
	}]]></insertedText>
  </DocumentChange>
  <DocumentChange __id="23703" _type="Insert" date="Fri Dec 20 09:08:21 EST 2019" docASTNodeCount="1" docActiveCodeLength="756" docExpressionCount="0" docLength="832" length="1" offset="376" starttimestamp="1576666505112" timestamp="184396509">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="23706" _type="Insert" date="Fri Dec 20 09:08:21 EST 2019" docASTNodeCount="1" docActiveCodeLength="757" docExpressionCount="0" docLength="833" length="1" offset="377" starttimestamp="1576666505112" timestamp="184396729">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="23709" _type="Insert" date="Fri Dec 20 09:08:22 EST 2019" docASTNodeCount="1" docActiveCodeLength="758" docExpressionCount="0" docLength="834" length="1" offset="378" starttimestamp="1576666505112" timestamp="184396945">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="23712" _type="Insert" date="Fri Dec 20 09:08:22 EST 2019" docASTNodeCount="1" docActiveCodeLength="759" docExpressionCount="0" docLength="835" length="1" offset="379" starttimestamp="1576666505112" timestamp="184397297">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="23719" _type="Replace" date="Fri Dec 20 09:08:30 EST 2019" docASTNodeCount="1" docActiveCodeLength="756" docExpressionCount="0" docLength="832" endLine="25" insertionLength="1" int_docASTNodeCount="1" int_docActiveCodeLength="755" int_docExpressionCount="0" int_docLength="831" length="4" offset="529" startLine="25" starttimestamp="1576666505112" timestamp="184404947">
    <deletedText><![CDATA[SIZE]]></deletedText>
    <insertedText><![CDATA[s]]></insertedText>
  </DocumentChange>
  <DocumentChange __id="23722" _type="Insert" date="Fri Dec 20 09:08:30 EST 2019" docASTNodeCount="1" docActiveCodeLength="757" docExpressionCount="0" docLength="833" length="1" offset="530" starttimestamp="1576666505112" timestamp="184405185">
    <text><![CDATA[i]]></text>
  </DocumentChange>
  <DocumentChange __id="23725" _type="Insert" date="Fri Dec 20 09:08:30 EST 2019" docASTNodeCount="1" docActiveCodeLength="758" docExpressionCount="0" docLength="834" length="1" offset="531" starttimestamp="1576666505112" timestamp="184405395">
    <text><![CDATA[z]]></text>
  </DocumentChange>
  <DocumentChange __id="23728" _type="Insert" date="Fri Dec 20 09:08:30 EST 2019" docASTNodeCount="1" docActiveCodeLength="759" docExpressionCount="0" docLength="835" length="1" offset="532" starttimestamp="1576666505112" timestamp="184405755">
    <text><![CDATA[e]]></text>
  </DocumentChange>
  <DocumentChange __id="23740" _type="Replace" date="Fri Dec 20 09:08:35 EST 2019" docASTNodeCount="1" docActiveCodeLength="759" docExpressionCount="0" docLength="835" endLine="26" insertionLength="4" int_docASTNodeCount="1" int_docActiveCodeLength="755" int_docExpressionCount="0" int_docLength="831" length="4" offset="568" startLine="26" starttimestamp="1576666505112" timestamp="184410787">
    <deletedText><![CDATA[SIZE]]></deletedText>
    <insertedText><![CDATA[size]]></insertedText>
  </DocumentChange>
  <DocumentChange __id="23746" _type="Replace" date="Fri Dec 20 09:08:39 EST 2019" docASTNodeCount="1" docActiveCodeLength="759" docExpressionCount="0" docLength="835" endLine="29" insertionLength="4" int_docASTNodeCount="1" int_docActiveCodeLength="755" int_docExpressionCount="0" int_docLength="831" length="4" offset="630" startLine="29" starttimestamp="1576666505112" timestamp="184413982">
    <deletedText><![CDATA[SIZE]]></deletedText>
    <insertedText><![CDATA[size]]></insertedText>
  </DocumentChange>
  <DocumentChange __id="32635" _type="Replace" date="Sat Dec 21 23:58:13 EST 2019" docASTNodeCount="565" docActiveCodeLength="3670" docExpressionCount="335" docLength="4237" endLine="36" insertionLength="9" int_docASTNodeCount="564" int_docActiveCodeLength="3661" int_docExpressionCount="334" int_docLength="4228" length="5" offset="1231" startLine="36" starttimestamp="1576666505112" timestamp="324188789">
    <deletedText><![CDATA[aFile]]></deletedText>
    <insertedText><![CDATA[aFileLine]]></insertedText>
  </DocumentChange>
  <DocumentChange __id="32636" _type="Replace" date="Sat Dec 21 23:58:13 EST 2019" docASTNodeCount="565" docActiveCodeLength="3674" docExpressionCount="335" docLength="4241" endLine="34" insertionLength="9" int_docASTNodeCount="547" int_docActiveCodeLength="3665" int_docExpressionCount="324" int_docLength="4232" length="5" offset="1125" startLine="34" starttimestamp="1576666505112" timestamp="324188805">
    <deletedText><![CDATA[aFile]]></deletedText>
    <insertedText><![CDATA[aFileLine]]></insertedText>
  </DocumentChange>
  <Command __id="32678" _type="DiffBasedFileOpenCommand" date="Sat Dec 21 23:58:18 EST 2019" projectName="null" starttimestamp="1576666505112" timestamp="324193512">
    <filePath><![CDATA[null]]></filePath>
    <diff><![CDATA[null]]></diff>
  </Command>
  <Command __id="32683" _type="DiffBasedFileOpenCommand" date="Sat Dec 21 23:58:20 EST 2019" docASTNodeCount="565" docActiveCodeLength="3674" docExpressionCount="335" docLength="4241" projectName="GraderBasics" starttimestamp="1576666505112" timestamp="324195574">
    <filePath><![CDATA[D:\dewan_backup\Java\GraderBasics\src\gradingTools\shared\testcases\openmp\OpenMPUtils.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package gradingTools.shared.testcases.openmp;¶¶import java.util.ArrayList;¶import java.util.HashMap;¶import java.util.List;¶import java.util.Map;¶"), Diff(INSERT,"import java.util.Stack;¶"), Diff(EQUAL,"¶¶public class OpenMPUtils {¶//	protected static Map<String, OpenMPKeywordEnum> stringToOpenMPKeyword = new HashMap();¶	public static List<OpenMPPragma> getOpemMPPragmas(StringBuffer aFileBuffer) {¶		String[] aFileLines = aFileBuffer.toString().split("\n");¶		return getOpenMPPragmas(aFileLines);¶	}¶	¶	public static boolean isCodeLine(String aLine) {¶		return !aLine.isEmpty() && !aLine.startsWith("//");¶	}¶	public static boolean isBlockStart(String aLine) {¶		return "{".equals(aLine);¶	}¶	public static boolean isBlockEnd(String aLine) {¶		return "}".equals(aLine);¶	}¶	public static boolean is"), Diff(DELETE,"PragmaStart(String aLine) {¶		return aLine.startsWith("#pragma");¶	}¶	"), Diff(INSERT,"LoopStart(String aLine) {¶		return aLine.startsWith("for");¶	}¶	public static boolean endsWithLoopHeader(String aLine) {¶		return aLine.endsWith(")");¶	}¶	public static boolean isPragmaStart(String aLine) {¶		return aLine.startsWith("#pragma");¶	}¶	public static void addToStack(Stack<OpenMPPragma> anOpenMPPragmas, String aFileLine) {¶		for (OpenMPPragma anOpenMPPragma:anOpenMPPragmas) {¶			anOpenMPPragma.getAnnotatedText().add(aFileLine);¶		}¶	}¶	¶	public static void incrementStackTop (Stack<Integer> aNumOpenBracesStack) {¶		int aTopIndex = aNumOpenBracesStack.size() - 1;¶		Integer aCurrentValue = aNumOpenBracesStack.get(aTopIndex);¶		aNumOpenBracesStack.set(aTopIndex, aCurrentValue + 1);¶	}¶	public static void decrementStackTop (Stack<Integer> aNumOpenBracesStack) {¶		int aTopIndex = aNumOpenBracesStack.size() - 1;¶		Integer aCurrentValue = aNumOpenBracesStack.get(aTopIndex);¶		aNumOpenBracesStack.set(aTopIndex, aCurrentValue - 1);¶	}"), Diff(EQUAL,"¶¶	public static List<OpenMPPragma> getOpenMPPragmas(String[] aFileLines) {¶		List<OpenMPPragma> retVal = new ArrayList();¶		"), Diff(INSERT,"Stack<"), Diff(EQUAL,"OpenMPPragma"), Diff(INSERT,">"), Diff(EQUAL," anOpenMPPragma"), Diff(INSERT,"s"), Diff(EQUAL," = n"), Diff(DELETE,"ull"), Diff(INSERT,"ew Stack();¶		Stack<Integer> aNumOpenBracesStack = new Stack()"), Diff(EQUAL,";¶"), Diff(INSERT,"//"), Diff(EQUAL,"		int aNumOpenBraces = 0;¶		boolean a"), Diff(DELETE,"LastNonEmpty"), Diff(INSERT,"NextCode"), Diff(EQUAL,"Line"), Diff(DELETE,"Wa"), Diff(INSERT,"I"), Diff(EQUAL,"sAPragma"), Diff(INSERT,"Block"), Diff(EQUAL," = false;¶		for (int i = 0; i < aFileLines.length; i++) {¶			String aFileLine = aFileLines[i].trim();¶			if (!isCodeLine(aFileLine)) {¶				continue;¶			}¶			"), Diff(INSERT,"addToStack(anOpenMPPragmas, aFileLine); // if it is empty add to none¶			"), Diff(EQUAL,"if (isPragmaStart(aFileLine)) {¶				"), Diff(INSERT,"¶				OpenMPPragma "), Diff(EQUAL,"anOpenMPPragma = getOpemMPPragma(aFileLine, i);¶				if (anOpenMPPragma != null) {¶					"), Diff(INSERT,"anOpenMPPragmas.add(anOpenMPPragma);¶					aNumOpenBracesStack.add(0);¶					"), Diff(EQUAL,"retVal.add(anOpenMPPragma);"), Diff(INSERT,"					"), Diff(EQUAL,"¶					a"), Diff(DELETE,"LastNonEmpty"), Diff(INSERT,"NextCode"), Diff(EQUAL,"Line"), Diff(DELETE,"Wa"), Diff(INSERT,"I"), Diff(EQUAL,"sAPragma"), Diff(INSERT,"Block"), Diff(EQUAL," = true;¶					continue;¶				} ¶			}¶			if (anOpenMPPragma"), Diff(DELETE," == null"), Diff(INSERT,"s.isEmpty()"), Diff(EQUAL,") {¶				continue;¶			}	¶			if (a"), Diff(DELETE,"LastNonEmpty"), Diff(INSERT,"NextCode"), Diff(EQUAL,"Line"), Diff(DELETE,"Wa"), Diff(INSERT,"I"), Diff(EQUAL,"sAPragma"), Diff(DELETE,") {"), Diff(INSERT,"Block) {				"), Diff(EQUAL,"¶				anOpenMPPragma"), Diff(INSERT,"s.peek()"), Diff(EQUAL,".setAnnotatedTextStartLineNumber(i);"), Diff(INSERT,"				"), Diff(EQUAL,"¶				a"), Diff(DELETE,"LastNonEmpty"), Diff(INSERT,"NextCode"), Diff(EQUAL,"Line"), Diff(DELETE,"Wa"), Diff(INSERT,"I"), Diff(EQUAL,"sAPragma"), Diff(INSERT,"Block"), Diff(EQUAL," = false;¶			}¶"), Diff(INSERT,"//"), Diff(EQUAL,"			anOpenMPPragma"), Diff(INSERT,"s.peek()"), Diff(EQUAL,".getAnnotatedText().add(aFileLine);¶			if (isBlockStart(aFileLine)) {¶				"), Diff(INSERT,"incrementStackTop("), Diff(EQUAL,"aNumOpenBraces"), Diff(DELETE,"++"), Diff(INSERT,"Stack)"), Diff(EQUAL,";¶			} else if (isBlockEnd(aFileLine)) {¶				"), Diff(DELETE,"aNumOpenBraces--;"), Diff(INSERT,"decrementStackTop(aNumOpenBracesStack);¶¶			}¶			if (isLoopStart(aFileLine) && endsWithLoopHeader(aFileLine)) {¶				continue; // gather following block also"), Diff(EQUAL,"¶			}¶			if (aNumOpenBraces"), Diff(INSERT,"Stack.peek()"), Diff(EQUAL," == 0) {¶				"), Diff(INSERT,"¶				"), Diff(EQUAL,"anOpenMPPragma"), Diff(INSERT,"s.peek()"), Diff(EQUAL,".setAnnotatedTextEndLineNumber(i);¶				anOpenMPPragma"), Diff(DELETE," = null"), Diff(INSERT,"s.pop()"), Diff(EQUAL,";¶				continue;¶			}					¶		}¶		return retVal;¶	}¶	public static OpenMPPragma getOpemMPPragma(String aFileLine, int aLineIndex) {¶		String[] aTokens = aFileLine.split(" ");¶		if (aTokens.length <= 2) {¶			return null;¶		}¶		if (!aTokens[1].equals("omp")) {¶			return null;¶		}¶		for (int i = 2; i < aTokens.length; i ++) {¶			String aStoredToken = aTokens[i].trim().toLowerCase();¶			aTokens[i] = aStoredToken;¶		}¶		OpenMPPragma retVal = new AnOpenMPPragma(aTokens, aLineIndex);¶		return retVal;¶		¶		¶	}¶	static {¶//		stringToOpenMPKeyword.put("for", OpenMPKeywordEnum.FOR);¶//		stringToOpenMPKeyword.put("parallel", OpenMPKeywordEnum.PARALLEL);¶//		stringToOpenMPKeyword.put("reduce", OpenMPKeywordEnum.REDUCE);¶//		stringToOpenMPKeyword.put("shared", OpenMPKeywordEnum.SHARED);¶//		stringToOpenMPKeyword.put("private", OpenMPKeywordEnum.PRIVATE);¶¶¶¶¶	}¶	¶¶}¶")]]]></diff>
    <snapshot><![CDATA[package gradingTools.shared.testcases.openmp;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Stack;


public class OpenMPUtils {
//	protected static Map<String, OpenMPKeywordEnum> stringToOpenMPKeyword = new HashMap();
	public static List<OpenMPPragma> getOpemMPPragmas(StringBuffer aFileBuffer) {
		String[] aFileLines = aFileBuffer.toString().split("\n");
		return getOpenMPPragmas(aFileLines);
	}
	
	public static boolean isCodeLine(String aLine) {
		return !aLine.isEmpty() && !aLine.startsWith("//");
	}
	public static boolean isBlockStart(String aLine) {
		return "{".equals(aLine);
	}
	public static boolean isBlockEnd(String aLine) {
		return "}".equals(aLine);
	}
	public static boolean isLoopStart(String aLine) {
		return aLine.startsWith("for");
	}
	public static boolean endsWithLoopHeader(String aLine) {
		return aLine.endsWith(")");
	}
	public static boolean isPragmaStart(String aLine) {
		return aLine.startsWith("#pragma");
	}
	public static void addToStack(Stack<OpenMPPragma> anOpenMPPragmas, String aFileLine) {
		for (OpenMPPragma anOpenMPPragma:anOpenMPPragmas) {
			anOpenMPPragma.getAnnotatedText().add(aFileLine);
		}
	}
	
	public static void incrementStackTop (Stack<Integer> aNumOpenBracesStack) {
		int aTopIndex = aNumOpenBracesStack.size() - 1;
		Integer aCurrentValue = aNumOpenBracesStack.get(aTopIndex);
		aNumOpenBracesStack.set(aTopIndex, aCurrentValue + 1);
	}
	public static void decrementStackTop (Stack<Integer> aNumOpenBracesStack) {
		int aTopIndex = aNumOpenBracesStack.size() - 1;
		Integer aCurrentValue = aNumOpenBracesStack.get(aTopIndex);
		aNumOpenBracesStack.set(aTopIndex, aCurrentValue - 1);
	}

	public static List<OpenMPPragma> getOpenMPPragmas(String[] aFileLines) {
		List<OpenMPPragma> retVal = new ArrayList();
		Stack<OpenMPPragma> anOpenMPPragmas = new Stack();
		Stack<Integer> aNumOpenBracesStack = new Stack();
//		int aNumOpenBraces = 0;
		boolean aNextCodeLineIsAPragmaBlock = false;
		for (int i = 0; i < aFileLines.length; i++) {
			String aFileLine = aFileLines[i].trim();
			if (!isCodeLine(aFileLine)) {
				continue;
			}
			addToStack(anOpenMPPragmas, aFileLine); // if it is empty add to none
			if (isPragmaStart(aFileLine)) {
				
				OpenMPPragma anOpenMPPragma = getOpemMPPragma(aFileLine, i);
				if (anOpenMPPragma != null) {
					anOpenMPPragmas.add(anOpenMPPragma);
					aNumOpenBracesStack.add(0);
					retVal.add(anOpenMPPragma);					
					aNextCodeLineIsAPragmaBlock = true;
					continue;
				} 
			}
			if (anOpenMPPragmas.isEmpty()) {
				continue;
			}	
			if (aNextCodeLineIsAPragmaBlock) {				
				anOpenMPPragmas.peek().setAnnotatedTextStartLineNumber(i);				
				aNextCodeLineIsAPragmaBlock = false;
			}
//			anOpenMPPragmas.peek().getAnnotatedText().add(aFileLine);
			if (isBlockStart(aFileLine)) {
				incrementStackTop(aNumOpenBracesStack);
			} else if (isBlockEnd(aFileLine)) {
				decrementStackTop(aNumOpenBracesStack);

			}
			if (isLoopStart(aFileLine) && endsWithLoopHeader(aFileLine)) {
				continue; // gather following block also
			}
			if (aNumOpenBracesStack.peek() == 0) {
				
				anOpenMPPragmas.peek().setAnnotatedTextEndLineNumber(i);
				anOpenMPPragmas.pop();
				continue;
			}					
		}
		return retVal;
	}
	public static OpenMPPragma getOpemMPPragma(String aFileLine, int aLineIndex) {
		String[] aTokens = aFileLine.split(" ");
		if (aTokens.length <= 2) {
			return null;
		}
		if (!aTokens[1].equals("omp")) {
			return null;
		}
		for (int i = 2; i < aTokens.length; i ++) {
			String aStoredToken = aTokens[i].trim().toLowerCase();
			aTokens[i] = aStoredToken;
		}
		OpenMPPragma retVal = new AnOpenMPPragma(aTokens, aLineIndex);
		return retVal;
		
		
	}
	static {
//		stringToOpenMPKeyword.put("for", OpenMPKeywordEnum.FOR);
//		stringToOpenMPKeyword.put("parallel", OpenMPKeywordEnum.PARALLEL);
//		stringToOpenMPKeyword.put("reduce", OpenMPKeywordEnum.REDUCE);
//		stringToOpenMPKeyword.put("shared", OpenMPKeywordEnum.SHARED);
//		stringToOpenMPKeyword.put("private", OpenMPKeywordEnum.PRIVATE);




	}
	

}
]]></snapshot>
  </Command>
  <Command __id="32687" _type="DiffBasedFileOpenCommand" date="Sat Dec 21 23:58:22 EST 2019" projectName="null" starttimestamp="1576666505112" timestamp="324197320">
    <filePath><![CDATA[null]]></filePath>
    <diff><![CDATA[null]]></diff>
  </Command>
  <Command __id="32691" _type="DiffBasedFileOpenCommand" date="Sat Dec 21 23:58:24 EST 2019" docASTNodeCount="565" docActiveCodeLength="3674" docExpressionCount="335" docLength="4241" projectName="GraderBasics" starttimestamp="1576666505112" timestamp="324199179">
    <filePath><![CDATA[D:\dewan_backup\Java\GraderBasics\src\gradingTools\shared\testcases\openmp\OpenMPUtils.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package gradingTools.shared.testcases.openmp;¶¶import java.util.ArrayList;¶import java.util.HashMap;¶import java.util.List;¶import java.util.Map;¶import java.util.Stack;¶¶¶public class OpenMPUtils {¶//	protected static Map<String, OpenMPKeywordEnum> stringToOpenMPKeyword = new HashMap();¶	public static List<OpenMPPragma> getOpemMPPragmas(StringBuffer aFileBuffer) {¶		String[] aFileLines = aFileBuffer.toString().split("\n");¶		return getOpenMPPragmas(aFileLines);¶	}¶	¶	public static boolean isCodeLine(String aLine) {¶		return !aLine.isEmpty() && !aLine.startsWith("//");¶	}¶	public static boolean isBlockStart(String aLine) {¶		return "{".equals(aLine);¶	}¶	public static boolean isBlockEnd(String aLine) {¶		return "}".equals(aLine);¶	}¶	public static boolean isLoopStart(String aLine) {¶		return aLine.startsWith("for");¶	}¶	public static boolean endsWithLoopHeader(String aLine) {¶		return aLine.endsWith(")");¶	}¶	public static boolean isPragmaStart(String aLine) {¶		return aLine.startsWith("#pragma");¶	}¶	public static void addToStack(Stack<OpenMPPragma> anOpenMPPragmas, String aFileLine) {¶		for (OpenMPPragma anOpenMPPragma:anOpenMPPragmas) {¶			anOpenMPPragma.getAnnotatedText().add(aFileLine);¶		}¶	}¶	¶	public static void incrementStackTop (Stack<Integer> aNumOpenBracesStack) {¶		int aTopIndex = aNumOpenBracesStack.size() - 1;¶		Integer aCurrentValue = aNumOpenBracesStack.get(aTopIndex);¶		aNumOpenBracesStack.set(aTopIndex, aCurrentValue + 1);¶	}¶	public static void decrementStackTop (Stack<Integer> aNumOpenBracesStack) {¶		int aTopIndex = aNumOpenBracesStack.size() - 1;¶		Integer aCurrentValue = aNumOpenBracesStack.get(aTopIndex);¶		aNumOpenBracesStack.set(aTopIndex, aCurrentValue - 1);¶	}¶¶	public static List<OpenMPPragma> getOpenMPPragmas(String[] aFileLines) {¶		List<OpenMPPragma> retVal = new ArrayList();¶		Stack<OpenMPPragma> anOpenMPPragmas = new Stack();¶		Stack<Integer> aNumOpenBracesStack = new Stack();¶//		int aNumOpenBraces = 0;¶		boolean aNextCodeLineIsAPragmaBlock = false;¶		for (int i = 0; i < aFileLines.length; i++) {¶			String aFileLine = aFileLines[i].trim();¶			if (!isCodeLine(aFileLine)) {¶				continue;¶			}¶			addToStack(anOpenMPPragmas, aFileLine); // if it is empty add to none¶			if (isPragmaStart(aFileLine)) {¶				¶				OpenMPPragma anOpenMPPragma = getOpemMPPragma(aFileLine, i);¶				if (anOpenMPPragma != null) {¶					anOpenMPPragmas.add(anOpenMPPragma);¶					aNumOpenBracesStack.add(0);¶					retVal.add(anOpenMPPragma);					¶					aNextCodeLineIsAPragmaBlock = true;¶					continue;¶				} ¶			}¶			if (anOpenMPPragmas.isEmpty()) {¶				continue;¶			}	¶			if (aNextCodeLineIsAPragmaBlock) {				¶				anOpenMPPragmas.peek().setAnnotatedTextStartLineNumber(i);				¶				aNextCodeLineIsAPragmaBlock = false;¶			}¶//			anOpenMPPragmas.peek().getAnnotatedText().add(aFileLine);¶			if (isBlockStart(aFileLine)) {¶				incrementStackTop(aNumOpenBracesStack);¶			} else if (isBlockEnd(aFileLine)) {¶				decrementStackTop(aNumOpenBracesStack);¶¶			}¶			if (isLoopStart(aFileLine) && endsWithLoopHeader(aFileLine)) {¶				continue; // gather following block also¶			}¶			if (aNumOpenBracesStack.peek() == 0) {¶				¶				anOpenMPPragmas.peek().setAnnotatedTextEndLineNumber(i);¶				anOpenMPPragmas.pop();¶				continue;¶			}					¶		}¶		return retVal;¶	}¶	public static OpenMPPragma getOpemMPPragma(String aFileLine, int aLineIndex) {¶		String[] aTokens = aFileLine.split(" ");¶		if (aTokens.length <= 2) {¶			return null;¶		}¶		if (!aTokens[1].equals("omp")) {¶			return null;¶		}¶		for (int i = 2; i < aTokens.length; i ++) {¶			String aStoredToken = aTokens[i].trim().toLowerCase();¶			aTokens[i] = aStoredToken;¶		}¶		OpenMPPragma retVal = new AnOpenMPPragma(aTokens, aLineIndex);¶		return retVal;¶		¶		¶	}¶	static {¶//		stringToOpenMPKeyword.put("for", OpenMPKeywordEnum.FOR);¶//		stringToOpenMPKeyword.put("parallel", OpenMPKeywordEnum.PARALLEL);¶//		stringToOpenMPKeyword.put("reduce", OpenMPKeywordEnum.REDUCE);¶//		stringToOpenMPKeyword.put("shared", OpenMPKeywordEnum.SHARED);¶//		stringToOpenMPKeyword.put("private", OpenMPKeywordEnum.PRIVATE);¶¶¶¶¶	}¶	¶¶}¶")]]]></diff>
  </Command>
  <Command __id="33129" _type="EclipseCommand" commandID="org.eclipse.debug.ui.commands.Resume" date="Sun Dec 22 00:05:43 EST 2019" starttimestamp="1576666505112" timestamp="324638304" />
  <Command __id="33130" _type="RunCommand" date="Sun Dec 22 00:05:43 EST 2019" kind="StepInto" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="324638307" type="Run" />
  <Command __id="33131" _type="EHExceptionCommand" date="Sun Dec 22 00:05:43 EST 2019" starttimestamp="1576666505112" timestamp="324638358" type="Exception">
    <outputString><![CDATA[file name:sum_parallel_for_local_var.cp
pragmas:[20:[#pragma, omp, parallel]-->21:[{, double local_sum = 0;, #pragma omp for, for(int i = 0; i < size; i++) {, local_sum += array[i];], 24:[#pragma, omp, for]-->25:[for(int i = 0; i < size; i++) {], 30:[#pragma, omp, critical]-->31:[sum += local_sum;]]
]]></outputString>
  </Command>
  <Command __id="33133" _type="MoveCaretCommand" caretOffset="308" date="Sun Dec 22 00:06:34 EST 2019" docOffset="308" starttimestamp="1576666505112" timestamp="324689775" />
  <Command __id="33134" _type="ShellCommand" date="Sun Dec 22 00:15:01 EST 2019" starttimestamp="1576666505112" timestamp="325196810" type="ECLIPSE_LOST_FOCUS" />
  <DocumentChange __id="33520" _type="Delete" date="Sun Dec 22 00:25:52 EST 2019" docASTNodeCount="194" docActiveCodeLength="1531" docExpressionCount="104" docLength="1776" endLine="62" length="1" offset="1746" startLine="62" starttimestamp="1576666505112" timestamp="325847234">
    <text><![CDATA["]]></text>
  </DocumentChange>
  <Command __id="33583" _type="DiffBasedFileOpenCommand" date="Sun Dec 22 00:27:31 EST 2019" docASTNodeCount="565" docActiveCodeLength="3679" docExpressionCount="335" docLength="4258" projectName="GraderBasics" starttimestamp="1576666505112" timestamp="325946200">
    <filePath><![CDATA[D:\dewan_backup\Java\GraderBasics\src\gradingTools\shared\testcases\openmp\OpenMPUtils.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package gradingTools.shared.testcases.openmp;¶¶import java.util.ArrayList;¶import java.util.HashMap;¶import java.util.List;¶import java.util.Map;¶import java.util.Stack;¶¶¶public class OpenMPUtils {¶//	protected static Map<String, OpenMPKeywordEnum> stringToOpenMPKeyword = new HashMap();¶	public static List<OpenMPPragma> getOpemMPPragmas(StringBuffer aFileBuffer) {¶		String[] aFileLines = aFileBuffer.toString().split("\n");¶		return getOpenMPPragmas(aFileLines);¶	}¶	¶	public static boolean isCodeLine(String aLine) {¶		return !aLine.isEmpty() && !aLine.startsWith("//");¶	}¶	public static boolean isBlockStart(String aLine) {¶		return aLine.contains("{");¶	}¶	public static boolean isBlockEnd(String aLine) {¶		return aLine.contains("}");¶	}¶	public static boolean isLoopStart(String aLine) {¶		return aLine.startsWith("for");¶	}¶	public static boolean endsWithLoopHeader(String aLine) {¶		return aLine.endsWith(")");¶	}¶	public static boolean isPragmaStart(String aLine) {¶		return aLine.startsWith("#pragma");¶	}¶	public static void addToStack(Stack<OpenMPPragma> anOpenMPPragmas, String aFileLine) {¶		for (OpenMPPragma anOpenMPPragma:anOpenMPPragmas) {¶			anOpenMPPragma.getAnnotatedText().add(aFileLine);¶		}¶	}¶	¶	public static void incrementStackTop (Stack<Integer> aNumOpenBracesStack) {¶		int aTopIndex = aNumOpenBracesStack.size() - 1;¶		Integer aCurrentValue = aNumOpenBracesStack.get(aTopIndex);¶		aNumOpenBracesStack.set(aTopIndex, aCurrentValue + 1);¶	}¶	public static void decrementStackTop (Stack<Integer> aNumOpenBracesStack) {¶		int aTopIndex = aNumOpenBracesStack.size() - 1;¶		Integer aCurrentValue = aNumOpenBracesStack.get(aTopIndex);¶		aNumOpenBracesStack.set(aTopIndex, aCurrentValue - 1);¶	}¶¶	public static List<OpenMPPragma> getOpenMPPragmas(String[] aFileLines) {¶		List<OpenMPPragma> retVal = new ArrayList();¶		Stack<OpenMPPragma> anOpenMPPragmas = new Stack();¶		Stack<Integer> aNumOpenBracesStack = new Stack();¶//		int aNumOpenBraces = 0;¶		boolean aNextCodeLineIsAPragmaBlock = false;¶		for (int i = 0; i < aFileLines.length; i++) {¶			String aFileLine = aFileLines[i].trim();¶			if (!isCodeLine(aFileLine)) {¶				continue;¶			}¶			addToStack(anOpenMPPragmas, aFileLine); // if it is empty add to none¶			if (isPragmaStart(aFileLine)) {¶				¶				OpenMPPragma anOpenMPPragma = getOpemMPPragma(aFileLine, i);¶				if (anOpenMPPragma != null) {¶					anOpenMPPragmas.add(anOpenMPPragma);¶					aNumOpenBracesStack.add(0);¶					retVal.add(anOpenMPPragma);					¶					aNextCodeLineIsAPragmaBlock = true;¶					continue;¶				} ¶			}¶			if (anOpenMPPragmas.isEmpty()) {¶				continue;¶			}	¶			if (aNextCodeLineIsAPragmaBlock) {				¶				anOpenMPPragmas.peek().setAnnotatedTextStartLineNumber(i);				¶				aNextCodeLineIsAPragmaBlock = false;¶			}¶//			anOpenMPPragmas.peek().getAnnotatedText().add(aFileLine);¶			if (isBlockStart(aFileLine)) {¶				incrementStackTop(aNumOpenBracesStack);¶"), Diff(INSERT,"			}¶"), Diff(EQUAL,"//			} else ¶			if (isBlockEnd(aFileLine)) {¶				decrementStackTop(aNumOpenBracesStack);¶¶			}¶			if (isLoopStart(aFileLine) && endsWithLoopHeader(aFileLine)) {¶				continue; // gather following block also¶			}¶			if (aNumOpenBracesStack.peek() == 0) {¶				¶				anOpenMPPragmas.peek().setAnnotatedTextEndLineNumber(i);¶				anOpenMPPragmas.pop();¶				continue;¶			}					¶		}¶		return retVal;¶	}¶	public static OpenMPPragma getOpemMPPragma(String aFileLine, int aLineIndex) {¶		String[] aTokens = aFileLine.split(" ");¶		if (aTokens.length <= 2) {¶			return null;¶		}¶		if (!aTokens[1].equals("omp")) {¶			return null;¶		}¶		for (int i = 2; i < aTokens.length; i ++) {¶			String aStoredToken = aTokens[i].trim().toLowerCase();¶			aTokens[i] = aStoredToken;¶		}¶		OpenMPPragma retVal = new AnOpenMPPragma(aTokens, aLineIndex);¶		return retVal;¶		¶		¶	}¶	static {¶//		stringToOpenMPKeyword.put("for", OpenMPKeywordEnum.FOR);¶//		stringToOpenMPKeyword.put("parallel", OpenMPKeywordEnum.PARALLEL);¶//		stringToOpenMPKeyword.put("reduce", OpenMPKeywordEnum.REDUCE);¶//		stringToOpenMPKeyword.put("shared", OpenMPKeywordEnum.SHARED);¶//		stringToOpenMPKeyword.put("private", OpenMPKeywordEnum.PRIVATE);¶¶¶¶¶	}¶	¶¶}¶")]]]></diff>
    <snapshot><![CDATA[package gradingTools.shared.testcases.openmp;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Stack;


public class OpenMPUtils {
//	protected static Map<String, OpenMPKeywordEnum> stringToOpenMPKeyword = new HashMap();
	public static List<OpenMPPragma> getOpemMPPragmas(StringBuffer aFileBuffer) {
		String[] aFileLines = aFileBuffer.toString().split("\n");
		return getOpenMPPragmas(aFileLines);
	}
	
	public static boolean isCodeLine(String aLine) {
		return !aLine.isEmpty() && !aLine.startsWith("//");
	}
	public static boolean isBlockStart(String aLine) {
		return aLine.contains("{");
	}
	public static boolean isBlockEnd(String aLine) {
		return aLine.contains("}");
	}
	public static boolean isLoopStart(String aLine) {
		return aLine.startsWith("for");
	}
	public static boolean endsWithLoopHeader(String aLine) {
		return aLine.endsWith(")");
	}
	public static boolean isPragmaStart(String aLine) {
		return aLine.startsWith("#pragma");
	}
	public static void addToStack(Stack<OpenMPPragma> anOpenMPPragmas, String aFileLine) {
		for (OpenMPPragma anOpenMPPragma:anOpenMPPragmas) {
			anOpenMPPragma.getAnnotatedText().add(aFileLine);
		}
	}
	
	public static void incrementStackTop (Stack<Integer> aNumOpenBracesStack) {
		int aTopIndex = aNumOpenBracesStack.size() - 1;
		Integer aCurrentValue = aNumOpenBracesStack.get(aTopIndex);
		aNumOpenBracesStack.set(aTopIndex, aCurrentValue + 1);
	}
	public static void decrementStackTop (Stack<Integer> aNumOpenBracesStack) {
		int aTopIndex = aNumOpenBracesStack.size() - 1;
		Integer aCurrentValue = aNumOpenBracesStack.get(aTopIndex);
		aNumOpenBracesStack.set(aTopIndex, aCurrentValue - 1);
	}

	public static List<OpenMPPragma> getOpenMPPragmas(String[] aFileLines) {
		List<OpenMPPragma> retVal = new ArrayList();
		Stack<OpenMPPragma> anOpenMPPragmas = new Stack();
		Stack<Integer> aNumOpenBracesStack = new Stack();
//		int aNumOpenBraces = 0;
		boolean aNextCodeLineIsAPragmaBlock = false;
		for (int i = 0; i < aFileLines.length; i++) {
			String aFileLine = aFileLines[i].trim();
			if (!isCodeLine(aFileLine)) {
				continue;
			}
			addToStack(anOpenMPPragmas, aFileLine); // if it is empty add to none
			if (isPragmaStart(aFileLine)) {
				
				OpenMPPragma anOpenMPPragma = getOpemMPPragma(aFileLine, i);
				if (anOpenMPPragma != null) {
					anOpenMPPragmas.add(anOpenMPPragma);
					aNumOpenBracesStack.add(0);
					retVal.add(anOpenMPPragma);					
					aNextCodeLineIsAPragmaBlock = true;
					continue;
				} 
			}
			if (anOpenMPPragmas.isEmpty()) {
				continue;
			}	
			if (aNextCodeLineIsAPragmaBlock) {				
				anOpenMPPragmas.peek().setAnnotatedTextStartLineNumber(i);				
				aNextCodeLineIsAPragmaBlock = false;
			}
//			anOpenMPPragmas.peek().getAnnotatedText().add(aFileLine);
			if (isBlockStart(aFileLine)) {
				incrementStackTop(aNumOpenBracesStack);
			}
//			} else 
			if (isBlockEnd(aFileLine)) {
				decrementStackTop(aNumOpenBracesStack);

			}
			if (isLoopStart(aFileLine) && endsWithLoopHeader(aFileLine)) {
				continue; // gather following block also
			}
			if (aNumOpenBracesStack.peek() == 0) {
				
				anOpenMPPragmas.peek().setAnnotatedTextEndLineNumber(i);
				anOpenMPPragmas.pop();
				continue;
			}					
		}
		return retVal;
	}
	public static OpenMPPragma getOpemMPPragma(String aFileLine, int aLineIndex) {
		String[] aTokens = aFileLine.split(" ");
		if (aTokens.length <= 2) {
			return null;
		}
		if (!aTokens[1].equals("omp")) {
			return null;
		}
		for (int i = 2; i < aTokens.length; i ++) {
			String aStoredToken = aTokens[i].trim().toLowerCase();
			aTokens[i] = aStoredToken;
		}
		OpenMPPragma retVal = new AnOpenMPPragma(aTokens, aLineIndex);
		return retVal;
		
		
	}
	static {
//		stringToOpenMPKeyword.put("for", OpenMPKeywordEnum.FOR);
//		stringToOpenMPKeyword.put("parallel", OpenMPKeywordEnum.PARALLEL);
//		stringToOpenMPKeyword.put("reduce", OpenMPKeywordEnum.REDUCE);
//		stringToOpenMPKeyword.put("shared", OpenMPKeywordEnum.SHARED);
//		stringToOpenMPKeyword.put("private", OpenMPKeywordEnum.PRIVATE);




	}
	

}
]]></snapshot>
  </Command>
  <Command __id="33622" _type="RunCommand" date="Sun Dec 22 00:29:01 EST 2019" kind="StepInto" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="326036470" type="Run" />
  <Command __id="33623" _type="RunCommand" date="Sun Dec 22 00:29:01 EST 2019" kind="StepInto" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="326036482" type="Run" />
  <Command __id="33625" _type="MoveCaretCommand" caretOffset="308" date="Sun Dec 22 00:29:08 EST 2019" docOffset="308" starttimestamp="1576666505112" timestamp="326043736" />
  <Command __id="33626" _type="ShellCommand" date="Sun Dec 22 00:29:19 EST 2019" starttimestamp="1576666505112" timestamp="326054312" type="ECLIPSE_MINIMIZED" />
  <Command __id="33627" _type="ShellCommand" date="Sun Dec 22 00:29:19 EST 2019" starttimestamp="1576666505112" timestamp="326054322" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="33652" _type="EclipseCommand" commandID="org.eclipse.debug.ui.commands.StepInto" date="Sun Dec 22 00:29:52 EST 2019" starttimestamp="1576666505112" timestamp="326087175" />
  <Command __id="33653" _type="RunCommand" date="Sun Dec 22 00:29:52 EST 2019" kind="StepInto" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="326087182" type="Run" />
  <Command __id="33654" _type="EclipseCommand" commandID="org.eclipse.debug.ui.commands.StepOver" date="Sun Dec 22 00:29:53 EST 2019" starttimestamp="1576666505112" timestamp="326088105" />
  <Command __id="33655" _type="RunCommand" date="Sun Dec 22 00:29:53 EST 2019" kind="StepInto" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="326088116" type="Run" />
  <Command __id="33659" _type="DiffBasedFileOpenCommand" date="Sun Dec 22 00:30:17 EST 2019" docASTNodeCount="565" docActiveCodeLength="3679" docExpressionCount="335" docLength="4258" projectName="GraderBasics" starttimestamp="1576666505112" timestamp="326112554">
    <filePath><![CDATA[D:\dewan_backup\Java\GraderBasics\src\gradingTools\shared\testcases\openmp\OpenMPUtils.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package gradingTools.shared.testcases.openmp;¶¶import java.util.ArrayList;¶import java.util.HashMap;¶import java.util.List;¶import java.util.Map;¶import java.util.Stack;¶¶¶public class OpenMPUtils {¶//	protected static Map<String, OpenMPKeywordEnum> stringToOpenMPKeyword = new HashMap();¶	public static List<OpenMPPragma> getOpemMPPragmas(StringBuffer aFileBuffer) {¶		String[] aFileLines = aFileBuffer.toString().split("\n");¶		return getOpenMPPragmas(aFileLines);¶	}¶	¶	public static boolean isCodeLine(String aLine) {¶		return !aLine.isEmpty() && !aLine.startsWith("//");¶	}¶	public static boolean isBlockStart(String aLine) {¶		return aLine.contains("{");¶	}¶	public static boolean isBlockEnd(String aLine) {¶		return aLine.contains("}");¶	}¶	public static boolean isLoopStart(String aLine) {¶		return aLine.startsWith("for");¶	}¶	public static boolean endsWithLoopHeader(String aLine) {¶		return aLine.endsWith(")");¶	}¶	public static boolean isPragmaStart(String aLine) {¶		return aLine.startsWith("#pragma");¶	}¶	public static void addToStack(Stack<OpenMPPragma> anOpenMPPragmas, String aFileLine) {¶		for (OpenMPPragma anOpenMPPragma:anOpenMPPragmas) {¶			anOpenMPPragma.getAnnotatedText().add(aFileLine);¶		}¶	}¶	¶	public static void incrementStackTop (Stack<Integer> aNumOpenBracesStack) {¶		int aTopIndex = aNumOpenBracesStack.size() - 1;¶		Integer aCurrentValue = aNumOpenBracesStack.get(aTopIndex);¶		aNumOpenBracesStack.set(aTopIndex, aCurrentValue + 1);¶	}¶	public static void decrementStackTop (Stack<Integer> aNumOpenBracesStack) {¶		int aTopIndex = aNumOpenBracesStack.size() - 1;¶		Integer aCurrentValue = aNumOpenBracesStack.get(aTopIndex);¶		aNumOpenBracesStack.set(aTopIndex, aCurrentValue - 1);¶	}¶¶	public static List<OpenMPPragma> getOpenMPPragmas(String[] aFileLines) {¶		List<OpenMPPragma> retVal = new ArrayList();¶		Stack<OpenMPPragma> anOpenMPPragmas = new Stack();¶		Stack<Integer> aNumOpenBracesStack = new Stack();¶//		int aNumOpenBraces = 0;¶		boolean aNextCodeLineIsAPragmaBlock = false;¶		for (int i = 0; i < aFileLines.length; i++) {¶			String aFileLine = aFileLines[i].trim();¶			if (!isCodeLine(aFileLine)) {¶				continue;¶			}¶			addToStack(anOpenMPPragmas, aFileLine); // if it is empty add to none¶			if (isPragmaStart(aFileLine)) {¶				¶				OpenMPPragma anOpenMPPragma = getOpemMPPragma(aFileLine, i);¶				if (anOpenMPPragma != null) {¶					anOpenMPPragmas.add(anOpenMPPragma);¶					aNumOpenBracesStack.add(0);¶					retVal.add(anOpenMPPragma);					¶					aNextCodeLineIsAPragmaBlock = true;¶					continue;¶				} ¶			}¶			if (anOpenMPPragmas.isEmpty()) {¶				continue;¶			}	¶			if (aNextCodeLineIsAPragmaBlock) {				¶				anOpenMPPragmas.peek().setAnnotatedTextStartLineNumber(i);				¶				aNextCodeLineIsAPragmaBlock = false;¶			}¶//			anOpenMPPragmas.peek().getAnnotatedText().add(aFileLine);¶			if (isBlockStart(aFileLine)) {¶				incrementStackTop(aNumOpenBracesStack);¶			}¶//			} else ¶			if (isBlockEnd(aFileLine)) {¶				decrementStackTop(aNumOpenBracesStack);¶¶			}¶			if (isLoopStart(aFileLine) && endsWithLoopHeader(aFileLine)) {¶				continue; // gather following block also¶			}¶			if (aNumOpenBracesStack.peek() == 0) {¶				¶				anOpenMPPragmas.peek().setAnnotatedTextEndLineNumber(i);¶				anOpenMPPragmas.pop();¶				continue;¶			}					¶		}¶		return retVal;¶	}¶	public static OpenMPPragma getOpemMPPragma(String aFileLine, int aLineIndex) {¶		String[] aTokens = aFileLine.split(" ");¶		if (aTokens.length <= 2) {¶			return null;¶		}¶		if (!aTokens[1].equals("omp")) {¶			return null;¶		}¶		for (int i = 2; i < aTokens.length; i ++) {¶			String aStoredToken = aTokens[i].trim().toLowerCase();¶			aTokens[i] = aStoredToken;¶		}¶		OpenMPPragma retVal = new AnOpenMPPragma(aTokens, aLineIndex);¶		return retVal;¶		¶		¶	}¶	static {¶//		stringToOpenMPKeyword.put("for", OpenMPKeywordEnum.FOR);¶//		stringToOpenMPKeyword.put("parallel", OpenMPKeywordEnum.PARALLEL);¶//		stringToOpenMPKeyword.put("reduce", OpenMPKeywordEnum.REDUCE);¶//		stringToOpenMPKeyword.put("shared", OpenMPKeywordEnum.SHARED);¶//		stringToOpenMPKeyword.put("private", OpenMPKeywordEnum.PRIVATE);¶¶¶¶¶	}¶	¶¶}¶")]]]></diff>
  </Command>
  <Command __id="33749" _type="RunCommand" date="Sun Dec 22 00:31:04 EST 2019" kind="StepInto" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="326159856" type="Run" />
  <Command __id="33750" _type="RunCommand" date="Sun Dec 22 00:31:04 EST 2019" kind="StepInto" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="326159871" type="Run" />
  <Command __id="33755" _type="DiffBasedFileOpenCommand" date="Sun Dec 22 00:31:16 EST 2019" docASTNodeCount="565" docActiveCodeLength="3679" docExpressionCount="335" docLength="4258" projectName="GraderBasics" starttimestamp="1576666505112" timestamp="326171765">
    <filePath><![CDATA[D:\dewan_backup\Java\GraderBasics\src\gradingTools\shared\testcases\openmp\OpenMPUtils.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package gradingTools.shared.testcases.openmp;¶¶import java.util.ArrayList;¶import java.util.HashMap;¶import java.util.List;¶import java.util.Map;¶import java.util.Stack;¶¶¶public class OpenMPUtils {¶//	protected static Map<String, OpenMPKeywordEnum> stringToOpenMPKeyword = new HashMap();¶	public static List<OpenMPPragma> getOpemMPPragmas(StringBuffer aFileBuffer) {¶		String[] aFileLines = aFileBuffer.toString().split("\n");¶		return getOpenMPPragmas(aFileLines);¶	}¶	¶	public static boolean isCodeLine(String aLine) {¶		return !aLine.isEmpty() && !aLine.startsWith("//");¶	}¶	public static boolean isBlockStart(String aLine) {¶		return aLine.contains("{");¶	}¶	public static boolean isBlockEnd(String aLine) {¶		return aLine.contains("}");¶	}¶	public static boolean isLoopStart(String aLine) {¶		return aLine.startsWith("for");¶	}¶	public static boolean endsWithLoopHeader(String aLine) {¶		return aLine.endsWith(")");¶	}¶	public static boolean isPragmaStart(String aLine) {¶		return aLine.startsWith("#pragma");¶	}¶	public static void addToStack(Stack<OpenMPPragma> anOpenMPPragmas, String aFileLine) {¶		for (OpenMPPragma anOpenMPPragma:anOpenMPPragmas) {¶			anOpenMPPragma.getAnnotatedText().add(aFileLine);¶		}¶	}¶	¶	public static void incrementStackTop (Stack<Integer> aNumOpenBracesStack) {¶		int aTopIndex = aNumOpenBracesStack.size() - 1;¶		Integer aCurrentValue = aNumOpenBracesStack.get(aTopIndex);¶		aNumOpenBracesStack.set(aTopIndex, aCurrentValue + 1);¶	}¶	public static void decrementStackTop (Stack<Integer> aNumOpenBracesStack) {¶		int aTopIndex = aNumOpenBracesStack.size() - 1;¶		Integer aCurrentValue = aNumOpenBracesStack.get(aTopIndex);¶		aNumOpenBracesStack.set(aTopIndex, aCurrentValue - 1);¶	}¶¶	public static List<OpenMPPragma> getOpenMPPragmas(String[] aFileLines) {¶		List<OpenMPPragma> retVal = new ArrayList();¶		Stack<OpenMPPragma> anOpenMPPragmas = new Stack();¶		Stack<Integer> aNumOpenBracesStack = new Stack();¶//		int aNumOpenBraces = 0;¶		boolean aNextCodeLineIsAPragmaBlock = false;¶		for (int i = 0; i < aFileLines.length; i++) {¶			String aFileLine = aFileLines[i].trim();¶			if (!isCodeLine(aFileLine)) {¶				continue;¶			}¶			addToStack(anOpenMPPragmas, aFileLine); // if it is empty add to none¶			if (isPragmaStart(aFileLine)) {¶				¶				OpenMPPragma anOpenMPPragma = getOpemMPPragma(aFileLine, i);¶				if (anOpenMPPragma != null) {¶					anOpenMPPragmas.add(anOpenMPPragma);¶					aNumOpenBracesStack.add(0);¶					retVal.add(anOpenMPPragma);					¶					aNextCodeLineIsAPragmaBlock = true;¶					continue;¶				} ¶			}¶			if (anOpenMPPragmas.isEmpty()) {¶				continue;¶			}	¶			if (aNextCodeLineIsAPragmaBlock) {				¶				anOpenMPPragmas.peek().setAnnotatedTextStartLineNumber(i);				¶				aNextCodeLineIsAPragmaBlock = false;¶			}¶//			anOpenMPPragmas.peek().getAnnotatedText().add(aFileLine);¶			if (isBlockStart(aFileLine)) {¶				incrementStackTop(aNumOpenBracesStack);¶			}¶//			} else ¶			if (isBlockEnd(aFileLine)) {¶				decrementStackTop(aNumOpenBracesStack);¶¶			}¶			if (isLoopStart(aFileLine) && endsWithLoopHeader(aFileLine)) {¶				continue; // gather following block also¶			}¶			if (aNumOpenBracesStack.peek() == 0) {¶				¶				anOpenMPPragmas.peek().setAnnotatedTextEndLineNumber(i);¶				anOpenMPPragmas.pop();¶				continue;¶			}					¶		}¶		return retVal;¶	}¶	public static OpenMPPragma getOpemMPPragma(String aFileLine, int aLineIndex) {¶		String[] aTokens = aFileLine.split(" ");¶		if (aTokens.length <= 2) {¶			return null;¶		}¶		if (!aTokens[1].equals("omp")) {¶			return null;¶		}¶		for (int i = 2; i < aTokens.length; i ++) {¶			String aStoredToken = aTokens[i].trim().toLowerCase();¶			aTokens[i] = aStoredToken;¶		}¶		OpenMPPragma retVal = new AnOpenMPPragma(aTokens, aLineIndex);¶		return retVal;¶		¶		¶	}¶	static {¶//		stringToOpenMPKeyword.put("for", OpenMPKeywordEnum.FOR);¶//		stringToOpenMPKeyword.put("parallel", OpenMPKeywordEnum.PARALLEL);¶//		stringToOpenMPKeyword.put("reduce", OpenMPKeywordEnum.REDUCE);¶//		stringToOpenMPKeyword.put("shared", OpenMPKeywordEnum.SHARED);¶//		stringToOpenMPKeyword.put("private", OpenMPKeywordEnum.PRIVATE);¶¶¶¶¶	}¶	¶¶}¶")]]]></diff>
  </Command>
  <Command __id="33761" _type="ShellCommand" date="Sun Dec 22 00:35:22 EST 2019" starttimestamp="1576666505112" timestamp="326417578" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="33762" _type="MoveCaretCommand" caretOffset="3419" date="Sun Dec 22 00:35:22 EST 2019" docOffset="3419" starttimestamp="1576666505112" timestamp="326417693" />
  <Command __id="33765" _type="RunCommand" date="Sun Dec 22 00:37:18 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="326533554" type="Debug" />
  <Command __id="33766" _type="RunCommand" date="Sun Dec 22 00:37:18 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="326533554" type="Debug" />
  <Command __id="33767" _type="RunCommand" date="Sun Dec 22 00:37:18 EST 2019" kind="HitBreakPoint" projectName="PL_Java" starttimestamp="1576666505112" timestamp="326533554" type="Run" />
  <Command __id="33781" _type="RunCommand" date="Sun Dec 22 00:37:26 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="326541880" type="Run" />
  <Command __id="33782" _type="RunCommand" date="Sun Dec 22 00:37:27 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="326541919" type="Run" />
  <Command __id="33783" _type="EHExceptionCommand" date="Sun Dec 22 00:37:27 EST 2019" starttimestamp="1576666505112" timestamp="326541919" type="Exception">
    <outputString><![CDATA[I***(TestCaseResult) ### SequentialSumTestCase: 1.0
Returning first of multiple entry points:[MyOpenMPTraining.exe, OpenMPTraining.exe]
I***(BasicProcessRunner) Running command:D:\dewan_backup\C\MyOpenMPTraining\Debug\MyOpenMPTraining.exe
I***(BasicProcessRunner) Running in folder: D:\dewan_backup\C\MyOpenMPTraining\Debug
I***(BasicProcessRunner)  Process started: D:\dewan_backup\C\MyOpenMPTraining\Debug\MyOpenMPTraining.exe folder: D:\dewan_backup\C\MyOpenMPTraining\Debug entry point: null class path: D:\dewan_backup\Java\PLTeaching\PL_Java\bin;D:\dewan_backup\Java\lib\oeall22.jar;C:\Users\dewan\.p2\pool\plugins\org.junit_4.12.0.v201504281640\junit.jar;C:\Users\dewan\.p2\pool\plugins\org.hamcrest.core_1.3.0.v20180420-1519.jar;D:\dewan_backup\Java\GraderBasics\lib\commons-configuration-1.9.jar;D:\dewan_backup\Java\GraderBasics\lib\commons-lang-2.6.jar;D:\dewan_backup\Java\GraderBasics\lib\commons-logging-1.1.1.jar;G:\My Drive\Java\lib\Herrmes\lib\weka3_6.jar;D:\dewan_backup\Java\GraderBasics\target\classes;D:\dewan_backup\Java\DemoCourseLocalBasicChecks\bin
]]></outputString>
  </Command>
  <Command __id="33784" _type="RunCommand" date="Sun Dec 22 00:37:27 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="326541922" type="Run" />
  <Command __id="33785" _type="EHExceptionCommand" date="Sun Dec 22 00:37:27 EST 2019" starttimestamp="1576666505112" timestamp="326542021" type="Exception">
    <outputString><![CDATA[I***(ARunnerInputStreamProcessor) Provided Input:
I***(BasicRunningProject) 1576993047044:Received output from main: sum_sequential
I***(BasicRunningProject) 1576993047045:Processing line from main: sum_sequential
I***(BasicRunningProject) 1576993047045:Received output from main: Sum: 499500
I***(BasicRunningProject) 1576993047045:Processing line from main: Sum: 499500
I***(BasicRunningProject) 1576993047045:Received output from main: Took: 0
I***(BasicRunningProject) 1576993047045:Processing line from main: Took: 0
I***(BasicRunningProject) 1576993047046:Received output from main: thread:0 lastIndex:999
I***(BasicRunningProject) 1576993047046:Processing line from main: thread:0 lastIndex:999
I***(BasicRunningProject) 1576993047046:Received output from main: _____________________________
I***(BasicRunningProject) 1576993047046:Processing line from main: _____________________________
I***(BasicRunningProject) 1576993047046:Received output from main: sum_parallel_for_reduction
I***(BasicRunningProject) 1576993047047:Processing line from main: sum_parallel_for_reduction
I***(BasicRunningProject) 1576993047047:Received output from main: Sum: 499500
I***(BasicRunningProject) 1576993047047:Processing line from main: Sum: 499500
I***(BasicRunningProject) 1576993047047:Received output from main: Took: 0
I***(BasicRunningProject) 1576993047047:Processing line from main: Took: 0
I***(BasicRunningProject) 1576993047048:Received output from main: _____________________________
I***(BasicRunningProject) 1576993047048:Processing line from main: _____________________________
I***(BasicRunningProject) 1576993047048:Received output from main: sum_parallel_for_local_var
I***(BasicRunningProject) 1576993047048:Processing line from main: sum_parallel_for_local_var
I***(BasicRunningProject) 1576993047048:Received output from main: Sum: 499500
I***(BasicRunningProject) 1576993047048:Processing line from main: Sum: 499500
I***(BasicRunningProject) 1576993047048:Received output from main: Took: 0
I***(BasicRunningProject) 1576993047048:Processing line from main: Took: 0
I***(BasicRunningProject) 1576993047048:Received output from main: thread:0 lastIndex:999
I***(BasicRunningProject) 1576993047048:Processing line from main: thread:0 lastIndex:999
I***(BasicRunningProject) 1576993047048:Received output from main: _____________________________
I***(BasicRunningProject) 1576993047048:Processing line from main: _____________________________
I***(BasicRunningProject) 1576993047049:Received output from main: sum_parallel
I***(BasicRunningProject) 1576993047049:Processing line from main: sum_parallel
I***(BasicRunningProject) 1576993047049:Received output from main: Sum: 499500
I***(BasicRunningProject) 1576993047049:Processing line from main: Sum: 499500
I***(BasicRunningProject) 1576993047049:Received output from main: Took: 0
I***(BasicRunningProject) 1576993047049:Processing line from main: Took: 0
I***(BasicRunningProject) 1576993047049:Received output from main: _____________________________
I***(BasicRunningProject) 1576993047049:Processing line from main: _____________________________
I***(BasicProcessRunner)  Process finished; folder: D:\dewan_backup\C\MyOpenMPTraining\Debug entry point: null class path: D:\dewan_backup\Java\PLTeaching\PL_Java\bin;D:\dewan_backup\Java\lib\oeall22.jar;C:\Users\dewan\.p2\pool\plugins\org.junit_4.12.0.v201504281640\junit.jar;C:\Users\dewan\.p2\pool\plugins\org.hamcrest.core_1.3.0.v20180420-1519.jar;D:\dewan_backup\Java\GraderBasics\lib\commons-configuration-1.9.jar;D:\dewan_backup\Java\GraderBasics\lib\commons-lang-2.6.jar;D:\dewan_backup\Java\GraderBasics\lib\commons-logging-1.1.1.jar;G:\My Drive\Java\lib\Herrmes\lib\weka3_6.jar;D:\dewan_backup\Java\GraderBasics\target\classes;D:\dewan_backup\Java\DemoCourseLocalBasicChecks\bin
I***(BasicRunningProject) Thread[AWT-EventQueue-0,6,main] sleeping for ms:2000 waiting for pending output from threads 
]]></outputString>
  </Command>
  <Command __id="33789" _type="DiffBasedFileOpenCommand" date="Sun Dec 22 00:37:31 EST 2019" docASTNodeCount="565" docActiveCodeLength="3679" docExpressionCount="335" docLength="4258" projectName="GraderBasics" starttimestamp="1576666505112" timestamp="326545912">
    <filePath><![CDATA[D:\dewan_backup\Java\GraderBasics\src\gradingTools\shared\testcases\openmp\OpenMPUtils.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package gradingTools.shared.testcases.openmp;¶¶import java.util.ArrayList;¶import java.util.HashMap;¶import java.util.List;¶import java.util.Map;¶import java.util.Stack;¶¶¶public class OpenMPUtils {¶//	protected static Map<String, OpenMPKeywordEnum> stringToOpenMPKeyword = new HashMap();¶	public static List<OpenMPPragma> getOpemMPPragmas(StringBuffer aFileBuffer) {¶		String[] aFileLines = aFileBuffer.toString().split("\n");¶		return getOpenMPPragmas(aFileLines);¶	}¶	¶	public static boolean isCodeLine(String aLine) {¶		return !aLine.isEmpty() && !aLine.startsWith("//");¶	}¶	public static boolean isBlockStart(String aLine) {¶		return aLine.contains("{");¶	}¶	public static boolean isBlockEnd(String aLine) {¶		return aLine.contains("}");¶	}¶	public static boolean isLoopStart(String aLine) {¶		return aLine.startsWith("for");¶	}¶	public static boolean endsWithLoopHeader(String aLine) {¶		return aLine.endsWith(")");¶	}¶	public static boolean isPragmaStart(String aLine) {¶		return aLine.startsWith("#pragma");¶	}¶	public static void addToStack(Stack<OpenMPPragma> anOpenMPPragmas, String aFileLine) {¶		for (OpenMPPragma anOpenMPPragma:anOpenMPPragmas) {¶			anOpenMPPragma.getAnnotatedText().add(aFileLine);¶		}¶	}¶	¶	public static void incrementStackTop (Stack<Integer> aNumOpenBracesStack) {¶		int aTopIndex = aNumOpenBracesStack.size() - 1;¶		Integer aCurrentValue = aNumOpenBracesStack.get(aTopIndex);¶		aNumOpenBracesStack.set(aTopIndex, aCurrentValue + 1);¶	}¶	public static void decrementStackTop (Stack<Integer> aNumOpenBracesStack) {¶		int aTopIndex = aNumOpenBracesStack.size() - 1;¶		Integer aCurrentValue = aNumOpenBracesStack.get(aTopIndex);¶		aNumOpenBracesStack.set(aTopIndex, aCurrentValue - 1);¶	}¶¶	public static List<OpenMPPragma> getOpenMPPragmas(String[] aFileLines) {¶		List<OpenMPPragma> retVal = new ArrayList();¶		Stack<OpenMPPragma> anOpenMPPragmas = new Stack();¶		Stack<Integer> aNumOpenBracesStack = new Stack();¶//		int aNumOpenBraces = 0;¶		boolean aNextCodeLineIsAPragmaBlock = false;¶		for (int i = 0; i < aFileLines.length; i++) {¶			String aFileLine = aFileLines[i].trim();¶			if (!isCodeLine(aFileLine)) {¶				continue;¶			}¶			addToStack(anOpenMPPragmas, aFileLine); // if it is empty add to none¶			if (isPragmaStart(aFileLine)) {¶				¶				OpenMPPragma anOpenMPPragma = getOpemMPPragma(aFileLine, i);¶				if (anOpenMPPragma != null) {¶					anOpenMPPragmas.add(anOpenMPPragma);¶					aNumOpenBracesStack.add(0);¶					retVal.add(anOpenMPPragma);					¶					aNextCodeLineIsAPragmaBlock = true;¶					continue;¶				} ¶			}¶			if (anOpenMPPragmas.isEmpty()) {¶				continue;¶			}	¶			if (aNextCodeLineIsAPragmaBlock) {				¶				anOpenMPPragmas.peek().setAnnotatedTextStartLineNumber(i);				¶				aNextCodeLineIsAPragmaBlock = false;¶			}¶//			anOpenMPPragmas.peek().getAnnotatedText().add(aFileLine);¶			if (isBlockStart(aFileLine)) {¶				incrementStackTop(aNumOpenBracesStack);¶			}¶//			} else ¶			if (isBlockEnd(aFileLine)) {¶				decrementStackTop(aNumOpenBracesStack);¶¶			}¶			if (isLoopStart(aFileLine) && endsWithLoopHeader(aFileLine)) {¶				continue; // gather following block also¶			}¶			if (aNumOpenBracesStack.peek() == 0) {¶				¶				anOpenMPPragmas.peek().setAnnotatedTextEndLineNumber(i);¶				anOpenMPPragmas.pop();¶				continue;¶			}					¶		}¶		return retVal;¶	}¶	public static OpenMPPragma getOpemMPPragma(String aFileLine, int aLineIndex) {¶		String[] aTokens = aFileLine.split(" ");¶		if (aTokens.length <= 2) {¶			return null;¶		}¶		if (!aTokens[1].equals("omp")) {¶			return null;¶		}¶		for (int i = 2; i < aTokens.length; i ++) {¶			String aStoredToken = aTokens[i].trim().toLowerCase();¶			aTokens[i] = aStoredToken;¶		}¶		OpenMPPragma retVal = new AnOpenMPPragma(aTokens, aLineIndex);¶		return retVal;¶		¶		¶	}¶	static {¶//		stringToOpenMPKeyword.put("for", OpenMPKeywordEnum.FOR);¶//		stringToOpenMPKeyword.put("parallel", OpenMPKeywordEnum.PARALLEL);¶//		stringToOpenMPKeyword.put("reduce", OpenMPKeywordEnum.REDUCE);¶//		stringToOpenMPKeyword.put("shared", OpenMPKeywordEnum.SHARED);¶//		stringToOpenMPKeyword.put("private", OpenMPKeywordEnum.PRIVATE);¶¶¶¶¶	}¶	¶¶}¶")]]]></diff>
  </Command>
  <Command __id="33804" _type="EclipseCommand" commandID="org.eclipse.debug.ui.commands.Resume" date="Sun Dec 22 00:37:58 EST 2019" starttimestamp="1576666505112" timestamp="326573490" />
  <Command __id="33805" _type="RunCommand" date="Sun Dec 22 00:37:58 EST 2019" kind="StepInto" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="326573491" type="Run" />
  <DocumentChange __id="34838" _type="Insert" date="Sun Dec 22 04:10:40 EST 2019" docASTNodeCount="226" docActiveCodeLength="1702" docExpressionCount="116" docLength="1947" length="1" offset="645" starttimestamp="1576666505112" timestamp="339335009">
    <text><![CDATA[g]]></text>
  </DocumentChange>
  <Command __id="34839" _type="InsertStringCommand" date="Sun Dec 22 04:10:40 EST 2019" starttimestamp="1576666505112" timestamp="339335013" timestamp2="339335013">
    <data><![CDATA[g]]></data>
  </Command>
  <Command __id="34844" _type="DiffBasedFileOpenCommand" date="Sun Dec 22 04:10:50 EST 2019" projectName="null" starttimestamp="1576666505112" timestamp="339345231">
    <filePath><![CDATA[null]]></filePath>
    <diff><![CDATA[null]]></diff>
  </Command>
  <Command __id="34845" _type="MoveCaretCommand" caretOffset="48552" date="Sun Dec 22 04:10:50 EST 2019" docOffset="48688" starttimestamp="1576666505112" timestamp="339345365" />
  <Command __id="35210" _type="EclipseCommand" commandID="" date="Sun Dec 22 04:28:48 EST 2019" starttimestamp="1576666505112" timestamp="340422963" />
  <Command __id="35212" _type="MoveCaretCommand" caretOffset="0" date="Sun Dec 22 04:28:48 EST 2019" docOffset="0" starttimestamp="1576666505112" timestamp="340423291" />
  <Command __id="35213" _type="EclipseCommand" commandID="" date="Sun Dec 22 04:28:48 EST 2019" starttimestamp="1576666505112" timestamp="340423694" />
  <Command __id="35214" _type="MoveCaretCommand" caretOffset="387" date="Sun Dec 22 04:28:52 EST 2019" docOffset="387" starttimestamp="1576666505112" timestamp="340427674" />
  <Command __id="35216" _type="InsertStringCommand" date="Sun Dec 22 04:28:53 EST 2019" starttimestamp="1576666505112" timestamp="340428030" timestamp2="340428030">
    <data><![CDATA[ ]]></data>
  </Command>
  <DocumentChange __id="35201" _type="Insert" date="Sun Dec 22 04:25:32 EST 2019" docASTNodeCount="250" docActiveCodeLength="1847" docExpressionCount="125" docLength="2092" length="1" offset="790" starttimestamp="1576666505112" timestamp="340227406">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="35205" _type="Delete" date="Sun Dec 22 04:25:42 EST 2019" docASTNodeCount="239" docActiveCodeLength="1773" docExpressionCount="122" docLength="2018" endLine="21" length="74" offset="720" startLine="19" starttimestamp="1576666505112" timestamp="340237474">
    <text><![CDATA[protected boolean ompCritical = false;
	protected boolean ompParallel 
	]]></text>
  </DocumentChange>
  <DocumentChange __id="35208" _type="Delete" date="Sun Dec 22 04:25:47 EST 2019" docASTNodeCount="225" docActiveCodeLength="1686" docExpressionCount="116" docLength="1931" endLine="18" length="87" offset="630" startLine="17" starttimestamp="1576666505112" timestamp="340242649">
    <text><![CDATA[protected String reductionVariable = null;
	protected String reductionOperator = null;]]></text>
  </DocumentChange>
  <Command __id="35211" _type="DiffBasedFileOpenCommand" date="Sun Dec 22 04:28:48 EST 2019" docASTNodeCount="1" docActiveCodeLength="496" docExpressionCount="0" docLength="520" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="340423112">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\sum_parallel_for_reduction.cpp]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"#include <iostream>¶#include <omp.h>¶¶using namespace std;¶¶//const int SIZE = 1000;¶void printSumWithTimes(int sum, int start, int end);¶void printNumThreads();¶void recordThreadIndex(int index);¶void sum_parallel_for_reduction(double* array, int size) {¶	cout << "sum_parallel_for_reduction\n";¶¶	double start = omp_get_wtime();¶¶	double sum = 0;¶    #pragma omp parallel for reduction(+:sum)¶¶	for (int i = 0; i < size; i++)¶		sum += array[i];¶¶	double end = omp_get_wtime();¶¶	printSumWithTimes(sum, start, end);¶¶}¶")]]]></diff>
  </Command>
  <DocumentChange __id="35215" _type="Insert" date="Sun Dec 22 04:28:53 EST 2019" docASTNodeCount="1" docActiveCodeLength="497" docExpressionCount="0" docLength="521" length="1" offset="387" starttimestamp="1576666505112" timestamp="340428027">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <Command __id="35217" _type="EclipseCommand" commandID="org.eclipse.ui.file.save" date="Sun Dec 22 04:28:55 EST 2019" starttimestamp="1576666505112" timestamp="340430439" />
  <Command __id="35219" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Dec 22 04:28:58 EST 2019" starttimestamp="1576666505112" timestamp="340432959" />
  <DocumentChange __id="35218" _type="Delete" date="Sun Dec 22 04:28:58 EST 2019" docASTNodeCount="1" docActiveCodeLength="496" docExpressionCount="0" docLength="520" endLine="15" length="1" offset="387" startLine="15" starttimestamp="1576666505112" timestamp="340432954">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <Command __id="35220" _type="MoveCaretCommand" caretOffset="370" date="Sun Dec 22 04:29:01 EST 2019" docOffset="370" starttimestamp="1576666505112" timestamp="340435911" />
  <Command __id="35221" _type="SelectTextCommand" caretOffset="373" date="Sun Dec 22 04:29:01 EST 2019" end="373" start="365" starttimestamp="1576666505112" timestamp="340436161" />
  <DocumentChange __id="35222" _type="Delete" date="Sun Dec 22 04:29:04 EST 2019" docASTNodeCount="1" docActiveCodeLength="488" docExpressionCount="0" docLength="512" endLine="15" length="8" offset="365" startLine="15" starttimestamp="1576666505112" timestamp="340439697">
    <text><![CDATA[parallel]]></text>
  </DocumentChange>
  <Command __id="35223" _type="CutCommand" date="Sun Dec 22 04:29:04 EST 2019" starttimestamp="1576666505112" timestamp="340439705" />
  <Command __id="35225" _type="UndoCommand" date="Sun Dec 22 04:29:06 EST 2019" starttimestamp="1576666505112" timestamp="340441615" />
  <Command __id="35226" _type="MoveCaretCommand" caretOffset="372" date="Sun Dec 22 04:29:08 EST 2019" docOffset="372" starttimestamp="1576666505112" timestamp="340443190" />
  <Command __id="35227" _type="SelectTextCommand" caretOffset="373" date="Sun Dec 22 04:29:08 EST 2019" end="373" start="365" starttimestamp="1576666505112" timestamp="340443426" />
  <Command __id="35229" _type="CutCommand" date="Sun Dec 22 04:29:09 EST 2019" starttimestamp="1576666505112" timestamp="340444302" />
  <Command __id="35230" _type="MoveCaretCommand" caretOffset="386" date="Sun Dec 22 04:29:10 EST 2019" docOffset="386" starttimestamp="1576666505112" timestamp="340445861" />
  <Command __id="35232" _type="InsertStringCommand" date="Sun Dec 22 04:29:11 EST 2019" starttimestamp="1576666505112" timestamp="340446140" timestamp2="340446140">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="35234" _type="PasteCommand" date="Sun Dec 22 04:29:11 EST 2019" starttimestamp="1576666505112" timestamp="340446525" />
  <Command __id="35235" _type="EclipseCommand" commandID="org.eclipse.ui.file.save" date="Sun Dec 22 04:29:12 EST 2019" starttimestamp="1576666505112" timestamp="340447370" />
  <Command __id="35236" _type="MoveCaretCommand" caretOffset="389" date="Sun Dec 22 04:29:17 EST 2019" docOffset="389" starttimestamp="1576666505112" timestamp="340452497" />
  <Command __id="35237" _type="SelectTextCommand" caretOffset="395" date="Sun Dec 22 04:29:17 EST 2019" end="395" start="387" starttimestamp="1576666505112" timestamp="340452798" />
  <Command __id="35238" _type="SelectTextCommand" caretOffset="395" date="Sun Dec 22 04:29:18 EST 2019" end="395" start="387" starttimestamp="1576666505112" timestamp="340453703" />
  <Command __id="35239" _type="ShellCommand" date="Sun Dec 22 04:29:23 EST 2019" starttimestamp="1576666505112" timestamp="340458750" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="35240" _type="ShellCommand" date="Sun Dec 22 04:29:24 EST 2019" starttimestamp="1576666505112" timestamp="340458936" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="35241" _type="ShellCommand" date="Sun Dec 22 04:29:24 EST 2019" starttimestamp="1576666505112" timestamp="340459049" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="35242" _type="ShellCommand" date="Sun Dec 22 04:29:26 EST 2019" starttimestamp="1576666505112" timestamp="340461695" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="35243" _type="EclipseCommand" commandID="org.eclipse.cdt.debug.ui.localCShortcut.run" date="Sun Dec 22 04:29:26 EST 2019" starttimestamp="1576666505112" timestamp="340461710" />
  <Command __id="35244" _type="ShellCommand" date="Sun Dec 22 04:29:36 EST 2019" starttimestamp="1576666505112" timestamp="340471114" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="35245" _type="ShellCommand" date="Sun Dec 22 04:29:36 EST 2019" starttimestamp="1576666505112" timestamp="340471265" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="35246" _type="ShellCommand" date="Sun Dec 22 04:29:36 EST 2019" starttimestamp="1576666505112" timestamp="340471334" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="35247" _type="ShellCommand" date="Sun Dec 22 04:29:41 EST 2019" starttimestamp="1576666505112" timestamp="340476321" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="35248" _type="EclipseCommand" commandID="org.eclipse.cdt.debug.ui.localCShortcut.debug" date="Sun Dec 22 04:29:41 EST 2019" starttimestamp="1576666505112" timestamp="340476432" />
  <Command __id="35249" _type="ShellCommand" date="Sun Dec 22 04:29:43 EST 2019" starttimestamp="1576666505112" timestamp="340478870" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="35250" _type="ShellCommand" date="Sun Dec 22 04:29:48 EST 2019" starttimestamp="1576666505112" timestamp="340482962" type="ECLIPSE_GAINED_FOCUS" />
  <DocumentChange __id="35224" _type="Insert" date="Sun Dec 22 04:29:06 EST 2019" docASTNodeCount="1" docActiveCodeLength="496" docExpressionCount="0" docLength="520" length="8" offset="365" starttimestamp="1576666505112" timestamp="340441606">
    <text><![CDATA[parallel]]></text>
  </DocumentChange>
  <DocumentChange __id="35228" _type="Delete" date="Sun Dec 22 04:29:09 EST 2019" docASTNodeCount="1" docActiveCodeLength="488" docExpressionCount="0" docLength="512" endLine="15" length="8" offset="365" startLine="15" starttimestamp="1576666505112" timestamp="340444292">
    <text><![CDATA[parallel]]></text>
  </DocumentChange>
  <DocumentChange __id="35231" _type="Insert" date="Sun Dec 22 04:29:11 EST 2019" docASTNodeCount="1" docActiveCodeLength="489" docExpressionCount="0" docLength="513" length="1" offset="386" starttimestamp="1576666505112" timestamp="340446140">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="35233" _type="Insert" date="Sun Dec 22 04:29:11 EST 2019" docASTNodeCount="1" docActiveCodeLength="497" docExpressionCount="0" docLength="521" length="8" offset="387" starttimestamp="1576666505112" timestamp="340446525">
    <text><![CDATA[parallel]]></text>
  </DocumentChange>
  <Command __id="35251" _type="MoveCaretCommand" caretOffset="389" date="Sun Dec 22 04:29:53 EST 2019" docOffset="389" starttimestamp="1576666505112" timestamp="340488343" />
  <Command __id="35252" _type="SelectTextCommand" caretOffset="395" date="Sun Dec 22 04:29:53 EST 2019" end="395" start="387" starttimestamp="1576666505112" timestamp="340488593" />
  <Command __id="35254" _type="CutCommand" date="Sun Dec 22 04:29:55 EST 2019" starttimestamp="1576666505112" timestamp="340490013" />
  <Command __id="35255" _type="MoveCaretCommand" caretOffset="366" date="Sun Dec 22 04:29:57 EST 2019" docOffset="366" starttimestamp="1576666505112" timestamp="340491969" />
  <Command __id="35257" _type="PasteCommand" date="Sun Dec 22 04:29:58 EST 2019" starttimestamp="1576666505112" timestamp="340492895" />
  <Command __id="35259" _type="InsertStringCommand" date="Sun Dec 22 04:29:58 EST 2019" starttimestamp="1576666505112" timestamp="340493634" timestamp2="340493634">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="35261" _type="EclipseCommand" commandID="org.eclipse.ui.file.save" date="Sun Dec 22 04:29:59 EST 2019" starttimestamp="1576666505112" timestamp="340494350" />
  <Command __id="35262" _type="MoveCaretCommand" caretOffset="388" date="Sun Dec 22 04:30:05 EST 2019" docOffset="388" starttimestamp="1576666505112" timestamp="340500353" />
  <Command __id="35264" _type="InsertStringCommand" date="Sun Dec 22 04:30:05 EST 2019" starttimestamp="1576666505112" timestamp="340500647" timestamp2="340500647">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="35265" _type="EclipseCommand" commandID="org.eclipse.ui.file.save" date="Sun Dec 22 04:30:06 EST 2019" starttimestamp="1576666505112" timestamp="340501207" />
  <Command __id="35266" _type="ShellCommand" date="Sun Dec 22 04:30:11 EST 2019" starttimestamp="1576666505112" timestamp="340506226" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="35267" _type="ShellCommand" date="Sun Dec 22 04:30:11 EST 2019" starttimestamp="1576666505112" timestamp="340506327" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="35268" _type="ShellCommand" date="Sun Dec 22 04:30:11 EST 2019" starttimestamp="1576666505112" timestamp="340506399" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="35271" _type="RunCommand" date="Sun Dec 22 04:30:16 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="340511063" type="Run" />
  <Command __id="35272" _type="RunCommand" date="Sun Dec 22 04:30:16 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="340511080" type="Run" />
  <Command __id="35273" _type="RunCommand" date="Sun Dec 22 04:30:16 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="340511400" type="Run" />
  <Command __id="35274" _type="EclipseCommand" commandID="org.eclipse.debug.ui.commands.Resume" date="Sun Dec 22 04:30:23 EST 2019" starttimestamp="1576666505112" timestamp="340518052" />
  <Command __id="35275" _type="RunCommand" date="Sun Dec 22 04:30:23 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="340518090" type="Debug" />
  <Command __id="35276" _type="RunCommand" date="Sun Dec 22 04:30:23 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="340518092" type="Run" />
  <Command __id="35277" _type="RunCommand" date="Sun Dec 22 04:30:23 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="340518097" type="Debug" />
  <Command __id="35278" _type="RunCommand" date="Sun Dec 22 04:30:23 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="340518101" type="Run" />
  <Command __id="35279" _type="EHExceptionCommand" date="Sun Dec 22 04:30:23 EST 2019" starttimestamp="1576666505112" timestamp="340518188" type="Exception">
    <outputString><![CDATA[sum_sequential
Sum: 499500
Took: 0
thread:0 lastIndex:999
_____________________________
sum_parallel_for_reduction
Sum: 499500
Took: 0
_____________________________
sum_parallel_for_local_var
Sum: 499500
Took: 0
thread:0 lastIndex:124
thread:1 lastIndex:249
thread:2 lastIndex:374
thread:3 lastIndex:499
thread:4 lastIndex:624
thread:5 lastIndex:749
thread:6 lastIndex:874
thread:7 lastIndex:999
_____________________________
sum_parallel
Sum: 499500
Took: 0
_____________________________
]]></outputString>
  </Command>
  <Command __id="35280" _type="RunCommand" date="Sun Dec 22 04:30:23 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="340518605" type="Debug" />
  <Command __id="35281" _type="RunCommand" date="Sun Dec 22 04:30:23 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="340518606" type="Run" />
  <Command __id="35282" _type="RunCommand" date="Sun Dec 22 04:30:23 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="340518609" type="Debug" />
  <Command __id="35283" _type="RunCommand" date="Sun Dec 22 04:30:23 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="340518612" type="Run" />
  <DocumentChange __id="35253" _type="Delete" date="Sun Dec 22 04:29:55 EST 2019" docASTNodeCount="1" docActiveCodeLength="489" docExpressionCount="0" docLength="513" endLine="15" length="8" offset="387" startLine="15" starttimestamp="1576666505112" timestamp="340489977">
    <text><![CDATA[parallel]]></text>
  </DocumentChange>
  <DocumentChange __id="35256" _type="Insert" date="Sun Dec 22 04:29:57 EST 2019" docASTNodeCount="1" docActiveCodeLength="497" docExpressionCount="0" docLength="521" length="8" offset="366" starttimestamp="1576666505112" timestamp="340492880">
    <text><![CDATA[parallel]]></text>
  </DocumentChange>
  <DocumentChange __id="35258" _type="Insert" date="Sun Dec 22 04:29:58 EST 2019" docASTNodeCount="1" docActiveCodeLength="498" docExpressionCount="0" docLength="522" length="1" offset="374" starttimestamp="1576666505112" timestamp="340493631">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="35260" _type="Delete" date="Sun Dec 22 04:29:59 EST 2019" docASTNodeCount="1" docActiveCodeLength="497" docExpressionCount="0" docLength="521" endLine="15" length="1" offset="395" startLine="15" starttimestamp="1576666505112" timestamp="340494308">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="35263" _type="Insert" date="Sun Dec 22 04:30:05 EST 2019" docASTNodeCount="1" docActiveCodeLength="498" docExpressionCount="0" docLength="522" length="1" offset="388" starttimestamp="1576666505112" timestamp="340500645">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <Command __id="35284" _type="MoveCaretCommand" caretOffset="429" date="Sun Dec 22 04:30:53 EST 2019" docOffset="429" starttimestamp="1576666505112" timestamp="340547990" />
  <DocumentChange __id="35285" _type="Insert" date="Sun Dec 22 04:30:54 EST 2019" docASTNodeCount="1" docActiveCodeLength="499" docExpressionCount="0" docLength="523" length="1" offset="429" starttimestamp="1576666505112" timestamp="340549686">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <Command __id="35286" _type="InsertStringCommand" date="Sun Dec 22 04:30:54 EST 2019" starttimestamp="1576666505112" timestamp="340549690" timestamp2="340549690">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="35288" _type="InsertStringCommand" date="Sun Dec 22 04:30:56 EST 2019" starttimestamp="1576666505112" timestamp="340550895" timestamp2="340550895">
    <data><![CDATA[{]]></data>
  </Command>
  <DocumentChange __id="35287" _type="Insert" date="Sun Dec 22 04:30:56 EST 2019" docASTNodeCount="1" docActiveCodeLength="500" docExpressionCount="0" docLength="524" length="1" offset="430" starttimestamp="1576666505112" timestamp="340550891">
    <text><![CDATA[{]]></text>
  </DocumentChange>
  <DocumentChange __id="35290" _type="Insert" date="Sun Dec 22 04:31:00 EST 2019" docASTNodeCount="1" docActiveCodeLength="503" docExpressionCount="0" docLength="527" length="3" offset="450" starttimestamp="1576666505112" timestamp="340555116">
    <text><![CDATA[
		]]></text>
  </DocumentChange>
  <Command __id="35289" _type="MoveCaretCommand" caretOffset="450" date="Sun Dec 22 04:30:59 EST 2019" docOffset="450" starttimestamp="1576666505112" timestamp="340554566" />
  <Command __id="35291" _type="InsertStringCommand" date="Sun Dec 22 04:31:00 EST 2019" starttimestamp="1576666505112" timestamp="340555121" timestamp2="340555121">
    <data><![CDATA[]]></data>
  </Command>
  <Command __id="35293" _type="InsertStringCommand" date="Sun Dec 22 04:31:01 EST 2019" starttimestamp="1576666505112" timestamp="340556199" timestamp2="340556199">
    <data><![CDATA[}]]></data>
  </Command>
  <Command __id="35316" _type="DiffBasedFileOpenCommand" date="Sun Dec 22 04:31:46 EST 2019" docASTNodeCount="1" docActiveCodeLength="478" docExpressionCount="0" docLength="478" projectName="OpenMPTraining" starttimestamp="1576666505112" timestamp="340601121">
    <filePath><![CDATA[D:\dewan_backup\C\OpenMPTraining\OpenMPTrainingC++\src\sum_parallel_for_reduction.cpp]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"#include <iostream>¶#include <omp.h>¶¶using namespace std;¶¶void printSumWithTimes(int sum, int start, int end);¶void printNumThreads();¶void recordThreadIndex(int index);¶void sum_parallel_for_reduction(double* array, int size) {¶	cout << "sum_parallel_for_reduction\n";¶¶	double start = omp_get_wtime();¶¶	double sum = 0;¶¶	for (int i = 0; i < size; i++) {¶		sum += array[i];¶		recordThreadIndex(i);¶	}¶¶	double end = omp_get_wtime();¶¶	printSumWithTimes(sum, start, end);¶¶}¶")]]]></diff>
  </Command>
  <Command __id="35304" _type="MoveCaretCommand" caretOffset="356" date="Sun Dec 22 04:31:31 EST 2019" docOffset="356" starttimestamp="1576666505112" timestamp="340586367" />
  <Command __id="35306" _type="InsertStringCommand" date="Sun Dec 22 04:31:31 EST 2019" starttimestamp="1576666505112" timestamp="340586637" timestamp2="340586637">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="35307" _type="EclipseCommand" commandID="org.eclipse.ui.file.save" date="Sun Dec 22 04:31:32 EST 2019" starttimestamp="1576666505112" timestamp="340587127" />
  <Command __id="35309" _type="SelectTextCommand" caretOffset="376" date="Sun Dec 22 04:31:34 EST 2019" end="376" start="329" starttimestamp="1576666505112" timestamp="340589518" />
  <Command __id="35311" _type="MoveCaretCommand" caretOffset="357" date="Sun Dec 22 04:31:36 EST 2019" docOffset="357" starttimestamp="1576666505112" timestamp="340591300" />
  <Command __id="35313" _type="MoveCaretCommand" caretOffset="0" date="Sun Dec 22 04:31:37 EST 2019" docOffset="0" starttimestamp="1576666505112" timestamp="340592742" />
  <Command __id="35315" _type="SelectTextCommand" caretOffset="376" date="Sun Dec 22 04:31:44 EST 2019" end="376" start="329" starttimestamp="1576666505112" timestamp="340599420" />
  <Command __id="35317" _type="MoveCaretCommand" caretOffset="357" date="Sun Dec 22 04:31:46 EST 2019" docOffset="357" starttimestamp="1576666505112" timestamp="340601231" />
  <Command __id="35319" _type="MoveCaretCommand" caretOffset="453" date="Sun Dec 22 04:32:03 EST 2019" docOffset="453" starttimestamp="1576666505112" timestamp="340618166" />
  <Command __id="35320" _type="SelectTextCommand" caretOffset="453" date="Sun Dec 22 04:32:06 EST 2019" end="453" start="430" starttimestamp="1576666505112" timestamp="340621729" />
  <Command __id="35322" _type="PasteCommand" date="Sun Dec 22 04:32:07 EST 2019" starttimestamp="1576666505112" timestamp="340622339" />
  <Command __id="35318" _type="DiffBasedFileOpenCommand" date="Sun Dec 22 04:32:03 EST 2019" docASTNodeCount="1" docActiveCodeLength="503" docExpressionCount="0" docLength="527" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="340618007">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\sum_parallel_for_reduction.cpp]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"#include <iostream>¶#include <omp.h>¶¶using namespace std;¶¶//const int SIZE = 1000;¶void printSumWithTimes(int sum, int start, int end);¶void printNumThreads();¶void recordThreadIndex(int index);¶void sum_parallel_for_reduction(double* array, int size) {¶	cout << "sum_parallel_for_reduction\n";¶¶	double start = omp_get_wtime();¶¶	double sum = 0;¶    #pragma omp "), Diff(INSERT," "), Diff(EQUAL,"parallel for reduction"), Diff(INSERT," "), Diff(EQUAL,"(+:sum)¶¶	for (int i = 0; i < size; i++)"), Diff(INSERT," {"), Diff(EQUAL,"¶		sum += array[i];"), Diff(INSERT,"¶	}"), Diff(EQUAL,"¶¶	double end = omp_get_wtime();¶¶	printSumWithTimes(sum, start, end);¶¶}¶")]]]></diff>
    <snapshot><![CDATA[#include <iostream>
#include <omp.h>

using namespace std;

//const int SIZE = 1000;
void printSumWithTimes(int sum, int start, int end);
void printNumThreads();
void recordThreadIndex(int index);
void sum_parallel_for_reduction(double* array, int size) {
	cout << "sum_parallel_for_reduction\n";

	double start = omp_get_wtime();

	double sum = 0;
    #pragma omp  parallel for reduction (+:sum)

	for (int i = 0; i < size; i++) {
		sum += array[i];
	}

	double end = omp_get_wtime();

	printSumWithTimes(sum, start, end);

}
]]></snapshot>
  </Command>
  <DocumentChange __id="35321" _type="Replace" date="Sun Dec 22 04:32:07 EST 2019" docASTNodeCount="1" docActiveCodeLength="527" docExpressionCount="0" docLength="551" endLine="19" insertionLength="47" int_docASTNodeCount="1" int_docActiveCodeLength="480" int_docExpressionCount="0" int_docLength="504" length="23" offset="430" startLine="17" starttimestamp="1576666505112" timestamp="340622325">
    <deletedText><![CDATA[{
		sum += array[i];
	}]]></deletedText>
    <insertedText><![CDATA[{
		sum += array[i];
		recordThreadIndex(i);
	}]]></insertedText>
  </DocumentChange>
  <Command __id="35323" _type="EclipseCommand" commandID="org.eclipse.ui.file.save" date="Sun Dec 22 04:32:08 EST 2019" starttimestamp="1576666505112" timestamp="340623467" />
  <Command __id="35324" _type="DiffBasedFileOpenCommand" date="Sun Dec 22 04:32:10 EST 2019" docASTNodeCount="1" docActiveCodeLength="749" docExpressionCount="0" docLength="825" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="340625006">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\sum_parallel.cpp]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"#include <iostream>¶#include <omp.h>¶¶using namespace std;¶¶void printSumWithTimes(int sum, int start, int end);¶void printNumThreads();¶void recordThreadIndex(int index);¶void sum_parallel(double* array, int size) {¶	cout << "sum_parallel\n";¶¶	double start = omp_get_wtime();¶¶	double sum = 0;¶¶//	#pragma omp parallel¶//	for (int i = 0; i < size; i++)¶//		sum += array[i];¶    #pragma omp parallel¶	{¶		double local_sum = 0;¶¶		"), Diff(DELETE,"#pragma omp for"), Diff(INSERT,"int rank = omp_get_thread_num();¶		int threads = omp_get_num_threads();¶¶		int start_index = (size/threads)*rank;¶		int end_index = (size/threads)*(rank+1);¶¶		if(rank==threads-1)¶			end_index=size;¶"), Diff(EQUAL,"¶		for(int i = "), Diff(DELETE,"0; i < size"), Diff(INSERT,"start_index; i < end_index"), Diff(EQUAL,"; i++)¶			local_sum += array[i];¶¶		#pragma omp critical¶		sum += local_sum;¶	}¶¶	double end = omp_get_wtime();¶¶	printSumWithTimes(sum, start, end);¶¶¶}¶")]]]></diff>
    <snapshot><![CDATA[#include <iostream>
#include <omp.h>

using namespace std;

void printSumWithTimes(int sum, int start, int end);
void printNumThreads();
void recordThreadIndex(int index);
void sum_parallel(double* array, int size) {
	cout << "sum_parallel\n";

	double start = omp_get_wtime();

	double sum = 0;

//	#pragma omp parallel
//	for (int i = 0; i < size; i++)
//		sum += array[i];
    #pragma omp parallel
	{
		double local_sum = 0;

		int rank = omp_get_thread_num();
		int threads = omp_get_num_threads();

		int start_index = (size/threads)*rank;
		int end_index = (size/threads)*(rank+1);

		if(rank==threads-1)
			end_index=size;

		for(int i = start_index; i < end_index; i++)
			local_sum += array[i];

		#pragma omp critical
		sum += local_sum;
	}

	double end = omp_get_wtime();

	printSumWithTimes(sum, start, end);


}
]]></snapshot>
  </Command>
  <Command __id="35325" _type="MoveCaretCommand" caretOffset="0" date="Sun Dec 22 04:32:10 EST 2019" docOffset="0" starttimestamp="1576666505112" timestamp="340625138" />
  <Command __id="35326" _type="DiffBasedFileOpenCommand" date="Sun Dec 22 04:32:15 EST 2019" docASTNodeCount="1" docActiveCodeLength="611" docExpressionCount="0" docLength="699" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="340630267">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\sum_parallel_for_local_var.cpp]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"#include <iostream>¶#include <omp.h>¶¶using namespace std;¶¶void printSumWithTimes (int sum, int start, int end);¶void printNumThreads();¶void recordThreadIndex(int index);¶void sum_parallel_for_local_var(double* array, int size)¶{¶	cout << "sum_parallel_for_local_var\n";¶¶	double start = omp_get_wtime();¶¶	double sum = 0;¶//¶//	for (int i = 0; i < size; i++) {¶//			sum += array[i];¶//			recordThreadIndex(i);¶//	}¶    #pragma omp parallel¶	{¶		double local_sum = 0;¶¶		#pragma omp for¶		for(int i = 0; i < size; i++) {¶			local_sum += array[i];¶			recordThreadIndex(i);¶		}¶¶		#pragma omp critical¶		sum += local_sum;¶	}¶¶	double end = omp_get_wtime();¶¶	printSumWithTimes(sum, start, end);¶	¶}¶")]]]></diff>
  </Command>
  <Command __id="35327" _type="MoveCaretCommand" caretOffset="577" date="Sun Dec 22 04:32:15 EST 2019" docOffset="577" starttimestamp="1576666505112" timestamp="340630415" />
  <Command __id="35329" _type="MoveCaretCommand" caretOffset="0" date="Sun Dec 22 04:32:18 EST 2019" docOffset="0" starttimestamp="1576666505112" timestamp="340632919" />
  <Command __id="35328" _type="DiffBasedFileOpenCommand" date="Sun Dec 22 04:32:17 EST 2019" docASTNodeCount="1" docActiveCodeLength="453" docExpressionCount="0" docLength="453" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="340632744">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\sum_sequential.cpp]]></filePath>
    <diff><![CDATA[null]]></diff>
    <snapshot><![CDATA[#include <iostream>
#include <omp.h>

using namespace std;
void printSumWithTimes(int sum, int start, int end);
void printNumThreads();
void recordThreadIndex(int index);
void sum_sequential(double* array, int size) {

	cout << "sum_sequential\n";

	double start = omp_get_wtime();

	double sum = 0;

	for (int i = 0; i < size; i++) {
		sum += array[i];
		recordThreadIndex(i);
	}

	double end = omp_get_wtime();

	printSumWithTimes(sum, start, end);
}
]]></snapshot>
  </Command>
  <Command __id="35330" _type="MoveCaretCommand" caretOffset="312" date="Sun Dec 22 04:32:20 EST 2019" docOffset="312" starttimestamp="1576666505112" timestamp="340635054" />
  <Command __id="35331" _type="DiffBasedFileOpenCommand" date="Sun Dec 22 04:36:17 EST 2019" docASTNodeCount="1" docActiveCodeLength="527" docExpressionCount="0" docLength="551" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="340872680">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\sum_parallel_for_reduction.cpp]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"#include <iostream>¶#include <omp.h>¶¶using namespace std;¶¶//const int SIZE = 1000;¶void printSumWithTimes(int sum, int start, int end);¶void printNumThreads();¶void recordThreadIndex(int index);¶void sum_parallel_for_reduction(double* array, int size) {¶	cout << "sum_parallel_for_reduction\n";¶¶	double start = omp_get_wtime();¶¶	double sum = 0;¶    #pragma omp  parallel for reduction (+:sum)¶¶	for (int i = 0; i < size; i++) {¶		sum += array[i];¶	"), Diff(INSERT,"	recordThreadIndex(i);¶	"), Diff(EQUAL,"}¶¶	double end = omp_get_wtime();¶¶	printSumWithTimes(sum, start, end);¶¶}¶")]]]></diff>
    <snapshot><![CDATA[#include <iostream>
#include <omp.h>

using namespace std;

//const int SIZE = 1000;
void printSumWithTimes(int sum, int start, int end);
void printNumThreads();
void recordThreadIndex(int index);
void sum_parallel_for_reduction(double* array, int size) {
	cout << "sum_parallel_for_reduction\n";

	double start = omp_get_wtime();

	double sum = 0;
    #pragma omp  parallel for reduction (+:sum)

	for (int i = 0; i < size; i++) {
		sum += array[i];
		recordThreadIndex(i);
	}

	double end = omp_get_wtime();

	printSumWithTimes(sum, start, end);

}
]]></snapshot>
  </Command>
  <Command __id="35332" _type="MoveCaretCommand" caretOffset="477" date="Sun Dec 22 04:36:17 EST 2019" docOffset="477" starttimestamp="1576666505112" timestamp="340872771" />
  <Command __id="35337" _type="DiffBasedFileOpenCommand" date="Sun Dec 22 04:37:49 EST 2019" docASTNodeCount="1" docActiveCodeLength="478" docExpressionCount="0" docLength="478" projectName="OpenMPTraining" starttimestamp="1576666505112" timestamp="340964350">
    <filePath><![CDATA[D:\dewan_backup\C\OpenMPTraining\OpenMPTrainingC++\src\sum_parallel_for_reduction.cpp]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"#include <iostream>¶#include <omp.h>¶¶using namespace std;¶¶void printSumWithTimes(int sum, int start, int end);¶void printNumThreads();¶void recordThreadIndex(int index);¶void sum_parallel_for_reduction(double* array, int size) {¶	cout << "sum_parallel_for_reduction\n";¶¶	double start = omp_get_wtime();¶¶	double sum = 0;¶¶	for (int i = 0; i < size; i++) {¶		sum += array[i];¶		recordThreadIndex(i);¶	}¶¶	double end = omp_get_wtime();¶¶	printSumWithTimes(sum, start, end);¶¶}¶")]]]></diff>
  </Command>
  <Command __id="35338" _type="MoveCaretCommand" caretOffset="0" date="Sun Dec 22 04:37:49 EST 2019" docOffset="0" starttimestamp="1576666505112" timestamp="340964543" />
  <Command __id="35340" _type="MoveCaretCommand" caretOffset="0" date="Sun Dec 22 04:37:59 EST 2019" docOffset="0" starttimestamp="1576666505112" timestamp="340974706" />
  <Command __id="35339" _type="DiffBasedFileOpenCommand" date="Sun Dec 22 04:37:59 EST 2019" docASTNodeCount="1" docActiveCodeLength="527" docExpressionCount="0" docLength="551" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="340974579">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\sum_parallel_for_reduction.cpp]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"#include <iostream>¶#include <omp.h>¶¶using namespace std;¶¶//const int SIZE = 1000;¶void printSumWithTimes(int sum, int start, int end);¶void printNumThreads();¶void recordThreadIndex(int index);¶void sum_parallel_for_reduction(double* array, int size) {¶	cout << "sum_parallel_for_reduction\n";¶¶	double start = omp_get_wtime();¶¶	double sum = 0;¶    #pragma omp  parallel for reduction (+:sum)¶¶	for (int i = 0; i < size; i++) {¶		sum += array[i];¶		recordThreadIndex(i);¶	}¶¶	double end = omp_get_wtime();¶¶	printSumWithTimes(sum, start, end);¶¶}¶")]]]></diff>
  </Command>
  <Command __id="35341" _type="MoveCaretCommand" caretOffset="396" date="Sun Dec 22 04:38:10 EST 2019" docOffset="396" starttimestamp="1576666505112" timestamp="340985703" />
  <Command __id="35343" _type="EclipseCommand" commandID="org.eclipse.ui.edit.delete" date="Sun Dec 22 04:38:12 EST 2019" starttimestamp="1576666505112" timestamp="340987272" />
  <DocumentChange __id="35342" _type="Delete" date="Sun Dec 22 04:38:12 EST 2019" docASTNodeCount="1" docActiveCodeLength="526" docExpressionCount="0" docLength="550" endLine="16" length="1" offset="396" startLine="15" starttimestamp="1576666505112" timestamp="340987261">
    <text><![CDATA[
]]></text>
  </DocumentChange>
  <Command __id="35344" _type="MoveCaretCommand" caretOffset="437" date="Sun Dec 22 04:38:15 EST 2019" docOffset="437" starttimestamp="1576666505112" timestamp="340989962" />
  <Command __id="35345" _type="MoveCaretCommand" caretOffset="438" date="Sun Dec 22 04:38:15 EST 2019" docOffset="438" starttimestamp="1576666505112" timestamp="340990884" />
  <DocumentChange __id="35346" _type="Insert" date="Sun Dec 22 04:38:17 EST 2019" docASTNodeCount="1" docActiveCodeLength="527" docExpressionCount="0" docLength="551" length="1" offset="438" starttimestamp="1576666505112" timestamp="340991961">
    <text><![CDATA[\]]></text>
  </DocumentChange>
  <Command __id="35347" _type="InsertStringCommand" date="Sun Dec 22 04:38:17 EST 2019" starttimestamp="1576666505112" timestamp="340991964" timestamp2="340991964">
    <data><![CDATA[\]]></data>
  </Command>
  <DocumentChange __id="35348" _type="Insert" date="Sun Dec 22 04:38:17 EST 2019" docASTNodeCount="1" docActiveCodeLength="528" docExpressionCount="0" docLength="552" length="1" offset="439" starttimestamp="1576666505112" timestamp="340992887">
    <text><![CDATA[*]]></text>
  </DocumentChange>
  <Command __id="35349" _type="InsertStringCommand" date="Sun Dec 22 04:38:18 EST 2019" starttimestamp="1576666505112" timestamp="340992895" timestamp2="340992895">
    <data><![CDATA[*]]></data>
  </Command>
  <DocumentChange __id="35350" _type="Delete" date="Sun Dec 22 04:38:19 EST 2019" docASTNodeCount="1" docActiveCodeLength="527" docExpressionCount="0" docLength="551" endLine="17" length="1" offset="439" startLine="17" starttimestamp="1576666505112" timestamp="340994258">
    <text><![CDATA[*]]></text>
  </DocumentChange>
  <Command __id="35351" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Dec 22 04:38:19 EST 2019" starttimestamp="1576666505112" timestamp="340994260" />
  <DocumentChange __id="35352" _type="Delete" date="Sun Dec 22 04:38:19 EST 2019" docASTNodeCount="1" docActiveCodeLength="526" docExpressionCount="0" docLength="550" endLine="17" length="1" offset="438" startLine="17" starttimestamp="1576666505112" timestamp="340994504">
    <text><![CDATA[\]]></text>
  </DocumentChange>
  <Command __id="35353" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Dec 22 04:38:19 EST 2019" starttimestamp="1576666505112" timestamp="340994506" />
  <DocumentChange __id="35354" _type="Delete" date="Sun Dec 22 04:38:20 EST 2019" docASTNodeCount="1" docActiveCodeLength="525" docExpressionCount="0" docLength="549" endLine="17" length="1" offset="437" startLine="17" starttimestamp="1576666505112" timestamp="340995132">
    <text><![CDATA[+]]></text>
  </DocumentChange>
  <Command __id="35355" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Dec 22 04:38:20 EST 2019" starttimestamp="1576666505112" timestamp="340995138" />
  <Command __id="35357" _type="InsertStringCommand" date="Sun Dec 22 04:38:22 EST 2019" starttimestamp="1576666505112" timestamp="340997115" timestamp2="340997115">
    <data><![CDATA[*]]></data>
  </Command>
  <Command __id="35358" _type="EclipseCommand" commandID="org.eclipse.ui.file.save" date="Sun Dec 22 04:38:23 EST 2019" starttimestamp="1576666505112" timestamp="340998143" />
  <Command __id="35360" _type="RunCommand" date="Sun Dec 22 04:38:28 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="341003160" type="Run" />
  <Command __id="35361" _type="RunCommand" date="Sun Dec 22 04:38:28 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="341003161" type="Run" />
  <Command __id="35362" _type="RunCommand" date="Sun Dec 22 04:38:28 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="341003170" type="Debug" />
  <Command __id="35363" _type="RunCommand" date="Sun Dec 22 04:38:28 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="341003170" type="Run" />
  <Command __id="35364" _type="RunCommand" date="Sun Dec 22 04:38:28 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="341003170" type="Debug" />
  <Command __id="35365" _type="RunCommand" date="Sun Dec 22 04:38:28 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="341003170" type="Run" />
  <Command __id="35366" _type="EHExceptionCommand" date="Sun Dec 22 04:38:28 EST 2019" starttimestamp="1576666505112" timestamp="341003277" type="Exception">
    <outputString><![CDATA[sum_sequential
Sum: 499500
Took: 0
thread:0 lastIndex:999
_____________________________
sum_parallel_for_reduction
Sum: 0
Took: 0
thread:0 lastIndex:124
thread:1 lastIndex:249
thread:2 lastIndex:374
thread:3 lastIndex:499
thread:4 lastIndex:624
thread:5 lastIndex:749
thread:6 lastIndex:874
thread:7 lastIndex:999
_____________________________
sum_parallel_for_local_var
Sum: 499500
Took: 0
thread:0 lastIndex:124
thread:1 lastIndex:249
thread:2 lastIndex:374
thread:3 lastIndex:499
thread:4 lastIndex:624
thread:5 lastIndex:749
thread:6 lastIndex:874
thread:7 lastIndex:999
_____________________________
sum_parallel
Sum: 499500
Took: 0
_____________________________
]]></outputString>
  </Command>
  <DocumentChange __id="35356" _type="Insert" date="Sun Dec 22 04:38:22 EST 2019" docASTNodeCount="1" docActiveCodeLength="526" docExpressionCount="0" docLength="550" length="1" offset="437" starttimestamp="1576666505112" timestamp="340997112">
    <text><![CDATA[*]]></text>
  </DocumentChange>
  <Command __id="35367" _type="MoveCaretCommand" caretOffset="438" date="Sun Dec 22 04:38:58 EST 2019" docOffset="438" starttimestamp="1576666505112" timestamp="341033433" />
  <DocumentChange __id="35368" _type="Delete" date="Sun Dec 22 04:39:00 EST 2019" docASTNodeCount="1" docActiveCodeLength="525" docExpressionCount="0" docLength="549" endLine="17" length="1" offset="437" startLine="17" starttimestamp="1576666505112" timestamp="341035468">
    <text><![CDATA[*]]></text>
  </DocumentChange>
  <Command __id="35369" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Dec 22 04:39:00 EST 2019" starttimestamp="1576666505112" timestamp="341035468" />
  <Command __id="35371" _type="InsertStringCommand" date="Sun Dec 22 04:39:01 EST 2019" starttimestamp="1576666505112" timestamp="341036228" timestamp2="341036228">
    <data><![CDATA[+]]></data>
  </Command>
  <Command __id="35372" _type="EclipseCommand" commandID="org.eclipse.ui.file.save" date="Sun Dec 22 04:39:02 EST 2019" starttimestamp="1576666505112" timestamp="341037450" />
  <Command __id="35374" _type="RunCommand" date="Sun Dec 22 04:39:06 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="341041381" type="Run" />
  <Command __id="35375" _type="RunCommand" date="Sun Dec 22 04:39:06 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="341041381" type="Run" />
  <Command __id="35376" _type="RunCommand" date="Sun Dec 22 04:39:06 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="341041398" type="Debug" />
  <Command __id="35377" _type="RunCommand" date="Sun Dec 22 04:39:06 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="341041398" type="Run" />
  <Command __id="35378" _type="RunCommand" date="Sun Dec 22 04:39:06 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="341041398" type="Debug" />
  <Command __id="35379" _type="RunCommand" date="Sun Dec 22 04:39:06 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="341041398" type="Run" />
  <Command __id="35380" _type="EHExceptionCommand" date="Sun Dec 22 04:39:06 EST 2019" starttimestamp="1576666505112" timestamp="341041504" type="Exception">
    <outputString><![CDATA[sum_sequential
Sum: 499500
Took: 0
thread:0 lastIndex:999
_____________________________
sum_parallel_for_reduction
Sum: 499500
Took: 0
thread:0 lastIndex:124
thread:1 lastIndex:249
thread:2 lastIndex:374
thread:3 lastIndex:499
thread:4 lastIndex:624
thread:5 lastIndex:749
thread:6 lastIndex:874
thread:7 lastIndex:999
_____________________________
sum_parallel_for_local_var
Sum: 499500
Took: 0
thread:0 lastIndex:124
thread:1 lastIndex:249
thread:2 lastIndex:374
thread:3 lastIndex:499
thread:4 lastIndex:624
thread:5 lastIndex:749
thread:6 lastIndex:874
thread:7 lastIndex:999
_____________________________
sum_parallel
Sum: 499500
Took: 0
_____________________________
]]></outputString>
  </Command>
  <Command __id="35381" _type="ShellCommand" date="Sun Dec 22 04:40:37 EST 2019" starttimestamp="1576666505112" timestamp="341132734" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="35387" _type="DiffBasedFileOpenCommand" date="Sun Dec 22 04:41:36 EST 2019" docASTNodeCount="225" docActiveCodeLength="1686" docExpressionCount="116" docLength="1931" projectName="GraderBasics" starttimestamp="1576666505112" timestamp="341191411">
    <filePath><![CDATA[D:\dewan_backup\Java\GraderBasics\src\gradingTools\shared\testcases\openmp\AnOpenMPPragma.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package gradingTools.shared.testcases.openmp;¶¶import java.util.ArrayList;¶import java.util.Arrays;¶import java.util.List;¶¶public class AnOpenMPPragma implements OpenMPPragma {¶//	protected List<OpenMPKeywordEnum> openMPKeywords = new ArrayList();¶	protected String[] openMPTokens;¶¶	protected int lineNumber;¶	protected List<String> annotatedText = new ArrayList();¶	protected int annotatedTextStartLineNumber;¶	protected int annotatedTextEndLineNumber;¶	protected OpenMPPragma parent;¶	protected List<OpenMPPragma> children = new ArrayList();¶	protected List<String[]> variableDeclarations = new ArrayList();¶	¶	¶	¶	public AnOpenMPPragma(String[] openMPTokens, int lineNumber) {¶		super();¶		this.openMPTokens = openMPTokens;¶		this.lineNumber = lineNumber;¶		¶//		this.nextNonEmptyString = nextNonEmptyString;¶	}¶	@Override¶	public String[] getOpenMPTokens() {¶		return openMPTokens;¶	}¶	@Override¶	public int getLineNumber() {¶		return lineNumber;¶	}¶	@Override¶	public List<String> getAnnotatedText() {¶		return annotatedText;¶	}¶//	@Override¶//	public void setAnnotatedText(List<String> nextNonEmptyString) {¶//		this.annotatedText = nextNonEmptyString;¶//	}¶	@Override¶	public int getAnnotatedTextStartLineNumber() {¶		return annotatedTextStartLineNumber;¶	}¶	@Override¶	public void setAnnotatedTextStartLineNumber(int annotatedLineNumber) {¶		this.annotatedTextStartLineNumber = annotatedLineNumber;¶	}¶	¶	@Override¶	public int getAnnotatedTextEndLineNumber() {¶		return annotatedTextEndLineNumber;¶	}¶	@Override¶	public void setAnnotatedTextEndLineNumber(int annotatedTextEndLineNumber) {¶		this.annotatedTextEndLineNumber = annotatedTextEndLineNumber;¶	}¶	¶	public String toString() {¶		return lineNumber + ":" + Arrays.toString(openMPTokens) +¶				"--> (" + annotatedTextStartLineNumber + "," + annotatedTextEndLineNumber + "):" + annotatedText;¶	}¶¶}¶")]]]></diff>
  </Command>
  <Command __id="35388" _type="MoveCaretCommand" caretOffset="630" date="Sun Dec 22 04:41:36 EST 2019" docOffset="630" starttimestamp="1576666505112" timestamp="341191650" />
  <Command __id="35390" _type="MoveCaretCommand" caretOffset="547" date="Sun Dec 22 04:41:42 EST 2019" docOffset="547" starttimestamp="1576666505112" timestamp="341197330" />
  <Command __id="35389" _type="DiffBasedFileOpenCommand" date="Sun Dec 22 04:41:42 EST 2019" docASTNodeCount="1" docActiveCodeLength="526" docExpressionCount="0" docLength="550" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="341197186">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\sum_parallel_for_reduction.cpp]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"#include <iostream>¶#include <omp.h>¶¶using namespace std;¶¶//const int SIZE = 1000;¶void printSumWithTimes(int sum, int start, int end);¶void printNumThreads();¶void recordThreadIndex(int index);¶void sum_parallel_for_reduction(double* array, int size) {¶	cout << "sum_parallel_for_reduction\n";¶¶	double start = omp_get_wtime();¶¶	double sum = 0;¶    #pragma omp  parallel for reduction (+:sum)¶"), Diff(DELETE,"¶"), Diff(EQUAL,"	for (int i = 0; i < size; i++) {¶		sum += array[i];¶		recordThreadIndex(i);¶	}¶¶	double end = omp_get_wtime();¶¶	printSumWithTimes(sum, start, end);¶¶}¶")]]]></diff>
    <snapshot><![CDATA[#include <iostream>
#include <omp.h>

using namespace std;

//const int SIZE = 1000;
void printSumWithTimes(int sum, int start, int end);
void printNumThreads();
void recordThreadIndex(int index);
void sum_parallel_for_reduction(double* array, int size) {
	cout << "sum_parallel_for_reduction\n";

	double start = omp_get_wtime();

	double sum = 0;
    #pragma omp  parallel for reduction (+:sum)
	for (int i = 0; i < size; i++) {
		sum += array[i];
		recordThreadIndex(i);
	}

	double end = omp_get_wtime();

	printSumWithTimes(sum, start, end);

}
]]></snapshot>
  </Command>
  <Command __id="35391" _type="SelectTextCommand" caretOffset="396" date="Sun Dec 22 04:41:52 EST 2019" end="396" start="389" starttimestamp="1576666505112" timestamp="341207406" />
  <DocumentChange __id="35392" _type="Delete" date="Sun Dec 22 04:41:53 EST 2019" docASTNodeCount="1" docActiveCodeLength="519" docExpressionCount="0" docLength="543" endLine="15" length="7" offset="389" startLine="15" starttimestamp="1576666505112" timestamp="341208856">
    <text><![CDATA[(+:sum)]]></text>
  </DocumentChange>
  <Command __id="35393" _type="CutCommand" date="Sun Dec 22 04:41:53 EST 2019" starttimestamp="1576666505112" timestamp="341208874" />
  <Command __id="35395" _type="EclipseCommand" commandID="org.eclipse.ui.file.save" date="Sun Dec 22 04:41:55 EST 2019" starttimestamp="1576666505112" timestamp="341210095" />
  <Command __id="35396" _type="EclipseCommand" commandID="org.eclipse.debug.ui.commands.RunLast" date="Sun Dec 22 04:41:58 EST 2019" starttimestamp="1576666505112" timestamp="341213478" />
  <Command __id="35397" _type="ShellCommand" date="Sun Dec 22 04:41:59 EST 2019" starttimestamp="1576666505112" timestamp="341214054" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="35398" _type="ShellCommand" date="Sun Dec 22 04:42:00 EST 2019" starttimestamp="1576666505112" timestamp="341215732" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="35399" _type="RunCommand" date="Sun Dec 22 04:42:00 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="341215832" type="Run" />
  <Command __id="35400" _type="RunCommand" date="Sun Dec 22 04:42:00 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="341215832" type="Run" />
  <Command __id="35401" _type="RunCommand" date="Sun Dec 22 04:42:00 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="341215849" type="Debug" />
  <Command __id="35402" _type="RunCommand" date="Sun Dec 22 04:42:00 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="341215849" type="Run" />
  <Command __id="35403" _type="RunCommand" date="Sun Dec 22 04:42:00 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="341215849" type="Debug" />
  <Command __id="35404" _type="RunCommand" date="Sun Dec 22 04:42:00 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="341215849" type="Run" />
  <Command __id="35405" _type="EHExceptionCommand" date="Sun Dec 22 04:42:01 EST 2019" starttimestamp="1576666505112" timestamp="341215948" type="Exception">
    <outputString><![CDATA[sum_sequential
Sum: 499500
Took: 0
thread:0 lastIndex:999
_____________________________
sum_parallel_for_reduction
Sum: 499500
Took: 0
thread:0 lastIndex:124
thread:1 lastIndex:249
thread:2 lastIndex:374
thread:3 lastIndex:499
thread:4 lastIndex:624
thread:5 lastIndex:749
thread:6 lastIndex:874
thread:7 lastIndex:999
_____________________________
sum_parallel_for_local_var
Sum: 499500
Took: 0
thread:0 lastIndex:124
thread:1 lastIndex:249
thread:2 lastIndex:374
thread:3 lastIndex:499
thread:4 lastIndex:624
thread:5 lastIndex:749
thread:6 lastIndex:874
thread:7 lastIndex:999
_____________________________
sum_parallel
Sum: 499500
Took: 0
_____________________________
]]></outputString>
  </Command>
  <DocumentChange __id="35394" _type="Delete" date="Sun Dec 22 04:41:55 EST 2019" docASTNodeCount="1" docActiveCodeLength="518" docExpressionCount="0" docLength="542" endLine="15" length="1" offset="388" startLine="15" starttimestamp="1576666505112" timestamp="341210055">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <Command __id="35406" _type="MoveCaretCommand" caretOffset="388" date="Sun Dec 22 04:42:15 EST 2019" docOffset="388" starttimestamp="1576666505112" timestamp="341230004" />
  <DocumentChange __id="35407" _type="Insert" date="Sun Dec 22 04:42:16 EST 2019" docASTNodeCount="1" docActiveCodeLength="519" docExpressionCount="0" docLength="543" length="1" offset="388" starttimestamp="1576666505112" timestamp="341231278">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <Command __id="35408" _type="UndoCommand" date="Sun Dec 22 04:42:16 EST 2019" starttimestamp="1576666505112" timestamp="341231293" />
  <Command __id="35410" _type="UndoCommand" date="Sun Dec 22 04:42:18 EST 2019" starttimestamp="1576666505112" timestamp="341233345" />
  <Command __id="35411" _type="EclipseCommand" commandID="org.eclipse.ui.file.save" date="Sun Dec 22 04:42:19 EST 2019" starttimestamp="1576666505112" timestamp="341234557" />
  <Command __id="35412" _type="MoveCaretCommand" caretOffset="390" date="Sun Dec 22 04:42:36 EST 2019" docOffset="390" starttimestamp="1576666505112" timestamp="341251086" />
  <Command __id="35414" _type="InsertStringCommand" date="Sun Dec 22 04:42:36 EST 2019" starttimestamp="1576666505112" timestamp="341251568" timestamp2="341251568">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="35415" _type="MoveCaretCommand" caretOffset="392" date="Sun Dec 22 04:42:38 EST 2019" docOffset="392" starttimestamp="1576666505112" timestamp="341253089" />
  <Command __id="35417" _type="InsertStringCommand" date="Sun Dec 22 04:42:38 EST 2019" starttimestamp="1576666505112" timestamp="341253424" timestamp2="341253424">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="35418" _type="MoveCaretCommand" caretOffset="395" date="Sun Dec 22 04:42:39 EST 2019" docOffset="395" starttimestamp="1576666505112" timestamp="341254804" />
  <Command __id="35419" _type="MoveCaretCommand" caretOffset="394" date="Sun Dec 22 04:42:40 EST 2019" docOffset="394" starttimestamp="1576666505112" timestamp="341255652" />
  <Command __id="35421" _type="InsertStringCommand" date="Sun Dec 22 04:42:41 EST 2019" starttimestamp="1576666505112" timestamp="341255943" timestamp2="341255943">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="35422" _type="EclipseCommand" commandID="org.eclipse.ui.file.save" date="Sun Dec 22 04:42:42 EST 2019" starttimestamp="1576666505112" timestamp="341257229" />
  <DocumentChange __id="36142" _type="Insert" date="Sun Dec 22 04:53:13 EST 2019" docASTNodeCount="610" docActiveCodeLength="3965" docExpressionCount="367" docLength="4544" length="1" offset="3925" starttimestamp="1576666505112" timestamp="341887990">
    <text><![CDATA[b]]></text>
  </DocumentChange>
  <DocumentChange __id="36144" _type="Insert" date="Sun Dec 22 04:53:13 EST 2019" docASTNodeCount="610" docActiveCodeLength="3966" docExpressionCount="367" docLength="4545" length="1" offset="3926" starttimestamp="1576666505112" timestamp="341888277">
    <text><![CDATA[r]]></text>
  </DocumentChange>
  <DocumentChange __id="36146" _type="Insert" date="Sun Dec 22 04:53:13 EST 2019" docASTNodeCount="610" docActiveCodeLength="3967" docExpressionCount="367" docLength="4546" length="1" offset="3927" starttimestamp="1576666505112" timestamp="341888398">
    <text><![CDATA[e]]></text>
  </DocumentChange>
  <DocumentChange __id="36148" _type="Insert" date="Sun Dec 22 04:53:13 EST 2019" docASTNodeCount="610" docActiveCodeLength="3968" docExpressionCount="367" docLength="4547" length="1" offset="3928" starttimestamp="1576666505112" timestamp="341888584">
    <text><![CDATA[a]]></text>
  </DocumentChange>
  <DocumentChange __id="36150" _type="Insert" date="Sun Dec 22 04:53:13 EST 2019" docASTNodeCount="609" docActiveCodeLength="3969" docExpressionCount="366" docLength="4548" length="1" offset="3929" starttimestamp="1576666505112" timestamp="341888769">
    <text><![CDATA[k]]></text>
  </DocumentChange>
  <DocumentChange __id="36152" _type="Insert" date="Sun Dec 22 04:53:14 EST 2019" docASTNodeCount="609" docActiveCodeLength="3970" docExpressionCount="366" docLength="4549" length="1" offset="3930" starttimestamp="1576666505112" timestamp="341889691">
    <text><![CDATA[;]]></text>
  </DocumentChange>
  <DocumentChange __id="36155" _type="Insert" date="Sun Dec 22 04:53:26 EST 2019" docASTNodeCount="609" docActiveCodeLength="3977" docExpressionCount="366" docLength="4556" length="7" offset="4031" starttimestamp="1576666505112" timestamp="341901669">
    <text><![CDATA[
					]]></text>
  </DocumentChange>
  <DocumentChange __id="36158" _type="Delete" date="Sun Dec 22 04:53:30 EST 2019" docASTNodeCount="609" docActiveCodeLength="3975" docExpressionCount="366" docLength="4554" endLine="122" length="2" offset="4031" startLine="121" starttimestamp="1576666505112" timestamp="341905733">
    <text><![CDATA[
]]></text>
  </DocumentChange>
  <Command __id="36186" _type="EclipseCommand" commandID="" date="Sun Dec 22 04:53:45 EST 2019" starttimestamp="1576666505112" timestamp="341920326" />
  <Command __id="36187" _type="EclipseCommand" commandID="" date="Sun Dec 22 04:53:45 EST 2019" starttimestamp="1576666505112" timestamp="341920326" />
  <Command __id="36188" _type="EclipseCommand" commandID="" date="Sun Dec 22 04:53:45 EST 2019" starttimestamp="1576666505112" timestamp="341920335" />
  <Command __id="36189" _type="EclipseCommand" commandID="" date="Sun Dec 22 04:53:45 EST 2019" starttimestamp="1576666505112" timestamp="341920335" />
  <Command __id="36190" _type="EclipseCommand" commandID="" date="Sun Dec 22 04:53:45 EST 2019" starttimestamp="1576666505112" timestamp="341920337" />
  <Command __id="36191" _type="EclipseCommand" commandID="" date="Sun Dec 22 04:53:45 EST 2019" starttimestamp="1576666505112" timestamp="341920337" />
  <Command __id="36192" _type="EclipseCommand" commandID="" date="Sun Dec 22 04:53:45 EST 2019" starttimestamp="1576666505112" timestamp="341920352" />
  <Command __id="36193" _type="EclipseCommand" commandID="" date="Sun Dec 22 04:53:45 EST 2019" starttimestamp="1576666505112" timestamp="341920352" />
  <Command __id="36194" _type="EclipseCommand" commandID="" date="Sun Dec 22 04:53:45 EST 2019" starttimestamp="1576666505112" timestamp="341920357" />
  <Command __id="36195" _type="EclipseCommand" commandID="" date="Sun Dec 22 04:53:45 EST 2019" starttimestamp="1576666505112" timestamp="341920357" />
  <Command __id="36196" _type="EclipseCommand" commandID="" date="Sun Dec 22 04:53:45 EST 2019" starttimestamp="1576666505112" timestamp="341920365" />
  <Command __id="36198" _type="MoveCaretCommand" caretOffset="395" date="Sun Dec 22 04:53:47 EST 2019" docOffset="395" starttimestamp="1576666505112" timestamp="341922646" />
  <Command __id="36199" _type="EclipseCommand" commandID="" date="Sun Dec 22 04:53:48 EST 2019" starttimestamp="1576666505112" timestamp="341923640" />
  <Command __id="36200" _type="EclipseCommand" commandID="" date="Sun Dec 22 04:53:48 EST 2019" starttimestamp="1576666505112" timestamp="341923702" />
  <Command __id="36201" _type="MoveCaretCommand" caretOffset="398" date="Sun Dec 22 04:53:49 EST 2019" docOffset="398" starttimestamp="1576666505112" timestamp="341924749" />
  <Command __id="36203" _type="InsertStringCommand" date="Sun Dec 22 04:53:50 EST 2019" starttimestamp="1576666505112" timestamp="341924969" timestamp2="341924969">
    <data><![CDATA[ ]]></data>
  </Command>
  <DocumentChange __id="37693" _type="Insert" date="Sun Dec 22 05:20:18 EST 2019" docASTNodeCount="615" docActiveCodeLength="4045" docExpressionCount="369" docLength="4655" length="1" offset="3892" starttimestamp="1576666505112" timestamp="343513121">
    <text><![CDATA[;]]></text>
  </DocumentChange>
  <Command __id="37787" _type="EclipseCommand" commandID="org.eclipse.ui.navigate.backwardHistory" date="Sun Dec 22 05:22:29 EST 2019" starttimestamp="1576666505112" timestamp="343644320" />
  <Command __id="37789" _type="MoveCaretCommand" caretOffset="399" date="Sun Dec 22 05:22:33 EST 2019" docOffset="399" starttimestamp="1576666505112" timestamp="343647913" />
  <Command __id="37790" _type="ShellCommand" date="Sun Dec 22 05:22:40 EST 2019" starttimestamp="1576666505112" timestamp="343655773" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="37791" _type="RunCommand" date="Sun Dec 22 05:22:41 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="343656220" type="Run" />
  <Command __id="37792" _type="RunCommand" date="Sun Dec 22 05:22:41 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="343656252" type="Run" />
  <Command __id="37793" _type="RunCommand" date="Sun Dec 22 05:22:41 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="343656252" type="Run" />
  <Command __id="37794" _type="EHExceptionCommand" date="Sun Dec 22 05:22:41 EST 2019" starttimestamp="1576666505112" timestamp="343656267" type="Exception">
    <outputString><![CDATA[I***(TestCaseResult) ### SequentialSumTestCase: 1.0
Returning first of multiple entry points:[MyOpenMPTraining.exe, OpenMPTraining.exe]
I***(BasicProcessRunner) Running command:D:\dewan_backup\C\MyOpenMPTraining\Debug\MyOpenMPTraining.exe
I***(BasicProcessRunner) Running in folder: D:\dewan_backup\C\MyOpenMPTraining\Debug
I***(BasicProcessRunner)  Process started: D:\dewan_backup\C\MyOpenMPTraining\Debug\MyOpenMPTraining.exe folder: D:\dewan_backup\C\MyOpenMPTraining\Debug entry point: null class path: D:\dewan_backup\Java\PLTeaching\PL_Java\bin;D:\dewan_backup\Java\lib\oeall22.jar;C:\Users\dewan\.p2\pool\plugins\org.junit_4.12.0.v201504281640\junit.jar;C:\Users\dewan\.p2\pool\plugins\org.hamcrest.core_1.3.0.v20180420-1519.jar;D:\dewan_backup\Java\GraderBasics\lib\commons-configuration-1.9.jar;D:\dewan_backup\Java\GraderBasics\lib\commons-lang-2.6.jar;D:\dewan_backup\Java\GraderBasics\lib\commons-logging-1.1.1.jar;G:\My Drive\Java\lib\Herrmes\lib\weka3_6.jar;D:\dewan_backup\Java\GraderBasics\target\classes;D:\dewan_backup\Java\DemoCourseLocalBasicChecks\bin
I***(ARunnerInputStreamProcessor) Provided Input:
I***(BasicRunningProject) 1577010161364:Received output from main: sum_sequential
I***(BasicRunningProject) 1577010161364:Processing line from main: sum_sequential
I***(BasicRunningProject) 1577010161364:Received output from main: Sum: 499500
I***(BasicRunningProject) 1577010161364:Processing line from main: Sum: 499500
I***(BasicRunningProject) 1577010161364:Received output from main: Took: 0
I***(BasicRunningProject) 1577010161364:Processing line from main: Took: 0
I***(BasicRunningProject) 1577010161364:Received output from main: thread:0 lastIndex:999
I***(BasicRunningProject) 1577010161364:Processing line from main: thread:0 lastIndex:999
I***(BasicRunningProject) 1577010161364:Received output from main: _____________________________
I***(BasicRunningProject) 1577010161364:Processing line from main: _____________________________
I***(BasicRunningProject) 1577010161364:Received output from main: sum_parallel_for_reduction
I***(BasicRunningProject) 1577010161364:Processing line from main: sum_parallel_for_reduction
I***(BasicRunningProject) 1577010161364:Received output from main: Sum: 499500
I***(BasicRunningProject) 1577010161364:Processing line from main: Sum: 499500
I***(BasicRunningProject) 1577010161364:Received output from main: Took: 0
I***(BasicRunningProject) 1577010161364:Processing line from main: Took: 0
]]></outputString>
  </Command>
  <Command __id="37795" _type="EHExceptionCommand" date="Sun Dec 22 05:22:41 EST 2019" starttimestamp="1576666505112" timestamp="343656267" type="Exception">
    <outputString><![CDATA[I***(BasicRunningProject) 1577010161364:Received output from main: thread:0 lastIndex:124
I***(BasicRunningProject) 1577010161364:Processing line from main: thread:0 lastIndex:124
I***(BasicRunningProject) 1577010161364:Received output from main: thread:1 lastIndex:249
I***(BasicRunningProject) 1577010161364:Processing line from main: thread:1 lastIndex:249
I***(BasicRunningProject) 1577010161364:Received output from main: thread:2 lastIndex:374
I***(BasicRunningProject) 1577010161364:Processing line from main: thread:2 lastIndex:374
I***(BasicRunningProject) 1577010161364:Received output from main: thread:3 lastIndex:499
I***(BasicRunningProject) 1577010161364:Processing line from main: thread:3 lastIndex:499
I***(BasicRunningProject) 1577010161379:Received output from main: thread:4 lastIndex:624
I***(BasicRunningProject) 1577010161379:Processing line from main: thread:4 lastIndex:624
I***(BasicRunningProject) 1577010161379:Received output from main: thread:5 lastIndex:749
I***(BasicRunningProject) 1577010161379:Processing line from main: thread:5 lastIndex:749
I***(BasicRunningProject) 1577010161379:Received output from main: thread:6 lastIndex:874
I***(BasicRunningProject) 1577010161379:Processing line from main: thread:6 lastIndex:874
I***(BasicRunningProject) 1577010161379:Received output from main: thread:7 lastIndex:999
I***(BasicRunningProject) 1577010161379:Processing line from main: thread:7 lastIndex:999
I***(BasicRunningProject) 1577010161379:Received output from main: _____________________________
I***(BasicRunningProject) 1577010161379:Processing line from main: _____________________________
I***(BasicRunningProject) 1577010161379:Received output from main: sum_parallel_for_local_var
I***(BasicRunningProject) 1577010161379:Processing line from main: sum_parallel_for_local_var
I***(BasicRunningProject) 1577010161379:Received output from main: Sum: 499500
I***(BasicRunningProject) 1577010161379:Processing line from main: Sum: 499500
I***(BasicRunningProject) 1577010161379:Received output from main: Took: 0
I***(BasicRunningProject) 1577010161379:Processing line from main: Took: 0
I***(BasicRunningProject) 1577010161379:Received output from main: thread:0 lastIndex:124
I***(BasicRunningProject) 1577010161379:Processing line from main: thread:0 lastIndex:124
I***(BasicRunningProject) 1577010161379:Received output from main: thread:1 lastIndex:249
I***(BasicRunningProject) 1577010161379:Processing line from main: thread:1 lastIndex:249
I***(BasicRunningProject) 1577010161379:Received output from main: thread:2 lastIndex:374
I***(BasicRunningProject) 1577010161379:Processing line from main: thread:2 lastIndex:374
I***(BasicRunningProject) 1577010161379:Received output from main: thread:3 lastIndex:499
I***(BasicRunningProject) 1577010161379:Processing line from main: thread:3 lastIndex:499
I***(BasicRunningProject) 1577010161379:Received output from main: thread:4 lastIndex:624
I***(BasicRunningProject) 1577010161379:Processing line from main: thread:4 lastIndex:624
I***(BasicRunningProject) 1577010161379:Received output from main: thread:5 lastIndex:749
I***(BasicRunningProject) 1577010161379:Processing line from main: thread:5 lastIndex:749
I***(BasicRunningProject) 1577010161379:Received output from main: thread:6 lastIndex:874
I***(BasicRunningProject) 1577010161379:Processing line from main: thread:6 lastIndex:874
I***(BasicRunningProject) 1577010161379:Received output from main: thread:7 lastIndex:999
I***(BasicRunningProject) 1577010161379:Received output from main: _____________________________
I***(BasicRunningProject) 1577010161379:Received output from main: sum_parallel
I***(BasicRunningProject) 1577010161379:Received output from main: Sum: 499500
I***(BasicProcessRunner)  Process finished; folder: D:\dewan_backup\C\MyOpenMPTraining\Debug entry point: null class path: D:\dewan_backup\Java\PLTeaching\PL_Java\bin;D:\dewan_backup\Java\lib\oeall22.jar;C:\Users\dewan\.p2\pool\plugins\org.junit_4.12.0.v201504281640\junit.jar;C:\Users\dewan\.p2\pool\plugins\org.hamcrest.core_1.3.0.v20180420-1519.jar;D:\dewan_backup\Java\GraderBasics\lib\commons-configuration-1.9.jar;D:\dewan_backup\Java\GraderBasics\lib\commons-lang-2.6.jar;D:\dewan_backup\Java\GraderBasics\lib\commons-logging-1.1.1.jar;G:\My Drive\Java\lib\Herrmes\lib\weka3_6.jar;D:\dewan_backup\Java\GraderBasics\target\classes;D:\dewan_backup\Java\DemoCourseLocalBasicChecks\bin
I***(BasicRunningProject) 1577010161379:Processing line from main: thread:7 lastIndex:999
I***(BasicRunningProject) 1577010161379:Received output from main: Took: 0
I***(BasicRunningProject) 1577010161379:Processing line from main: _____________________________
I***(BasicRunningProject) 1577010161379:Processing line from main: sum_parallel
I***(BasicRunningProject) 1577010161379:Processing line from main: Sum: 499500
I***(BasicRunningProject) 1577010161379:Processing line from main: Took: 0
I***(BasicRunningProject) 1577010161379:Received output from main: _____________________________
I***(BasicRunningProject) 1577010161379:Processing line from main: _____________________________
I***(BasicRunningProject) Thread[AWT-EventQueue-0,6,main] sleeping for ms:2000 waiting for pending output from threads 
]]></outputString>
  </Command>
  <Command __id="37796" _type="EHExceptionCommand" date="Sun Dec 22 05:22:43 EST 2019" starttimestamp="1576666505112" timestamp="343658370" type="Exception">
    <outputString><![CDATA[line matcher for key:main
I***(ALinesMatcher) Matching pattern:.*sum_sequential.*?starting at:0
I***(ALinesMatcher) 0: Checking: sum_sequential

0: Matched  pattern .*sum_sequential.*?
I***(ALinesMatcher) Matching pattern:.*499500.*?starting at:1
I***(ALinesMatcher) 1: Checking: Sum: 499500

1: Matched  pattern .*499500.*?
I***(ALinesMatcher) Matching pattern:.*Took.*?starting at:2
I***(ALinesMatcher) 2: Checking: Took: 0

2: Matched  pattern .*Took.*?
I***(ALinesMatcher) Matching pattern:.*thread.*?starting at:3
I***(ALinesMatcher) 3: Checking: thread:0 lastIndex:999

3: Matched  pattern .*thread.*?
Matched Line sum_sequential
 for pattern [.*sum_sequential.*?, .*499500.*?, .*Took.*?, .*thread.*?]
Matched Line Sum: 499500
 for pattern [.*sum_sequential.*?, .*499500.*?, .*Took.*?, .*thread.*?]
Matched Line Took: 0
 for pattern [.*sum_sequential.*?, .*499500.*?, .*Took.*?, .*thread.*?]
Matched Line thread:0 lastIndex:999
 for pattern [.*sum_sequential.*?, .*499500.*?, .*Took.*?, .*thread.*?]
file name:sum_parallel_for_reduction.cp
pragmas:[15:[parallel, for, reduction(+:sum)]--> (16,19):[for (int i = 0; i < size; i++) {, sum += array[i];, recordThreadIndex(i);, }]]
file name:sum_parallel_for_local_var.cp
pragmas:[20:[parallel]--> (21,32):[{, double local_sum = 0;, #pragma omp for, for(int i = 0; i < size; i++) {, local_sum += array[i];, recordThreadIndex(i);, }, #pragma omp critical, sum += local_sum;, }], 24:[for]--> (25,28):[for(int i = 0; i < size; i++) {, local_sum += array[i];, recordThreadIndex(i);, }], 30:[critical]--> (31,31):[sum += local_sum;]]
file name:sum_main.cp
pragmas:[]
file name:sum_sequential.cp
pragmas:[]
file name:sum_parallel.cp
pragmas:[18:[parallel]--> (19,36):[{, double local_sum = 0;, int rank = omp_get_thread_num();, int threads = omp_get_num_threads();, int start_index = (size/threads)*rank;, int end_index = (size/threads)*(rank+1);, if(rank==threads-1), end_index=size;, for(int i = start_index; i < end_index; i++), local_sum += array[i];, #pragma omp critical, sum += local_sum;, }], 34:[critical]--> (35,35):[sum += local_sum;]]
I***(TestCaseResult) ### anonymous: 1.0
]]></outputString>
  </Command>
  <DocumentChange __id="38051" _type="Insert" date="Sun Dec 22 05:30:12 EST 2019" docASTNodeCount="230" docActiveCodeLength="1705" docExpressionCount="114" docLength="1987" length="1" offset="716" starttimestamp="1576666505112" timestamp="344107703">
    <text><![CDATA[o]]></text>
  </DocumentChange>
  <DocumentChange __id="38054" _type="Insert" date="Sun Dec 22 05:30:12 EST 2019" docASTNodeCount="230" docActiveCodeLength="1706" docExpressionCount="114" docLength="1988" length="1" offset="717" starttimestamp="1576666505112" timestamp="344107879">
    <text><![CDATA[p]]></text>
  </DocumentChange>
  <DocumentChange __id="38057" _type="Insert" date="Sun Dec 22 05:30:13 EST 2019" docASTNodeCount="230" docActiveCodeLength="1707" docExpressionCount="114" docLength="1989" length="1" offset="718" starttimestamp="1576666505112" timestamp="344108006">
    <text><![CDATA[e]]></text>
  </DocumentChange>
  <DocumentChange __id="38060" _type="Insert" date="Sun Dec 22 05:30:13 EST 2019" docASTNodeCount="230" docActiveCodeLength="1708" docExpressionCount="114" docLength="1990" length="1" offset="719" starttimestamp="1576666505112" timestamp="344108282">
    <text><![CDATA[r]]></text>
  </DocumentChange>
  <DocumentChange __id="38063" _type="Insert" date="Sun Dec 22 05:30:13 EST 2019" docASTNodeCount="230" docActiveCodeLength="1709" docExpressionCount="114" docLength="1991" length="1" offset="720" starttimestamp="1576666505112" timestamp="344108381">
    <text><![CDATA[a]]></text>
  </DocumentChange>
  <DocumentChange __id="38066" _type="Insert" date="Sun Dec 22 05:30:13 EST 2019" docASTNodeCount="230" docActiveCodeLength="1710" docExpressionCount="114" docLength="1992" length="1" offset="721" starttimestamp="1576666505112" timestamp="344108484">
    <text><![CDATA[t]]></text>
  </DocumentChange>
  <DocumentChange __id="38069" _type="Delete" date="Sun Dec 22 05:30:14 EST 2019" docASTNodeCount="230" docActiveCodeLength="1709" docExpressionCount="114" docLength="1991" endLine="18" length="1" offset="721" startLine="18" starttimestamp="1576666505112" timestamp="344109241">
    <text><![CDATA[t]]></text>
  </DocumentChange>
  <DocumentChange __id="38072" _type="Delete" date="Sun Dec 22 05:30:14 EST 2019" docASTNodeCount="230" docActiveCodeLength="1708" docExpressionCount="114" docLength="1990" endLine="18" length="1" offset="720" startLine="18" starttimestamp="1576666505112" timestamp="344109402">
    <text><![CDATA[a]]></text>
  </DocumentChange>
  <DocumentChange __id="38075" _type="Delete" date="Sun Dec 22 05:30:14 EST 2019" docASTNodeCount="230" docActiveCodeLength="1707" docExpressionCount="114" docLength="1989" endLine="18" length="1" offset="719" startLine="18" starttimestamp="1576666505112" timestamp="344109570">
    <text><![CDATA[r]]></text>
  </DocumentChange>
  <DocumentChange __id="38078" _type="Delete" date="Sun Dec 22 05:30:14 EST 2019" docASTNodeCount="230" docActiveCodeLength="1706" docExpressionCount="114" docLength="1988" endLine="18" length="1" offset="718" startLine="18" starttimestamp="1576666505112" timestamp="344109751">
    <text><![CDATA[e]]></text>
  </DocumentChange>
  <DocumentChange __id="38081" _type="Delete" date="Sun Dec 22 05:30:15 EST 2019" docASTNodeCount="230" docActiveCodeLength="1705" docExpressionCount="114" docLength="1987" endLine="18" length="1" offset="717" startLine="18" starttimestamp="1576666505112" timestamp="344109916">
    <text><![CDATA[p]]></text>
  </DocumentChange>
  <DocumentChange __id="38084" _type="Delete" date="Sun Dec 22 05:30:15 EST 2019" docASTNodeCount="230" docActiveCodeLength="1704" docExpressionCount="114" docLength="1986" endLine="18" length="1" offset="716" startLine="18" starttimestamp="1576666505112" timestamp="344110268">
    <text><![CDATA[o]]></text>
  </DocumentChange>
  <DocumentChange __id="38087" _type="Insert" date="Sun Dec 22 05:30:16 EST 2019" docASTNodeCount="230" docActiveCodeLength="1705" docExpressionCount="114" docLength="1987" length="1" offset="716" starttimestamp="1576666505112" timestamp="344110973">
    <text><![CDATA[O]]></text>
  </DocumentChange>
  <DocumentChange __id="38090" _type="Insert" date="Sun Dec 22 05:30:16 EST 2019" docASTNodeCount="230" docActiveCodeLength="1706" docExpressionCount="114" docLength="1988" length="1" offset="717" starttimestamp="1576666505112" timestamp="344111154">
    <text><![CDATA[p]]></text>
  </DocumentChange>
  <DocumentChange __id="38093" _type="Insert" date="Sun Dec 22 05:30:16 EST 2019" docASTNodeCount="230" docActiveCodeLength="1707" docExpressionCount="114" docLength="1989" length="1" offset="718" starttimestamp="1576666505112" timestamp="344111338">
    <text><![CDATA[e]]></text>
  </DocumentChange>
  <DocumentChange __id="38096" _type="Insert" date="Sun Dec 22 05:30:16 EST 2019" docASTNodeCount="230" docActiveCodeLength="1708" docExpressionCount="114" docLength="1990" length="1" offset="719" starttimestamp="1576666505112" timestamp="344111554">
    <text><![CDATA[r]]></text>
  </DocumentChange>
  <DocumentChange __id="38099" _type="Insert" date="Sun Dec 22 05:30:16 EST 2019" docASTNodeCount="230" docActiveCodeLength="1709" docExpressionCount="114" docLength="1991" length="1" offset="720" starttimestamp="1576666505112" timestamp="344111638">
    <text><![CDATA[a]]></text>
  </DocumentChange>
  <DocumentChange __id="38102" _type="Insert" date="Sun Dec 22 05:30:17 EST 2019" docASTNodeCount="230" docActiveCodeLength="1710" docExpressionCount="114" docLength="1992" length="1" offset="721" starttimestamp="1576666505112" timestamp="344111914">
    <text><![CDATA[t]]></text>
  </DocumentChange>
  <DocumentChange __id="38105" _type="Insert" date="Sun Dec 22 05:30:17 EST 2019" docASTNodeCount="230" docActiveCodeLength="1711" docExpressionCount="114" docLength="1993" length="1" offset="722" starttimestamp="1576666505112" timestamp="344112408">
    <text><![CDATA[i]]></text>
  </DocumentChange>
  <DocumentChange __id="38108" _type="Insert" date="Sun Dec 22 05:30:17 EST 2019" docASTNodeCount="230" docActiveCodeLength="1712" docExpressionCount="114" docLength="1994" length="1" offset="723" starttimestamp="1576666505112" timestamp="344112592">
    <text><![CDATA[o]]></text>
  </DocumentChange>
  <DocumentChange __id="38111" _type="Insert" date="Sun Dec 22 05:30:18 EST 2019" docASTNodeCount="230" docActiveCodeLength="1713" docExpressionCount="114" docLength="1995" length="1" offset="724" starttimestamp="1576666505112" timestamp="344113130">
    <text><![CDATA[n]]></text>
  </DocumentChange>
  <DocumentChange __id="38114" _type="Insert" date="Sun Dec 22 05:30:19 EST 2019" docASTNodeCount="230" docActiveCodeLength="1714" docExpressionCount="114" docLength="1996" length="1" offset="725" starttimestamp="1576666505112" timestamp="344114035">
    <text><![CDATA[;]]></text>
  </DocumentChange>
  <Command __id="38158" _type="DiffBasedFileOpenCommand" date="Sun Dec 22 05:31:59 EST 2019" docASTNodeCount="53" docActiveCodeLength="436" docExpressionCount="26" docLength="494" projectName="GraderBasics" starttimestamp="1576666505112" timestamp="344214381">
    <filePath><![CDATA[D:\dewan_backup\Java\GraderBasics\src\gradingTools\shared\testcases\openmp\OpenMPPragma.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package gradingTools.shared.testcases.openmp;¶¶import java.util.List;¶¶public interface OpenMPPragma {¶¶	List<String> getOpenMPTokens();¶¶	int getLineNumber();¶¶	List<String> getAnnotatedText();¶¶//	void setAnnotatedText(StringBuffer nextNonEmptyString);¶¶	int getAnnotatedTextStartLineNumber();¶¶	void setAnnotatedTextStartLineNumber(int annotatedLineNumber);¶¶	int getAnnotatedTextEndLineNumber();¶¶	void setAnnotatedTextEndLineNumber(int annotatedTextEndLineNumber);¶¶}")]]]></diff>
  </Command>
  <Command __id="38159" _type="SelectTextCommand" caretOffset="123" date="Sun Dec 22 05:31:59 EST 2019" end="123" start="111" starttimestamp="1576666505112" timestamp="344214470" />
  <DocumentChange __id="39817" _type="Insert" date="Sun Dec 22 11:34:19 EST 2019" docASTNodeCount="693" docActiveCodeLength="4592" docExpressionCount="428" docLength="5202" length="1" offset="4512" starttimestamp="1576666505112" timestamp="365954033">
    <text><![CDATA[a]]></text>
  </DocumentChange>
  <DocumentChange __id="39819" _type="Insert" date="Sun Dec 22 11:34:19 EST 2019" docASTNodeCount="693" docActiveCodeLength="4593" docExpressionCount="428" docLength="5203" length="1" offset="4513" starttimestamp="1576666505112" timestamp="365954687">
    <text><![CDATA[V]]></text>
  </DocumentChange>
  <DocumentChange __id="39821" _type="Insert" date="Sun Dec 22 11:34:19 EST 2019" docASTNodeCount="693" docActiveCodeLength="4594" docExpressionCount="428" docLength="5204" length="1" offset="4514" starttimestamp="1576666505112" timestamp="365954875">
    <text><![CDATA[a]]></text>
  </DocumentChange>
  <DocumentChange __id="39823" _type="Insert" date="Sun Dec 22 11:34:20 EST 2019" docASTNodeCount="693" docActiveCodeLength="4595" docExpressionCount="428" docLength="5205" length="1" offset="4515" starttimestamp="1576666505112" timestamp="365955144">
    <text><![CDATA[r]]></text>
  </DocumentChange>
  <DocumentChange __id="39825" _type="Insert" date="Sun Dec 22 11:34:20 EST 2019" docASTNodeCount="693" docActiveCodeLength="4596" docExpressionCount="428" docLength="5206" length="1" offset="4516" starttimestamp="1576666505112" timestamp="365955271">
    <text><![CDATA[i]]></text>
  </DocumentChange>
  <DocumentChange __id="39827" _type="Insert" date="Sun Dec 22 11:34:20 EST 2019" docASTNodeCount="693" docActiveCodeLength="4597" docExpressionCount="428" docLength="5207" length="1" offset="4517" starttimestamp="1576666505112" timestamp="365955404">
    <text><![CDATA[a]]></text>
  </DocumentChange>
  <DocumentChange __id="39829" _type="Insert" date="Sun Dec 22 11:34:20 EST 2019" docASTNodeCount="693" docActiveCodeLength="4598" docExpressionCount="428" docLength="5208" length="1" offset="4518" starttimestamp="1576666505112" timestamp="365955562">
    <text><![CDATA[b]]></text>
  </DocumentChange>
  <DocumentChange __id="39831" _type="Insert" date="Sun Dec 22 11:34:20 EST 2019" docASTNodeCount="693" docActiveCodeLength="4599" docExpressionCount="428" docLength="5209" length="1" offset="4519" starttimestamp="1576666505112" timestamp="365955841">
    <text><![CDATA[l]]></text>
  </DocumentChange>
  <DocumentChange __id="39833" _type="Insert" date="Sun Dec 22 11:34:21 EST 2019" docASTNodeCount="693" docActiveCodeLength="4600" docExpressionCount="428" docLength="5210" length="1" offset="4520" starttimestamp="1576666505112" timestamp="365955918">
    <text><![CDATA[e]]></text>
  </DocumentChange>
  <Command __id="39900" _type="EclipseCommand" commandID="org.eclipse.debug.ui.commands.Resume" date="Sun Dec 22 11:34:47 EST 2019" starttimestamp="1576666505112" timestamp="365982102" />
  <Command __id="39901" _type="RunCommand" date="Sun Dec 22 11:34:47 EST 2019" kind="StepInto" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="365982102" type="Run" />
  <Command __id="39902" _type="EHExceptionCommand" date="Sun Dec 22 11:34:47 EST 2019" starttimestamp="1576666505112" timestamp="365982247" type="Exception">
    <outputString><![CDATA[file name:sum_parallel_for_reduction.cp
pragmas:[15:[parallel, for, reduction(+:sum)]--> (16,19):[for (int i = 0; i < size; i++) {, sum += array[i];, recordThreadIndex(i);, }]]
file name:sum_parallel_for_local_var.cp
pragmas:[20:[parallel]--> (21,32):[{, double local_sum = 0;, #pragma omp for, for(int i = 0; i < size; i++) {, local_sum += array[i];, recordThreadIndex(i);, }, #pragma omp critical, sum += local_sum;, }], 24:[for]--> (25,28):[for(int i = 0; i < size; i++) {, local_sum += array[i];, recordThreadIndex(i);, }], 30:[critical]--> (31,31):[sum += local_sum;]]
file name:sum_main.cp
pragmas:[]
file name:sum_sequential.cp
pragmas:[]
file name:sum_parallel.cp
pragmas:[18:[parallel]--> (19,36):[{, double local_sum = 0;, int rank = omp_get_thread_num();, int threads = omp_get_num_threads();, int start_index = (size/threads)*rank;, int end_index = (size/threads)*(rank+1);, if(rank==threads-1), end_index=size;, for(int i = start_index; i < end_index; i++), local_sum += array[i];, #pragma omp critical, sum += local_sum;, }], 34:[critical]--> (35,35):[sum += local_sum;]]
I***(TestCaseResult) ### anonymous: 1.0
]]></outputString>
  </Command>
  <Command __id="39905" _type="DiffBasedFileOpenCommand" date="Sun Dec 22 11:37:42 EST 2019" docASTNodeCount="1" docActiveCodeLength="482" docExpressionCount="0" docLength="482" projectName="OpenMPTraining" starttimestamp="1576666505112" timestamp="366157549">
    <filePath><![CDATA[D:\dewan_backup\C\OpenMPTraining\OpenMPTrainingC++\src\sum_parallel_for_local_var.cpp]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"#include <iostream>¶#include <omp.h>¶¶using namespace std;¶¶void printSumWithTimes (int sum, int start, int end);¶void printNumThreads();¶void recordThreadIndex(int index);¶void sum_parallel_for_local_var(double* array, int size)¶{¶	cout << "sum_parallel_for_local_var\n";¶¶	double start = omp_get_wtime();¶¶	double sum = 0;¶¶	for (int i = 0; i < size; i++) {¶			sum += array[i];¶			recordThreadIndex(i);¶	}¶¶	double end = omp_get_wtime();¶¶	printSumWithTimes(sum, start, end);¶	¶}¶")]]]></diff>
  </Command>
  <Command __id="39906" _type="MoveCaretCommand" caretOffset="0" date="Sun Dec 22 11:37:42 EST 2019" docOffset="0" starttimestamp="1576666505112" timestamp="366157690" />
  <Command __id="39908" _type="MoveCaretCommand" caretOffset="0" date="Sun Dec 22 11:38:07 EST 2019" docOffset="0" starttimestamp="1576666505112" timestamp="366182444" />
  <Command __id="39907" _type="DiffBasedFileOpenCommand" date="Sun Dec 22 11:38:07 EST 2019" docASTNodeCount="1" docActiveCodeLength="611" docExpressionCount="0" docLength="699" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="366182266">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\sum_parallel_for_local_var.cpp]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"#include <iostream>¶#include <omp.h>¶¶using namespace std;¶¶void printSumWithTimes (int sum, int start, int end);¶void printNumThreads();¶void recordThreadIndex(int index);¶void sum_parallel_for_local_var(double* array, int size)¶{¶	cout << "sum_parallel_for_local_var\n";¶¶	double start = omp_get_wtime();¶¶	double sum = 0;¶//¶//	for (int i = 0; i < size; i++) {¶//			sum += array[i];¶//			recordThreadIndex(i);¶//	}¶    #pragma omp parallel¶	{¶		double local_sum = 0;¶¶		#pragma omp for¶		for(int i = 0; i < size; i++) {¶			local_sum += array[i];¶			recordThreadIndex(i);¶		}¶¶		#pragma omp critical¶		sum += local_sum;¶	}¶¶	double end = omp_get_wtime();¶¶	printSumWithTimes(sum, start, end);¶	¶}¶")]]]></diff>
  </Command>
  <Command __id="39909" _type="MoveCaretCommand" caretOffset="488" date="Sun Dec 22 11:38:13 EST 2019" docOffset="488" starttimestamp="1576666505112" timestamp="366188477" />
  <DocumentChange __id="39910" _type="Insert" date="Sun Dec 22 11:38:18 EST 2019" docASTNodeCount="1" docActiveCodeLength="612" docExpressionCount="0" docLength="700" length="1" offset="488" starttimestamp="1576666505112" timestamp="366193761">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <Command __id="39911" _type="InsertStringCommand" date="Sun Dec 22 11:38:18 EST 2019" starttimestamp="1576666505112" timestamp="366193763" timestamp2="366193763">
    <data><![CDATA[ ]]></data>
  </Command>
  <DocumentChange __id="39912" _type="Insert" date="Sun Dec 22 11:38:19 EST 2019" docASTNodeCount="1" docActiveCodeLength="613" docExpressionCount="0" docLength="701" length="1" offset="489" starttimestamp="1576666505112" timestamp="366194076">
    <text><![CDATA[r]]></text>
  </DocumentChange>
  <Command __id="39913" _type="InsertStringCommand" date="Sun Dec 22 11:38:19 EST 2019" starttimestamp="1576666505112" timestamp="366194083" timestamp2="366194083">
    <data><![CDATA[r]]></data>
  </Command>
  <DocumentChange __id="39914" _type="Insert" date="Sun Dec 22 11:38:19 EST 2019" docASTNodeCount="1" docActiveCodeLength="614" docExpressionCount="0" docLength="702" length="1" offset="490" starttimestamp="1576666505112" timestamp="366194299">
    <text><![CDATA[e]]></text>
  </DocumentChange>
  <Command __id="39915" _type="InsertStringCommand" date="Sun Dec 22 11:38:19 EST 2019" starttimestamp="1576666505112" timestamp="366194302" timestamp2="366194302">
    <data><![CDATA[e]]></data>
  </Command>
  <DocumentChange __id="39916" _type="Insert" date="Sun Dec 22 11:38:19 EST 2019" docASTNodeCount="1" docActiveCodeLength="615" docExpressionCount="0" docLength="703" length="1" offset="491" starttimestamp="1576666505112" timestamp="366194565">
    <text><![CDATA[d]]></text>
  </DocumentChange>
  <Command __id="39917" _type="InsertStringCommand" date="Sun Dec 22 11:38:19 EST 2019" starttimestamp="1576666505112" timestamp="366194565" timestamp2="366194565">
    <data><![CDATA[d]]></data>
  </Command>
  <DocumentChange __id="39918" _type="Insert" date="Sun Dec 22 11:38:19 EST 2019" docASTNodeCount="1" docActiveCodeLength="616" docExpressionCount="0" docLength="704" length="1" offset="492" starttimestamp="1576666505112" timestamp="366194795">
    <text><![CDATA[u]]></text>
  </DocumentChange>
  <Command __id="39919" _type="InsertStringCommand" date="Sun Dec 22 11:38:19 EST 2019" starttimestamp="1576666505112" timestamp="366194811" timestamp2="366194811">
    <data><![CDATA[u]]></data>
  </Command>
  <DocumentChange __id="39920" _type="Insert" date="Sun Dec 22 11:38:20 EST 2019" docASTNodeCount="1" docActiveCodeLength="617" docExpressionCount="0" docLength="705" length="1" offset="493" starttimestamp="1576666505112" timestamp="366194951">
    <text><![CDATA[c]]></text>
  </DocumentChange>
  <Command __id="39921" _type="InsertStringCommand" date="Sun Dec 22 11:38:20 EST 2019" starttimestamp="1576666505112" timestamp="366194967" timestamp2="366194967">
    <data><![CDATA[c]]></data>
  </Command>
  <DocumentChange __id="39922" _type="Insert" date="Sun Dec 22 11:38:20 EST 2019" docASTNodeCount="1" docActiveCodeLength="618" docExpressionCount="0" docLength="706" length="1" offset="494" starttimestamp="1576666505112" timestamp="366195282">
    <text><![CDATA[t]]></text>
  </DocumentChange>
  <Command __id="39923" _type="InsertStringCommand" date="Sun Dec 22 11:38:20 EST 2019" starttimestamp="1576666505112" timestamp="366195297" timestamp2="366195297">
    <data><![CDATA[t]]></data>
  </Command>
  <DocumentChange __id="39924" _type="Insert" date="Sun Dec 22 11:38:20 EST 2019" docASTNodeCount="1" docActiveCodeLength="619" docExpressionCount="0" docLength="707" length="1" offset="495" starttimestamp="1576666505112" timestamp="366195498">
    <text><![CDATA[i]]></text>
  </DocumentChange>
  <Command __id="39925" _type="InsertStringCommand" date="Sun Dec 22 11:38:20 EST 2019" starttimestamp="1576666505112" timestamp="366195507" timestamp2="366195507">
    <data><![CDATA[i]]></data>
  </Command>
  <DocumentChange __id="39926" _type="Insert" date="Sun Dec 22 11:38:20 EST 2019" docASTNodeCount="1" docActiveCodeLength="620" docExpressionCount="0" docLength="708" length="1" offset="496" starttimestamp="1576666505112" timestamp="366195674">
    <text><![CDATA[o]]></text>
  </DocumentChange>
  <Command __id="39927" _type="InsertStringCommand" date="Sun Dec 22 11:38:20 EST 2019" starttimestamp="1576666505112" timestamp="366195677" timestamp2="366195677">
    <data><![CDATA[o]]></data>
  </Command>
  <DocumentChange __id="39928" _type="Insert" date="Sun Dec 22 11:38:21 EST 2019" docASTNodeCount="1" docActiveCodeLength="621" docExpressionCount="0" docLength="709" length="1" offset="497" starttimestamp="1576666505112" timestamp="366195943">
    <text><![CDATA[n]]></text>
  </DocumentChange>
  <Command __id="39929" _type="InsertStringCommand" date="Sun Dec 22 11:38:21 EST 2019" starttimestamp="1576666505112" timestamp="366195945" timestamp2="366195945">
    <data><![CDATA[n]]></data>
  </Command>
  <DocumentChange __id="39930" _type="Insert" date="Sun Dec 22 11:38:21 EST 2019" docASTNodeCount="1" docActiveCodeLength="622" docExpressionCount="0" docLength="710" length="1" offset="498" starttimestamp="1576666505112" timestamp="366196524">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <Command __id="39931" _type="InsertStringCommand" date="Sun Dec 22 11:38:21 EST 2019" starttimestamp="1576666505112" timestamp="366196524" timestamp2="366196524">
    <data><![CDATA[ ]]></data>
  </Command>
  <DocumentChange __id="39932" _type="Insert" date="Sun Dec 22 11:38:22 EST 2019" docASTNodeCount="1" docActiveCodeLength="624" docExpressionCount="0" docLength="712" length="2" offset="499" starttimestamp="1576666505112" timestamp="366197699">
    <text><![CDATA[()]]></text>
  </DocumentChange>
  <Command __id="39933" _type="InsertStringCommand" date="Sun Dec 22 11:38:22 EST 2019" starttimestamp="1576666505112" timestamp="366197715" timestamp2="366197715">
    <data><![CDATA[(]]></data>
  </Command>
  <DocumentChange __id="39934" _type="Insert" date="Sun Dec 22 11:38:25 EST 2019" docASTNodeCount="1" docActiveCodeLength="625" docExpressionCount="0" docLength="713" length="1" offset="500" starttimestamp="1576666505112" timestamp="366200814">
    <text><![CDATA[+]]></text>
  </DocumentChange>
  <Command __id="39935" _type="InsertStringCommand" date="Sun Dec 22 11:38:25 EST 2019" starttimestamp="1576666505112" timestamp="366200814" timestamp2="366200814">
    <data><![CDATA[+]]></data>
  </Command>
  <DocumentChange __id="39936" _type="Insert" date="Sun Dec 22 11:38:29 EST 2019" docASTNodeCount="1" docActiveCodeLength="626" docExpressionCount="0" docLength="714" length="1" offset="501" starttimestamp="1576666505112" timestamp="366204038">
    <text><![CDATA[:]]></text>
  </DocumentChange>
  <Command __id="39937" _type="InsertStringCommand" date="Sun Dec 22 11:38:29 EST 2019" starttimestamp="1576666505112" timestamp="366204041" timestamp2="366204041">
    <data><![CDATA[:]]></data>
  </Command>
  <DocumentChange __id="39938" _type="Delete" date="Sun Dec 22 11:38:32 EST 2019" docASTNodeCount="1" docActiveCodeLength="624" docExpressionCount="0" docLength="712" endLine="24" length="2" offset="500" startLine="24" starttimestamp="1576666505112" timestamp="366207298">
    <text><![CDATA[+:]]></text>
  </DocumentChange>
  <Command __id="39939" _type="UndoCommand" date="Sun Dec 22 11:38:32 EST 2019" starttimestamp="1576666505112" timestamp="366207313" />
  <DocumentChange __id="39940" _type="Delete" date="Sun Dec 22 11:38:32 EST 2019" docASTNodeCount="1" docActiveCodeLength="622" docExpressionCount="0" docLength="710" endLine="24" length="2" offset="499" startLine="24" starttimestamp="1576666505112" timestamp="366207751">
    <text><![CDATA[()]]></text>
  </DocumentChange>
  <Command __id="39941" _type="UndoCommand" date="Sun Dec 22 11:38:32 EST 2019" starttimestamp="1576666505112" timestamp="366207847" />
  <Command __id="39943" _type="UndoCommand" date="Sun Dec 22 11:38:33 EST 2019" starttimestamp="1576666505112" timestamp="366208150" />
  <Command __id="39945" _type="RunCommand" date="Sun Dec 22 11:41:41 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="366396829" type="Debug" />
  <Command __id="39946" _type="RunCommand" date="Sun Dec 22 11:41:41 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="366396830" type="Debug" />
  <Command __id="39947" _type="RunCommand" date="Sun Dec 22 11:41:41 EST 2019" kind="HitBreakPoint" projectName="PL_Java" starttimestamp="1576666505112" timestamp="366396830" type="Run" />
  <DocumentChange __id="42550" _type="Insert" date="Sun Dec 22 22:35:54 EST 2019" docASTNodeCount="758" docActiveCodeLength="5250" docExpressionCount="472" docLength="5886" length="18" offset="2722" starttimestamp="1576666505112" timestamp="405649808">
    <text><![CDATA[
							
						}]]></text>
  </DocumentChange>
  <DocumentChange __id="42555" _type="Replace" date="Sun Dec 22 22:36:05 EST 2019" docASTNodeCount="765" docActiveCodeLength="5316" docExpressionCount="478" docLength="5952" endLine="71" insertionLength="73" int_docASTNodeCount="758" int_docActiveCodeLength="5243" int_docExpressionCount="472" int_docLength="5879" length="7" offset="2724" startLine="71" starttimestamp="1576666505112" timestamp="405660469">
    <deletedText><![CDATA[							]]></deletedText>
    <insertedText><![CDATA[							lastOpenMPPragma.getReductionVariableAssignments().add(aFileLine);]]></insertedText>
  </DocumentChange>
  <DocumentChange __id="42558" _type="Replace" date="Sun Dec 22 22:36:12 EST 2019" docASTNodeCount="765" docActiveCodeLength="5298" docExpressionCount="478" docLength="5934" endLine="71" insertionLength="1" int_docASTNodeCount="765" int_docActiveCodeLength="5297" int_docExpressionCount="478" int_docLength="5933" length="19" offset="2760" startLine="71" starttimestamp="1576666505112" timestamp="405667503">
    <deletedText><![CDATA[VariableAssignments]]></deletedText>
    <insertedText><![CDATA[O]]></insertedText>
  </DocumentChange>
  <DocumentChange __id="42560" _type="Insert" date="Sun Dec 22 22:36:12 EST 2019" docASTNodeCount="765" docActiveCodeLength="5299" docExpressionCount="478" docLength="5935" length="1" offset="2761" starttimestamp="1576666505112" timestamp="405667693">
    <text><![CDATA[p]]></text>
  </DocumentChange>
  <DocumentChange __id="42562" _type="Insert" date="Sun Dec 22 22:36:12 EST 2019" docASTNodeCount="765" docActiveCodeLength="5300" docExpressionCount="478" docLength="5936" length="1" offset="2762" starttimestamp="1576666505112" timestamp="405667812">
    <text><![CDATA[e]]></text>
  </DocumentChange>
  <DocumentChange __id="42564" _type="Insert" date="Sun Dec 22 22:36:13 EST 2019" docASTNodeCount="765" docActiveCodeLength="5301" docExpressionCount="478" docLength="5937" length="1" offset="2763" starttimestamp="1576666505112" timestamp="405668076">
    <text><![CDATA[r]]></text>
  </DocumentChange>
  <DocumentChange __id="42566" _type="Insert" date="Sun Dec 22 22:36:13 EST 2019" docASTNodeCount="765" docActiveCodeLength="5302" docExpressionCount="478" docLength="5938" length="1" offset="2764" starttimestamp="1576666505112" timestamp="405668193">
    <text><![CDATA[a]]></text>
  </DocumentChange>
  <DocumentChange __id="42568" _type="Insert" date="Sun Dec 22 22:36:13 EST 2019" docASTNodeCount="765" docActiveCodeLength="5303" docExpressionCount="478" docLength="5939" length="1" offset="2765" starttimestamp="1576666505112" timestamp="405668484">
    <text><![CDATA[t]]></text>
  </DocumentChange>
  <DocumentChange __id="42570" _type="Insert" date="Sun Dec 22 22:36:13 EST 2019" docASTNodeCount="765" docActiveCodeLength="5304" docExpressionCount="478" docLength="5940" length="1" offset="2766" starttimestamp="1576666505112" timestamp="405668673">
    <text><![CDATA[i]]></text>
  </DocumentChange>
  <DocumentChange __id="42572" _type="Insert" date="Sun Dec 22 22:36:14 EST 2019" docASTNodeCount="765" docActiveCodeLength="5305" docExpressionCount="478" docLength="5941" length="1" offset="2767" starttimestamp="1576666505112" timestamp="405669305">
    <text><![CDATA[o]]></text>
  </DocumentChange>
  <DocumentChange __id="42574" _type="Insert" date="Sun Dec 22 22:36:14 EST 2019" docASTNodeCount="765" docActiveCodeLength="5306" docExpressionCount="478" docLength="5942" length="1" offset="2768" starttimestamp="1576666505112" timestamp="405669606">
    <text><![CDATA[n]]></text>
  </DocumentChange>
  <DocumentChange __id="42581" _type="Replace" date="Sun Dec 22 22:36:18 EST 2019" docASTNodeCount="767" docActiveCodeLength="5312" docExpressionCount="480" docLength="5948" endLine="71" insertionLength="27" int_docASTNodeCount="765" int_docActiveCodeLength="5285" int_docExpressionCount="478" int_docLength="5921" length="21" offset="2748" startLine="71" starttimestamp="1576666505112" timestamp="405673874">
    <deletedText><![CDATA[getReductionOperation]]></deletedText>
    <insertedText><![CDATA[getReductionOperationUses()]]></insertedText>
  </DocumentChange>
  <DocumentChange __id="42584" _type="Delete" date="Sun Dec 22 22:36:21 EST 2019" docASTNodeCount="765" docActiveCodeLength="5311" docExpressionCount="478" docLength="5947" endLine="71" length="1" offset="2776" startLine="71" starttimestamp="1576666505112" timestamp="405676488">
    <text><![CDATA[)]]></text>
  </DocumentChange>
  <DocumentChange __id="42586" _type="Delete" date="Sun Dec 22 22:36:21 EST 2019" docASTNodeCount="765" docActiveCodeLength="5310" docExpressionCount="478" docLength="5946" endLine="71" length="1" offset="2775" startLine="71" starttimestamp="1576666505112" timestamp="405676658">
    <text><![CDATA[(]]></text>
  </DocumentChange>
  <DocumentChange __id="42588" _type="Delete" date="Sun Dec 22 22:36:21 EST 2019" docASTNodeCount="765" docActiveCodeLength="5309" docExpressionCount="478" docLength="5945" endLine="71" length="1" offset="2774" startLine="71" starttimestamp="1576666505112" timestamp="405676865">
    <text><![CDATA[)]]></text>
  </DocumentChange>
  <DocumentChange __id="42590" _type="Insert" date="Sun Dec 22 22:36:22 EST 2019" docASTNodeCount="765" docActiveCodeLength="5310" docExpressionCount="478" docLength="5946" length="1" offset="2774" starttimestamp="1576666505112" timestamp="405677839">
    <text><![CDATA[)]]></text>
  </DocumentChange>
  <DocumentChange __id="42628" _type="Delete" date="Sun Dec 22 22:36:28 EST 2019" docASTNodeCount="765" docActiveCodeLength="5308" docExpressionCount="478" docLength="5944" endLine="75" length="2" offset="2815" startLine="74" starttimestamp="1576666505112" timestamp="405683290">
    <text><![CDATA[
]]></text>
  </DocumentChange>
  <DocumentChange __id="42747" _type="Insert" date="Sun Dec 22 22:57:16 EST 2019" docASTNodeCount="765" docActiveCodeLength="5311" docExpressionCount="478" docLength="5947" length="3" offset="207" starttimestamp="1576666505112" timestamp="406931156">
    <text><![CDATA[
	]]></text>
  </DocumentChange>
  <Command __id="42750" _type="ShellCommand" date="Sun Dec 22 22:57:23 EST 2019" starttimestamp="1576666505112" timestamp="406938434" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="42751" _type="MoveCaretCommand" caretOffset="255" date="Sun Dec 22 22:57:23 EST 2019" docOffset="255" starttimestamp="1576666505112" timestamp="406938534" />
  <Command __id="42752" _type="DiffBasedFileOpenCommand" date="Sun Dec 22 22:57:38 EST 2019" docASTNodeCount="1" docActiveCodeLength="749" docExpressionCount="0" docLength="825" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="406953475">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\sum_parallel.cpp]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"#include <iostream>¶#include <omp.h>¶¶using namespace std;¶¶void printSumWithTimes(int sum, int start, int end);¶void printNumThreads();¶void recordThreadIndex(int index);¶void sum_parallel(double* array, int size) {¶	cout << "sum_parallel\n";¶¶	double start = omp_get_wtime();¶¶	double sum = 0;¶¶//	#pragma omp parallel¶//	for (int i = 0; i < size; i++)¶//		sum += array[i];¶    #pragma omp parallel¶	{¶		double local_sum = 0;¶¶		int rank = omp_get_thread_num();¶		int threads = omp_get_num_threads();¶¶		int start_index = (size/threads)*rank;¶		int end_index = (size/threads)*(rank+1);¶¶		if(rank==threads-1)¶			end_index=size;¶¶		for(int i = start_index; i < end_index; i++)¶			local_sum += array[i];¶¶		#pragma omp critical¶		sum += local_sum;¶	}¶¶	double end = omp_get_wtime();¶¶	printSumWithTimes(sum, start, end);¶¶¶}¶")]]]></diff>
  </Command>
  <Command __id="42753" _type="MoveCaretCommand" caretOffset="0" date="Sun Dec 22 22:57:38 EST 2019" docOffset="0" starttimestamp="1576666505112" timestamp="406953675" />
  <DocumentChange __id="43223" _type="Insert" date="Sun Dec 22 23:10:15 EST 2019" docASTNodeCount="349" docActiveCodeLength="2568" docExpressionCount="171" docLength="2850" length="1" offset="389" starttimestamp="1576666505112" timestamp="407710794">
    <text><![CDATA[c]]></text>
  </DocumentChange>
  <Command __id="55575" _type="DiffBasedFileOpenCommand" date="Mon Dec 23 06:31:07 EST 2019" docASTNodeCount="89" docActiveCodeLength="709" docExpressionCount="51" docLength="786" projectName="GraderBasics" starttimestamp="1576666505112" timestamp="434161994">
    <filePath><![CDATA[D:\dewan_backup\Java\GraderBasics\src\gradingTools\shared\testcases\openmp\AnOpenMPParallelPragma.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package gradingTools.shared.testcases.openmp;¶¶import java.util.ArrayList;¶import java.util.List;¶¶public class AnOpenMPParallelPragma extends AnOpenMPPragma implements OpenMPParallelPragma{¶	protected List<String> variableDeclarationsInParallel = new ArrayList();//separate subclass for this variable?¶¶	public AnOpenMPParallelPragma(int lineNumber) {¶		super(lineNumber);¶		// TODO Auto-generated constructor stub¶	}¶	@Override¶	public void addToAnnotatedText(String aFileLine) {¶		super.addToAnnotatedText(aFileLine);¶		¶		if (OpenMPUtils.startsWithTypeName(aFileLine)) {¶				getVariableDeclarationsInParallel().add(aFileLine);¶		}¶		 ¶	}¶	@Override¶	public List<String> getVariableDeclarationsInParallel() {¶		return variableDeclarationsInParallel;¶	}¶¶}¶")]]]></diff>
  </Command>
  <Command __id="55576" _type="MoveCaretCommand" caretOffset="592" date="Mon Dec 23 06:31:07 EST 2019" docOffset="592" starttimestamp="1576666505112" timestamp="434162169" />
  <Command __id="55578" _type="MoveCaretCommand" caretOffset="488" date="Mon Dec 23 06:32:28 EST 2019" docOffset="488" starttimestamp="1576666505112" timestamp="434243213" />
  <Command __id="55579" _type="ShellCommand" date="Mon Dec 23 06:32:50 EST 2019" starttimestamp="1576666505112" timestamp="434264942" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="55577" _type="DiffBasedFileOpenCommand" date="Mon Dec 23 06:32:28 EST 2019" docASTNodeCount="1" docActiveCodeLength="611" docExpressionCount="0" docLength="699" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="434243048">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\sum_parallel_for_local_var.cpp]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"#include <iostream>¶#include <omp.h>¶¶using namespace std;¶¶void printSumWithTimes (int sum, int start, int end);¶void printNumThreads();¶void recordThreadIndex(int index);¶void sum_parallel_for_local_var(double* array, int size)¶{¶	cout << "sum_parallel_for_local_var\n";¶¶	double start = omp_get_wtime();¶¶	double sum = 0;¶//¶//	for (int i = 0; i < size; i++) {¶//			sum += array[i];¶//			recordThreadIndex(i);¶//	}¶    #pragma omp parallel¶	{¶		double local_sum = 0;¶¶		#pragma omp for¶		for(int i = 0; i < size; i++) {¶			local_sum += array[i];¶			recordThreadIndex(i);¶		}¶¶		#pragma omp critical¶		sum += local_sum;¶	}¶¶	double end = omp_get_wtime();¶¶	printSumWithTimes(sum, start, end);¶	¶}¶")]]]></diff>
  </Command>
  <Command __id="55580" _type="ShellCommand" date="Mon Dec 23 06:45:42 EST 2019" starttimestamp="1576666505112" timestamp="435037280" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="55581" _type="DiffBasedFileOpenCommand" date="Mon Dec 23 06:46:51 EST 2019" docASTNodeCount="1" docActiveCodeLength="749" docExpressionCount="0" docLength="825" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="435106649">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\sum_parallel.cpp]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"#include <iostream>¶#include <omp.h>¶¶using namespace std;¶¶void printSumWithTimes(int sum, int start, int end);¶void printNumThreads();¶void recordThreadIndex(int index);¶void sum_parallel(double* array, int size) {¶	cout << "sum_parallel\n";¶¶	double start = omp_get_wtime();¶¶	double sum = 0;¶¶//	#pragma omp parallel¶//	for (int i = 0; i < size; i++)¶//		sum += array[i];¶    #pragma omp parallel¶	{¶		double local_sum = 0;¶¶		int rank = omp_get_thread_num();¶		int threads = omp_get_num_threads();¶¶		int start_index = (size/threads)*rank;¶		int end_index = (size/threads)*(rank+1);¶¶		if(rank==threads-1)¶			end_index=size;¶¶		for(int i = start_index; i < end_index; i++)¶			local_sum += array[i];¶¶		#pragma omp critical¶		sum += local_sum;¶	}¶¶	double end = omp_get_wtime();¶¶	printSumWithTimes(sum, start, end);¶¶¶}¶")]]]></diff>
  </Command>
  <Command __id="55582" _type="MoveCaretCommand" caretOffset="0" date="Mon Dec 23 06:46:51 EST 2019" docOffset="0" starttimestamp="1576666505112" timestamp="435106801" />
  <Command __id="55583" _type="DiffBasedFileOpenCommand" date="Mon Dec 23 06:48:48 EST 2019" docASTNodeCount="1" docActiveCodeLength="611" docExpressionCount="0" docLength="699" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="435223184">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\sum_parallel_for_local_var.cpp]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"#include <iostream>¶#include <omp.h>¶¶using namespace std;¶¶void printSumWithTimes (int sum, int start, int end);¶void printNumThreads();¶void recordThreadIndex(int index);¶void sum_parallel_for_local_var(double* array, int size)¶{¶	cout << "sum_parallel_for_local_var\n";¶¶	double start = omp_get_wtime();¶¶	double sum = 0;¶//¶//	for (int i = 0; i < size; i++) {¶//			sum += array[i];¶//			recordThreadIndex(i);¶//	}¶    #pragma omp parallel¶	{¶		double local_sum = 0;¶¶		#pragma omp for¶		for(int i = 0; i < size; i++) {¶			local_sum += array[i];¶			recordThreadIndex(i);¶		}¶¶		#pragma omp critical¶		sum += local_sum;¶	}¶¶	double end = omp_get_wtime();¶¶	printSumWithTimes(sum, start, end);¶	¶}¶")]]]></diff>
  </Command>
  <Command __id="55584" _type="MoveCaretCommand" caretOffset="488" date="Mon Dec 23 06:48:48 EST 2019" docOffset="488" starttimestamp="1576666505112" timestamp="435223309" />
  <DocumentChange __id="56403" _type="Insert" date="Mon Dec 23 07:15:49 EST 2019" docASTNodeCount="992" docActiveCodeLength="6711" docExpressionCount="620" docLength="8593" length="2" offset="428" starttimestamp="1576666505112" timestamp="436844803">
    <text><![CDATA[""]]></text>
  </DocumentChange>
  <Command __id="56404" _type="InsertStringCommand" date="Mon Dec 23 07:15:49 EST 2019" starttimestamp="1576666505112" timestamp="436844807" timestamp2="436844807">
    <data><![CDATA["]]></data>
  </Command>
  <Command __id="56405" _type="InsertStringCommand" date="Mon Dec 23 07:15:49 EST 2019" starttimestamp="1576666505112" timestamp="436844808" timestamp2="436844808">
    <data><![CDATA["]]></data>
  </Command>
  <Command __id="56407" _type="MoveCaretCommand" caretOffset="0" date="Mon Dec 23 07:15:53 EST 2019" docOffset="0" starttimestamp="1576666505112" timestamp="436847910" />
  <Command __id="56408" _type="EclipseCommand" commandID="" date="Mon Dec 23 07:15:53 EST 2019" starttimestamp="1576666505112" timestamp="436848680" />
  <Command __id="56409" _type="EclipseCommand" commandID="" date="Mon Dec 23 07:15:54 EST 2019" starttimestamp="1576666505112" timestamp="436849222" />
  <DocumentChange __id="56443" _type="Insert" date="Mon Dec 23 07:16:48 EST 2019" docASTNodeCount="992" docActiveCodeLength="6738" docExpressionCount="620" docLength="8620" length="1" offset="455" starttimestamp="1576666505112" timestamp="436903160">
    <text><![CDATA[p]]></text>
  </DocumentChange>
  <Command __id="56444" _type="InsertStringCommand" date="Mon Dec 23 07:16:48 EST 2019" starttimestamp="1576666505112" timestamp="436903160" timestamp2="436903160">
    <data><![CDATA[p]]></data>
  </Command>
  <Command __id="56445" _type="InsertStringCommand" date="Mon Dec 23 07:16:48 EST 2019" starttimestamp="1576666505112" timestamp="436903160" timestamp2="436903160">
    <data><![CDATA[p]]></data>
  </Command>
  <Command __id="56447" _type="SelectTextCommand" caretOffset="460" date="Mon Dec 23 07:18:03 EST 2019" end="460" start="442" starttimestamp="1576666505112" timestamp="436978179" />
  <DocumentChange __id="58635" _type="Insert" date="Mon Dec 23 07:39:55 EST 2019" docASTNodeCount="1070" docActiveCodeLength="7213" docExpressionCount="660" docLength="9095" length="1" offset="1633" starttimestamp="1576666505112" timestamp="438290086">
    <text><![CDATA[S]]></text>
  </DocumentChange>
  <DocumentChange __id="58638" _type="Insert" date="Mon Dec 23 07:39:55 EST 2019" docASTNodeCount="1070" docActiveCodeLength="7214" docExpressionCount="660" docLength="9096" length="1" offset="1634" starttimestamp="1576666505112" timestamp="438290551">
    <text><![CDATA[t]]></text>
  </DocumentChange>
  <DocumentChange __id="58641" _type="Insert" date="Mon Dec 23 07:39:55 EST 2019" docASTNodeCount="1070" docActiveCodeLength="7215" docExpressionCount="660" docLength="9097" length="1" offset="1635" starttimestamp="1576666505112" timestamp="438290674">
    <text><![CDATA[r]]></text>
  </DocumentChange>
  <DocumentChange __id="58644" _type="Insert" date="Mon Dec 23 07:39:55 EST 2019" docASTNodeCount="1070" docActiveCodeLength="7216" docExpressionCount="660" docLength="9098" length="1" offset="1636" starttimestamp="1576666505112" timestamp="438290862">
    <text><![CDATA[i]]></text>
  </DocumentChange>
  <DocumentChange __id="58647" _type="Insert" date="Mon Dec 23 07:39:56 EST 2019" docASTNodeCount="1070" docActiveCodeLength="7217" docExpressionCount="660" docLength="9099" length="1" offset="1637" starttimestamp="1576666505112" timestamp="438291058">
    <text><![CDATA[n]]></text>
  </DocumentChange>
  <DocumentChange __id="58650" _type="Insert" date="Mon Dec 23 07:39:56 EST 2019" docASTNodeCount="1070" docActiveCodeLength="7218" docExpressionCount="660" docLength="9100" length="1" offset="1638" starttimestamp="1576666505112" timestamp="438291512">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="58653" _type="Insert" date="Mon Dec 23 07:39:56 EST 2019" docASTNodeCount="1074" docActiveCodeLength="7219" docExpressionCount="662" docLength="9101" length="1" offset="1639" starttimestamp="1576666505112" timestamp="438291669">
    <text><![CDATA[a]]></text>
  </DocumentChange>
  <DocumentChange __id="58656" _type="Insert" date="Mon Dec 23 07:39:57 EST 2019" docASTNodeCount="1074" docActiveCodeLength="7220" docExpressionCount="662" docLength="9102" length="1" offset="1640" starttimestamp="1576666505112" timestamp="438292386">
    <text><![CDATA[F]]></text>
  </DocumentChange>
  <DocumentChange __id="58659" _type="Insert" date="Mon Dec 23 07:39:57 EST 2019" docASTNodeCount="1074" docActiveCodeLength="7221" docExpressionCount="662" docLength="9103" length="1" offset="1641" starttimestamp="1576666505112" timestamp="438292765">
    <text><![CDATA[i]]></text>
  </DocumentChange>
  <DocumentChange __id="58662" _type="Insert" date="Mon Dec 23 07:39:58 EST 2019" docASTNodeCount="1074" docActiveCodeLength="7222" docExpressionCount="662" docLength="9104" length="1" offset="1642" starttimestamp="1576666505112" timestamp="438293002">
    <text><![CDATA[l]]></text>
  </DocumentChange>
  <DocumentChange __id="58665" _type="Insert" date="Mon Dec 23 07:39:58 EST 2019" docASTNodeCount="1074" docActiveCodeLength="7223" docExpressionCount="662" docLength="9105" length="1" offset="1643" starttimestamp="1576666505112" timestamp="438293081">
    <text><![CDATA[e]]></text>
  </DocumentChange>
  <DocumentChange __id="58668" _type="Insert" date="Mon Dec 23 07:39:58 EST 2019" docASTNodeCount="1074" docActiveCodeLength="7224" docExpressionCount="662" docLength="9106" length="1" offset="1644" starttimestamp="1576666505112" timestamp="438293568">
    <text><![CDATA[L]]></text>
  </DocumentChange>
  <DocumentChange __id="58671" _type="Insert" date="Mon Dec 23 07:39:58 EST 2019" docASTNodeCount="1074" docActiveCodeLength="7225" docExpressionCount="662" docLength="9107" length="1" offset="1645" starttimestamp="1576666505112" timestamp="438293814">
    <text><![CDATA[i]]></text>
  </DocumentChange>
  <DocumentChange __id="58674" _type="Insert" date="Mon Dec 23 07:39:59 EST 2019" docASTNodeCount="1074" docActiveCodeLength="7226" docExpressionCount="662" docLength="9108" length="1" offset="1646" starttimestamp="1576666505112" timestamp="438294113">
    <text><![CDATA[n]]></text>
  </DocumentChange>
  <DocumentChange __id="58677" _type="Insert" date="Mon Dec 23 07:39:59 EST 2019" docASTNodeCount="1074" docActiveCodeLength="7227" docExpressionCount="662" docLength="9109" length="1" offset="1647" starttimestamp="1576666505112" timestamp="438294221">
    <text><![CDATA[e]]></text>
  </DocumentChange>
  <DocumentChange __id="58682" _type="Insert" date="Mon Dec 23 07:40:01 EST 2019" docASTNodeCount="1074" docActiveCodeLength="7228" docExpressionCount="662" docLength="9110" length="1" offset="1638" starttimestamp="1576666505112" timestamp="438296632">
    <text><![CDATA[g]]></text>
  </DocumentChange>
  <DocumentChange __id="58687" _type="Insert" date="Mon Dec 23 07:40:03 EST 2019" docASTNodeCount="1074" docActiveCodeLength="7229" docExpressionCount="662" docLength="9111" length="1" offset="1650" starttimestamp="1576666505112" timestamp="438298106">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="58690" _type="Insert" date="Mon Dec 23 07:40:03 EST 2019" docASTNodeCount="1074" docActiveCodeLength="7230" docExpressionCount="662" docLength="9112" length="1" offset="1651" starttimestamp="1576666505112" timestamp="438298808">
    <text><![CDATA[{]]></text>
  </DocumentChange>
  <DocumentChange __id="58693" _type="Insert" date="Mon Dec 23 07:40:04 EST 2019" docASTNodeCount="1074" docActiveCodeLength="7238" docExpressionCount="662" docLength="9120" length="8" offset="1652" starttimestamp="1576666505112" timestamp="438299088">
    <text><![CDATA[
		
	}]]></text>
  </DocumentChange>
  <Command __id="58720" _type="EclipseCommand" commandID="" date="Mon Dec 23 07:40:05 EST 2019" starttimestamp="1576666505112" timestamp="438300672" />
  <Command __id="58721" _type="EclipseCommand" commandID="" date="Mon Dec 23 07:40:05 EST 2019" starttimestamp="1576666505112" timestamp="438300673" />
  <Command __id="58722" _type="EclipseCommand" commandID="" date="Mon Dec 23 07:40:05 EST 2019" starttimestamp="1576666505112" timestamp="438300682" />
  <Command __id="58723" _type="EclipseCommand" commandID="" date="Mon Dec 23 07:40:05 EST 2019" starttimestamp="1576666505112" timestamp="438300682" />
  <Command __id="58724" _type="EclipseCommand" commandID="" date="Mon Dec 23 07:40:05 EST 2019" starttimestamp="1576666505112" timestamp="438300684" />
  <Command __id="58725" _type="EclipseCommand" commandID="" date="Mon Dec 23 07:40:05 EST 2019" starttimestamp="1576666505112" timestamp="438300684" />
  <Command __id="58726" _type="EclipseCommand" commandID="" date="Mon Dec 23 07:40:05 EST 2019" starttimestamp="1576666505112" timestamp="438300698" />
  <Command __id="58727" _type="EclipseCommand" commandID="" date="Mon Dec 23 07:40:05 EST 2019" starttimestamp="1576666505112" timestamp="438300699" />
  <Command __id="58728" _type="EclipseCommand" commandID="" date="Mon Dec 23 07:40:05 EST 2019" starttimestamp="1576666505112" timestamp="438300704" />
  <Command __id="58729" _type="EclipseCommand" commandID="" date="Mon Dec 23 07:40:05 EST 2019" starttimestamp="1576666505112" timestamp="438300704" />
  <Command __id="58730" _type="EclipseCommand" commandID="" date="Mon Dec 23 07:40:05 EST 2019" starttimestamp="1576666505112" timestamp="438300710" />
  <Command __id="60355" _type="DiffBasedFileOpenCommand" date="Mon Dec 23 07:47:38 EST 2019" docASTNodeCount="1140" docActiveCodeLength="7664" docExpressionCount="708" docLength="9546" projectName="GraderBasics" starttimestamp="1576666505112" timestamp="438753416">
    <filePath><![CDATA[D:\dewan_backup\Java\GraderBasics\src\gradingTools\shared\testcases\openmp\OpenMPUtils.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package gradingTools.shared.testcases.openmp;¶¶import java.util.ArrayList;¶import java.util.HashMap;¶import java.util.List;¶import java.util.Map;¶import java.util.Stack;¶¶¶public class OpenMPUtils {¶	¶	protected static Map<String, OpenMPKeywordEnum> stringToOpenMPKeyword = new HashMap();¶	protected static String[] typeNames = {"double", "float", "int", "short", "long"};¶	protected static String[] openMPCalls = {"omp_get_thread_num()", "omp_get_num_threads()"};¶	public static List<OpenMPPragma> getOpemMPPragmas(StringBuffer aFileBuffer) {¶		String[] aFileLines = aFileBuffer.toString().split("\n");¶		return getOpenMPPragmas(aFileLines);¶	}¶	¶	public static boolean isCodeLine(String aLine) {¶		return !aLine.isEmpty() && !aLine.startsWith("//");¶	}¶	public static boolean isBlockStart(String aLine) {¶		return aLine.contains("{");¶	}¶	public static boolean isBlockEnd(String aLine) {¶		return aLine.contains("}");¶	}¶	public static boolean isLoopStart(String aLine) {¶		return aLine.startsWith("for");¶	}¶	public static boolean endsWithLoopHeader(String aLine) {¶		return aLine.endsWith(")");¶	}¶	public static boolean isPragmaStart(String aLine) {¶		return aLine.startsWith("#pragma");¶	}¶	public static void addToStack(Stack<OpenMPPragma> anOpenMPPragmas, String aFileLine) {¶		List<String> anOpenMPCalls = getOMPCalls(aFileLine);¶		for (OpenMPPragma anOpenMPPragma:anOpenMPPragmas) {¶			anOpenMPPragma.addToAnnotatedText(aFileLine);¶			for (String anOpenMPCall:anOpenMPCalls) {¶				anOpenMPPragma.addOpenMPCall(anOpenMPCall);¶			}		¶		}¶	}¶	public static "), Diff(INSERT,"A"), Diff(EQUAL,"ForHeader getForHeader(String aFileLine, int aLineNumber) {¶		int aLeftParenIndex = aFileLine.indexOf("(");¶		int aRightParenIndex = aFileLine.indexOf(")");¶		if (aLeftParenIndex < 0 || aRightParenIndex < 0) {¶			return null;¶		}¶		String aHeaderString = aFileLine.substring(aLeftParenIndex + 1, aRightParenIndex);¶		String[] aForComponents = aHeaderString.split(";");¶		return "), Diff(INSERT,"new A"), Diff(EQUAL,"ForHeader(aForComponents[0], aForComponents[1], aForComponents[2], aLineNumber);¶	}¶	public static List<String> getOMPCalls(String aFileLine) {¶		List<String> retVal = new ArrayList();¶		for (String anOpenMPCall:openMPCalls) {¶			if (aFileLine.contains(anOpenMPCall)) {¶				retVal.add(anOpenMPCall);¶			}¶		}¶		return retVal;¶	}¶	¶	public static void incrementStackTop (Stack<Integer> aNumOpenBracesStack) {¶		int aTopIndex = aNumOpenBracesStack.size() - 1;¶		Integer aCurrentValue = aNumOpenBracesStack.get(aTopIndex);¶		aNumOpenBracesStack.set(aTopIndex, aCurrentValue + 1);¶	}¶	public static void decrementStackTop (Stack<Integer> aNumOpenBracesStack) {¶		int aTopIndex = aNumOpenBracesStack.size() - 1;¶		Integer aCurrentValue = aNumOpenBracesStack.get(aTopIndex);¶		aNumOpenBracesStack.set(aTopIndex, aCurrentValue - 1);¶	}¶	¶	public static boolean startsWithTypeName(String aLine) {¶		for (String aTypeName:typeNames) {¶			if (aLine.startsWith(aTypeName)) {¶				return true;¶			}¶		}¶		return false;¶	}¶¶	public static List<OpenMPPragma> getOpenMPPragmas(String[] aFileLines) {¶		List<OpenMPPragma> retVal = new ArrayList();¶		Stack<OpenMPPragma> anOpenMPPragmas = new Stack();¶		Stack<Integer> aNumOpenBracesStack = new Stack();¶//		OpenMPPragma lastOpenMPPragma = null;¶//		String lastReductionVariable = null;¶//		String lastReductionOperation = null;¶//		int aNumOpenBraces = 0;¶		boolean aNextCodeLineIsAPragmaBlock = false;¶		List<OpenMPPragma> newOpenMPPragmas = null;¶		for (int i = 0; i < aFileLines.length; i++) {¶			String aFileLine = aFileLines[i].trim();¶			if (!isCodeLine(aFileLine)) {¶				continue;¶			}¶			addToStack(anOpenMPPragmas, aFileLine); // if it is empty add to none¶//			if (lastReductionVariable != null) {¶//				if (aFileLine.startsWith(lastReductionVariable)) {¶//					lastOpenMPPragma.getReductionVariableAssignments().add(aFileLine);¶//					if (lastReductionOperation != null) { // can it ever be not null¶//						if (aFileLine.contains(lastReductionOperation)) {¶//							lastOpenMPPragma.getReductionOperationUses().add(aFileLine);¶//						}¶//					}¶//				}			¶//			}¶//			if (lastOpenMPPragma != null && lastOpenMPPragma.getFirstOpenMPKeyword() == OpenMPKeywordEnum.PARALLEL) {¶//				if (startsWithTypeName(aFileLine)) {¶//					lastOpenMPPragma.getVariableDeclarationsInParallel().add(aFileLine);¶//				}¶//			} ¶//			else if (lastOpenMPPragma != null && lastOpenMPPragma.getFirstOpenMPKeyword() == OpenMPKeywordEnum.CRITICAL) {¶//				String[] aTokens = aFileLine.split("\\s+");¶//				lastOpenMPPragma.setAssignedVariableInCritical(aTokens[0]);				¶//			}¶			if (isPragmaStart(aFileLine)) {¶				¶				newOpenMPPragmas = getOpenMPPragmas(aFileLine, i);¶				if (newOpenMPPragmas.size() != 0) {¶					for (OpenMPPragma anOpenMPPragma:newOpenMPPragmas) {¶						if (anOpenMPPragmas.size() > 0) {¶						    anOpenMPPragma.setParent(anOpenMPPragmas.peek());¶						}¶						anOpenMPPragmas.push(anOpenMPPragma);¶						aNumOpenBracesStack.push(0);¶						retVal.add(anOpenMPPragma);¶¶					}¶//					anOpenMPPragmas.addAll(newOpenMPPragmas);¶					aNumOpenBracesStack.add(0);¶//					retVal.add(lastOpenMPPragma);					¶					aNextCodeLineIsAPragmaBlock = true;¶//					String lastReductionOperation = lastOpenMPPragma.getReductionOperation();¶//					String lastReductionVariable = lastOpenMPPragma.getReductionVariable();¶					continue;¶				} ¶			}¶			if (anOpenMPPragmas.isEmpty()) {¶				continue;¶			}	¶			if (aNextCodeLineIsAPragmaBlock) {				¶				anOpenMPPragmas.peek().setAnnotatedTextStartLineNumber(i);				¶				aNextCodeLineIsAPragmaBlock = false;¶			}¶//			anOpenMPPragmas.peek().getAnnotatedText().add(aFileLine);¶			if (isBlockStart(aFileLine)) {¶				incrementStackTop(aNumOpenBracesStack);¶			}¶//			} else ¶			if (isBlockEnd(aFileLine)) {¶				decrementStackTop(aNumOpenBracesStack);¶¶			}¶			if (isLoopStart(aFileLine) && endsWithLoopHeader(aFileLine)) {¶				continue; // gather following block also¶			}¶			if (aNumOpenBracesStack.peek() == 0) {¶				¶				anOpenMPPragmas.peek().setAnnotatedTextEndLineNumber(i);¶				for (int j = 0; j < newOpenMPPragmas.size(); j++) {¶					anOpenMPPragmas.pop();¶					aNumOpenBracesStack.pop();¶				}¶//				lastOpenMPPragma = null;¶//				lastReductionVariable = null;¶//				lastReductionOperation = null;¶				continue;¶			}					¶		}¶		return retVal;¶	}¶	public static List<OpenMPPragma> getOpenMPPragmas(String aFileLine, int aLineIndex) {¶		String[] aTokens = aFileLine.split("\\s+");¶		if (aTokens.length <= 2) {¶			return null;¶		}¶		if (!aTokens[1].equals("omp")) {¶			return null;¶		}¶		if (aTokens.length < 3) {¶			return null;¶		}¶		String aFirstToken = aTokens[2];¶		OpenMPKeywordEnum anOpenMPKeyword = stringToOpenMPKeyword.get(aFirstToken);¶		List<OpenMPPragma> retVal = new ArrayList();¶		OpenMPPragma lastChild;¶		int aStartIndex = 2;¶		switch (anOpenMPKeyword) {¶		case PARALLEL:¶			lastChild = new AnOpenMPParallelPragma(aLineIndex);¶			¶//			lastChild.setFirstOpenMPKeyword(stringToOpenMPKeyword.get(aFirstToken));	¶¶			retVal.add(lastChild);¶			if (aTokens.length > 3 && aTokens[3].equals("for")) {¶				OpenMPPragma aForChild = new AnOpenMPForPragma(aLineIndex);¶				retVal.add(aForChild);¶				lastChild = aForChild;¶				aStartIndex++;¶			}¶			break;¶		case FOR:¶			lastChild = new AnOpenMPForPragma(aLineIndex);¶			retVal.add (lastChild);¶			break;¶		case CRITICAL:¶			lastChild = new AnOpenMPCriticalPragma(aLineIndex);¶			retVal.add (lastChild);¶			break;¶			default: ¶				lastChild = new AnOpenMPPragma(aLineIndex);¶				retVal.add(lastChild);¶			¶		}¶//		retVal.setFirstOpenMPKeyword(stringToOpenMPKeyword.get(aFirstToken));	¶//		OpenMPPragma retVal = new AnOpenMPPragma(aLineIndex);¶¶¶		for (int i = aStartIndex; i < aTokens.length; i ++) {¶			String aStoredToken = aTokens[i].trim();¶			if (aStoredToken.isEmpty()) {¶				continue;¶			}¶			if (aStoredToken.startsWith("reduction")) {¶				while (!aStoredToken.endsWith(")")) {¶					i++;¶					if (i >= aTokens.length) {¶						break;¶					}¶					String aNewToken = aTokens[i].trim();¶					aStoredToken += aNewToken; 					¶				}¶				int aLeftParenIndex = aStoredToken.indexOf("(");¶				int aRightParenIndex = aStoredToken.indexOf(")");¶				int aColonIndex = aStoredToken.indexOf(":");¶				if (aLeftParenIndex != -1 && aRightParenIndex != -1 && aColonIndex != -1) {¶					String anOperationString = aStoredToken.substring(aLeftParenIndex + 1, aColonIndex).trim();¶					String aVariableString = aStoredToken.substring(aColonIndex + 1, aRightParenIndex).trim();¶					((OpenMPForPragma) lastChild).setReductionVariable(aVariableString);¶					((OpenMPForPragma) lastChild).setReductionOperation(anOperationString);¶				}¶				¶			}¶//			aTokens[i] = aStoredToken;¶			lastChild.getOpenMPTokens().add(aStoredToken);¶		}¶//		String aFirstToken = retVal.getOpenMPTokens().get(0);¶//		retVal.setFirstOpenMPKeyword(stringToOpenMPKeyword.get(aFirstToken));		¶		return retVal;¶		¶		¶	}¶	static {¶		stringToOpenMPKeyword.put("for", OpenMPKeywordEnum.FOR);¶		stringToOpenMPKeyword.put("parallel", OpenMPKeywordEnum.PARALLEL);¶		stringToOpenMPKeyword.put("reduce", OpenMPKeywordEnum.REDUCE);¶		stringToOpenMPKeyword.put("shared", OpenMPKeywordEnum.SHARED);¶		stringToOpenMPKeyword.put("private", OpenMPKeywordEnum.PRIVATE);¶		stringToOpenMPKeyword.put("critical", OpenMPKeywordEnum.CRITICAL);¶¶¶¶¶¶	}¶	¶¶}¶")]]]></diff>
    <snapshot><![CDATA[package gradingTools.shared.testcases.openmp;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Stack;


public class OpenMPUtils {
	
	protected static Map<String, OpenMPKeywordEnum> stringToOpenMPKeyword = new HashMap();
	protected static String[] typeNames = {"double", "float", "int", "short", "long"};
	protected static String[] openMPCalls = {"omp_get_thread_num()", "omp_get_num_threads()"};
	public static List<OpenMPPragma> getOpemMPPragmas(StringBuffer aFileBuffer) {
		String[] aFileLines = aFileBuffer.toString().split("\n");
		return getOpenMPPragmas(aFileLines);
	}
	
	public static boolean isCodeLine(String aLine) {
		return !aLine.isEmpty() && !aLine.startsWith("//");
	}
	public static boolean isBlockStart(String aLine) {
		return aLine.contains("{");
	}
	public static boolean isBlockEnd(String aLine) {
		return aLine.contains("}");
	}
	public static boolean isLoopStart(String aLine) {
		return aLine.startsWith("for");
	}
	public static boolean endsWithLoopHeader(String aLine) {
		return aLine.endsWith(")");
	}
	public static boolean isPragmaStart(String aLine) {
		return aLine.startsWith("#pragma");
	}
	public static void addToStack(Stack<OpenMPPragma> anOpenMPPragmas, String aFileLine) {
		List<String> anOpenMPCalls = getOMPCalls(aFileLine);
		for (OpenMPPragma anOpenMPPragma:anOpenMPPragmas) {
			anOpenMPPragma.addToAnnotatedText(aFileLine);
			for (String anOpenMPCall:anOpenMPCalls) {
				anOpenMPPragma.addOpenMPCall(anOpenMPCall);
			}		
		}
	}
	public static AForHeader getForHeader(String aFileLine, int aLineNumber) {
		int aLeftParenIndex = aFileLine.indexOf("(");
		int aRightParenIndex = aFileLine.indexOf(")");
		if (aLeftParenIndex < 0 || aRightParenIndex < 0) {
			return null;
		}
		String aHeaderString = aFileLine.substring(aLeftParenIndex + 1, aRightParenIndex);
		String[] aForComponents = aHeaderString.split(";");
		return new AForHeader(aForComponents[0], aForComponents[1], aForComponents[2], aLineNumber);
	}
	public static List<String> getOMPCalls(String aFileLine) {
		List<String> retVal = new ArrayList();
		for (String anOpenMPCall:openMPCalls) {
			if (aFileLine.contains(anOpenMPCall)) {
				retVal.add(anOpenMPCall);
			}
		}
		return retVal;
	}
	
	public static void incrementStackTop (Stack<Integer> aNumOpenBracesStack) {
		int aTopIndex = aNumOpenBracesStack.size() - 1;
		Integer aCurrentValue = aNumOpenBracesStack.get(aTopIndex);
		aNumOpenBracesStack.set(aTopIndex, aCurrentValue + 1);
	}
	public static void decrementStackTop (Stack<Integer> aNumOpenBracesStack) {
		int aTopIndex = aNumOpenBracesStack.size() - 1;
		Integer aCurrentValue = aNumOpenBracesStack.get(aTopIndex);
		aNumOpenBracesStack.set(aTopIndex, aCurrentValue - 1);
	}
	
	public static boolean startsWithTypeName(String aLine) {
		for (String aTypeName:typeNames) {
			if (aLine.startsWith(aTypeName)) {
				return true;
			}
		}
		return false;
	}

	public static List<OpenMPPragma> getOpenMPPragmas(String[] aFileLines) {
		List<OpenMPPragma> retVal = new ArrayList();
		Stack<OpenMPPragma> anOpenMPPragmas = new Stack();
		Stack<Integer> aNumOpenBracesStack = new Stack();
//		OpenMPPragma lastOpenMPPragma = null;
//		String lastReductionVariable = null;
//		String lastReductionOperation = null;
//		int aNumOpenBraces = 0;
		boolean aNextCodeLineIsAPragmaBlock = false;
		List<OpenMPPragma> newOpenMPPragmas = null;
		for (int i = 0; i < aFileLines.length; i++) {
			String aFileLine = aFileLines[i].trim();
			if (!isCodeLine(aFileLine)) {
				continue;
			}
			addToStack(anOpenMPPragmas, aFileLine); // if it is empty add to none
//			if (lastReductionVariable != null) {
//				if (aFileLine.startsWith(lastReductionVariable)) {
//					lastOpenMPPragma.getReductionVariableAssignments().add(aFileLine);
//					if (lastReductionOperation != null) { // can it ever be not null
//						if (aFileLine.contains(lastReductionOperation)) {
//							lastOpenMPPragma.getReductionOperationUses().add(aFileLine);
//						}
//					}
//				}			
//			}
//			if (lastOpenMPPragma != null && lastOpenMPPragma.getFirstOpenMPKeyword() == OpenMPKeywordEnum.PARALLEL) {
//				if (startsWithTypeName(aFileLine)) {
//					lastOpenMPPragma.getVariableDeclarationsInParallel().add(aFileLine);
//				}
//			} 
//			else if (lastOpenMPPragma != null && lastOpenMPPragma.getFirstOpenMPKeyword() == OpenMPKeywordEnum.CRITICAL) {
//				String[] aTokens = aFileLine.split("\\s+");
//				lastOpenMPPragma.setAssignedVariableInCritical(aTokens[0]);				
//			}
			if (isPragmaStart(aFileLine)) {
				
				newOpenMPPragmas = getOpenMPPragmas(aFileLine, i);
				if (newOpenMPPragmas.size() != 0) {
					for (OpenMPPragma anOpenMPPragma:newOpenMPPragmas) {
						if (anOpenMPPragmas.size() > 0) {
						    anOpenMPPragma.setParent(anOpenMPPragmas.peek());
						}
						anOpenMPPragmas.push(anOpenMPPragma);
						aNumOpenBracesStack.push(0);
						retVal.add(anOpenMPPragma);

					}
//					anOpenMPPragmas.addAll(newOpenMPPragmas);
					aNumOpenBracesStack.add(0);
//					retVal.add(lastOpenMPPragma);					
					aNextCodeLineIsAPragmaBlock = true;
//					String lastReductionOperation = lastOpenMPPragma.getReductionOperation();
//					String lastReductionVariable = lastOpenMPPragma.getReductionVariable();
					continue;
				} 
			}
			if (anOpenMPPragmas.isEmpty()) {
				continue;
			}	
			if (aNextCodeLineIsAPragmaBlock) {				
				anOpenMPPragmas.peek().setAnnotatedTextStartLineNumber(i);				
				aNextCodeLineIsAPragmaBlock = false;
			}
//			anOpenMPPragmas.peek().getAnnotatedText().add(aFileLine);
			if (isBlockStart(aFileLine)) {
				incrementStackTop(aNumOpenBracesStack);
			}
//			} else 
			if (isBlockEnd(aFileLine)) {
				decrementStackTop(aNumOpenBracesStack);

			}
			if (isLoopStart(aFileLine) && endsWithLoopHeader(aFileLine)) {
				continue; // gather following block also
			}
			if (aNumOpenBracesStack.peek() == 0) {
				
				anOpenMPPragmas.peek().setAnnotatedTextEndLineNumber(i);
				for (int j = 0; j < newOpenMPPragmas.size(); j++) {
					anOpenMPPragmas.pop();
					aNumOpenBracesStack.pop();
				}
//				lastOpenMPPragma = null;
//				lastReductionVariable = null;
//				lastReductionOperation = null;
				continue;
			}					
		}
		return retVal;
	}
	public static List<OpenMPPragma> getOpenMPPragmas(String aFileLine, int aLineIndex) {
		String[] aTokens = aFileLine.split("\\s+");
		if (aTokens.length <= 2) {
			return null;
		}
		if (!aTokens[1].equals("omp")) {
			return null;
		}
		if (aTokens.length < 3) {
			return null;
		}
		String aFirstToken = aTokens[2];
		OpenMPKeywordEnum anOpenMPKeyword = stringToOpenMPKeyword.get(aFirstToken);
		List<OpenMPPragma> retVal = new ArrayList();
		OpenMPPragma lastChild;
		int aStartIndex = 2;
		switch (anOpenMPKeyword) {
		case PARALLEL:
			lastChild = new AnOpenMPParallelPragma(aLineIndex);
			
//			lastChild.setFirstOpenMPKeyword(stringToOpenMPKeyword.get(aFirstToken));	

			retVal.add(lastChild);
			if (aTokens.length > 3 && aTokens[3].equals("for")) {
				OpenMPPragma aForChild = new AnOpenMPForPragma(aLineIndex);
				retVal.add(aForChild);
				lastChild = aForChild;
				aStartIndex++;
			}
			break;
		case FOR:
			lastChild = new AnOpenMPForPragma(aLineIndex);
			retVal.add (lastChild);
			break;
		case CRITICAL:
			lastChild = new AnOpenMPCriticalPragma(aLineIndex);
			retVal.add (lastChild);
			break;
			default: 
				lastChild = new AnOpenMPPragma(aLineIndex);
				retVal.add(lastChild);
			
		}
//		retVal.setFirstOpenMPKeyword(stringToOpenMPKeyword.get(aFirstToken));	
//		OpenMPPragma retVal = new AnOpenMPPragma(aLineIndex);


		for (int i = aStartIndex; i < aTokens.length; i ++) {
			String aStoredToken = aTokens[i].trim();
			if (aStoredToken.isEmpty()) {
				continue;
			}
			if (aStoredToken.startsWith("reduction")) {
				while (!aStoredToken.endsWith(")")) {
					i++;
					if (i >= aTokens.length) {
						break;
					}
					String aNewToken = aTokens[i].trim();
					aStoredToken += aNewToken; 					
				}
				int aLeftParenIndex = aStoredToken.indexOf("(");
				int aRightParenIndex = aStoredToken.indexOf(")");
				int aColonIndex = aStoredToken.indexOf(":");
				if (aLeftParenIndex != -1 && aRightParenIndex != -1 && aColonIndex != -1) {
					String anOperationString = aStoredToken.substring(aLeftParenIndex + 1, aColonIndex).trim();
					String aVariableString = aStoredToken.substring(aColonIndex + 1, aRightParenIndex).trim();
					((OpenMPForPragma) lastChild).setReductionVariable(aVariableString);
					((OpenMPForPragma) lastChild).setReductionOperation(anOperationString);
				}
				
			}
//			aTokens[i] = aStoredToken;
			lastChild.getOpenMPTokens().add(aStoredToken);
		}
//		String aFirstToken = retVal.getOpenMPTokens().get(0);
//		retVal.setFirstOpenMPKeyword(stringToOpenMPKeyword.get(aFirstToken));		
		return retVal;
		
		
	}
	static {
		stringToOpenMPKeyword.put("for", OpenMPKeywordEnum.FOR);
		stringToOpenMPKeyword.put("parallel", OpenMPKeywordEnum.PARALLEL);
		stringToOpenMPKeyword.put("reduce", OpenMPKeywordEnum.REDUCE);
		stringToOpenMPKeyword.put("shared", OpenMPKeywordEnum.SHARED);
		stringToOpenMPKeyword.put("private", OpenMPKeywordEnum.PRIVATE);
		stringToOpenMPKeyword.put("critical", OpenMPKeywordEnum.CRITICAL);





	}
	

}
]]></snapshot>
  </Command>
  <DocumentChange __id="60359" _type="Delete" date="Mon Dec 23 07:47:42 EST 2019" docASTNodeCount="1140" docActiveCodeLength="7663" docExpressionCount="708" docLength="9545" endLine="46" length="1" offset="1610" startLine="46" starttimestamp="1576666505112" timestamp="438757760">
    <text><![CDATA[A]]></text>
  </DocumentChange>
  <Command __id="60386" _type="EclipseCommand" commandID="" date="Mon Dec 23 07:47:45 EST 2019" starttimestamp="1576666505112" timestamp="438760398" />
  <Command __id="60387" _type="EclipseCommand" commandID="" date="Mon Dec 23 07:47:45 EST 2019" starttimestamp="1576666505112" timestamp="438760398" />
  <Command __id="60388" _type="EclipseCommand" commandID="" date="Mon Dec 23 07:47:45 EST 2019" starttimestamp="1576666505112" timestamp="438760398" />
  <Command __id="60389" _type="EclipseCommand" commandID="" date="Mon Dec 23 07:47:45 EST 2019" starttimestamp="1576666505112" timestamp="438760398" />
  <Command __id="60390" _type="EclipseCommand" commandID="" date="Mon Dec 23 07:47:45 EST 2019" starttimestamp="1576666505112" timestamp="438760398" />
  <Command __id="60391" _type="EclipseCommand" commandID="" date="Mon Dec 23 07:47:45 EST 2019" starttimestamp="1576666505112" timestamp="438760398" />
  <Command __id="60392" _type="EclipseCommand" commandID="" date="Mon Dec 23 07:47:45 EST 2019" starttimestamp="1576666505112" timestamp="438760414" />
  <Command __id="60393" _type="EclipseCommand" commandID="" date="Mon Dec 23 07:47:45 EST 2019" starttimestamp="1576666505112" timestamp="438760414" />
  <Command __id="60394" _type="EclipseCommand" commandID="" date="Mon Dec 23 07:47:45 EST 2019" starttimestamp="1576666505112" timestamp="438760414" />
  <Command __id="60395" _type="EclipseCommand" commandID="" date="Mon Dec 23 07:47:45 EST 2019" starttimestamp="1576666505112" timestamp="438760414" />
  <Command __id="60396" _type="EclipseCommand" commandID="" date="Mon Dec 23 07:47:45 EST 2019" starttimestamp="1576666505112" timestamp="438760430" />
  <Command __id="62625" _type="DiffBasedFileOpenCommand" date="Mon Dec 23 08:29:21 EST 2019" docASTNodeCount="395" docActiveCodeLength="2839" docExpressionCount="210" docLength="4742" projectName="GraderBasics" starttimestamp="1576666505112" timestamp="441255986">
    <filePath><![CDATA[D:\dewan_backup\Java\GraderBasics\src\gradingTools\shared\testcases\openmp\AnOpenMPPragma.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package gradingTools.shared.testcases.openmp;¶¶import java.util.ArrayList;¶import java.util.Arrays;¶import java.util.List;¶¶public class AnOpenMPPragma implements OpenMPPragma {¶//	protected List<OpenMPKeywordEnum> openMPKeywords = new ArrayList();¶	protected List<String> openMPTokens = new ArrayList();¶//	protected OpenMPKeywordEnum firstOpenMPKeyword;¶	¶//	protected List<String> variableDeclarationsInParallel = new ArrayList();//separate subclass for this variable?¶	¶//	protected String assignedVariableInCritical;// separate subclass for this variable?¶	¶	protected int lineNumber;¶	protected List<String> annotatedText = new ArrayList();¶	protected List<String> openMPCalls = new ArrayList();¶	"), Diff(INSERT,"protected List<String> linesWithOpenMPCalls = new ArrayList();¶	"), Diff(EQUAL,"protected List<ForHeader> forHeaders = new ArrayList();¶	¶	protected int annotatedTextStartLineNumber;¶	protected int annotatedTextEndLineNumber;¶	protected OpenMPPragma parent;¶	¶¶	protected List<OpenMPPragma> children = new ArrayList();¶¶	//	protected String reductionVariable;¶//	protected String reductionOperation;¶//	protected List<String> reductionVariableAssignments = new ArrayList();¶//	protected List<String> reductionOperationUses = new ArrayList();¶//	¶	public AnOpenMPPragma(int lineNumber) {¶		super();¶//		this.openMPTokens = openMPTokens;¶		this.lineNumber = lineNumber;¶		¶//		this.nextNonEmptyString = nextNonEmptyString;¶	}¶	@Override¶	public List<String> getOpenMPTokens() {¶		return openMPTokens;¶	}¶	@Override¶	public int getLineNumber() {¶		return lineNumber;¶	}¶	@Override¶	public List<String> getAnnotatedText() {¶		return annotatedText;¶	}¶	@Override¶	public void addToAnnotatedText(String aFileLine, int aLineNumber) {¶		annotatedText.add(aFileLine);¶		List<String> anOpenMPCalls = OpenMPUtils.getOMPCalls(aFileLine);¶		¶			for (String anOpenMPCall:anOpenMPCalls) {¶				addOpenMPCall(anOpenMPCall, aLineNumber);¶			}¶			"), Diff(INSERT,"if (anOpenMPCalls.size() > 1) {¶				linesWithOpenMPCalls.add(aFileLine);¶			}¶			"), Diff(EQUAL,"ForHeader aForHeader = OpenMPUtils.getForHeader(aFileLine, aLineNumber);¶			if (aForHeader != null) {¶				forHeaders.add(aForHeader);¶			}¶			¶	}¶//	@Override¶//	public void setAnnotatedText(List<String> nextNonEmptyString) {¶//		this.annotatedText = nextNonEmptyString;¶//	}¶	@Override¶	public int getAnnotatedTextStartLineNumber() {¶		return annotatedTextStartLineNumber;¶	}¶	@Override¶	public void setAnnotatedTextStartLineNumber(int annotatedLineNumber) {¶		this.annotatedTextStartLineNumber = annotatedLineNumber;¶	}¶	¶	@Override¶	public int getAnnotatedTextEndLineNumber() {¶		return annotatedTextEndLineNumber;¶	}¶	@Override¶	public void setAnnotatedTextEndLineNumber(int annotatedTextEndLineNumber) {¶		this.annotatedTextEndLineNumber = annotatedTextEndLineNumber;¶	}¶//	@Override¶//	public String getReductionVariable() {¶//		return reductionVariable;¶//	}¶//	@Override¶//	public void setReductionVariable(String reductionVariable) {¶//		this.reductionVariable = reductionVariable;¶//	}¶//	@Override¶//	public String getReductionOperation() {¶//		return reductionOperation;¶//	}¶//	@Override¶//	public void setReductionOperation(String reductionOperation) {¶//		this.reductionOperation = reductionOperation;¶//	}¶//	@Override¶//	public List<String> getReductionVariableAssignments() {¶//		return reductionVariableAssignments;¶//	}¶//	@Override¶//	public List<String> getReductionOperationUses() {¶//		return reductionOperationUses;¶//	}¶//	@Override¶//	public OpenMPKeywordEnum getFirstOpenMPKeyword() {¶//		return firstOpenMPKeyword;¶//	}¶//	@Override¶//	public void setFirstOpenMPKeyword(OpenMPKeywordEnum firstOpenMPKeyword) {¶//		this.firstOpenMPKeyword = firstOpenMPKeyword;¶//	}¶//	@Override¶//	public String getAssignedVariableInCritical() {¶//		return assignedVariableInCritical;¶//	}¶//	@Override¶//	public void setAssignedVariableInCritical(String assignedVariableInCritical) {¶//		this.assignedVariableInCritical = assignedVariableInCritical;¶//	}¶	@Override¶	public OpenMPPragma getParent() {¶		return parent;¶	}¶	@Override¶	public void setParent(OpenMPPragma parent) {¶		this.parent = parent;¶		parent.getChildren().add(this);¶	}¶	@Override¶	public List<OpenMPPragma> getChildren() {¶		return children;¶	}¶	@Override¶	public List<String> getOpenMPCalls() {¶		return openMPCalls;¶	}¶	@Override¶	public void addOpenMPCall(String aFileLine, int aLineNumber) {¶		openMPCalls.add(aFileLine);¶	}¶	public String toString() {¶		return lineNumber + ":" + openMPTokens +¶				"--> (" + annotatedTextStartLineNumber + "," + annotatedTextEndLineNumber + "):" + annotatedText;¶	}¶}¶")]]]></diff>
    <snapshot><![CDATA[package gradingTools.shared.testcases.openmp;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public class AnOpenMPPragma implements OpenMPPragma {
//	protected List<OpenMPKeywordEnum> openMPKeywords = new ArrayList();
	protected List<String> openMPTokens = new ArrayList();
//	protected OpenMPKeywordEnum firstOpenMPKeyword;
	
//	protected List<String> variableDeclarationsInParallel = new ArrayList();//separate subclass for this variable?
	
//	protected String assignedVariableInCritical;// separate subclass for this variable?
	
	protected int lineNumber;
	protected List<String> annotatedText = new ArrayList();
	protected List<String> openMPCalls = new ArrayList();
	protected List<String> linesWithOpenMPCalls = new ArrayList();
	protected List<ForHeader> forHeaders = new ArrayList();
	
	protected int annotatedTextStartLineNumber;
	protected int annotatedTextEndLineNumber;
	protected OpenMPPragma parent;
	

	protected List<OpenMPPragma> children = new ArrayList();

	//	protected String reductionVariable;
//	protected String reductionOperation;
//	protected List<String> reductionVariableAssignments = new ArrayList();
//	protected List<String> reductionOperationUses = new ArrayList();
//	
	public AnOpenMPPragma(int lineNumber) {
		super();
//		this.openMPTokens = openMPTokens;
		this.lineNumber = lineNumber;
		
//		this.nextNonEmptyString = nextNonEmptyString;
	}
	@Override
	public List<String> getOpenMPTokens() {
		return openMPTokens;
	}
	@Override
	public int getLineNumber() {
		return lineNumber;
	}
	@Override
	public List<String> getAnnotatedText() {
		return annotatedText;
	}
	@Override
	public void addToAnnotatedText(String aFileLine, int aLineNumber) {
		annotatedText.add(aFileLine);
		List<String> anOpenMPCalls = OpenMPUtils.getOMPCalls(aFileLine);
		
			for (String anOpenMPCall:anOpenMPCalls) {
				addOpenMPCall(anOpenMPCall, aLineNumber);
			}
			if (anOpenMPCalls.size() > 1) {
				linesWithOpenMPCalls.add(aFileLine);
			}
			ForHeader aForHeader = OpenMPUtils.getForHeader(aFileLine, aLineNumber);
			if (aForHeader != null) {
				forHeaders.add(aForHeader);
			}
			
	}
//	@Override
//	public void setAnnotatedText(List<String> nextNonEmptyString) {
//		this.annotatedText = nextNonEmptyString;
//	}
	@Override
	public int getAnnotatedTextStartLineNumber() {
		return annotatedTextStartLineNumber;
	}
	@Override
	public void setAnnotatedTextStartLineNumber(int annotatedLineNumber) {
		this.annotatedTextStartLineNumber = annotatedLineNumber;
	}
	
	@Override
	public int getAnnotatedTextEndLineNumber() {
		return annotatedTextEndLineNumber;
	}
	@Override
	public void setAnnotatedTextEndLineNumber(int annotatedTextEndLineNumber) {
		this.annotatedTextEndLineNumber = annotatedTextEndLineNumber;
	}
//	@Override
//	public String getReductionVariable() {
//		return reductionVariable;
//	}
//	@Override
//	public void setReductionVariable(String reductionVariable) {
//		this.reductionVariable = reductionVariable;
//	}
//	@Override
//	public String getReductionOperation() {
//		return reductionOperation;
//	}
//	@Override
//	public void setReductionOperation(String reductionOperation) {
//		this.reductionOperation = reductionOperation;
//	}
//	@Override
//	public List<String> getReductionVariableAssignments() {
//		return reductionVariableAssignments;
//	}
//	@Override
//	public List<String> getReductionOperationUses() {
//		return reductionOperationUses;
//	}
//	@Override
//	public OpenMPKeywordEnum getFirstOpenMPKeyword() {
//		return firstOpenMPKeyword;
//	}
//	@Override
//	public void setFirstOpenMPKeyword(OpenMPKeywordEnum firstOpenMPKeyword) {
//		this.firstOpenMPKeyword = firstOpenMPKeyword;
//	}
//	@Override
//	public String getAssignedVariableInCritical() {
//		return assignedVariableInCritical;
//	}
//	@Override
//	public void setAssignedVariableInCritical(String assignedVariableInCritical) {
//		this.assignedVariableInCritical = assignedVariableInCritical;
//	}
	@Override
	public OpenMPPragma getParent() {
		return parent;
	}
	@Override
	public void setParent(OpenMPPragma parent) {
		this.parent = parent;
		parent.getChildren().add(this);
	}
	@Override
	public List<OpenMPPragma> getChildren() {
		return children;
	}
	@Override
	public List<String> getOpenMPCalls() {
		return openMPCalls;
	}
	@Override
	public void addOpenMPCall(String aFileLine, int aLineNumber) {
		openMPCalls.add(aFileLine);
	}
	public String toString() {
		return lineNumber + ":" + openMPTokens +
				"--> (" + annotatedTextStartLineNumber + "," + annotatedTextEndLineNumber + "):" + annotatedText;
	}
}
]]></snapshot>
  </Command>
  <DocumentChange __id="62713" _type="Replace" date="Mon Dec 23 08:30:06 EST 2019" docASTNodeCount="395" docActiveCodeLength="2839" docExpressionCount="210" docLength="4742" endLine="60" insertionLength="1" int_docASTNodeCount="363" int_docActiveCodeLength="2838" int_docExpressionCount="187" int_docLength="4741" length="1" offset="2002" startLine="60" starttimestamp="1576666505112" timestamp="441301796">
    <deletedText><![CDATA[1]]></deletedText>
    <insertedText><![CDATA[0]]></insertedText>
  </DocumentChange>
  <Command __id="62791" _type="EclipseCommand" commandID="org.eclipse.debug.ui.commands.Resume" date="Mon Dec 23 08:32:47 EST 2019" starttimestamp="1576666505112" timestamp="441462118" />
  <Command __id="62792" _type="RunCommand" date="Mon Dec 23 08:32:47 EST 2019" kind="StepInto" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="441462118" type="Run" />
  <Command __id="62793" _type="EHExceptionCommand" date="Mon Dec 23 08:32:47 EST 2019" starttimestamp="1576666505112" timestamp="441462225" type="Exception">
    <outputString><![CDATA[file name:sum_parallel.cp
pragmas:[18:[parallel]--> (19,0):[{, double local_sum = 0;, int rank = omp_get_thread_num();, int threads = omp_get_num_threads();, int start_index = (size/threads)*rank;, int end_index = (size/threads)*(rank+1);, if(rank==threads-1), end_index=size;, for(int i = start_index; i < end_index; i++), local_sum += array[i];, #pragma omp critical, sum += local_sum;, }, double end = omp_get_wtime();, printSumWithTimes(sum, start, end);, }], 34:[critical]--> (35,35):[sum += local_sum;]]
I***(TestCaseResult) ### anonymous: 1.0
]]></outputString>
  </Command>
  <Command __id="63437" _type="RunCommand" date="Mon Dec 23 08:59:09 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="443044205" type="Debug" />
  <Command __id="63438" _type="RunCommand" date="Mon Dec 23 08:59:09 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="443044205" type="Debug" />
  <Command __id="63439" _type="RunCommand" date="Mon Dec 23 08:59:09 EST 2019" kind="HitBreakPoint" projectName="PL_Java" starttimestamp="1576666505112" timestamp="443044205" type="Run" />
  <Command __id="63441" _type="ShellCommand" date="Mon Dec 23 09:00:49 EST 2019" starttimestamp="1576666505112" timestamp="443144716" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="63442" _type="EclipseCommand" commandID="org.eclipse.jdt.ui.edit.text.java.rename.element" date="Mon Dec 23 09:00:49 EST 2019" starttimestamp="1576666505112" timestamp="443144741" />
  <Command __id="63443" _type="ShellCommand" date="Mon Dec 23 09:01:03 EST 2019" starttimestamp="1576666505112" timestamp="443158817" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="63444" _type="ShellCommand" date="Mon Dec 23 09:01:06 EST 2019" starttimestamp="1576666505112" timestamp="443161033" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="63445" _type="EclipseCommand" commandID="org.eclipse.ui.project.cleanAction" date="Mon Dec 23 09:01:06 EST 2019" starttimestamp="1576666505112" timestamp="443161046" />
  <Command __id="63446" _type="EclipseCommand" commandID="org.eclipse.ui.project.buildProject" date="Mon Dec 23 09:01:15 EST 2019" starttimestamp="1576666505112" timestamp="443170200" />
  <Command __id="63448" _type="ShellCommand" date="Mon Dec 23 09:01:30 EST 2019" starttimestamp="1576666505112" timestamp="443185629" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="63449" _type="EclipseCommand" commandID="org.eclipse.jdt.ui.edit.text.java.rename.element" date="Mon Dec 23 09:01:30 EST 2019" starttimestamp="1576666505112" timestamp="443185645" />
  <Command __id="63451" _type="ShellCommand" date="Mon Dec 23 09:01:39 EST 2019" starttimestamp="1576666505112" timestamp="443194813" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="63452" _type="EclipseCommand" commandID="org.eclipse.jdt.ui.edit.text.java.rename.element" date="Mon Dec 23 09:01:39 EST 2019" starttimestamp="1576666505112" timestamp="443194829" />
  <Command __id="63454" _type="ShellCommand" date="Mon Dec 23 09:01:48 EST 2019" starttimestamp="1576666505112" timestamp="443203387" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="63455" _type="EclipseCommand" commandID="org.eclipse.jdt.ui.edit.text.java.rename.element" date="Mon Dec 23 09:01:48 EST 2019" starttimestamp="1576666505112" timestamp="443203403" />
  <DocumentChange __id="63434" _type="Insert" date="Mon Dec 23 08:57:06 EST 2019" docASTNodeCount="136" docActiveCodeLength="1021" docExpressionCount="77" docLength="1136" length="2" offset="893" starttimestamp="1576666505112" timestamp="442921485">
    <text><![CDATA[
]]></text>
  </DocumentChange>
  <Command __id="63460" _type="ShellCommand" date="Mon Dec 23 22:33:14 EST 2019" starttimestamp="1576666505112" timestamp="491889409" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="63461" _type="DiffBasedFileOpenCommand" date="Mon Dec 23 22:33:21 EST 2019" docASTNodeCount="1" docActiveCodeLength="611" docExpressionCount="0" docLength="699" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="491896212">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\my_sum_parallel_for_local_var.cpp]]></filePath>
    <diff><![CDATA[null]]></diff>
    <snapshot><![CDATA[#include <iostream>
#include <omp.h>

using namespace std;

void printSumWithTimes (int sum, int start, int end);
void printNumThreads();
void recordThreadIndex(int index);
void sum_parallel_for_local_var(double* array, int size)
{
	cout << "sum_parallel_for_local_var\n";

	double start = omp_get_wtime();

	double sum = 0;
//
//	for (int i = 0; i < size; i++) {
//			sum += array[i];
//			recordThreadIndex(i);
//	}
    #pragma omp parallel
	{
		double local_sum = 0;

		#pragma omp for
		for(int i = 0; i < size; i++) {
			local_sum += array[i];
			recordThreadIndex(i);
		}

		#pragma omp critical
		sum += local_sum;
	}

	double end = omp_get_wtime();

	printSumWithTimes(sum, start, end);
	
}
]]></snapshot>
  </Command>
  <Command __id="63462" _type="MoveCaretCommand" caretOffset="488" date="Mon Dec 23 22:33:21 EST 2019" docOffset="488" starttimestamp="1576666505112" timestamp="491896585" />
  <DocumentChange __id="63463" _type="Insert" date="Mon Dec 23 22:33:31 EST 2019" docASTNodeCount="1" docActiveCodeLength="612" docExpressionCount="0" docLength="700" length="1" offset="488" starttimestamp="1576666505112" timestamp="491906720">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <Command __id="63464" _type="InsertStringCommand" date="Mon Dec 23 22:33:31 EST 2019" starttimestamp="1576666505112" timestamp="491906726" timestamp2="491906726">
    <data><![CDATA[ ]]></data>
  </Command>
  <DocumentChange __id="63465" _type="Insert" date="Mon Dec 23 22:33:32 EST 2019" docASTNodeCount="1" docActiveCodeLength="613" docExpressionCount="0" docLength="701" length="1" offset="489" starttimestamp="1576666505112" timestamp="491907001">
    <text><![CDATA[s]]></text>
  </DocumentChange>
  <Command __id="63466" _type="InsertStringCommand" date="Mon Dec 23 22:33:32 EST 2019" starttimestamp="1576666505112" timestamp="491907014" timestamp2="491907014">
    <data><![CDATA[s]]></data>
  </Command>
  <DocumentChange __id="63467" _type="Insert" date="Mon Dec 23 22:33:32 EST 2019" docASTNodeCount="1" docActiveCodeLength="614" docExpressionCount="0" docLength="702" length="1" offset="490" starttimestamp="1576666505112" timestamp="491907121">
    <text><![CDATA[h]]></text>
  </DocumentChange>
  <Command __id="63468" _type="InsertStringCommand" date="Mon Dec 23 22:33:32 EST 2019" starttimestamp="1576666505112" timestamp="491907128" timestamp2="491907128">
    <data><![CDATA[h]]></data>
  </Command>
  <DocumentChange __id="63469" _type="Insert" date="Mon Dec 23 22:33:32 EST 2019" docASTNodeCount="1" docActiveCodeLength="615" docExpressionCount="0" docLength="703" length="1" offset="491" starttimestamp="1576666505112" timestamp="491907360">
    <text><![CDATA[a]]></text>
  </DocumentChange>
  <Command __id="63470" _type="InsertStringCommand" date="Mon Dec 23 22:33:32 EST 2019" starttimestamp="1576666505112" timestamp="491907373" timestamp2="491907373">
    <data><![CDATA[a]]></data>
  </Command>
  <DocumentChange __id="63471" _type="Insert" date="Mon Dec 23 22:33:32 EST 2019" docASTNodeCount="1" docActiveCodeLength="616" docExpressionCount="0" docLength="704" length="1" offset="492" starttimestamp="1576666505112" timestamp="491907464">
    <text><![CDATA[r]]></text>
  </DocumentChange>
  <Command __id="63472" _type="InsertStringCommand" date="Mon Dec 23 22:33:32 EST 2019" starttimestamp="1576666505112" timestamp="491907473" timestamp2="491907473">
    <data><![CDATA[r]]></data>
  </Command>
  <DocumentChange __id="63473" _type="Insert" date="Mon Dec 23 22:33:32 EST 2019" docASTNodeCount="1" docActiveCodeLength="617" docExpressionCount="0" docLength="705" length="1" offset="493" starttimestamp="1576666505112" timestamp="491907608">
    <text><![CDATA[e]]></text>
  </DocumentChange>
  <Command __id="63474" _type="InsertStringCommand" date="Mon Dec 23 22:33:32 EST 2019" starttimestamp="1576666505112" timestamp="491907616" timestamp2="491907616">
    <data><![CDATA[e]]></data>
  </Command>
  <DocumentChange __id="63475" _type="Insert" date="Mon Dec 23 22:33:32 EST 2019" docASTNodeCount="1" docActiveCodeLength="618" docExpressionCount="0" docLength="706" length="1" offset="494" starttimestamp="1576666505112" timestamp="491907762">
    <text><![CDATA[d]]></text>
  </DocumentChange>
  <Command __id="63476" _type="InsertStringCommand" date="Mon Dec 23 22:33:32 EST 2019" starttimestamp="1576666505112" timestamp="491907769" timestamp2="491907769">
    <data><![CDATA[d]]></data>
  </Command>
  <DocumentChange __id="63477" _type="Insert" date="Mon Dec 23 22:33:33 EST 2019" docASTNodeCount="1" docActiveCodeLength="620" docExpressionCount="0" docLength="708" length="2" offset="495" starttimestamp="1576666505112" timestamp="491908661">
    <text><![CDATA[()]]></text>
  </DocumentChange>
  <Command __id="63478" _type="InsertStringCommand" date="Mon Dec 23 22:33:33 EST 2019" starttimestamp="1576666505112" timestamp="491908686" timestamp2="491908686">
    <data><![CDATA[(]]></data>
  </Command>
  <DocumentChange __id="63479" _type="Insert" date="Mon Dec 23 22:33:34 EST 2019" docASTNodeCount="1" docActiveCodeLength="621" docExpressionCount="0" docLength="709" length="1" offset="496" starttimestamp="1576666505112" timestamp="491908908">
    <text><![CDATA[l]]></text>
  </DocumentChange>
  <Command __id="63480" _type="InsertStringCommand" date="Mon Dec 23 22:33:34 EST 2019" starttimestamp="1576666505112" timestamp="491908914" timestamp2="491908914">
    <data><![CDATA[l]]></data>
  </Command>
  <DocumentChange __id="63481" _type="Insert" date="Mon Dec 23 22:33:34 EST 2019" docASTNodeCount="1" docActiveCodeLength="622" docExpressionCount="0" docLength="710" length="1" offset="497" starttimestamp="1576666505112" timestamp="491909153">
    <text><![CDATA[o]]></text>
  </DocumentChange>
  <Command __id="63482" _type="InsertStringCommand" date="Mon Dec 23 22:33:34 EST 2019" starttimestamp="1576666505112" timestamp="491909155" timestamp2="491909155">
    <data><![CDATA[o]]></data>
  </Command>
  <DocumentChange __id="63483" _type="Insert" date="Mon Dec 23 22:33:34 EST 2019" docASTNodeCount="1" docActiveCodeLength="623" docExpressionCount="0" docLength="711" length="1" offset="498" starttimestamp="1576666505112" timestamp="491909249">
    <text><![CDATA[c]]></text>
  </DocumentChange>
  <Command __id="63484" _type="InsertStringCommand" date="Mon Dec 23 22:33:34 EST 2019" starttimestamp="1576666505112" timestamp="491909252" timestamp2="491909252">
    <data><![CDATA[c]]></data>
  </Command>
  <DocumentChange __id="63485" _type="Insert" date="Mon Dec 23 22:33:34 EST 2019" docASTNodeCount="1" docActiveCodeLength="624" docExpressionCount="0" docLength="712" length="1" offset="499" starttimestamp="1576666505112" timestamp="491909410">
    <text><![CDATA[a]]></text>
  </DocumentChange>
  <Command __id="63486" _type="InsertStringCommand" date="Mon Dec 23 22:33:34 EST 2019" starttimestamp="1576666505112" timestamp="491909412" timestamp2="491909412">
    <data><![CDATA[a]]></data>
  </Command>
  <DocumentChange __id="63487" _type="Insert" date="Mon Dec 23 22:33:34 EST 2019" docASTNodeCount="1" docActiveCodeLength="625" docExpressionCount="0" docLength="713" length="1" offset="500" starttimestamp="1576666505112" timestamp="491909626">
    <text><![CDATA[l]]></text>
  </DocumentChange>
  <Command __id="63488" _type="InsertStringCommand" date="Mon Dec 23 22:33:34 EST 2019" starttimestamp="1576666505112" timestamp="491909631" timestamp2="491909631">
    <data><![CDATA[l]]></data>
  </Command>
  <DocumentChange __id="63489" _type="Insert" date="Mon Dec 23 22:33:35 EST 2019" docASTNodeCount="1" docActiveCodeLength="626" docExpressionCount="0" docLength="714" length="1" offset="501" starttimestamp="1576666505112" timestamp="491910421">
    <text><![CDATA[_]]></text>
  </DocumentChange>
  <Command __id="63490" _type="InsertStringCommand" date="Mon Dec 23 22:33:35 EST 2019" starttimestamp="1576666505112" timestamp="491910425" timestamp2="491910425">
    <data><![CDATA[_]]></data>
  </Command>
  <DocumentChange __id="63491" _type="Insert" date="Mon Dec 23 22:33:35 EST 2019" docASTNodeCount="1" docActiveCodeLength="627" docExpressionCount="0" docLength="715" length="1" offset="502" starttimestamp="1576666505112" timestamp="491910612">
    <text><![CDATA[s]]></text>
  </DocumentChange>
  <Command __id="63492" _type="InsertStringCommand" date="Mon Dec 23 22:33:35 EST 2019" starttimestamp="1576666505112" timestamp="491910623" timestamp2="491910623">
    <data><![CDATA[s]]></data>
  </Command>
  <DocumentChange __id="63493" _type="Insert" date="Mon Dec 23 22:33:35 EST 2019" docASTNodeCount="1" docActiveCodeLength="628" docExpressionCount="0" docLength="716" length="1" offset="503" starttimestamp="1576666505112" timestamp="491910834">
    <text><![CDATA[u]]></text>
  </DocumentChange>
  <Command __id="63494" _type="InsertStringCommand" date="Mon Dec 23 22:33:35 EST 2019" starttimestamp="1576666505112" timestamp="491910841" timestamp2="491910841">
    <data><![CDATA[u]]></data>
  </Command>
  <Command __id="63496" _type="InsertStringCommand" date="Mon Dec 23 22:33:36 EST 2019" starttimestamp="1576666505112" timestamp="491911052" timestamp2="491911052">
    <data><![CDATA[m]]></data>
  </Command>
  <Command __id="63497" _type="EclipseCommand" commandID="org.eclipse.ui.file.save" date="Mon Dec 23 22:33:39 EST 2019" starttimestamp="1576666505112" timestamp="491913893" />
  <Command __id="63498" _type="MoveCaretCommand" caretOffset="506" date="Mon Dec 23 22:33:48 EST 2019" docOffset="506" starttimestamp="1576666505112" timestamp="491923226" />
  <Command __id="63499" _type="ShellCommand" date="Mon Dec 23 22:33:57 EST 2019" starttimestamp="1576666505112" timestamp="491932473" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="63500" _type="ShellCommand" date="Mon Dec 23 22:33:57 EST 2019" starttimestamp="1576666505112" timestamp="491932642" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="63501" _type="ShellCommand" date="Mon Dec 23 22:33:58 EST 2019" starttimestamp="1576666505112" timestamp="491933011" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="63502" _type="ShellCommand" date="Mon Dec 23 22:34:00 EST 2019" starttimestamp="1576666505112" timestamp="491935502" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="63503" _type="EclipseCommand" commandID="org.eclipse.cdt.debug.ui.localCShortcut.debug" date="Mon Dec 23 22:34:00 EST 2019" starttimestamp="1576666505112" timestamp="491935569" />
  <Command __id="63504" _type="ShellCommand" date="Mon Dec 23 22:34:04 EST 2019" starttimestamp="1576666505112" timestamp="491939195" type="ECLIPSE_LOST_FOCUS" />
  <DocumentChange __id="63495" _type="Insert" date="Mon Dec 23 22:33:36 EST 2019" docASTNodeCount="1" docActiveCodeLength="629" docExpressionCount="0" docLength="717" length="1" offset="504" starttimestamp="1576666505112" timestamp="491911051">
    <text><![CDATA[m]]></text>
  </DocumentChange>
  <Command __id="63509" _type="RunCommand" date="Mon Dec 23 22:34:15 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="491950682" type="Debug" />
  <Command __id="63510" _type="RunCommand" date="Mon Dec 23 22:34:15 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="491950684" type="Run" />
  <Command __id="63511" _type="RunCommand" date="Mon Dec 23 22:34:15 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="491950684" type="Debug" />
  <Command __id="63512" _type="RunCommand" date="Mon Dec 23 22:34:15 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="491950684" type="Run" />
  <Command __id="63513" _type="RunCommand" date="Mon Dec 23 22:34:16 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="491951250" type="Debug" />
  <Command __id="63514" _type="RunCommand" date="Mon Dec 23 22:34:16 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="491951250" type="Run" />
  <Command __id="63515" _type="RunCommand" date="Mon Dec 23 22:34:16 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="491951250" type="Debug" />
  <Command __id="63516" _type="RunCommand" date="Mon Dec 23 22:34:16 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="491951250" type="Run" />
  <Command __id="63517" _type="DiffBasedFileOpenCommand" date="Mon Dec 23 22:34:40 EST 2019" docASTNodeCount="1" docActiveCodeLength="1642" docExpressionCount="0" docLength="1924" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="491975305">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\my_sum_main.cpp]]></filePath>
    <diff><![CDATA[null]]></diff>
    <snapshot><![CDATA[#include <iostream>
#include <omp.h>

using namespace std;
//need to declare headers of external functions called
void sum_sequential(double* array, int size);
void sum_parallel_for_reduction(double* array, int size);
void sum_parallel(double* array, int size);
void sum_parallel_for_local_var(double* array, int size);

// if this main is used to call functions to do other computations
// then those headers should also be declared here

const int SIZE = 1000;
void initArray (double* array, int size ) {
	for(int i = 0; i < size; i++)
			array[i]=i;
}
/**
 * Called by each of the summing alternatives
 */
void printSumWithTimes (int sum, int start, int end) {
	cout << "Sum: " << sum << endl;
	cout << "Took: " << end - start << endl;
}
void printNumThreads() {
	cout << "threads:" << omp_get_num_threads() << endl;
}
/**
 * an array to learn how much concurrency occcurred
 */
int MAX_THREADS = 100;
double* threadsLastIndex = new double[MAX_THREADS];
int numThreads;


void recordThreadIndex(int index) {
	int thread =  omp_get_thread_num();
	if (thread >= MAX_THREADS) {
		return;
	}
	threadsLastIndex[thread] = index;
	numThreads = omp_get_num_threads();
}
void initThreadRecording() {
	numThreads = 0;
	for (int i = 0; i < MAX_THREADS; i++) {
		threadsLastIndex[i] = -1;
	}
}

void printThreadLastIndex() {
	for (int i = 0; i < numThreads; i++) {
		cout << "thread:" << i << " lastIndex:" << threadsLastIndex[i] << endl;
	}
	cout << "_____________________________" << endl;
}


int main()
{
	double* array = new double[SIZE];
	initArray(array, SIZE);
	initThreadRecording();
	sum_sequential(array, SIZE);
	printThreadLastIndex();
	initThreadRecording();
	sum_parallel_for_reduction(array, SIZE);
	printThreadLastIndex();
	initThreadRecording();
	sum_parallel_for_local_var(array, SIZE);
	printThreadLastIndex();
	initThreadRecording();
	sum_parallel(array, SIZE);
	printThreadLastIndex();
	initThreadRecording();
}
]]></snapshot>
  </Command>
  <Command __id="63518" _type="MoveCaretCommand" caretOffset="1500" date="Mon Dec 23 22:34:40 EST 2019" docOffset="1500" starttimestamp="1576666505112" timestamp="491975461" />
  <Command __id="63520" _type="MoveCaretCommand" caretOffset="506" date="Mon Dec 23 22:36:23 EST 2019" docOffset="506" starttimestamp="1576666505112" timestamp="492078554" />
  <Command __id="63519" _type="DiffBasedFileOpenCommand" date="Mon Dec 23 22:36:23 EST 2019" docASTNodeCount="1" docActiveCodeLength="629" docExpressionCount="0" docLength="717" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="492078192">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\my_sum_parallel_for_local_var.cpp]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"#include <iostream>¶#include <omp.h>¶¶using namespace std;¶¶void printSumWithTimes (int sum, int start, int end);¶void printNumThreads();¶void recordThreadIndex(int index);¶void sum_parallel_for_local_var(double* array, int size)¶{¶	cout << "sum_parallel_for_local_var\n";¶¶	double start = omp_get_wtime();¶¶	double sum = 0;¶//¶//	for (int i = 0; i < size; i++) {¶//			sum += array[i];¶//			recordThreadIndex(i);¶//	}¶    #pragma omp parallel¶	{¶		double local_sum = 0;¶¶		#pragma omp for"), Diff(INSERT," shared(local_sum)"), Diff(EQUAL,"¶		for(int i = 0; i < size; i++) {¶			local_sum += array[i];¶			recordThreadIndex(i);¶		}¶¶		#pragma omp critical¶		sum += local_sum;¶	}¶¶	double end = omp_get_wtime();¶¶	printSumWithTimes(sum, start, end);¶	¶}¶")]]]></diff>
    <snapshot><![CDATA[#include <iostream>
#include <omp.h>

using namespace std;

void printSumWithTimes (int sum, int start, int end);
void printNumThreads();
void recordThreadIndex(int index);
void sum_parallel_for_local_var(double* array, int size)
{
	cout << "sum_parallel_for_local_var\n";

	double start = omp_get_wtime();

	double sum = 0;
//
//	for (int i = 0; i < size; i++) {
//			sum += array[i];
//			recordThreadIndex(i);
//	}
    #pragma omp parallel
	{
		double local_sum = 0;

		#pragma omp for shared(local_sum)
		for(int i = 0; i < size; i++) {
			local_sum += array[i];
			recordThreadIndex(i);
		}

		#pragma omp critical
		sum += local_sum;
	}

	double end = omp_get_wtime();

	printSumWithTimes(sum, start, end);
	
}
]]></snapshot>
  </Command>
  <DocumentChange __id="63522" _type="Delete" date="Mon Dec 23 22:36:32 EST 2019" docASTNodeCount="1" docActiveCodeLength="612" docExpressionCount="0" docLength="700" endLine="24" length="17" offset="489" startLine="24" starttimestamp="1576666505112" timestamp="492087814">
    <text><![CDATA[shared(local_sum)]]></text>
  </DocumentChange>
  <Command __id="63521" _type="SelectTextCommand" caretOffset="506" date="Mon Dec 23 22:36:32 EST 2019" end="506" start="489" starttimestamp="1576666505112" timestamp="492087038" />
  <Command __id="63523" _type="EclipseCommand" commandID="org.eclipse.ui.edit.delete" date="Mon Dec 23 22:36:32 EST 2019" starttimestamp="1576666505112" timestamp="492087853" />
  <Command __id="63525" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Mon Dec 23 22:36:35 EST 2019" starttimestamp="1576666505112" timestamp="492090360" />
  <DocumentChange __id="63524" _type="Delete" date="Mon Dec 23 22:36:35 EST 2019" docASTNodeCount="1" docActiveCodeLength="611" docExpressionCount="0" docLength="699" endLine="24" length="1" offset="488" startLine="24" starttimestamp="1576666505112" timestamp="492090352">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <Command __id="63526" _type="EclipseCommand" commandID="org.eclipse.ui.file.save" date="Mon Dec 23 22:36:39 EST 2019" starttimestamp="1576666505112" timestamp="492094057" />
  <DocumentChange __id="63527" _type="Insert" date="Mon Dec 23 22:37:00 EST 2019" docASTNodeCount="1" docActiveCodeLength="612" docExpressionCount="0" docLength="700" length="1" offset="488" starttimestamp="1576666505112" timestamp="492115522">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <Command __id="63528" _type="InsertStringCommand" date="Mon Dec 23 22:37:00 EST 2019" starttimestamp="1576666505112" timestamp="492115529" timestamp2="492115529">
    <data><![CDATA[ ]]></data>
  </Command>
  <DocumentChange __id="63529" _type="Insert" date="Mon Dec 23 22:37:01 EST 2019" docASTNodeCount="1" docActiveCodeLength="613" docExpressionCount="0" docLength="701" length="1" offset="489" starttimestamp="1576666505112" timestamp="492116224">
    <text><![CDATA[p]]></text>
  </DocumentChange>
  <Command __id="63530" _type="InsertStringCommand" date="Mon Dec 23 22:37:01 EST 2019" starttimestamp="1576666505112" timestamp="492116242" timestamp2="492116242">
    <data><![CDATA[p]]></data>
  </Command>
  <DocumentChange __id="63531" _type="Insert" date="Mon Dec 23 22:37:01 EST 2019" docASTNodeCount="1" docActiveCodeLength="614" docExpressionCount="0" docLength="702" length="1" offset="490" starttimestamp="1576666505112" timestamp="492116445">
    <text><![CDATA[r]]></text>
  </DocumentChange>
  <Command __id="63532" _type="InsertStringCommand" date="Mon Dec 23 22:37:01 EST 2019" starttimestamp="1576666505112" timestamp="492116452" timestamp2="492116452">
    <data><![CDATA[r]]></data>
  </Command>
  <DocumentChange __id="63533" _type="Insert" date="Mon Dec 23 22:37:01 EST 2019" docASTNodeCount="1" docActiveCodeLength="615" docExpressionCount="0" docLength="703" length="1" offset="491" starttimestamp="1576666505112" timestamp="492116621">
    <text><![CDATA[i]]></text>
  </DocumentChange>
  <Command __id="63534" _type="InsertStringCommand" date="Mon Dec 23 22:37:01 EST 2019" starttimestamp="1576666505112" timestamp="492116630" timestamp2="492116630">
    <data><![CDATA[i]]></data>
  </Command>
  <DocumentChange __id="63535" _type="Insert" date="Mon Dec 23 22:37:02 EST 2019" docASTNodeCount="1" docActiveCodeLength="616" docExpressionCount="0" docLength="704" length="1" offset="492" starttimestamp="1576666505112" timestamp="492116974">
    <text><![CDATA[v]]></text>
  </DocumentChange>
  <Command __id="63536" _type="InsertStringCommand" date="Mon Dec 23 22:37:02 EST 2019" starttimestamp="1576666505112" timestamp="492116978" timestamp2="492116978">
    <data><![CDATA[v]]></data>
  </Command>
  <DocumentChange __id="63537" _type="Insert" date="Mon Dec 23 22:37:02 EST 2019" docASTNodeCount="1" docActiveCodeLength="617" docExpressionCount="0" docLength="705" length="1" offset="493" starttimestamp="1576666505112" timestamp="492117208">
    <text><![CDATA[a]]></text>
  </DocumentChange>
  <Command __id="63538" _type="InsertStringCommand" date="Mon Dec 23 22:37:02 EST 2019" starttimestamp="1576666505112" timestamp="492117214" timestamp2="492117214">
    <data><![CDATA[a]]></data>
  </Command>
  <DocumentChange __id="63539" _type="Insert" date="Mon Dec 23 22:37:02 EST 2019" docASTNodeCount="1" docActiveCodeLength="618" docExpressionCount="0" docLength="706" length="1" offset="494" starttimestamp="1576666505112" timestamp="492117387">
    <text><![CDATA[t]]></text>
  </DocumentChange>
  <Command __id="63540" _type="InsertStringCommand" date="Mon Dec 23 22:37:02 EST 2019" starttimestamp="1576666505112" timestamp="492117396" timestamp2="492117396">
    <data><![CDATA[t]]></data>
  </Command>
  <DocumentChange __id="63541" _type="Insert" date="Mon Dec 23 22:37:02 EST 2019" docASTNodeCount="1" docActiveCodeLength="619" docExpressionCount="0" docLength="707" length="1" offset="495" starttimestamp="1576666505112" timestamp="492117499">
    <text><![CDATA[e]]></text>
  </DocumentChange>
  <Command __id="63542" _type="InsertStringCommand" date="Mon Dec 23 22:37:02 EST 2019" starttimestamp="1576666505112" timestamp="492117511" timestamp2="492117511">
    <data><![CDATA[e]]></data>
  </Command>
  <DocumentChange __id="63543" _type="Insert" date="Mon Dec 23 22:37:03 EST 2019" docASTNodeCount="1" docActiveCodeLength="621" docExpressionCount="0" docLength="709" length="2" offset="496" starttimestamp="1576666505112" timestamp="492118875">
    <text><![CDATA[()]]></text>
  </DocumentChange>
  <Command __id="63544" _type="InsertStringCommand" date="Mon Dec 23 22:37:04 EST 2019" starttimestamp="1576666505112" timestamp="492118903" timestamp2="492118903">
    <data><![CDATA[(]]></data>
  </Command>
  <DocumentChange __id="63545" _type="Insert" date="Mon Dec 23 22:37:04 EST 2019" docASTNodeCount="1" docActiveCodeLength="622" docExpressionCount="0" docLength="710" length="1" offset="497" starttimestamp="1576666505112" timestamp="492119131">
    <text><![CDATA[s]]></text>
  </DocumentChange>
  <Command __id="63546" _type="InsertStringCommand" date="Mon Dec 23 22:37:04 EST 2019" starttimestamp="1576666505112" timestamp="492119138" timestamp2="492119138">
    <data><![CDATA[s]]></data>
  </Command>
  <DocumentChange __id="63547" _type="Insert" date="Mon Dec 23 22:37:04 EST 2019" docASTNodeCount="1" docActiveCodeLength="623" docExpressionCount="0" docLength="711" length="1" offset="498" starttimestamp="1576666505112" timestamp="492119242">
    <text><![CDATA[u]]></text>
  </DocumentChange>
  <Command __id="63548" _type="InsertStringCommand" date="Mon Dec 23 22:37:04 EST 2019" starttimestamp="1576666505112" timestamp="492119249" timestamp2="492119249">
    <data><![CDATA[u]]></data>
  </Command>
  <Command __id="63550" _type="InsertStringCommand" date="Mon Dec 23 22:37:04 EST 2019" starttimestamp="1576666505112" timestamp="492119499" timestamp2="492119499">
    <data><![CDATA[m]]></data>
  </Command>
  <Command __id="63551" _type="InsertStringCommand" date="Mon Dec 23 22:37:05 EST 2019" starttimestamp="1576666505112" timestamp="492120409" timestamp2="492120409">
    <data><![CDATA[)]]></data>
  </Command>
  <Command __id="63552" _type="EclipseCommand" commandID="org.eclipse.ui.file.save" date="Mon Dec 23 22:37:06 EST 2019" starttimestamp="1576666505112" timestamp="492121454" />
  <Command __id="63554" _type="RunCommand" date="Mon Dec 23 22:37:25 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="492140546" type="Run" />
  <Command __id="63555" _type="RunCommand" date="Mon Dec 23 22:37:25 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="492140546" type="Run" />
  <Command __id="63556" _type="RunCommand" date="Mon Dec 23 22:37:25 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="492140553" type="Debug" />
  <Command __id="63557" _type="RunCommand" date="Mon Dec 23 22:37:25 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="492140553" type="Run" />
  <Command __id="63558" _type="RunCommand" date="Mon Dec 23 22:37:25 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="492140553" type="Debug" />
  <Command __id="63559" _type="RunCommand" date="Mon Dec 23 22:37:25 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="492140553" type="Run" />
  <Command __id="63560" _type="EHExceptionCommand" date="Mon Dec 23 22:37:25 EST 2019" starttimestamp="1576666505112" timestamp="492140726" type="Exception">
    <outputString><![CDATA[sum_sequential
Sum: 499500
Took: 0
thread:0 lastIndex:999
_____________________________
sum_parallel_for_reduction
Sum: 499500
Took: 0
thread:0 lastIndex:124
thread:1 lastIndex:249
thread:2 lastIndex:374
thread:3 lastIndex:499
thread:4 lastIndex:624
thread:5 lastIndex:749
thread:6 lastIndex:874
thread:7 lastIndex:999
_____________________________
sum_parallel_for_local_var
Sum: 499500
Took: 0
thread:0 lastIndex:124
thread:1 lastIndex:249
thread:2 lastIndex:374
thread:3 lastIndex:499
thread:4 lastIndex:624
thread:5 lastIndex:749
thread:6 lastIndex:874
thread:7 lastIndex:999
_____________________________
sum_parallel
Sum: 499500
Took: 0
_____________________________
]]></outputString>
  </Command>
  <Command __id="63561" _type="MoveCaretCommand" caretOffset="492" date="Mon Dec 23 22:37:31 EST 2019" docOffset="492" starttimestamp="1576666505112" timestamp="492146153" />
  <Command __id="63562" _type="SelectTextCommand" caretOffset="496" date="Mon Dec 23 22:37:31 EST 2019" end="496" start="489" starttimestamp="1576666505112" timestamp="492146428" />
  <Command __id="63564" _type="InsertStringCommand" date="Mon Dec 23 22:37:32 EST 2019" starttimestamp="1576666505112" timestamp="492147359" timestamp2="492147359">
    <data><![CDATA[s]]></data>
  </Command>
  <Command __id="63566" _type="InsertStringCommand" date="Mon Dec 23 22:37:32 EST 2019" starttimestamp="1576666505112" timestamp="492147456" timestamp2="492147456">
    <data><![CDATA[h]]></data>
  </Command>
  <Command __id="63568" _type="InsertStringCommand" date="Mon Dec 23 22:37:32 EST 2019" starttimestamp="1576666505112" timestamp="492147621" timestamp2="492147621">
    <data><![CDATA[a]]></data>
  </Command>
  <Command __id="63570" _type="InsertStringCommand" date="Mon Dec 23 22:37:32 EST 2019" starttimestamp="1576666505112" timestamp="492147811" timestamp2="492147811">
    <data><![CDATA[r]]></data>
  </Command>
  <Command __id="63572" _type="InsertStringCommand" date="Mon Dec 23 22:37:33 EST 2019" starttimestamp="1576666505112" timestamp="492147917" timestamp2="492147917">
    <data><![CDATA[e]]></data>
  </Command>
  <Command __id="63574" _type="InsertStringCommand" date="Mon Dec 23 22:37:33 EST 2019" starttimestamp="1576666505112" timestamp="492148079" timestamp2="492148079">
    <data><![CDATA[d]]></data>
  </Command>
  <Command __id="63575" _type="EclipseCommand" commandID="org.eclipse.ui.file.save" date="Mon Dec 23 22:37:35 EST 2019" starttimestamp="1576666505112" timestamp="492150788" />
  <Command __id="63576" _type="EclipseCommand" commandID="org.eclipse.ui.edit.text.showRulerContextMenu" date="Mon Dec 23 22:37:37 EST 2019" starttimestamp="1576666505112" timestamp="492152462" />
  <Command __id="63577" _type="MoveCaretCommand" caretOffset="469" date="Mon Dec 23 22:37:40 EST 2019" docOffset="469" starttimestamp="1576666505112" timestamp="492155626" />
  <Command __id="63578" _type="EclipseCommand" commandID="org.eclipse.debug.ui.commands.RunLast" date="Mon Dec 23 22:37:42 EST 2019" starttimestamp="1576666505112" timestamp="492156952" />
  <Command __id="63579" _type="ShellCommand" date="Mon Dec 23 22:37:43 EST 2019" starttimestamp="1576666505112" timestamp="492158200" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="63580" _type="ShellCommand" date="Mon Dec 23 22:37:45 EST 2019" starttimestamp="1576666505112" timestamp="492160793" type="ECLIPSE_GAINED_FOCUS" />
  <DocumentChange __id="63549" _type="Insert" date="Mon Dec 23 22:37:04 EST 2019" docASTNodeCount="1" docActiveCodeLength="624" docExpressionCount="0" docLength="712" length="1" offset="499" starttimestamp="1576666505112" timestamp="492119487">
    <text><![CDATA[m]]></text>
  </DocumentChange>
  <DocumentChange __id="63563" _type="Replace" date="Mon Dec 23 22:37:32 EST 2019" docASTNodeCount="1" docActiveCodeLength="618" docExpressionCount="0" docLength="706" endLine="24" insertionLength="1" int_docASTNodeCount="1" int_docActiveCodeLength="617" int_docExpressionCount="0" int_docLength="705" length="7" offset="489" startLine="24" starttimestamp="1576666505112" timestamp="492147317">
    <deletedText><![CDATA[private]]></deletedText>
    <insertedText><![CDATA[s]]></insertedText>
  </DocumentChange>
  <DocumentChange __id="63565" _type="Insert" date="Mon Dec 23 22:37:32 EST 2019" docASTNodeCount="1" docActiveCodeLength="619" docExpressionCount="0" docLength="707" length="1" offset="490" starttimestamp="1576666505112" timestamp="492147445">
    <text><![CDATA[h]]></text>
  </DocumentChange>
  <DocumentChange __id="63567" _type="Insert" date="Mon Dec 23 22:37:32 EST 2019" docASTNodeCount="1" docActiveCodeLength="620" docExpressionCount="0" docLength="708" length="1" offset="491" starttimestamp="1576666505112" timestamp="492147614">
    <text><![CDATA[a]]></text>
  </DocumentChange>
  <DocumentChange __id="63569" _type="Insert" date="Mon Dec 23 22:37:32 EST 2019" docASTNodeCount="1" docActiveCodeLength="621" docExpressionCount="0" docLength="709" length="1" offset="492" starttimestamp="1576666505112" timestamp="492147802">
    <text><![CDATA[r]]></text>
  </DocumentChange>
  <DocumentChange __id="63571" _type="Insert" date="Mon Dec 23 22:37:33 EST 2019" docASTNodeCount="1" docActiveCodeLength="622" docExpressionCount="0" docLength="710" length="1" offset="493" starttimestamp="1576666505112" timestamp="492147905">
    <text><![CDATA[e]]></text>
  </DocumentChange>
  <DocumentChange __id="63573" _type="Insert" date="Mon Dec 23 22:37:33 EST 2019" docASTNodeCount="1" docActiveCodeLength="623" docExpressionCount="0" docLength="711" length="1" offset="494" starttimestamp="1576666505112" timestamp="492148072">
    <text><![CDATA[d]]></text>
  </DocumentChange>
  <DocumentChange __id="63582" _type="Delete" date="Mon Dec 23 22:37:55 EST 2019" docASTNodeCount="1" docActiveCodeLength="612" docExpressionCount="0" docLength="700" endLine="24" length="11" offset="489" startLine="24" starttimestamp="1576666505112" timestamp="492170694">
    <text><![CDATA[shared(sum)]]></text>
  </DocumentChange>
  <Command __id="63581" _type="SelectTextCommand" caretOffset="500" date="Mon Dec 23 22:37:55 EST 2019" end="500" start="489" starttimestamp="1576666505112" timestamp="492169920" />
  <Command __id="63583" _type="EclipseCommand" commandID="org.eclipse.ui.edit.delete" date="Mon Dec 23 22:37:55 EST 2019" starttimestamp="1576666505112" timestamp="492170720" />
  <Command __id="63585" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Mon Dec 23 22:37:58 EST 2019" starttimestamp="1576666505112" timestamp="492173393" />
  <Command __id="63586" _type="EclipseCommand" commandID="org.eclipse.ui.file.save" date="Mon Dec 23 22:38:00 EST 2019" starttimestamp="1576666505112" timestamp="492174959" />
  <Command __id="63587" _type="ShellCommand" date="Mon Dec 23 22:38:09 EST 2019" starttimestamp="1576666505112" timestamp="492184409" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="63588" _type="ShellCommand" date="Mon Dec 23 22:38:25 EST 2019" starttimestamp="1576666505112" timestamp="492200869" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="63589" _type="MoveCaretCommand" caretOffset="390" date="Mon Dec 23 22:38:35 EST 2019" docOffset="390" starttimestamp="1576666505112" timestamp="492210301" />
  <Command __id="63590" _type="MoveCaretCommand" caretOffset="417" date="Mon Dec 23 22:38:36 EST 2019" docOffset="417" starttimestamp="1576666505112" timestamp="492211877" />
  <Command __id="63592" _type="InsertStringCommand" date="Mon Dec 23 22:38:37 EST 2019" starttimestamp="1576666505112" timestamp="492212822" timestamp2="492212822">
    <data><![CDATA[]]></data>
  </Command>
  <Command __id="63594" _type="InsertStringCommand" date="Mon Dec 23 22:38:38 EST 2019" starttimestamp="1576666505112" timestamp="492213520" timestamp2="492213520">
    <data><![CDATA[i]]></data>
  </Command>
  <Command __id="63596" _type="InsertStringCommand" date="Mon Dec 23 22:38:38 EST 2019" starttimestamp="1576666505112" timestamp="492213788" timestamp2="492213788">
    <data><![CDATA[n]]></data>
  </Command>
  <Command __id="63598" _type="InsertStringCommand" date="Mon Dec 23 22:38:39 EST 2019" starttimestamp="1576666505112" timestamp="492213893" timestamp2="492213893">
    <data><![CDATA[t]]></data>
  </Command>
  <Command __id="63600" _type="InsertStringCommand" date="Mon Dec 23 22:38:39 EST 2019" starttimestamp="1576666505112" timestamp="492214095" timestamp2="492214095">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="63602" _type="InsertStringCommand" date="Mon Dec 23 22:38:39 EST 2019" starttimestamp="1576666505112" timestamp="492214299" timestamp2="492214299">
    <data><![CDATA[i]]></data>
  </Command>
  <Command __id="63604" _type="InsertStringCommand" date="Mon Dec 23 22:38:40 EST 2019" starttimestamp="1576666505112" timestamp="492215148" timestamp2="492215148">
    <data><![CDATA[;]]></data>
  </Command>
  <Command __id="63605" _type="MoveCaretCommand" caretOffset="507" date="Mon Dec 23 22:38:42 EST 2019" docOffset="507" starttimestamp="1576666505112" timestamp="492217684" />
  <Command __id="63607" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Mon Dec 23 22:38:43 EST 2019" starttimestamp="1576666505112" timestamp="492218182" />
  <Command __id="63609" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Mon Dec 23 22:38:43 EST 2019" starttimestamp="1576666505112" timestamp="492218353" />
  <Command __id="63611" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Mon Dec 23 22:38:43 EST 2019" starttimestamp="1576666505112" timestamp="492218528" />
  <Command __id="63613" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Mon Dec 23 22:38:44 EST 2019" starttimestamp="1576666505112" timestamp="492219204" />
  <Command __id="63614" _type="MoveCaretCommand" caretOffset="496" date="Mon Dec 23 22:38:46 EST 2019" docOffset="496" starttimestamp="1576666505112" timestamp="492221176" />
  <Command __id="63616" _type="InsertStringCommand" date="Mon Dec 23 22:38:46 EST 2019" starttimestamp="1576666505112" timestamp="492221500" timestamp2="492221500">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="63618" _type="InsertStringCommand" date="Mon Dec 23 22:38:46 EST 2019" starttimestamp="1576666505112" timestamp="492221690" timestamp2="492221690">
    <data><![CDATA[s]]></data>
  </Command>
  <Command __id="63620" _type="InsertStringCommand" date="Mon Dec 23 22:38:46 EST 2019" starttimestamp="1576666505112" timestamp="492221799" timestamp2="492221799">
    <data><![CDATA[h]]></data>
  </Command>
  <Command __id="63622" _type="InsertStringCommand" date="Mon Dec 23 22:38:47 EST 2019" starttimestamp="1576666505112" timestamp="492221942" timestamp2="492221942">
    <data><![CDATA[a]]></data>
  </Command>
  <Command __id="63624" _type="InsertStringCommand" date="Mon Dec 23 22:38:47 EST 2019" starttimestamp="1576666505112" timestamp="492222097" timestamp2="492222097">
    <data><![CDATA[r]]></data>
  </Command>
  <Command __id="63626" _type="InsertStringCommand" date="Mon Dec 23 22:38:47 EST 2019" starttimestamp="1576666505112" timestamp="492222170" timestamp2="492222170">
    <data><![CDATA[e]]></data>
  </Command>
  <Command __id="63628" _type="InsertStringCommand" date="Mon Dec 23 22:38:47 EST 2019" starttimestamp="1576666505112" timestamp="492222341" timestamp2="492222341">
    <data><![CDATA[d]]></data>
  </Command>
  <Command __id="63630" _type="InsertStringCommand" date="Mon Dec 23 22:38:48 EST 2019" starttimestamp="1576666505112" timestamp="492223146" timestamp2="492223146">
    <data><![CDATA[(]]></data>
  </Command>
  <Command __id="63632" _type="InsertStringCommand" date="Mon Dec 23 22:38:48 EST 2019" starttimestamp="1576666505112" timestamp="492223397" timestamp2="492223397">
    <data><![CDATA[i]]></data>
  </Command>
  <Command __id="63633" _type="EclipseCommand" commandID="org.eclipse.ui.file.save" date="Mon Dec 23 22:38:50 EST 2019" starttimestamp="1576666505112" timestamp="492225467" />
  <Command __id="63634" _type="EclipseCommand" commandID="org.eclipse.debug.ui.commands.RunLast" date="Mon Dec 23 22:38:53 EST 2019" starttimestamp="1576666505112" timestamp="492228066" />
  <Command __id="63635" _type="ShellCommand" date="Mon Dec 23 22:38:53 EST 2019" starttimestamp="1576666505112" timestamp="492228444" type="ECLIPSE_LOST_FOCUS" />
  <DocumentChange __id="63584" _type="Delete" date="Mon Dec 23 22:37:58 EST 2019" docASTNodeCount="1" docActiveCodeLength="611" docExpressionCount="0" docLength="699" endLine="24" length="1" offset="488" startLine="24" starttimestamp="1576666505112" timestamp="492173385">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="63591" _type="Insert" date="Mon Dec 23 22:38:37 EST 2019" docASTNodeCount="1" docActiveCodeLength="613" docExpressionCount="0" docLength="701" length="2" offset="417" starttimestamp="1576666505112" timestamp="492212808">
    <text><![CDATA[
	]]></text>
  </DocumentChange>
  <DocumentChange __id="63593" _type="Insert" date="Mon Dec 23 22:38:38 EST 2019" docASTNodeCount="1" docActiveCodeLength="614" docExpressionCount="0" docLength="702" length="1" offset="419" starttimestamp="1576666505112" timestamp="492213517">
    <text><![CDATA[i]]></text>
  </DocumentChange>
  <DocumentChange __id="63595" _type="Insert" date="Mon Dec 23 22:38:38 EST 2019" docASTNodeCount="1" docActiveCodeLength="615" docExpressionCount="0" docLength="703" length="1" offset="420" starttimestamp="1576666505112" timestamp="492213783">
    <text><![CDATA[n]]></text>
  </DocumentChange>
  <DocumentChange __id="63597" _type="Insert" date="Mon Dec 23 22:38:39 EST 2019" docASTNodeCount="1" docActiveCodeLength="616" docExpressionCount="0" docLength="704" length="1" offset="421" starttimestamp="1576666505112" timestamp="492213889">
    <text><![CDATA[t]]></text>
  </DocumentChange>
  <DocumentChange __id="63599" _type="Insert" date="Mon Dec 23 22:38:39 EST 2019" docASTNodeCount="1" docActiveCodeLength="617" docExpressionCount="0" docLength="705" length="1" offset="422" starttimestamp="1576666505112" timestamp="492214088">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="63601" _type="Insert" date="Mon Dec 23 22:38:39 EST 2019" docASTNodeCount="1" docActiveCodeLength="618" docExpressionCount="0" docLength="706" length="1" offset="423" starttimestamp="1576666505112" timestamp="492214294">
    <text><![CDATA[i]]></text>
  </DocumentChange>
  <DocumentChange __id="63603" _type="Insert" date="Mon Dec 23 22:38:40 EST 2019" docASTNodeCount="1" docActiveCodeLength="619" docExpressionCount="0" docLength="707" length="1" offset="424" starttimestamp="1576666505112" timestamp="492215144">
    <text><![CDATA[;]]></text>
  </DocumentChange>
  <DocumentChange __id="63606" _type="Delete" date="Mon Dec 23 22:38:43 EST 2019" docASTNodeCount="1" docActiveCodeLength="618" docExpressionCount="0" docLength="706" endLine="26" length="1" offset="506" startLine="26" starttimestamp="1576666505112" timestamp="492218182">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="63608" _type="Delete" date="Mon Dec 23 22:38:43 EST 2019" docASTNodeCount="1" docActiveCodeLength="617" docExpressionCount="0" docLength="705" endLine="26" length="1" offset="505" startLine="26" starttimestamp="1576666505112" timestamp="492218344">
    <text><![CDATA[t]]></text>
  </DocumentChange>
  <DocumentChange __id="63610" _type="Delete" date="Mon Dec 23 22:38:43 EST 2019" docASTNodeCount="1" docActiveCodeLength="616" docExpressionCount="0" docLength="704" endLine="26" length="1" offset="504" startLine="26" starttimestamp="1576666505112" timestamp="492218519">
    <text><![CDATA[n]]></text>
  </DocumentChange>
  <DocumentChange __id="63612" _type="Delete" date="Mon Dec 23 22:38:44 EST 2019" docASTNodeCount="1" docActiveCodeLength="615" docExpressionCount="0" docLength="703" endLine="26" length="1" offset="503" startLine="26" starttimestamp="1576666505112" timestamp="492219198">
    <text><![CDATA[i]]></text>
  </DocumentChange>
  <DocumentChange __id="63615" _type="Insert" date="Mon Dec 23 22:38:46 EST 2019" docASTNodeCount="1" docActiveCodeLength="616" docExpressionCount="0" docLength="704" length="1" offset="496" starttimestamp="1576666505112" timestamp="492221498">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="63617" _type="Insert" date="Mon Dec 23 22:38:46 EST 2019" docASTNodeCount="1" docActiveCodeLength="617" docExpressionCount="0" docLength="705" length="1" offset="497" starttimestamp="1576666505112" timestamp="492221678">
    <text><![CDATA[s]]></text>
  </DocumentChange>
  <DocumentChange __id="63619" _type="Insert" date="Mon Dec 23 22:38:46 EST 2019" docASTNodeCount="1" docActiveCodeLength="618" docExpressionCount="0" docLength="706" length="1" offset="498" starttimestamp="1576666505112" timestamp="492221790">
    <text><![CDATA[h]]></text>
  </DocumentChange>
  <DocumentChange __id="63621" _type="Insert" date="Mon Dec 23 22:38:47 EST 2019" docASTNodeCount="1" docActiveCodeLength="619" docExpressionCount="0" docLength="707" length="1" offset="499" starttimestamp="1576666505112" timestamp="492221934">
    <text><![CDATA[a]]></text>
  </DocumentChange>
  <DocumentChange __id="63623" _type="Insert" date="Mon Dec 23 22:38:47 EST 2019" docASTNodeCount="1" docActiveCodeLength="620" docExpressionCount="0" docLength="708" length="1" offset="500" starttimestamp="1576666505112" timestamp="492222087">
    <text><![CDATA[r]]></text>
  </DocumentChange>
  <DocumentChange __id="63625" _type="Insert" date="Mon Dec 23 22:38:47 EST 2019" docASTNodeCount="1" docActiveCodeLength="621" docExpressionCount="0" docLength="709" length="1" offset="501" starttimestamp="1576666505112" timestamp="492222161">
    <text><![CDATA[e]]></text>
  </DocumentChange>
  <DocumentChange __id="63627" _type="Insert" date="Mon Dec 23 22:38:47 EST 2019" docASTNodeCount="1" docActiveCodeLength="622" docExpressionCount="0" docLength="710" length="1" offset="502" starttimestamp="1576666505112" timestamp="492222336">
    <text><![CDATA[d]]></text>
  </DocumentChange>
  <DocumentChange __id="63629" _type="Insert" date="Mon Dec 23 22:38:48 EST 2019" docASTNodeCount="1" docActiveCodeLength="624" docExpressionCount="0" docLength="712" length="2" offset="503" starttimestamp="1576666505112" timestamp="492223138">
    <text><![CDATA[()]]></text>
  </DocumentChange>
  <DocumentChange __id="63631" _type="Insert" date="Mon Dec 23 22:38:48 EST 2019" docASTNodeCount="1" docActiveCodeLength="625" docExpressionCount="0" docLength="713" length="1" offset="504" starttimestamp="1576666505112" timestamp="492223391">
    <text><![CDATA[i]]></text>
  </DocumentChange>
  <Command __id="63636" _type="ShellCommand" date="Mon Dec 23 22:38:55 EST 2019" starttimestamp="1576666505112" timestamp="492230286" type="ECLIPSE_GAINED_FOCUS" />
  <DocumentChange __id="63637" _type="Delete" date="Mon Dec 23 22:39:03 EST 2019" docASTNodeCount="1" docActiveCodeLength="624" docExpressionCount="0" docLength="712" endLine="25" length="1" offset="505" startLine="25" starttimestamp="1576666505112" timestamp="492238876">
    <text><![CDATA[)]]></text>
  </DocumentChange>
  <Command __id="63638" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Mon Dec 23 22:39:04 EST 2019" starttimestamp="1576666505112" timestamp="492238906" />
  <DocumentChange __id="63639" _type="Delete" date="Mon Dec 23 22:39:04 EST 2019" docASTNodeCount="1" docActiveCodeLength="623" docExpressionCount="0" docLength="711" endLine="25" length="1" offset="504" startLine="25" starttimestamp="1576666505112" timestamp="492239162">
    <text><![CDATA[i]]></text>
  </DocumentChange>
  <Command __id="63640" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Mon Dec 23 22:39:04 EST 2019" starttimestamp="1576666505112" timestamp="492239163" />
  <DocumentChange __id="63641" _type="Delete" date="Mon Dec 23 22:39:04 EST 2019" docASTNodeCount="1" docActiveCodeLength="622" docExpressionCount="0" docLength="710" endLine="25" length="1" offset="503" startLine="25" starttimestamp="1576666505112" timestamp="492239342">
    <text><![CDATA[(]]></text>
  </DocumentChange>
  <Command __id="63642" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Mon Dec 23 22:39:04 EST 2019" starttimestamp="1576666505112" timestamp="492239346" />
  <DocumentChange __id="63643" _type="Delete" date="Mon Dec 23 22:39:04 EST 2019" docASTNodeCount="1" docActiveCodeLength="621" docExpressionCount="0" docLength="709" endLine="25" length="1" offset="502" startLine="25" starttimestamp="1576666505112" timestamp="492239517">
    <text><![CDATA[d]]></text>
  </DocumentChange>
  <Command __id="63644" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Mon Dec 23 22:39:04 EST 2019" starttimestamp="1576666505112" timestamp="492239520" />
  <DocumentChange __id="63645" _type="Delete" date="Mon Dec 23 22:39:04 EST 2019" docASTNodeCount="1" docActiveCodeLength="620" docExpressionCount="0" docLength="708" endLine="25" length="1" offset="501" startLine="25" starttimestamp="1576666505112" timestamp="492239682">
    <text><![CDATA[e]]></text>
  </DocumentChange>
  <Command __id="63646" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Mon Dec 23 22:39:04 EST 2019" starttimestamp="1576666505112" timestamp="492239689" />
  <DocumentChange __id="63647" _type="Delete" date="Mon Dec 23 22:39:05 EST 2019" docASTNodeCount="1" docActiveCodeLength="619" docExpressionCount="0" docLength="707" endLine="25" length="1" offset="500" startLine="25" starttimestamp="1576666505112" timestamp="492239894">
    <text><![CDATA[r]]></text>
  </DocumentChange>
  <Command __id="63648" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Mon Dec 23 22:39:05 EST 2019" starttimestamp="1576666505112" timestamp="492239901" />
  <DocumentChange __id="63649" _type="Delete" date="Mon Dec 23 22:39:05 EST 2019" docASTNodeCount="1" docActiveCodeLength="618" docExpressionCount="0" docLength="706" endLine="25" length="1" offset="499" startLine="25" starttimestamp="1576666505112" timestamp="492240089">
    <text><![CDATA[a]]></text>
  </DocumentChange>
  <Command __id="63650" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Mon Dec 23 22:39:05 EST 2019" starttimestamp="1576666505112" timestamp="492240097" />
  <DocumentChange __id="63651" _type="Delete" date="Mon Dec 23 22:39:05 EST 2019" docASTNodeCount="1" docActiveCodeLength="617" docExpressionCount="0" docLength="705" endLine="25" length="1" offset="498" startLine="25" starttimestamp="1576666505112" timestamp="492240260">
    <text><![CDATA[h]]></text>
  </DocumentChange>
  <Command __id="63652" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Mon Dec 23 22:39:05 EST 2019" starttimestamp="1576666505112" timestamp="492240264" />
  <DocumentChange __id="63653" _type="Delete" date="Mon Dec 23 22:39:05 EST 2019" docASTNodeCount="1" docActiveCodeLength="616" docExpressionCount="0" docLength="704" endLine="25" length="1" offset="497" startLine="25" starttimestamp="1576666505112" timestamp="492240415">
    <text><![CDATA[s]]></text>
  </DocumentChange>
  <Command __id="63654" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Mon Dec 23 22:39:05 EST 2019" starttimestamp="1576666505112" timestamp="492240419" />
  <Command __id="63656" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Mon Dec 23 22:39:05 EST 2019" starttimestamp="1576666505112" timestamp="492240578" />
  <Command __id="63657" _type="MoveCaretCommand" caretOffset="503" date="Mon Dec 23 22:39:09 EST 2019" docOffset="503" starttimestamp="1576666505112" timestamp="492244033" />
  <Command __id="63659" _type="InsertStringCommand" date="Mon Dec 23 22:39:09 EST 2019" starttimestamp="1576666505112" timestamp="492244726" timestamp2="492244726">
    <data><![CDATA[i]]></data>
  </Command>
  <Command __id="63661" _type="InsertStringCommand" date="Mon Dec 23 22:39:10 EST 2019" starttimestamp="1576666505112" timestamp="492245025" timestamp2="492245025">
    <data><![CDATA[n]]></data>
  </Command>
  <Command __id="63663" _type="InsertStringCommand" date="Mon Dec 23 22:39:10 EST 2019" starttimestamp="1576666505112" timestamp="492245340" timestamp2="492245340">
    <data><![CDATA[t]]></data>
  </Command>
  <Command __id="63665" _type="InsertStringCommand" date="Mon Dec 23 22:39:10 EST 2019" starttimestamp="1576666505112" timestamp="492245726" timestamp2="492245726">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="63666" _type="MoveCaretCommand" caretOffset="422" date="Mon Dec 23 22:39:14 EST 2019" docOffset="422" starttimestamp="1576666505112" timestamp="492249272" />
  <Command __id="63667" _type="SelectTextCommand" caretOffset="422" date="Mon Dec 23 22:39:14 EST 2019" end="422" start="419" starttimestamp="1576666505112" timestamp="492249465" />
  <Command __id="63668" _type="SelectTextCommand" caretOffset="426" date="Mon Dec 23 22:39:15 EST 2019" end="426" start="418" starttimestamp="1576666505112" timestamp="492249955" />
  <Command __id="63670" _type="EclipseCommand" commandID="org.eclipse.ui.edit.delete" date="Mon Dec 23 22:39:15 EST 2019" starttimestamp="1576666505112" timestamp="492250811" />
  <Command __id="63671" _type="EclipseCommand" commandID="org.eclipse.ui.file.save" date="Mon Dec 23 22:39:17 EST 2019" starttimestamp="1576666505112" timestamp="492252084" />
  <DocumentChange __id="63655" _type="Delete" date="Mon Dec 23 22:39:05 EST 2019" docASTNodeCount="1" docActiveCodeLength="615" docExpressionCount="0" docLength="703" endLine="25" length="1" offset="496" startLine="25" starttimestamp="1576666505112" timestamp="492240567">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="63658" _type="Insert" date="Mon Dec 23 22:39:09 EST 2019" docASTNodeCount="1" docActiveCodeLength="616" docExpressionCount="0" docLength="704" length="1" offset="503" starttimestamp="1576666505112" timestamp="492244708">
    <text><![CDATA[i]]></text>
  </DocumentChange>
  <DocumentChange __id="63660" _type="Insert" date="Mon Dec 23 22:39:10 EST 2019" docASTNodeCount="1" docActiveCodeLength="617" docExpressionCount="0" docLength="705" length="1" offset="504" starttimestamp="1576666505112" timestamp="492245011">
    <text><![CDATA[n]]></text>
  </DocumentChange>
  <DocumentChange __id="63662" _type="Insert" date="Mon Dec 23 22:39:10 EST 2019" docASTNodeCount="1" docActiveCodeLength="618" docExpressionCount="0" docLength="706" length="1" offset="505" starttimestamp="1576666505112" timestamp="492245333">
    <text><![CDATA[t]]></text>
  </DocumentChange>
  <DocumentChange __id="63664" _type="Insert" date="Mon Dec 23 22:39:10 EST 2019" docASTNodeCount="1" docActiveCodeLength="619" docExpressionCount="0" docLength="707" length="1" offset="506" starttimestamp="1576666505112" timestamp="492245721">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="63669" _type="Delete" date="Mon Dec 23 22:39:15 EST 2019" docASTNodeCount="1" docActiveCodeLength="611" docExpressionCount="0" docLength="699" endLine="21" length="8" offset="418" startLine="20" starttimestamp="1576666505112" timestamp="492250789">
    <text><![CDATA[	int i;
]]></text>
  </DocumentChange>
  <Command __id="63672" _type="MoveCaretCommand" caretOffset="488" date="Mon Dec 23 22:39:19 EST 2019" docOffset="488" starttimestamp="1576666505112" timestamp="492254734" />
  <DocumentChange __id="63673" _type="Insert" date="Mon Dec 23 22:39:23 EST 2019" docASTNodeCount="1" docActiveCodeLength="612" docExpressionCount="0" docLength="700" length="1" offset="488" starttimestamp="1576666505112" timestamp="492258602">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <Command __id="63674" _type="InsertStringCommand" date="Mon Dec 23 22:39:23 EST 2019" starttimestamp="1576666505112" timestamp="492258606" timestamp2="492258606">
    <data><![CDATA[ ]]></data>
  </Command>
  <DocumentChange __id="63675" _type="Insert" date="Mon Dec 23 22:39:23 EST 2019" docASTNodeCount="1" docActiveCodeLength="613" docExpressionCount="0" docLength="701" length="1" offset="489" starttimestamp="1576666505112" timestamp="492258866">
    <text><![CDATA[p]]></text>
  </DocumentChange>
  <Command __id="63676" _type="InsertStringCommand" date="Mon Dec 23 22:39:23 EST 2019" starttimestamp="1576666505112" timestamp="492258870" timestamp2="492258870">
    <data><![CDATA[p]]></data>
  </Command>
  <DocumentChange __id="63677" _type="Insert" date="Mon Dec 23 22:39:24 EST 2019" docASTNodeCount="1" docActiveCodeLength="614" docExpressionCount="0" docLength="702" length="1" offset="490" starttimestamp="1576666505112" timestamp="492259064">
    <text><![CDATA[r]]></text>
  </DocumentChange>
  <Command __id="63678" _type="InsertStringCommand" date="Mon Dec 23 22:39:24 EST 2019" starttimestamp="1576666505112" timestamp="492259079" timestamp2="492259079">
    <data><![CDATA[r]]></data>
  </Command>
  <DocumentChange __id="63679" _type="Insert" date="Mon Dec 23 22:39:24 EST 2019" docASTNodeCount="1" docActiveCodeLength="615" docExpressionCount="0" docLength="703" length="1" offset="491" starttimestamp="1576666505112" timestamp="492259210">
    <text><![CDATA[o]]></text>
  </DocumentChange>
  <Command __id="63680" _type="InsertStringCommand" date="Mon Dec 23 22:39:24 EST 2019" starttimestamp="1576666505112" timestamp="492259219" timestamp2="492259219">
    <data><![CDATA[o]]></data>
  </Command>
  <DocumentChange __id="63681" _type="Insert" date="Mon Dec 23 22:39:24 EST 2019" docASTNodeCount="1" docActiveCodeLength="616" docExpressionCount="0" docLength="704" length="1" offset="492" starttimestamp="1576666505112" timestamp="492259607">
    <text><![CDATA[v]]></text>
  </DocumentChange>
  <Command __id="63682" _type="InsertStringCommand" date="Mon Dec 23 22:39:24 EST 2019" starttimestamp="1576666505112" timestamp="492259611" timestamp2="492259611">
    <data><![CDATA[v]]></data>
  </Command>
  <DocumentChange __id="63683" _type="Insert" date="Mon Dec 23 22:39:24 EST 2019" docASTNodeCount="1" docActiveCodeLength="617" docExpressionCount="0" docLength="705" length="1" offset="493" starttimestamp="1576666505112" timestamp="492259878">
    <text><![CDATA[a]]></text>
  </DocumentChange>
  <Command __id="63684" _type="InsertStringCommand" date="Mon Dec 23 22:39:25 EST 2019" starttimestamp="1576666505112" timestamp="492259889" timestamp2="492259889">
    <data><![CDATA[a]]></data>
  </Command>
  <DocumentChange __id="63685" _type="Insert" date="Mon Dec 23 22:39:25 EST 2019" docASTNodeCount="1" docActiveCodeLength="618" docExpressionCount="0" docLength="706" length="1" offset="494" starttimestamp="1576666505112" timestamp="492260070">
    <text><![CDATA[t]]></text>
  </DocumentChange>
  <Command __id="63686" _type="InsertStringCommand" date="Mon Dec 23 22:39:25 EST 2019" starttimestamp="1576666505112" timestamp="492260077" timestamp2="492260077">
    <data><![CDATA[t]]></data>
  </Command>
  <DocumentChange __id="63687" _type="Insert" date="Mon Dec 23 22:39:25 EST 2019" docASTNodeCount="1" docActiveCodeLength="619" docExpressionCount="0" docLength="707" length="1" offset="495" starttimestamp="1576666505112" timestamp="492260179">
    <text><![CDATA[e]]></text>
  </DocumentChange>
  <Command __id="63688" _type="InsertStringCommand" date="Mon Dec 23 22:39:25 EST 2019" starttimestamp="1576666505112" timestamp="492260188" timestamp2="492260188">
    <data><![CDATA[e]]></data>
  </Command>
  <DocumentChange __id="63689" _type="Delete" date="Mon Dec 23 22:39:25 EST 2019" docASTNodeCount="1" docActiveCodeLength="618" docExpressionCount="0" docLength="706" endLine="24" length="1" offset="495" startLine="24" starttimestamp="1576666505112" timestamp="492260605">
    <text><![CDATA[e]]></text>
  </DocumentChange>
  <Command __id="63690" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Mon Dec 23 22:39:25 EST 2019" starttimestamp="1576666505112" timestamp="492260609" />
  <DocumentChange __id="63691" _type="Delete" date="Mon Dec 23 22:39:25 EST 2019" docASTNodeCount="1" docActiveCodeLength="617" docExpressionCount="0" docLength="705" endLine="24" length="1" offset="494" startLine="24" starttimestamp="1576666505112" timestamp="492260760">
    <text><![CDATA[t]]></text>
  </DocumentChange>
  <Command __id="63692" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Mon Dec 23 22:39:25 EST 2019" starttimestamp="1576666505112" timestamp="492260766" />
  <DocumentChange __id="63693" _type="Delete" date="Mon Dec 23 22:39:26 EST 2019" docASTNodeCount="1" docActiveCodeLength="616" docExpressionCount="0" docLength="704" endLine="24" length="1" offset="493" startLine="24" starttimestamp="1576666505112" timestamp="492260945">
    <text><![CDATA[a]]></text>
  </DocumentChange>
  <Command __id="63694" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Mon Dec 23 22:39:26 EST 2019" starttimestamp="1576666505112" timestamp="492260948" />
  <DocumentChange __id="63695" _type="Delete" date="Mon Dec 23 22:39:26 EST 2019" docASTNodeCount="1" docActiveCodeLength="615" docExpressionCount="0" docLength="703" endLine="24" length="1" offset="492" startLine="24" starttimestamp="1576666505112" timestamp="492261128">
    <text><![CDATA[v]]></text>
  </DocumentChange>
  <Command __id="63696" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Mon Dec 23 22:39:26 EST 2019" starttimestamp="1576666505112" timestamp="492261138" />
  <DocumentChange __id="63697" _type="Delete" date="Mon Dec 23 22:39:26 EST 2019" docASTNodeCount="1" docActiveCodeLength="614" docExpressionCount="0" docLength="702" endLine="24" length="1" offset="491" startLine="24" starttimestamp="1576666505112" timestamp="492261302">
    <text><![CDATA[o]]></text>
  </DocumentChange>
  <Command __id="63698" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Mon Dec 23 22:39:26 EST 2019" starttimestamp="1576666505112" timestamp="492261311" />
  <DocumentChange __id="63699" _type="Insert" date="Mon Dec 23 22:39:27 EST 2019" docASTNodeCount="1" docActiveCodeLength="615" docExpressionCount="0" docLength="703" length="1" offset="491" starttimestamp="1576666505112" timestamp="492262035">
    <text><![CDATA[i]]></text>
  </DocumentChange>
  <Command __id="63700" _type="InsertStringCommand" date="Mon Dec 23 22:39:27 EST 2019" starttimestamp="1576666505112" timestamp="492262038" timestamp2="492262038">
    <data><![CDATA[i]]></data>
  </Command>
  <DocumentChange __id="63701" _type="Insert" date="Mon Dec 23 22:39:27 EST 2019" docASTNodeCount="1" docActiveCodeLength="616" docExpressionCount="0" docLength="704" length="1" offset="492" starttimestamp="1576666505112" timestamp="492262423">
    <text><![CDATA[v]]></text>
  </DocumentChange>
  <Command __id="63702" _type="InsertStringCommand" date="Mon Dec 23 22:39:27 EST 2019" starttimestamp="1576666505112" timestamp="492262433" timestamp2="492262433">
    <data><![CDATA[v]]></data>
  </Command>
  <DocumentChange __id="63703" _type="Insert" date="Mon Dec 23 22:39:27 EST 2019" docASTNodeCount="1" docActiveCodeLength="617" docExpressionCount="0" docLength="705" length="1" offset="493" starttimestamp="1576666505112" timestamp="492262557">
    <text><![CDATA[a]]></text>
  </DocumentChange>
  <Command __id="63704" _type="InsertStringCommand" date="Mon Dec 23 22:39:27 EST 2019" starttimestamp="1576666505112" timestamp="492262561" timestamp2="492262561">
    <data><![CDATA[a]]></data>
  </Command>
  <DocumentChange __id="63705" _type="Insert" date="Mon Dec 23 22:39:27 EST 2019" docASTNodeCount="1" docActiveCodeLength="618" docExpressionCount="0" docLength="706" length="1" offset="494" starttimestamp="1576666505112" timestamp="492262717">
    <text><![CDATA[t]]></text>
  </DocumentChange>
  <Command __id="63706" _type="InsertStringCommand" date="Mon Dec 23 22:39:27 EST 2019" starttimestamp="1576666505112" timestamp="492262727" timestamp2="492262727">
    <data><![CDATA[t]]></data>
  </Command>
  <DocumentChange __id="63707" _type="Insert" date="Mon Dec 23 22:39:27 EST 2019" docASTNodeCount="1" docActiveCodeLength="619" docExpressionCount="0" docLength="707" length="1" offset="495" starttimestamp="1576666505112" timestamp="492262798">
    <text><![CDATA[e]]></text>
  </DocumentChange>
  <Command __id="63708" _type="InsertStringCommand" date="Mon Dec 23 22:39:27 EST 2019" starttimestamp="1576666505112" timestamp="492262804" timestamp2="492262804">
    <data><![CDATA[e]]></data>
  </Command>
  <DocumentChange __id="63709" _type="Insert" date="Mon Dec 23 22:39:28 EST 2019" docASTNodeCount="1" docActiveCodeLength="621" docExpressionCount="0" docLength="709" length="2" offset="496" starttimestamp="1576666505112" timestamp="492263852">
    <text><![CDATA[()]]></text>
  </DocumentChange>
  <Command __id="63710" _type="InsertStringCommand" date="Mon Dec 23 22:39:28 EST 2019" starttimestamp="1576666505112" timestamp="492263866" timestamp2="492263866">
    <data><![CDATA[(]]></data>
  </Command>
  <DocumentChange __id="63711" _type="Insert" date="Mon Dec 23 22:39:29 EST 2019" docASTNodeCount="1" docActiveCodeLength="622" docExpressionCount="0" docLength="710" length="1" offset="497" starttimestamp="1576666505112" timestamp="492264250">
    <text><![CDATA[s]]></text>
  </DocumentChange>
  <Command __id="63712" _type="InsertStringCommand" date="Mon Dec 23 22:39:29 EST 2019" starttimestamp="1576666505112" timestamp="492264255" timestamp2="492264255">
    <data><![CDATA[s]]></data>
  </Command>
  <DocumentChange __id="63713" _type="Insert" date="Mon Dec 23 22:39:29 EST 2019" docASTNodeCount="1" docActiveCodeLength="623" docExpressionCount="0" docLength="711" length="1" offset="498" starttimestamp="1576666505112" timestamp="492264603">
    <text><![CDATA[u]]></text>
  </DocumentChange>
  <Command __id="63714" _type="InsertStringCommand" date="Mon Dec 23 22:39:29 EST 2019" starttimestamp="1576666505112" timestamp="492264608" timestamp2="492264608">
    <data><![CDATA[u]]></data>
  </Command>
  <Command __id="63716" _type="InsertStringCommand" date="Mon Dec 23 22:39:30 EST 2019" starttimestamp="1576666505112" timestamp="492264929" timestamp2="492264929">
    <data><![CDATA[m]]></data>
  </Command>
  <Command __id="63717" _type="EclipseCommand" commandID="org.eclipse.ui.file.save" date="Mon Dec 23 22:39:31 EST 2019" starttimestamp="1576666505112" timestamp="492266241" />
  <Command __id="63719" _type="RunCommand" date="Mon Dec 23 22:39:35 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="492270347" type="Run" />
  <Command __id="63720" _type="RunCommand" date="Mon Dec 23 22:39:35 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="492270347" type="Run" />
  <Command __id="63721" _type="RunCommand" date="Mon Dec 23 22:39:35 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="492270363" type="Debug" />
  <Command __id="63722" _type="RunCommand" date="Mon Dec 23 22:39:35 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="492270363" type="Run" />
  <Command __id="63723" _type="RunCommand" date="Mon Dec 23 22:39:35 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="492270363" type="Debug" />
  <Command __id="63724" _type="RunCommand" date="Mon Dec 23 22:39:35 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="492270363" type="Run" />
  <Command __id="63725" _type="EHExceptionCommand" date="Mon Dec 23 22:39:35 EST 2019" starttimestamp="1576666505112" timestamp="492270527" type="Exception">
    <outputString><![CDATA[sum_sequential
Sum: 499500
Took: 0
thread:0 lastIndex:999
_____________________________
sum_parallel_for_reduction
Sum: 499500
Took: 0
thread:0 lastIndex:124
thread:1 lastIndex:249
thread:2 lastIndex:374
thread:3 lastIndex:499
thread:4 lastIndex:624
thread:5 lastIndex:749
thread:6 lastIndex:874
thread:7 lastIndex:999
_____________________________
sum_parallel_for_local_var
Sum: 499500
Took: 0
thread:0 lastIndex:124
thread:1 lastIndex:249
thread:2 lastIndex:374
thread:3 lastIndex:499
thread:4 lastIndex:624
thread:5 lastIndex:749
thread:6 lastIndex:874
thread:7 lastIndex:999
_____________________________
sum_parallel
Sum: 499500
Took: 0
_____________________________
]]></outputString>
  </Command>
  <DocumentChange __id="63715" _type="Insert" date="Mon Dec 23 22:39:30 EST 2019" docASTNodeCount="1" docActiveCodeLength="624" docExpressionCount="0" docLength="712" length="1" offset="499" starttimestamp="1576666505112" timestamp="492264924">
    <text><![CDATA[m]]></text>
  </DocumentChange>
  <DocumentChange __id="63727" _type="Delete" date="Mon Dec 23 22:39:38 EST 2019" docASTNodeCount="1" docActiveCodeLength="612" docExpressionCount="0" docLength="700" endLine="24" length="12" offset="489" startLine="24" starttimestamp="1576666505112" timestamp="492272896">
    <text><![CDATA[private(sum)]]></text>
  </DocumentChange>
  <Command __id="63726" _type="SelectTextCommand" caretOffset="501" date="Mon Dec 23 22:39:37 EST 2019" end="501" start="489" starttimestamp="1576666505112" timestamp="492272296" />
  <Command __id="63728" _type="EclipseCommand" commandID="org.eclipse.ui.edit.delete" date="Mon Dec 23 22:39:38 EST 2019" starttimestamp="1576666505112" timestamp="492272922" />
  <Command __id="63730" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Mon Dec 23 22:39:40 EST 2019" starttimestamp="1576666505112" timestamp="492275161" />
  <Command __id="63731" _type="EclipseCommand" commandID="org.eclipse.ui.file.save" date="Mon Dec 23 22:39:41 EST 2019" starttimestamp="1576666505112" timestamp="492276345" />
  <Command __id="63732" _type="ShellCommand" date="Mon Dec 23 22:40:06 EST 2019" starttimestamp="1576666505112" timestamp="492301583" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="63733" _type="ShellCommand" date="Mon Dec 23 22:41:55 EST 2019" starttimestamp="1576666505112" timestamp="492410169" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="67713" _type="DiffBasedFileOpenCommand" date="Mon Dec 23 23:30:41 EST 2019" docASTNodeCount="467" docActiveCodeLength="3343" docExpressionCount="244" docLength="5334" projectName="GraderBasics" starttimestamp="1576666505112" timestamp="495336877">
    <filePath><![CDATA[D:\dewan_backup\Java\GraderBasics\src\gradingTools\shared\testcases\openmp\AnOpenMPPragma.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package gradingTools.shared.testcases.openmp;¶¶import java.util.ArrayList;¶import java.util.Arrays;¶import java.util.List;¶¶public class AnOpenMPPragma implements OpenMPPragma {¶//	protected List<OpenMPKeywordEnum> openMPKeywords = new ArrayList();¶	protected List<String> openMPTokens = new ArrayList();¶//	protected OpenMPKeywordEnum firstOpenMPKeyword;¶	¶//	protected List<String> variableDeclarationsInParallel = new ArrayList();//separate subclass for this variable?¶	¶//	protected String assignedVariableInCritical;// separate subclass for this variable?¶	¶	protected int lineNumber;¶	protected List<String> annotatedText = new ArrayList();¶	protected List<String> openMPCalls = new ArrayList();¶	protected List<String> linesWithOpenMPCalls = new ArrayList();¶	protected List<ForHeader> forHeaders = new ArrayList();¶	¶	protected int annotatedTextStartLineNumber;¶	protected int annotatedTextEndLineNumber;¶	protected OpenMPPragma parent;¶	protected String[] privateVariables ; // can occur in for and parallel¶	¶	protected String[]  sharedVariables ; // can occur only in parallel, but let us keep them here¶	¶¶	¶¶	protected List<OpenMPPragma> children = new ArrayList();¶¶	//	protected String reductionVariable;¶//	protected String reductionOperation;¶//	protected List<String> reductionVariableAssignments = new ArrayList();¶//	protected List<String> reductionOperationUses = new ArrayList();¶//	¶	public AnOpenMPPragma(int lineNumber) {¶		super();¶//		this.openMPTokens = openMPTokens;¶		this.lineNumber = lineNumber;¶		¶//		this.nextNonEmptyString = nextNonEmptyString;¶	}¶	@Override¶	public List<String> getOpenMPTokens() {¶		return openMPTokens;¶	}¶	@Override¶	public int getLineNumber() {¶		return lineNumber;¶	}¶	@Override¶	public List<String> getAnnotatedText() {¶		return annotatedText;¶	}¶	@Override¶	public void addToAnnotatedText(String aFileLine, int aLineNumber) {¶		annotatedText.add(aFileLine);¶		List<String> anOpenMPCalls = OpenMPUtils.getOMPCalls(aFileLine);¶		¶			for (String anOpenMPCall:anOpenMPCalls) {¶				addOpenMPCall(anOpenMPCall, aLineNumber);¶			}¶			if (anOpenMPCalls.size() > 0) {¶				linesWithOpenMPCalls.add(aFileLine);¶			}¶			ForHeader aForHeader = OpenMPUtils.getForHeader(aFileLine, aLineNumber);¶			if (aForHeader != null) {¶				forHeaders.add(aForHeader);¶			}¶			¶	}¶//	@Override¶//	public void setAnnotatedText(List<String> nextNonEmptyString) {¶//		this.annotatedText = nextNonEmptyString;¶//	}¶	@Override¶	public int getAnnotatedTextStartLineNumber() {¶		return annotatedTextStartLineNumber;¶	}¶	@Override¶	public void setAnnotatedTextStartLineNumber(int annotatedLineNumber) {¶		this.annotatedTextStartLineNumber = annotatedLineNumber;¶	}¶	¶	@Override¶	public int getAnnotatedTextEndLineNumber() {¶		return annotatedTextEndLineNumber;¶	}¶	@Override¶	public void setAnnotatedTextEndLineNumber(int annotatedTextEndLineNumber) {¶		this.annotatedTextEndLineNumber = annotatedTextEndLineNumber;¶	}¶//	@Override¶//	public String getReductionVariable() {¶//		return reductionVariable;¶//	}¶//	@Override¶//	public void setReductionVariable(String reductionVariable) {¶//		this.reductionVariable = reductionVariable;¶//	}¶//	@Override¶//	public String getReductionOperation() {¶//		return reductionOperation;¶//	}¶//	@Override¶//	public void setReductionOperation(String reductionOperation) {¶//		this.reductionOperation = reductionOperation;¶//	}¶//	@Override¶//	public List<String> getReductionVariableAssignments() {¶//		return reductionVariableAssignments;¶//	}¶//	@Override¶//	public List<String> getReductionOperationUses() {¶//		return reductionOperationUses;¶//	}¶//	@Override¶//	public OpenMPKeywordEnum getFirstOpenMPKeyword() {¶//		return firstOpenMPKeyword;¶//	}¶//	@Override¶//	public void setFirstOpenMPKeyword(OpenMPKeywordEnum firstOpenMPKeyword) {¶//		this.firstOpenMPKeyword = firstOpenMPKeyword;¶//	}¶//	@Override¶//	public String getAssignedVariableInCritical() {¶//		return assignedVariableInCritical;¶//	}¶//	@Override¶//	public void setAssignedVariableInCritical(String assignedVariableInCritical) {¶//		this.assignedVariableInCritical = assignedVariableInCritical;¶//	}¶	@Override¶	public OpenMPPragma getParent() {¶		return parent;¶	}¶	@Override¶	public void setParent(OpenMPPragma parent) {¶		this.parent = parent;¶		parent.getChildren().add(this);¶	}¶	@Override¶	public List<OpenMPPragma> getChildren() {¶		return children;¶	}¶	@Override¶	public List<String> getOpenMPCalls() {¶		return openMPCalls;¶	}¶	@Override¶	public void addOpenMPCall(String aFileLine, int aLineNumber) {¶		openMPCalls.add(aFileLine);¶	}¶	@Override¶	public String[] getSharedVariables() {¶		return sharedVariables;¶	}¶	@Override¶	public String[] getPrivateVariables() {¶		return privateVariables;¶	}¶	@Override¶	public void setPrivateVariables(String[] privateVariables) {¶		this.privateVariables = privateVariables;¶	}¶	@Override¶	public void setSharedVariables(String[] sharedVariables) {¶		this.sharedVariables = sharedVariables;¶	}¶	public String toString() {¶		return lineNumber + ":" + openMPTokens +¶				"--> (" + annotatedTextStartLineNumber + "," + annotatedTextEndLineNumber + "):" + annotatedText;¶	}¶}¶")]]]></diff>
  </Command>
  <Command __id="67714" _type="SelectTextCommand" caretOffset="5100" date="Mon Dec 23 23:30:42 EST 2019" end="5100" start="5056" starttimestamp="1576666505112" timestamp="495337028" />
  <Command __id="67716" _type="MoveCaretCommand" caretOffset="523" date="Mon Dec 23 23:30:50 EST 2019" docOffset="523" starttimestamp="1576666505112" timestamp="495345218" />
  <Command __id="67715" _type="DiffBasedFileOpenCommand" date="Mon Dec 23 23:30:50 EST 2019" docASTNodeCount="1" docActiveCodeLength="611" docExpressionCount="0" docLength="699" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="495345075">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\my_sum_parallel_for_local_var.cpp]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"#include <iostream>¶#include <omp.h>¶¶using namespace std;¶¶void printSumWithTimes (int sum, int start, int end);¶void printNumThreads();¶void recordThreadIndex(int index);¶void sum_parallel_for_local_var(double* array, int size)¶{¶	cout << "sum_parallel_for_local_var\n";¶¶	double start = omp_get_wtime();¶¶	double sum = 0;¶//¶//	for (int i = 0; i < size; i++) {¶//			sum += array[i];¶//			recordThreadIndex(i);¶//	}¶    #pragma omp parallel¶	{¶		double local_sum = 0;¶¶		#pragma omp for"), Diff(DELETE," shared(local_sum)"), Diff(EQUAL,"¶		for(int i = 0; i < size; i++) {¶			local_sum += array[i];¶			recordThreadIndex(i);¶		}¶¶		#pragma omp critical¶		sum += local_sum;¶	}¶¶	double end = omp_get_wtime();¶¶	printSumWithTimes(sum, start, end);¶	¶}¶")]]]></diff>
    <snapshot><![CDATA[#include <iostream>
#include <omp.h>

using namespace std;

void printSumWithTimes (int sum, int start, int end);
void printNumThreads();
void recordThreadIndex(int index);
void sum_parallel_for_local_var(double* array, int size)
{
	cout << "sum_parallel_for_local_var\n";

	double start = omp_get_wtime();

	double sum = 0;
//
//	for (int i = 0; i < size; i++) {
//			sum += array[i];
//			recordThreadIndex(i);
//	}
    #pragma omp parallel
	{
		double local_sum = 0;

		#pragma omp for
		for(int i = 0; i < size; i++) {
			local_sum += array[i];
			recordThreadIndex(i);
		}

		#pragma omp critical
		sum += local_sum;
	}

	double end = omp_get_wtime();

	printSumWithTimes(sum, start, end);
	
}
]]></snapshot>
  </Command>
  <DocumentChange __id="67718" _type="Insert" date="Mon Dec 23 23:30:54 EST 2019" docASTNodeCount="1" docActiveCodeLength="612" docExpressionCount="0" docLength="700" length="1" offset="442" starttimestamp="1576666505112" timestamp="495349414">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="67720" _type="Insert" date="Mon Dec 23 23:30:54 EST 2019" docASTNodeCount="1" docActiveCodeLength="613" docExpressionCount="0" docLength="701" length="1" offset="443" starttimestamp="1576666505112" timestamp="495349648">
    <text><![CDATA[s]]></text>
  </DocumentChange>
  <DocumentChange __id="67722" _type="Insert" date="Mon Dec 23 23:30:54 EST 2019" docASTNodeCount="1" docActiveCodeLength="614" docExpressionCount="0" docLength="702" length="1" offset="444" starttimestamp="1576666505112" timestamp="495349756">
    <text><![CDATA[h]]></text>
  </DocumentChange>
  <DocumentChange __id="67724" _type="Insert" date="Mon Dec 23 23:30:55 EST 2019" docASTNodeCount="1" docActiveCodeLength="615" docExpressionCount="0" docLength="703" length="1" offset="445" starttimestamp="1576666505112" timestamp="495349915">
    <text><![CDATA[a]]></text>
  </DocumentChange>
  <DocumentChange __id="67726" _type="Insert" date="Mon Dec 23 23:30:55 EST 2019" docASTNodeCount="1" docActiveCodeLength="616" docExpressionCount="0" docLength="704" length="1" offset="446" starttimestamp="1576666505112" timestamp="495350115">
    <text><![CDATA[r]]></text>
  </DocumentChange>
  <DocumentChange __id="67728" _type="Insert" date="Mon Dec 23 23:30:55 EST 2019" docASTNodeCount="1" docActiveCodeLength="617" docExpressionCount="0" docLength="705" length="1" offset="447" starttimestamp="1576666505112" timestamp="495350188">
    <text><![CDATA[e]]></text>
  </DocumentChange>
  <DocumentChange __id="67730" _type="Insert" date="Mon Dec 23 23:30:55 EST 2019" docASTNodeCount="1" docActiveCodeLength="618" docExpressionCount="0" docLength="706" length="1" offset="448" starttimestamp="1576666505112" timestamp="495350358">
    <text><![CDATA[d]]></text>
  </DocumentChange>
  <DocumentChange __id="67732" _type="Insert" date="Mon Dec 23 23:30:56 EST 2019" docASTNodeCount="1" docActiveCodeLength="620" docExpressionCount="0" docLength="708" length="2" offset="449" starttimestamp="1576666505112" timestamp="495351669">
    <text><![CDATA[()]]></text>
  </DocumentChange>
  <DocumentChange __id="67734" _type="Insert" date="Mon Dec 23 23:30:57 EST 2019" docASTNodeCount="1" docActiveCodeLength="621" docExpressionCount="0" docLength="709" length="1" offset="450" starttimestamp="1576666505112" timestamp="495351944">
    <text><![CDATA[s]]></text>
  </DocumentChange>
  <DocumentChange __id="67736" _type="Insert" date="Mon Dec 23 23:30:57 EST 2019" docASTNodeCount="1" docActiveCodeLength="622" docExpressionCount="0" docLength="710" length="1" offset="451" starttimestamp="1576666505112" timestamp="495352178">
    <text><![CDATA[u]]></text>
  </DocumentChange>
  <DocumentChange __id="67738" _type="Insert" date="Mon Dec 23 23:30:57 EST 2019" docASTNodeCount="1" docActiveCodeLength="623" docExpressionCount="0" docLength="711" length="1" offset="452" starttimestamp="1576666505112" timestamp="495352569">
    <text><![CDATA[m]]></text>
  </DocumentChange>
  <DocumentChange __id="67740" _type="Insert" date="Mon Dec 23 23:30:58 EST 2019" docASTNodeCount="1" docActiveCodeLength="624" docExpressionCount="0" docLength="712" length="1" offset="453" starttimestamp="1576666505112" timestamp="495353817">
    <text><![CDATA[,]]></text>
  </DocumentChange>
  <DocumentChange __id="67742" _type="Insert" date="Mon Dec 23 23:30:59 EST 2019" docASTNodeCount="1" docActiveCodeLength="625" docExpressionCount="0" docLength="713" length="1" offset="454" starttimestamp="1576666505112" timestamp="495354130">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="67744" _type="Insert" date="Mon Dec 23 23:30:59 EST 2019" docASTNodeCount="1" docActiveCodeLength="626" docExpressionCount="0" docLength="714" length="1" offset="455" starttimestamp="1576666505112" timestamp="495354280">
    <text><![CDATA[s]]></text>
  </DocumentChange>
  <DocumentChange __id="67746" _type="Insert" date="Mon Dec 23 23:30:59 EST 2019" docASTNodeCount="1" docActiveCodeLength="627" docExpressionCount="0" docLength="715" length="1" offset="456" starttimestamp="1576666505112" timestamp="495354505">
    <text><![CDATA[u]]></text>
  </DocumentChange>
  <DocumentChange __id="67748" _type="Insert" date="Mon Dec 23 23:30:59 EST 2019" docASTNodeCount="1" docActiveCodeLength="628" docExpressionCount="0" docLength="716" length="1" offset="457" starttimestamp="1576666505112" timestamp="495354780">
    <text><![CDATA[m]]></text>
  </DocumentChange>
  <Command __id="67717" _type="MoveCaretCommand" caretOffset="442" date="Mon Dec 23 23:30:54 EST 2019" docOffset="442" starttimestamp="1576666505112" timestamp="495348984" />
  <Command __id="67719" _type="InsertStringCommand" date="Mon Dec 23 23:30:54 EST 2019" starttimestamp="1576666505112" timestamp="495349418" timestamp2="495349418">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="67721" _type="InsertStringCommand" date="Mon Dec 23 23:30:54 EST 2019" starttimestamp="1576666505112" timestamp="495349657" timestamp2="495349657">
    <data><![CDATA[s]]></data>
  </Command>
  <Command __id="67723" _type="InsertStringCommand" date="Mon Dec 23 23:30:54 EST 2019" starttimestamp="1576666505112" timestamp="495349761" timestamp2="495349761">
    <data><![CDATA[h]]></data>
  </Command>
  <Command __id="67725" _type="InsertStringCommand" date="Mon Dec 23 23:30:55 EST 2019" starttimestamp="1576666505112" timestamp="495349918" timestamp2="495349918">
    <data><![CDATA[a]]></data>
  </Command>
  <Command __id="67727" _type="InsertStringCommand" date="Mon Dec 23 23:30:55 EST 2019" starttimestamp="1576666505112" timestamp="495350127" timestamp2="495350127">
    <data><![CDATA[r]]></data>
  </Command>
  <Command __id="67729" _type="InsertStringCommand" date="Mon Dec 23 23:30:55 EST 2019" starttimestamp="1576666505112" timestamp="495350201" timestamp2="495350201">
    <data><![CDATA[e]]></data>
  </Command>
  <Command __id="67731" _type="InsertStringCommand" date="Mon Dec 23 23:30:55 EST 2019" starttimestamp="1576666505112" timestamp="495350368" timestamp2="495350368">
    <data><![CDATA[d]]></data>
  </Command>
  <Command __id="67733" _type="InsertStringCommand" date="Mon Dec 23 23:30:56 EST 2019" starttimestamp="1576666505112" timestamp="495351678" timestamp2="495351678">
    <data><![CDATA[(]]></data>
  </Command>
  <Command __id="67735" _type="InsertStringCommand" date="Mon Dec 23 23:30:57 EST 2019" starttimestamp="1576666505112" timestamp="495351948" timestamp2="495351948">
    <data><![CDATA[s]]></data>
  </Command>
  <Command __id="67737" _type="InsertStringCommand" date="Mon Dec 23 23:30:57 EST 2019" starttimestamp="1576666505112" timestamp="495352184" timestamp2="495352184">
    <data><![CDATA[u]]></data>
  </Command>
  <Command __id="67739" _type="InsertStringCommand" date="Mon Dec 23 23:30:57 EST 2019" starttimestamp="1576666505112" timestamp="495352571" timestamp2="495352571">
    <data><![CDATA[m]]></data>
  </Command>
  <Command __id="67741" _type="InsertStringCommand" date="Mon Dec 23 23:30:58 EST 2019" starttimestamp="1576666505112" timestamp="495353820" timestamp2="495353820">
    <data><![CDATA[,]]></data>
  </Command>
  <Command __id="67743" _type="InsertStringCommand" date="Mon Dec 23 23:30:59 EST 2019" starttimestamp="1576666505112" timestamp="495354135" timestamp2="495354135">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="67745" _type="InsertStringCommand" date="Mon Dec 23 23:30:59 EST 2019" starttimestamp="1576666505112" timestamp="495354284" timestamp2="495354284">
    <data><![CDATA[s]]></data>
  </Command>
  <Command __id="67747" _type="InsertStringCommand" date="Mon Dec 23 23:30:59 EST 2019" starttimestamp="1576666505112" timestamp="495354512" timestamp2="495354512">
    <data><![CDATA[u]]></data>
  </Command>
  <Command __id="67749" _type="InsertStringCommand" date="Mon Dec 23 23:30:59 EST 2019" starttimestamp="1576666505112" timestamp="495354784" timestamp2="495354784">
    <data><![CDATA[m]]></data>
  </Command>
  <Command __id="67751" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Mon Dec 23 23:31:01 EST 2019" starttimestamp="1576666505112" timestamp="495356000" />
  <Command __id="67753" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Mon Dec 23 23:31:01 EST 2019" starttimestamp="1576666505112" timestamp="495356159" />
  <Command __id="67755" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Mon Dec 23 23:31:01 EST 2019" starttimestamp="1576666505112" timestamp="495356335" />
  <Command __id="67757" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Mon Dec 23 23:31:01 EST 2019" starttimestamp="1576666505112" timestamp="495356500" />
  <Command __id="67759" _type="InsertStringCommand" date="Mon Dec 23 23:31:02 EST 2019" starttimestamp="1576666505112" timestamp="495357181" timestamp2="495357181">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="67761" _type="InsertStringCommand" date="Mon Dec 23 23:31:02 EST 2019" starttimestamp="1576666505112" timestamp="495357302" timestamp2="495357302">
    <data><![CDATA[s]]></data>
  </Command>
  <Command __id="67763" _type="InsertStringCommand" date="Mon Dec 23 23:31:02 EST 2019" starttimestamp="1576666505112" timestamp="495357522" timestamp2="495357522">
    <data><![CDATA[r]]></data>
  </Command>
  <Command __id="67765" _type="InsertStringCommand" date="Mon Dec 23 23:31:02 EST 2019" starttimestamp="1576666505112" timestamp="495357528" timestamp2="495357528">
    <data><![CDATA[t]]></data>
  </Command>
  <Command __id="67767" _type="InsertStringCommand" date="Mon Dec 23 23:31:02 EST 2019" starttimestamp="1576666505112" timestamp="495357575" timestamp2="495357575">
    <data><![CDATA[a]]></data>
  </Command>
  <Command __id="67769" _type="InsertStringCommand" date="Mon Dec 23 23:31:02 EST 2019" starttimestamp="1576666505112" timestamp="495357717" timestamp2="495357717">
    <data><![CDATA[r]]></data>
  </Command>
  <Command __id="67771" _type="InsertStringCommand" date="Mon Dec 23 23:31:03 EST 2019" starttimestamp="1576666505112" timestamp="495357936" timestamp2="495357936">
    <data><![CDATA[t]]></data>
  </Command>
  <Command __id="67773" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Mon Dec 23 23:31:03 EST 2019" starttimestamp="1576666505112" timestamp="495358442" />
  <Command __id="67775" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Mon Dec 23 23:31:03 EST 2019" starttimestamp="1576666505112" timestamp="495358595" />
  <Command __id="67777" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Mon Dec 23 23:31:03 EST 2019" starttimestamp="1576666505112" timestamp="495358757" />
  <Command __id="67779" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Mon Dec 23 23:31:04 EST 2019" starttimestamp="1576666505112" timestamp="495358927" />
  <Command __id="67781" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Mon Dec 23 23:31:04 EST 2019" starttimestamp="1576666505112" timestamp="495359357" />
  <Command __id="67783" _type="InsertStringCommand" date="Mon Dec 23 23:31:05 EST 2019" starttimestamp="1576666505112" timestamp="495359895" timestamp2="495359895">
    <data><![CDATA[t]]></data>
  </Command>
  <Command __id="67785" _type="InsertStringCommand" date="Mon Dec 23 23:31:05 EST 2019" starttimestamp="1576666505112" timestamp="495359969" timestamp2="495359969">
    <data><![CDATA[a]]></data>
  </Command>
  <Command __id="67787" _type="InsertStringCommand" date="Mon Dec 23 23:31:05 EST 2019" starttimestamp="1576666505112" timestamp="495360162" timestamp2="495360162">
    <data><![CDATA[r]]></data>
  </Command>
  <Command __id="67789" _type="InsertStringCommand" date="Mon Dec 23 23:31:05 EST 2019" starttimestamp="1576666505112" timestamp="495360378" timestamp2="495360378">
    <data><![CDATA[t]]></data>
  </Command>
  <Command __id="67790" _type="MoveCaretCommand" caretOffset="461" date="Mon Dec 23 23:31:08 EST 2019" docOffset="461" starttimestamp="1576666505112" timestamp="495362894" />
  <Command __id="67791" _type="MoveCaretCommand" caretOffset="449" date="Mon Dec 23 23:31:16 EST 2019" docOffset="449" starttimestamp="1576666505112" timestamp="495371048" />
  <Command __id="67793" _type="InsertStringCommand" date="Mon Dec 23 23:31:16 EST 2019" starttimestamp="1576666505112" timestamp="495371443" timestamp2="495371443">
    <data><![CDATA[ ]]></data>
  </Command>
  <DocumentChange __id="67750" _type="Delete" date="Mon Dec 23 23:31:01 EST 2019" docASTNodeCount="1" docActiveCodeLength="627" docExpressionCount="0" docLength="715" endLine="20" length="1" offset="457" startLine="20" starttimestamp="1576666505112" timestamp="495355991">
    <text><![CDATA[m]]></text>
  </DocumentChange>
  <DocumentChange __id="67752" _type="Delete" date="Mon Dec 23 23:31:01 EST 2019" docASTNodeCount="1" docActiveCodeLength="626" docExpressionCount="0" docLength="714" endLine="20" length="1" offset="456" startLine="20" starttimestamp="1576666505112" timestamp="495356151">
    <text><![CDATA[u]]></text>
  </DocumentChange>
  <DocumentChange __id="67754" _type="Delete" date="Mon Dec 23 23:31:01 EST 2019" docASTNodeCount="1" docActiveCodeLength="625" docExpressionCount="0" docLength="713" endLine="20" length="1" offset="455" startLine="20" starttimestamp="1576666505112" timestamp="495356329">
    <text><![CDATA[s]]></text>
  </DocumentChange>
  <DocumentChange __id="67756" _type="Delete" date="Mon Dec 23 23:31:01 EST 2019" docASTNodeCount="1" docActiveCodeLength="624" docExpressionCount="0" docLength="712" endLine="20" length="1" offset="454" startLine="20" starttimestamp="1576666505112" timestamp="495356496">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="67758" _type="Insert" date="Mon Dec 23 23:31:02 EST 2019" docASTNodeCount="1" docActiveCodeLength="625" docExpressionCount="0" docLength="713" length="1" offset="454" starttimestamp="1576666505112" timestamp="495357177">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="67760" _type="Insert" date="Mon Dec 23 23:31:02 EST 2019" docASTNodeCount="1" docActiveCodeLength="626" docExpressionCount="0" docLength="714" length="1" offset="455" starttimestamp="1576666505112" timestamp="495357298">
    <text><![CDATA[s]]></text>
  </DocumentChange>
  <DocumentChange __id="67762" _type="Insert" date="Mon Dec 23 23:31:02 EST 2019" docASTNodeCount="1" docActiveCodeLength="627" docExpressionCount="0" docLength="715" length="1" offset="456" starttimestamp="1576666505112" timestamp="495357516">
    <text><![CDATA[r]]></text>
  </DocumentChange>
  <DocumentChange __id="67764" _type="Insert" date="Mon Dec 23 23:31:02 EST 2019" docASTNodeCount="1" docActiveCodeLength="628" docExpressionCount="0" docLength="716" length="1" offset="457" starttimestamp="1576666505112" timestamp="495357526">
    <text><![CDATA[t]]></text>
  </DocumentChange>
  <DocumentChange __id="67766" _type="Insert" date="Mon Dec 23 23:31:02 EST 2019" docASTNodeCount="1" docActiveCodeLength="629" docExpressionCount="0" docLength="717" length="1" offset="458" starttimestamp="1576666505112" timestamp="495357569">
    <text><![CDATA[a]]></text>
  </DocumentChange>
  <DocumentChange __id="67768" _type="Insert" date="Mon Dec 23 23:31:02 EST 2019" docASTNodeCount="1" docActiveCodeLength="630" docExpressionCount="0" docLength="718" length="1" offset="459" starttimestamp="1576666505112" timestamp="495357709">
    <text><![CDATA[r]]></text>
  </DocumentChange>
  <DocumentChange __id="67770" _type="Insert" date="Mon Dec 23 23:31:03 EST 2019" docASTNodeCount="1" docActiveCodeLength="631" docExpressionCount="0" docLength="719" length="1" offset="460" starttimestamp="1576666505112" timestamp="495357926">
    <text><![CDATA[t]]></text>
  </DocumentChange>
  <DocumentChange __id="67772" _type="Delete" date="Mon Dec 23 23:31:03 EST 2019" docASTNodeCount="1" docActiveCodeLength="630" docExpressionCount="0" docLength="718" endLine="20" length="1" offset="460" startLine="20" starttimestamp="1576666505112" timestamp="495358435">
    <text><![CDATA[t]]></text>
  </DocumentChange>
  <DocumentChange __id="67774" _type="Delete" date="Mon Dec 23 23:31:03 EST 2019" docASTNodeCount="1" docActiveCodeLength="629" docExpressionCount="0" docLength="717" endLine="20" length="1" offset="459" startLine="20" starttimestamp="1576666505112" timestamp="495358587">
    <text><![CDATA[r]]></text>
  </DocumentChange>
  <DocumentChange __id="67776" _type="Delete" date="Mon Dec 23 23:31:03 EST 2019" docASTNodeCount="1" docActiveCodeLength="628" docExpressionCount="0" docLength="716" endLine="20" length="1" offset="458" startLine="20" starttimestamp="1576666505112" timestamp="495358753">
    <text><![CDATA[a]]></text>
  </DocumentChange>
  <DocumentChange __id="67778" _type="Delete" date="Mon Dec 23 23:31:04 EST 2019" docASTNodeCount="1" docActiveCodeLength="627" docExpressionCount="0" docLength="715" endLine="20" length="1" offset="457" startLine="20" starttimestamp="1576666505112" timestamp="495358924">
    <text><![CDATA[t]]></text>
  </DocumentChange>
  <DocumentChange __id="67780" _type="Delete" date="Mon Dec 23 23:31:04 EST 2019" docASTNodeCount="1" docActiveCodeLength="626" docExpressionCount="0" docLength="714" endLine="20" length="1" offset="456" startLine="20" starttimestamp="1576666505112" timestamp="495359354">
    <text><![CDATA[r]]></text>
  </DocumentChange>
  <DocumentChange __id="67782" _type="Insert" date="Mon Dec 23 23:31:05 EST 2019" docASTNodeCount="1" docActiveCodeLength="627" docExpressionCount="0" docLength="715" length="1" offset="456" starttimestamp="1576666505112" timestamp="495359893">
    <text><![CDATA[t]]></text>
  </DocumentChange>
  <DocumentChange __id="67784" _type="Insert" date="Mon Dec 23 23:31:05 EST 2019" docASTNodeCount="1" docActiveCodeLength="628" docExpressionCount="0" docLength="716" length="1" offset="457" starttimestamp="1576666505112" timestamp="495359965">
    <text><![CDATA[a]]></text>
  </DocumentChange>
  <DocumentChange __id="67786" _type="Insert" date="Mon Dec 23 23:31:05 EST 2019" docASTNodeCount="1" docActiveCodeLength="629" docExpressionCount="0" docLength="717" length="1" offset="458" starttimestamp="1576666505112" timestamp="495360157">
    <text><![CDATA[r]]></text>
  </DocumentChange>
  <DocumentChange __id="67788" _type="Insert" date="Mon Dec 23 23:31:05 EST 2019" docASTNodeCount="1" docActiveCodeLength="630" docExpressionCount="0" docLength="718" length="1" offset="459" starttimestamp="1576666505112" timestamp="495360372">
    <text><![CDATA[t]]></text>
  </DocumentChange>
  <DocumentChange __id="67792" _type="Insert" date="Mon Dec 23 23:31:16 EST 2019" docASTNodeCount="1" docActiveCodeLength="631" docExpressionCount="0" docLength="719" length="1" offset="449" starttimestamp="1576666505112" timestamp="495371438">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="67795" _type="Insert" date="Mon Dec 23 23:31:18 EST 2019" docASTNodeCount="1" docActiveCodeLength="632" docExpressionCount="0" docLength="720" length="1" offset="462" starttimestamp="1576666505112" timestamp="495373737">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="67797" _type="Insert" date="Mon Dec 23 23:31:19 EST 2019" docASTNodeCount="1" docActiveCodeLength="633" docExpressionCount="0" docLength="721" length="1" offset="463" starttimestamp="1576666505112" timestamp="495374128">
    <text><![CDATA[p]]></text>
  </DocumentChange>
  <DocumentChange __id="67799" _type="Insert" date="Mon Dec 23 23:31:19 EST 2019" docASTNodeCount="1" docActiveCodeLength="634" docExpressionCount="0" docLength="722" length="1" offset="464" starttimestamp="1576666505112" timestamp="495374277">
    <text><![CDATA[r]]></text>
  </DocumentChange>
  <Command __id="67794" _type="MoveCaretCommand" caretOffset="462" date="Mon Dec 23 23:31:18 EST 2019" docOffset="462" starttimestamp="1576666505112" timestamp="495372892" />
  <Command __id="67796" _type="InsertStringCommand" date="Mon Dec 23 23:31:18 EST 2019" starttimestamp="1576666505112" timestamp="495373750" timestamp2="495373750">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="67798" _type="InsertStringCommand" date="Mon Dec 23 23:31:19 EST 2019" starttimestamp="1576666505112" timestamp="495374137" timestamp2="495374137">
    <data><![CDATA[p]]></data>
  </Command>
  <Command __id="67800" _type="InsertStringCommand" date="Mon Dec 23 23:31:19 EST 2019" starttimestamp="1576666505112" timestamp="495374282" timestamp2="495374282">
    <data><![CDATA[r]]></data>
  </Command>
  <Command __id="67802" _type="InsertStringCommand" date="Mon Dec 23 23:31:19 EST 2019" starttimestamp="1576666505112" timestamp="495374436" timestamp2="495374436">
    <data><![CDATA[i]]></data>
  </Command>
  <Command __id="67804" _type="InsertStringCommand" date="Mon Dec 23 23:31:20 EST 2019" starttimestamp="1576666505112" timestamp="495375203" timestamp2="495375203">
    <data><![CDATA[v]]></data>
  </Command>
  <Command __id="67806" _type="InsertStringCommand" date="Mon Dec 23 23:31:20 EST 2019" starttimestamp="1576666505112" timestamp="495375421" timestamp2="495375421">
    <data><![CDATA[a]]></data>
  </Command>
  <Command __id="67808" _type="InsertStringCommand" date="Mon Dec 23 23:31:20 EST 2019" starttimestamp="1576666505112" timestamp="495375571" timestamp2="495375571">
    <data><![CDATA[t]]></data>
  </Command>
  <Command __id="67810" _type="InsertStringCommand" date="Mon Dec 23 23:31:20 EST 2019" starttimestamp="1576666505112" timestamp="495375707" timestamp2="495375707">
    <data><![CDATA[e]]></data>
  </Command>
  <Command __id="67812" _type="InsertStringCommand" date="Mon Dec 23 23:31:21 EST 2019" starttimestamp="1576666505112" timestamp="495376483" timestamp2="495376483">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="67814" _type="InsertStringCommand" date="Mon Dec 23 23:31:22 EST 2019" starttimestamp="1576666505112" timestamp="495377122" timestamp2="495377122">
    <data><![CDATA[(]]></data>
  </Command>
  <Command __id="67816" _type="InsertStringCommand" date="Mon Dec 23 23:31:22 EST 2019" starttimestamp="1576666505112" timestamp="495377571" timestamp2="495377571">
    <data><![CDATA[s]]></data>
  </Command>
  <Command __id="67818" _type="InsertStringCommand" date="Mon Dec 23 23:31:22 EST 2019" starttimestamp="1576666505112" timestamp="495377835" timestamp2="495377835">
    <data><![CDATA[u]]></data>
  </Command>
  <Command __id="67820" _type="InsertStringCommand" date="Mon Dec 23 23:31:23 EST 2019" starttimestamp="1576666505112" timestamp="495378213" timestamp2="495378213">
    <data><![CDATA[,]]></data>
  </Command>
  <Command __id="67822" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Mon Dec 23 23:31:23 EST 2019" starttimestamp="1576666505112" timestamp="495378833" />
  <Command __id="67824" _type="InsertStringCommand" date="Mon Dec 23 23:31:24 EST 2019" starttimestamp="1576666505112" timestamp="495379345" timestamp2="495379345">
    <data><![CDATA[m]]></data>
  </Command>
  <Command __id="67826" _type="InsertStringCommand" date="Mon Dec 23 23:31:25 EST 2019" starttimestamp="1576666505112" timestamp="495380146" timestamp2="495380146">
    <data><![CDATA[,]]></data>
  </Command>
  <Command __id="67828" _type="InsertStringCommand" date="Mon Dec 23 23:31:25 EST 2019" starttimestamp="1576666505112" timestamp="495380397" timestamp2="495380397">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="67830" _type="InsertStringCommand" date="Mon Dec 23 23:31:25 EST 2019" starttimestamp="1576666505112" timestamp="495380559" timestamp2="495380559">
    <data><![CDATA[s]]></data>
  </Command>
  <Command __id="67832" _type="InsertStringCommand" date="Mon Dec 23 23:31:25 EST 2019" starttimestamp="1576666505112" timestamp="495380749" timestamp2="495380749">
    <data><![CDATA[t]]></data>
  </Command>
  <Command __id="67834" _type="InsertStringCommand" date="Mon Dec 23 23:31:25 EST 2019" starttimestamp="1576666505112" timestamp="495380829" timestamp2="495380829">
    <data><![CDATA[a]]></data>
  </Command>
  <Command __id="67836" _type="InsertStringCommand" date="Mon Dec 23 23:31:26 EST 2019" starttimestamp="1576666505112" timestamp="495380972" timestamp2="495380972">
    <data><![CDATA[r]]></data>
  </Command>
  <Command __id="67838" _type="InsertStringCommand" date="Mon Dec 23 23:31:26 EST 2019" starttimestamp="1576666505112" timestamp="495381194" timestamp2="495381194">
    <data><![CDATA[t]]></data>
  </Command>
  <Command __id="67839" _type="EclipseCommand" commandID="org.eclipse.ui.file.save" date="Mon Dec 23 23:31:28 EST 2019" starttimestamp="1576666505112" timestamp="495382966" />
  <Command __id="67840" _type="EclipseCommand" commandID="org.eclipse.debug.ui.commands.RunLast" date="Mon Dec 23 23:31:31 EST 2019" starttimestamp="1576666505112" timestamp="495386500" />
  <Command __id="67841" _type="ShellCommand" date="Mon Dec 23 23:31:34 EST 2019" starttimestamp="1576666505112" timestamp="495389535" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="67842" _type="ShellCommand" date="Mon Dec 23 23:31:36 EST 2019" starttimestamp="1576666505112" timestamp="495391476" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="67843" _type="MoveCaretCommand" caretOffset="417" date="Mon Dec 23 23:31:42 EST 2019" docOffset="417" starttimestamp="1576666505112" timestamp="495397484" />
  <Command __id="67844" _type="MoveCaretCommand" caretOffset="476" date="Mon Dec 23 23:31:43 EST 2019" docOffset="476" starttimestamp="1576666505112" timestamp="495398344" />
  <DocumentChange __id="67801" _type="Insert" date="Mon Dec 23 23:31:19 EST 2019" docASTNodeCount="1" docActiveCodeLength="635" docExpressionCount="0" docLength="723" length="1" offset="465" starttimestamp="1576666505112" timestamp="495374421">
    <text><![CDATA[i]]></text>
  </DocumentChange>
  <DocumentChange __id="67803" _type="Insert" date="Mon Dec 23 23:31:20 EST 2019" docASTNodeCount="1" docActiveCodeLength="636" docExpressionCount="0" docLength="724" length="1" offset="466" starttimestamp="1576666505112" timestamp="495375198">
    <text><![CDATA[v]]></text>
  </DocumentChange>
  <DocumentChange __id="67805" _type="Insert" date="Mon Dec 23 23:31:20 EST 2019" docASTNodeCount="1" docActiveCodeLength="637" docExpressionCount="0" docLength="725" length="1" offset="467" starttimestamp="1576666505112" timestamp="495375412">
    <text><![CDATA[a]]></text>
  </DocumentChange>
  <DocumentChange __id="67807" _type="Insert" date="Mon Dec 23 23:31:20 EST 2019" docASTNodeCount="1" docActiveCodeLength="638" docExpressionCount="0" docLength="726" length="1" offset="468" starttimestamp="1576666505112" timestamp="495375562">
    <text><![CDATA[t]]></text>
  </DocumentChange>
  <DocumentChange __id="67809" _type="Insert" date="Mon Dec 23 23:31:20 EST 2019" docASTNodeCount="1" docActiveCodeLength="639" docExpressionCount="0" docLength="727" length="1" offset="469" starttimestamp="1576666505112" timestamp="495375698">
    <text><![CDATA[e]]></text>
  </DocumentChange>
  <DocumentChange __id="67811" _type="Insert" date="Mon Dec 23 23:31:21 EST 2019" docASTNodeCount="1" docActiveCodeLength="640" docExpressionCount="0" docLength="728" length="1" offset="470" starttimestamp="1576666505112" timestamp="495376479">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="67813" _type="Insert" date="Mon Dec 23 23:31:22 EST 2019" docASTNodeCount="1" docActiveCodeLength="642" docExpressionCount="0" docLength="730" length="2" offset="471" starttimestamp="1576666505112" timestamp="495377121">
    <text><![CDATA[()]]></text>
  </DocumentChange>
  <DocumentChange __id="67815" _type="Insert" date="Mon Dec 23 23:31:22 EST 2019" docASTNodeCount="1" docActiveCodeLength="643" docExpressionCount="0" docLength="731" length="1" offset="472" starttimestamp="1576666505112" timestamp="495377569">
    <text><![CDATA[s]]></text>
  </DocumentChange>
  <DocumentChange __id="67817" _type="Insert" date="Mon Dec 23 23:31:22 EST 2019" docASTNodeCount="1" docActiveCodeLength="644" docExpressionCount="0" docLength="732" length="1" offset="473" starttimestamp="1576666505112" timestamp="495377833">
    <text><![CDATA[u]]></text>
  </DocumentChange>
  <DocumentChange __id="67819" _type="Insert" date="Mon Dec 23 23:31:23 EST 2019" docASTNodeCount="1" docActiveCodeLength="645" docExpressionCount="0" docLength="733" length="1" offset="474" starttimestamp="1576666505112" timestamp="495378210">
    <text><![CDATA[,]]></text>
  </DocumentChange>
  <DocumentChange __id="67821" _type="Delete" date="Mon Dec 23 23:31:23 EST 2019" docASTNodeCount="1" docActiveCodeLength="644" docExpressionCount="0" docLength="732" endLine="20" length="1" offset="474" startLine="20" starttimestamp="1576666505112" timestamp="495378827">
    <text><![CDATA[,]]></text>
  </DocumentChange>
  <DocumentChange __id="67823" _type="Insert" date="Mon Dec 23 23:31:24 EST 2019" docASTNodeCount="1" docActiveCodeLength="645" docExpressionCount="0" docLength="733" length="1" offset="474" starttimestamp="1576666505112" timestamp="495379340">
    <text><![CDATA[m]]></text>
  </DocumentChange>
  <DocumentChange __id="67825" _type="Insert" date="Mon Dec 23 23:31:25 EST 2019" docASTNodeCount="1" docActiveCodeLength="646" docExpressionCount="0" docLength="734" length="1" offset="475" starttimestamp="1576666505112" timestamp="495380144">
    <text><![CDATA[,]]></text>
  </DocumentChange>
  <DocumentChange __id="67827" _type="Insert" date="Mon Dec 23 23:31:25 EST 2019" docASTNodeCount="1" docActiveCodeLength="647" docExpressionCount="0" docLength="735" length="1" offset="476" starttimestamp="1576666505112" timestamp="495380390">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="67829" _type="Insert" date="Mon Dec 23 23:31:25 EST 2019" docASTNodeCount="1" docActiveCodeLength="648" docExpressionCount="0" docLength="736" length="1" offset="477" starttimestamp="1576666505112" timestamp="495380552">
    <text><![CDATA[s]]></text>
  </DocumentChange>
  <DocumentChange __id="67831" _type="Insert" date="Mon Dec 23 23:31:25 EST 2019" docASTNodeCount="1" docActiveCodeLength="649" docExpressionCount="0" docLength="737" length="1" offset="478" starttimestamp="1576666505112" timestamp="495380744">
    <text><![CDATA[t]]></text>
  </DocumentChange>
  <DocumentChange __id="67833" _type="Insert" date="Mon Dec 23 23:31:25 EST 2019" docASTNodeCount="1" docActiveCodeLength="650" docExpressionCount="0" docLength="738" length="1" offset="479" starttimestamp="1576666505112" timestamp="495380823">
    <text><![CDATA[a]]></text>
  </DocumentChange>
  <DocumentChange __id="67835" _type="Insert" date="Mon Dec 23 23:31:26 EST 2019" docASTNodeCount="1" docActiveCodeLength="651" docExpressionCount="0" docLength="739" length="1" offset="480" starttimestamp="1576666505112" timestamp="495380969">
    <text><![CDATA[r]]></text>
  </DocumentChange>
  <DocumentChange __id="67837" _type="Insert" date="Mon Dec 23 23:31:26 EST 2019" docASTNodeCount="1" docActiveCodeLength="652" docExpressionCount="0" docLength="740" length="1" offset="481" starttimestamp="1576666505112" timestamp="495381188">
    <text><![CDATA[t]]></text>
  </DocumentChange>
  <DocumentChange __id="67846" _type="Insert" date="Mon Dec 23 23:31:48 EST 2019" docASTNodeCount="1" docActiveCodeLength="654" docExpressionCount="0" docLength="742" length="2" offset="324" starttimestamp="1576666505112" timestamp="495403148">
    <text><![CDATA[
	]]></text>
  </DocumentChange>
  <DocumentChange __id="67848" _type="Insert" date="Mon Dec 23 23:31:48 EST 2019" docASTNodeCount="1" docActiveCodeLength="656" docExpressionCount="0" docLength="744" length="2" offset="326" starttimestamp="1576666505112" timestamp="495403674">
    <text><![CDATA[
	]]></text>
  </DocumentChange>
  <DocumentChange __id="67850" _type="Insert" date="Mon Dec 23 23:31:49 EST 2019" docASTNodeCount="1" docActiveCodeLength="657" docExpressionCount="0" docLength="745" length="1" offset="328" starttimestamp="1576666505112" timestamp="495404084">
    <text><![CDATA[i]]></text>
  </DocumentChange>
  <DocumentChange __id="67852" _type="Insert" date="Mon Dec 23 23:31:49 EST 2019" docASTNodeCount="1" docActiveCodeLength="658" docExpressionCount="0" docLength="746" length="1" offset="329" starttimestamp="1576666505112" timestamp="495404315">
    <text><![CDATA[n]]></text>
  </DocumentChange>
  <DocumentChange __id="67854" _type="Insert" date="Mon Dec 23 23:31:49 EST 2019" docASTNodeCount="1" docActiveCodeLength="659" docExpressionCount="0" docLength="747" length="1" offset="330" starttimestamp="1576666505112" timestamp="495404390">
    <text><![CDATA[t]]></text>
  </DocumentChange>
  <Command __id="67845" _type="MoveCaretCommand" caretOffset="324" date="Mon Dec 23 23:31:47 EST 2019" docOffset="324" starttimestamp="1576666505112" timestamp="495402627" />
  <Command __id="67847" _type="InsertStringCommand" date="Mon Dec 23 23:31:48 EST 2019" starttimestamp="1576666505112" timestamp="495403152" timestamp2="495403152">
    <data><![CDATA[]]></data>
  </Command>
  <Command __id="67849" _type="InsertStringCommand" date="Mon Dec 23 23:31:48 EST 2019" starttimestamp="1576666505112" timestamp="495403679" timestamp2="495403679">
    <data><![CDATA[]]></data>
  </Command>
  <Command __id="67851" _type="InsertStringCommand" date="Mon Dec 23 23:31:49 EST 2019" starttimestamp="1576666505112" timestamp="495404093" timestamp2="495404093">
    <data><![CDATA[i]]></data>
  </Command>
  <Command __id="67853" _type="InsertStringCommand" date="Mon Dec 23 23:31:49 EST 2019" starttimestamp="1576666505112" timestamp="495404324" timestamp2="495404324">
    <data><![CDATA[n]]></data>
  </Command>
  <Command __id="67855" _type="InsertStringCommand" date="Mon Dec 23 23:31:49 EST 2019" starttimestamp="1576666505112" timestamp="495404400" timestamp2="495404400">
    <data><![CDATA[t]]></data>
  </Command>
  <Command __id="67857" _type="InsertStringCommand" date="Mon Dec 23 23:31:50 EST 2019" starttimestamp="1576666505112" timestamp="495405073" timestamp2="495405073">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="67859" _type="InsertStringCommand" date="Mon Dec 23 23:31:50 EST 2019" starttimestamp="1576666505112" timestamp="495405795" timestamp2="495405795">
    <data><![CDATA[j]]></data>
  </Command>
  <Command __id="67861" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Mon Dec 23 23:31:51 EST 2019" starttimestamp="1576666505112" timestamp="495406506" />
  <Command __id="67863" _type="InsertStringCommand" date="Mon Dec 23 23:31:52 EST 2019" starttimestamp="1576666505112" timestamp="495406957" timestamp2="495406957">
    <data><![CDATA[a]]></data>
  </Command>
  <Command __id="67865" _type="InsertStringCommand" date="Mon Dec 23 23:31:52 EST 2019" starttimestamp="1576666505112" timestamp="495407310" timestamp2="495407310">
    <data><![CDATA[,]]></data>
  </Command>
  <Command __id="67867" _type="InsertStringCommand" date="Mon Dec 23 23:31:52 EST 2019" starttimestamp="1576666505112" timestamp="495407496" timestamp2="495407496">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="67869" _type="InsertStringCommand" date="Mon Dec 23 23:31:52 EST 2019" starttimestamp="1576666505112" timestamp="495407801" timestamp2="495407801">
    <data><![CDATA[b]]></data>
  </Command>
  <Command __id="67870" _type="MoveCaretCommand" caretOffset="486" date="Mon Dec 23 23:31:55 EST 2019" docOffset="486" starttimestamp="1576666505112" timestamp="495410010" />
  <Command __id="67871" _type="SelectTextCommand" caretOffset="487" date="Mon Dec 23 23:31:55 EST 2019" end="487" start="484" starttimestamp="1576666505112" timestamp="495410284" />
  <Command __id="67873" _type="InsertStringCommand" date="Mon Dec 23 23:31:55 EST 2019" starttimestamp="1576666505112" timestamp="495410527" timestamp2="495410527">
    <data><![CDATA[a]]></data>
  </Command>
  <Command __id="67874" _type="MoveCaretCommand" caretOffset="489" date="Mon Dec 23 23:31:57 EST 2019" docOffset="489" starttimestamp="1576666505112" timestamp="495411962" />
  <Command __id="67875" _type="SelectTextCommand" caretOffset="492" date="Mon Dec 23 23:31:57 EST 2019" end="492" start="487" starttimestamp="1576666505112" timestamp="495412164" />
  <Command __id="67877" _type="InsertStringCommand" date="Mon Dec 23 23:31:57 EST 2019" starttimestamp="1576666505112" timestamp="495412562" timestamp2="495412562">
    <data><![CDATA[b]]></data>
  </Command>
  <Command __id="67879" _type="EclipseCommand" commandID="org.eclipse.ui.file.save" date="Mon Dec 23 23:31:58 EST 2019" starttimestamp="1576666505112" timestamp="495413567" />
  <Command __id="67880" _type="EclipseCommand" commandID="org.eclipse.debug.ui.commands.RunLast" date="Mon Dec 23 23:32:06 EST 2019" starttimestamp="1576666505112" timestamp="495421375" />
  <Command __id="67881" _type="ShellCommand" date="Mon Dec 23 23:32:06 EST 2019" starttimestamp="1576666505112" timestamp="495421817" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="67882" _type="ShellCommand" date="Mon Dec 23 23:32:08 EST 2019" starttimestamp="1576666505112" timestamp="495423297" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="67883" _type="MoveCaretCommand" caretOffset="335" date="Mon Dec 23 23:32:22 EST 2019" docOffset="335" starttimestamp="1576666505112" timestamp="495437115" />
  <Command __id="67885" _type="InsertStringCommand" date="Mon Dec 23 23:32:23 EST 2019" starttimestamp="1576666505112" timestamp="495437980" timestamp2="495437980">
    <data><![CDATA[;]]></data>
  </Command>
  <Command __id="67886" _type="EclipseCommand" commandID="org.eclipse.ui.file.save" date="Mon Dec 23 23:32:23 EST 2019" starttimestamp="1576666505112" timestamp="495438494" />
  <Command __id="67895" _type="RunCommand" date="Mon Dec 23 23:32:40 EST 2019" kind="HitBreakPoint" projectName="PL_Java" starttimestamp="1576666505112" timestamp="495455466" type="Run" />
  <Command __id="67896" _type="RunCommand" date="Mon Dec 23 23:32:40 EST 2019" kind="HitBreakPoint" projectName="PL_Java" starttimestamp="1576666505112" timestamp="495455466" type="Run" />
  <Command __id="67897" _type="RunCommand" date="Mon Dec 23 23:32:40 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="495455689" type="Run" />
  <Command __id="67898" _type="RunCommand" date="Mon Dec 23 23:32:40 EST 2019" kind="StepInto" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="495455853" type="Run" />
  <Command __id="67899" _type="RunCommand" date="Mon Dec 23 23:32:41 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="495456120" type="Run" />
  <Command __id="67900" _type="EHExceptionCommand" date="Mon Dec 23 23:32:41 EST 2019" starttimestamp="1576666505112" timestamp="495456243" type="Exception">
    <outputString><![CDATA[I***Tracer: showInfo = true
]]></outputString>
  </Command>
  <Command __id="67901" _type="EHExceptionCommand" date="Mon Dec 23 23:32:41 EST 2019" starttimestamp="1576666505112" timestamp="495456429" type="Exception">
    <outputString><![CDATA[Buffer traced nessages =false
]]></outputString>
  </Command>
  <Command __id="67902" _type="RunCommand" date="Mon Dec 23 23:32:42 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="495457380" type="Run" />
  <Command __id="67903" _type="RunCommand" date="Mon Dec 23 23:32:42 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="495457381" type="Run" />
  <Command __id="67904" _type="RunCommand" date="Mon Dec 23 23:32:42 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="495457383" type="Run" />
  <Command __id="67905" _type="RunCommand" date="Mon Dec 23 23:32:42 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="495457384" type="Run" />
  <Command __id="67906" _type="EHExceptionCommand" date="Mon Dec 23 23:32:43 EST 2019" starttimestamp="1576666505112" timestamp="495457934" type="Exception">
    <outputString><![CDATA[ObjectEditor(Version 22, built on Thu Dec 06 16:26:09 EST 2018). Copyright Prasun Dewan, 2012, All rights reserved. US Patent Appl. No.: 12/532,327
]]></outputString>
  </Command>
  <Command __id="67907" _type="ShellCommand" date="Mon Dec 23 23:32:43 EST 2019" starttimestamp="1576666505112" timestamp="495458616" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="67908" _type="EHExceptionCommand" date="Mon Dec 23 23:32:46 EST 2019" starttimestamp="1576666505112" timestamp="495460899" type="Exception">
    <outputString><![CDATA[I***(TestCaseResult) ### SequentialSumTestCase: 1.0
]]></outputString>
  </Command>
  <Command __id="67909" _type="RunCommand" date="Mon Dec 23 23:32:46 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="495460918" type="Run" />
  <Command __id="67910" _type="EHExceptionCommand" date="Mon Dec 23 23:32:46 EST 2019" starttimestamp="1576666505112" timestamp="495460954" type="Exception">
    <outputString><![CDATA[Returning first of multiple entry points:[MyOpenMPTraining.exe, OpenMPTraining.exe]
I***(BasicProcessRunner) Running command:D:\dewan_backup\C\MyOpenMPTraining\Debug\MyOpenMPTraining.exe
I***(BasicProcessRunner) Running in folder: D:\dewan_backup\C\MyOpenMPTraining\Debug
I***(BasicProcessRunner)  Process started: D:\dewan_backup\C\MyOpenMPTraining\Debug\MyOpenMPTraining.exe folder: D:\dewan_backup\C\MyOpenMPTraining\Debug entry point: null class path: D:\dewan_backup\Java\PLTeaching\PL_Java\bin;D:\dewan_backup\Java\lib\oeall22.jar;C:\Users\dewan\.p2\pool\plugins\org.junit_4.12.0.v201504281640\junit.jar;C:\Users\dewan\.p2\pool\plugins\org.hamcrest.core_1.3.0.v20180420-1519.jar;D:\dewan_backup\Java\GraderBasics\lib\commons-configuration-1.9.jar;D:\dewan_backup\Java\GraderBasics\lib\commons-lang-2.6.jar;D:\dewan_backup\Java\GraderBasics\lib\commons-logging-1.1.1.jar;G:\My Drive\Java\lib\Herrmes\lib\weka3_6.jar;D:\dewan_backup\Java\GraderBasics\target\classes;D:\dewan_backup\Java\DemoCourseLocalBasicChecks\bin
]]></outputString>
  </Command>
  <Command __id="67911" _type="RunCommand" date="Mon Dec 23 23:32:46 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="495460991" type="Run" />
  <Command __id="67912" _type="RunCommand" date="Mon Dec 23 23:32:46 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="495460994" type="Run" />
  <Command __id="67913" _type="EHExceptionCommand" date="Mon Dec 23 23:32:46 EST 2019" starttimestamp="1576666505112" timestamp="495461092" type="Exception">
    <outputString><![CDATA[I***(BasicRunningProject) 1577161966104:Received output from main: sum_sequential
I***(BasicRunningProject) 1577161966107:Processing line from main: sum_sequential
I***(BasicRunningProject) 1577161966108:Received output from main: Sum: 499500
I***(BasicRunningProject) 1577161966108:Processing line from main: Sum: 499500
I***(BasicRunningProject) 1577161966108:Received output from main: Took: 0
I***(BasicRunningProject) 1577161966108:Processing line from main: Took: 0
I***(BasicRunningProject) 1577161966108:Received output from main: thread:0 lastIndex:999
I***(BasicRunningProject) 1577161966108:Processing line from main: thread:0 lastIndex:999
I***(BasicRunningProject) 1577161966108:Received output from main: _____________________________
I***(BasicRunningProject) 1577161966109:Processing line from main: _____________________________
I***(BasicRunningProject) 1577161966109:Received output from main: sum_parallel_for_reduction
I***(BasicRunningProject) 1577161966109:Processing line from main: sum_parallel_for_reduction
I***(BasicRunningProject) 1577161966109:Received output from main: Sum: 499500
I***(BasicRunningProject) 1577161966109:Processing line from main: Sum: 499500
I***(BasicRunningProject) 1577161966109:Received output from main: Took: 0
I***(BasicRunningProject) 1577161966109:Processing line from main: Took: 0
I***(BasicRunningProject) 1577161966109:Received output from main: thread:0 lastIndex:124
I***(BasicRunningProject) 1577161966109:Processing line from main: thread:0 lastIndex:124
I***(BasicRunningProject) 1577161966110:Received output from main: thread:1 lastIndex:249
I***(BasicRunningProject) 1577161966110:Processing line from main: thread:1 lastIndex:249
I***(BasicRunningProject) 1577161966110:Received output from main: thread:2 lastIndex:374
I***(BasicRunningProject) 1577161966110:Processing line from main: thread:2 lastIndex:374
I***(BasicRunningProject) 1577161966110:Received output from main: thread:3 lastIndex:499
I***(BasicRunningProject) 1577161966110:Processing line from main: thread:3 lastIndex:499
I***(BasicRunningProject) 1577161966110:Received output from main: thread:4 lastIndex:624
I***(BasicRunningProject) 1577161966110:Processing line from main: thread:4 lastIndex:624
I***(BasicRunningProject) 1577161966110:Received output from main: thread:5 lastIndex:749
I***(BasicRunningProject) 1577161966110:Processing line from main: thread:5 lastIndex:749
I***(BasicRunningProject) 1577161966110:Received output from main: thread:6 lastIndex:874
I***(BasicRunningProject) 1577161966111:Processing line from main: thread:6 lastIndex:874
I***(BasicRunningProject) 1577161966111:Received output from main: thread:7 lastIndex:999
I***(BasicRunningProject) 1577161966111:Processing line from main: thread:7 lastIndex:999
I***(BasicRunningProject) 1577161966111:Received output from main: _____________________________
I***(BasicRunningProject) 1577161966111:Processing line from main: _____________________________
I***(BasicRunningProject) 1577161966111:Received output from main: sum_parallel_for_local_var
I***(BasicRunningProject) 1577161966111:Processing line from main: sum_parallel_for_local_var
I***(BasicRunningProject) 1577161966111:Received output from main: Sum: 499500
I***(BasicRunningProject) 1577161966111:Processing line from main: Sum: 499500
I***(BasicRunningProject) 1577161966112:Received output from main: Took: 0
I***(BasicRunningProject) 1577161966112:Processing line from main: Took: 0
I***(BasicRunningProject) 1577161966112:Received output from main: thread:0 lastIndex:124
I***(BasicRunningProject) 1577161966112:Processing line from main: thread:0 lastIndex:124
I***(BasicRunningProject) 1577161966112:Received output from main: thread:1 lastIndex:249
I***(BasicRunningProject) 1577161966112:Processing line from main: thread:1 lastIndex:249
I***(BasicRunningProject) 1577161966112:Received output from main: thread:2 lastIndex:374
I***(BasicRunningProject) 1577161966112:Processing line from main: thread:2 lastIndex:374
I***(BasicRunningProject) 1577161966112:Received output from main: thread:3 lastIndex:499
I***(BasicRunningProject) 1577161966113:Processing line from main: thread:3 lastIndex:499
I***(BasicRunningProject) 1577161966113:Received output from main: thread:4 lastIndex:624
I***(BasicRunningProject) 1577161966113:Processing line from main: thread:4 lastIndex:624
I***(BasicRunningProject) 1577161966113:Received output from main: thread:5 lastIndex:749
I***(BasicRunningProject) 1577161966121:Processing line from main: thread:5 lastIndex:749
I***(ARunnerInputStreamProcessor) Provided Input:
I***(BasicRunningProject) 1577161966121:Received output from main: thread:6 lastIndex:874
I***(BasicRunningProject) 1577161966121:Processing line from main: thread:6 lastIndex:874
I***(BasicRunningProject) 1577161966121:Received output from main: thread:7 lastIndex:999
I***(BasicRunningProject) 1577161966121:Processing line from main: thread:7 lastIndex:999
I***(BasicRunningProject) 1577161966122:Received output from main: _____________________________
I***(BasicRunningProject) 1577161966122:Processing line from main: _____________________________
I***(BasicRunningProject) 1577161966122:Received output from main: sum_parallel
I***(BasicRunningProject) 1577161966122:Processing line from main: sum_parallel
I***(BasicRunningProject) 1577161966122:Received output from main: Sum: 499500
I***(BasicRunningProject) 1577161966122:Processing line from main: Sum: 499500
I***(BasicRunningProject) 1577161966122:Received output from main: Took: 0
I***(BasicRunningProject) 1577161966122:Processing line from main: Took: 0
I***(BasicRunningProject) 1577161966122:Received output from main: _____________________________
I***(BasicRunningProject) 1577161966122:Processing line from main: _____________________________
I***(BasicProcessRunner)  Process finished; folder: D:\dewan_backup\C\MyOpenMPTraining\Debug entry point: null class path: D:\dewan_backup\Java\PLTeaching\PL_Java\bin;D:\dewan_backup\Java\lib\oeall22.jar;C:\Users\dewan\.p2\pool\plugins\org.junit_4.12.0.v201504281640\junit.jar;C:\Users\dewan\.p2\pool\plugins\org.hamcrest.core_1.3.0.v20180420-1519.jar;D:\dewan_backup\Java\GraderBasics\lib\commons-configuration-1.9.jar;D:\dewan_backup\Java\GraderBasics\lib\commons-lang-2.6.jar;D:\dewan_backup\Java\GraderBasics\lib\commons-logging-1.1.1.jar;G:\My Drive\Java\lib\Herrmes\lib\weka3_6.jar;D:\dewan_backup\Java\GraderBasics\target\classes;D:\dewan_backup\Java\DemoCourseLocalBasicChecks\bin
I***(BasicRunningProject) Thread[AWT-EventQueue-0,6,main] sleeping for ms:2000 waiting for pending output from threads 
]]></outputString>
  </Command>
  <DocumentChange __id="67856" _type="Insert" date="Mon Dec 23 23:31:50 EST 2019" docASTNodeCount="1" docActiveCodeLength="660" docExpressionCount="0" docLength="748" length="1" offset="331" starttimestamp="1576666505112" timestamp="495405070">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="67858" _type="Insert" date="Mon Dec 23 23:31:50 EST 2019" docASTNodeCount="1" docActiveCodeLength="661" docExpressionCount="0" docLength="749" length="1" offset="332" starttimestamp="1576666505112" timestamp="495405786">
    <text><![CDATA[j]]></text>
  </DocumentChange>
  <DocumentChange __id="67860" _type="Delete" date="Mon Dec 23 23:31:51 EST 2019" docASTNodeCount="1" docActiveCodeLength="660" docExpressionCount="0" docLength="748" endLine="16" length="1" offset="332" startLine="16" starttimestamp="1576666505112" timestamp="495406502">
    <text><![CDATA[j]]></text>
  </DocumentChange>
  <DocumentChange __id="67862" _type="Insert" date="Mon Dec 23 23:31:52 EST 2019" docASTNodeCount="1" docActiveCodeLength="661" docExpressionCount="0" docLength="749" length="1" offset="332" starttimestamp="1576666505112" timestamp="495406951">
    <text><![CDATA[a]]></text>
  </DocumentChange>
  <DocumentChange __id="67864" _type="Insert" date="Mon Dec 23 23:31:52 EST 2019" docASTNodeCount="1" docActiveCodeLength="662" docExpressionCount="0" docLength="750" length="1" offset="333" starttimestamp="1576666505112" timestamp="495407300">
    <text><![CDATA[,]]></text>
  </DocumentChange>
  <DocumentChange __id="67866" _type="Insert" date="Mon Dec 23 23:31:52 EST 2019" docASTNodeCount="1" docActiveCodeLength="663" docExpressionCount="0" docLength="751" length="1" offset="334" starttimestamp="1576666505112" timestamp="495407489">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="67868" _type="Insert" date="Mon Dec 23 23:31:52 EST 2019" docASTNodeCount="1" docActiveCodeLength="664" docExpressionCount="0" docLength="752" length="1" offset="335" starttimestamp="1576666505112" timestamp="495407791">
    <text><![CDATA[b]]></text>
  </DocumentChange>
  <DocumentChange __id="67872" _type="Replace" date="Mon Dec 23 23:31:55 EST 2019" docASTNodeCount="1" docActiveCodeLength="662" docExpressionCount="0" docLength="750" endLine="22" insertionLength="1" int_docASTNodeCount="1" int_docActiveCodeLength="661" int_docExpressionCount="0" int_docLength="749" length="3" offset="484" startLine="22" starttimestamp="1576666505112" timestamp="495410519">
    <deletedText><![CDATA[sum]]></deletedText>
    <insertedText><![CDATA[a]]></insertedText>
  </DocumentChange>
  <DocumentChange __id="67876" _type="Replace" date="Mon Dec 23 23:31:57 EST 2019" docASTNodeCount="1" docActiveCodeLength="658" docExpressionCount="0" docLength="746" endLine="22" insertionLength="1" int_docASTNodeCount="1" int_docActiveCodeLength="657" int_docExpressionCount="0" int_docLength="745" length="5" offset="487" startLine="22" starttimestamp="1576666505112" timestamp="495412549">
    <deletedText><![CDATA[start]]></deletedText>
    <insertedText><![CDATA[b]]></insertedText>
  </DocumentChange>
  <DocumentChange __id="67878" _type="Delete" date="Mon Dec 23 23:31:58 EST 2019" docASTNodeCount="1" docActiveCodeLength="657" docExpressionCount="0" docLength="745" endLine="15" length="1" offset="325" startLine="15" starttimestamp="1576666505112" timestamp="495413478">
    <text><![CDATA[	]]></text>
  </DocumentChange>
  <DocumentChange __id="67884" _type="Insert" date="Mon Dec 23 23:32:23 EST 2019" docASTNodeCount="1" docActiveCodeLength="658" docExpressionCount="0" docLength="746" length="1" offset="335" starttimestamp="1576666505112" timestamp="495437973">
    <text><![CDATA[;]]></text>
  </DocumentChange>
  <Command __id="67917" _type="DiffBasedFileOpenCommand" date="Mon Dec 23 23:32:50 EST 2019" docASTNodeCount="1278" docActiveCodeLength="8826" docExpressionCount="798" docLength="11251" projectName="GraderBasics" starttimestamp="1576666505112" timestamp="495465266">
    <filePath><![CDATA[D:\dewan_backup\Java\GraderBasics\src\gradingTools\shared\testcases\openmp\OpenMPUtils.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package gradingTools.shared.testcases.openmp;¶¶import java.util.ArrayList;¶import java.util.HashMap;¶import java.util.List;¶import java.util.Map;¶import java.util.Stack;¶¶¶public class OpenMPUtils {¶	¶	protected static Map<String, OpenMPKeywordEnum> stringToOpenMPKeyword = new HashMap();¶	protected static String[] typeNames = {"double", "float", "int", "short", "long"};¶	protected static String[] openMPCalls = {"omp_get_thread_num()", "omp_get_num_threads()"};¶	public static List<OpenMPPragma> getOpemMPPragmas(StringBuffer aFileBuffer) {¶		String[] aFileLines = aFileBuffer.toString().split("\n");¶		return getOpenMPPragmas(aFileLines);¶	}¶	¶	public static boolean isCodeLine(String aLine) {¶		return !aLine.isEmpty() && !aLine.startsWith("//");¶	}¶	public static boolean isBlockStart(String aLine) {¶		return aLine.contains("{");¶	}¶	public static boolean isBlockEnd(String aLine) {¶		return aLine.contains("}");¶	}¶	public static boolean isLoopStart(String aLine) {¶		return aLine.startsWith("for");¶	}¶	public static boolean endsWithLoopHeader(String aLine) {¶		return aLine.endsWith(")");¶	}¶	public static boolean isPragmaStart(String aLine) {¶		return aLine.startsWith("#pragma");¶	}¶	public static void addToStack(Stack<OpenMPPragma> anOpenMPPragmas, String aFileLine, int aLineNumber) {¶		for (OpenMPPragma anOpenMPPragma:anOpenMPPragmas) {¶			anOpenMPPragma.addToAnnotatedText(aFileLine, aLineNumber);				¶		}¶		¶	}¶	public static ForHeader getForHeader(String aFileLine, int aLineNumber) {¶		if (!aFileLine.startsWith("for"))¶			return null;¶		int aLeftParenIndex = aFileLine.indexOf("(");¶		int aRightParenIndex = aFileLine.indexOf(")");¶		if (aLeftParenIndex < 0 || aRightParenIndex < 0) {¶			return null;¶		}¶		String aHeaderString = aFileLine.substring(aLeftParenIndex + 1, aRightParenIndex);¶		String[] aForComponents = aHeaderString.split(";");¶		return new AForHeader(aForComponents[0], aForComponents[1], aForComponents[2], aLineNumber);¶	}¶	public static List<String> getOMPCalls(String aFileLine) {¶		List<String> retVal = new ArrayList();¶		for (String anOpenMPCall:openMPCalls) {¶			if (aFileLine.contains(anOpenMPCall)) {¶				retVal.add(anOpenMPCall);¶			}¶		}¶		return retVal;¶	}¶	¶	public static void incrementStackTop (Stack<Integer> aNumOpenBracesStack) {¶		int aTopIndex = aNumOpenBracesStack.size() - 1;¶		Integer aCurrentValue = aNumOpenBracesStack.get(aTopIndex);¶		aNumOpenBracesStack.set(aTopIndex, aCurrentValue + 1);¶	}¶	public static void decrementStackTop (Stack<Integer> aNumOpenBracesStack) {¶		int aTopIndex = aNumOpenBracesStack.size() - 1;¶		Integer aCurrentValue = aNumOpenBracesStack.get(aTopIndex);¶		aNumOpenBracesStack.set(aTopIndex, aCurrentValue - 1);¶	}¶	¶	public static boolean startsWithTypeName(String aLine) {¶		for (String aTypeName:typeNames) {¶			if (aLine.startsWith(aTypeName)) {¶				return true;¶			}¶		}¶		return false;¶	}¶¶	public static List<OpenMPPragma> getOpenMPPragmas(String[] aFileLines) {¶		List<OpenMPPragma> retVal = new ArrayList();¶		Stack<OpenMPPragma> anOpenMPPragmas = new Stack();¶		Stack<Integer> aNumOpenBracesStack = new Stack();¶//		OpenMPPragma lastOpenMPPragma = null;¶//		String lastReductionVariable = null;¶//		String lastReductionOperation = null;¶//		int aNumOpenBraces = 0;¶		boolean aNextCodeLineIsAPragmaBlock = false;¶		List<OpenMPPragma> newOpenMPPragmas = null;¶		for (int i = 0; i < aFileLines.length; i++) {¶			String aFileLine = aFileLines[i].trim();¶			if (!isCodeLine(aFileLine)) {¶				continue;¶			}¶			addToStack(anOpenMPPragmas, aFileLine, i); // if it is empty add to none¶//			if (lastReductionVariable != null) {¶//				if (aFileLine.startsWith(lastReductionVariable)) {¶//					lastOpenMPPragma.getReductionVariableAssignments().add(aFileLine);¶//					if (lastReductionOperation != null) { // can it ever be not null¶//						if (aFileLine.contains(lastReductionOperation)) {¶//							lastOpenMPPragma.getReductionOperationUses().add(aFileLine);¶//						}¶//					}¶//				}			¶//			}¶//			if (lastOpenMPPragma != null && lastOpenMPPragma.getFirstOpenMPKeyword() == OpenMPKeywordEnum.PARALLEL) {¶//				if (startsWithTypeName(aFileLine)) {¶//					lastOpenMPPragma.getVariableDeclarationsInParallel().add(aFileLine);¶//				}¶//			} ¶//			else if (lastOpenMPPragma != null && lastOpenMPPragma.getFirstOpenMPKeyword() == OpenMPKeywordEnum.CRITICAL) {¶//				String[] aTokens = aFileLine.split("\\s+");¶//				lastOpenMPPragma.setAssignedVariableInCritical(aTokens[0]);				¶//			}¶			if (isPragmaStart(aFileLine)) {¶				¶				newOpenMPPragmas = getOpenMPPragmas(aFileLine, i);¶				if (newOpenMPPragmas.size() != 0) {¶					for (OpenMPPragma anOpenMPPragma:newOpenMPPragmas) {¶						if (anOpenMPPragmas.size() > 0) {¶						    anOpenMPPragma.setParent(anOpenMPPragmas.peek());¶						}¶						anOpenMPPragmas.push(anOpenMPPragma);¶						aNumOpenBracesStack.push(0);¶						retVal.add(anOpenMPPragma);¶¶					}¶//					anOpenMPPragmas.addAll(newOpenMPPragmas);¶					aNumOpenBracesStack.add(0);¶//					retVal.add(lastOpenMPPragma);					¶					aNextCodeLineIsAPragmaBlock = true;¶//					String lastReductionOperation = lastOpenMPPragma.getReductionOperation();¶//					String lastReductionVariable = lastOpenMPPragma.getReductionVariable();¶					continue;¶				} ¶			}¶			if (anOpenMPPragmas.isEmpty()) {¶				continue;¶			}	¶			if (aNextCodeLineIsAPragmaBlock) {				¶				anOpenMPPragmas.peek().setAnnotatedTextStartLineNumber(i);				¶				aNextCodeLineIsAPragmaBlock = false;¶			}¶//			anOpenMPPragmas.peek().getAnnotatedText().add(aFileLine);¶			if (isBlockStart(aFileLine)) {¶				incrementStackTop(aNumOpenBracesStack);¶			}¶//			} else ¶			if (isBlockEnd(aFileLine)) {¶				decrementStackTop(aNumOpenBracesStack);¶¶			}¶			if (isLoopStart(aFileLine) && endsWithLoopHeader(aFileLine)) {¶				continue; // gather following block also¶			}¶			if (aNumOpenBracesStack.peek() == 0) {¶				¶				anOpenMPPragmas.peek().setAnnotatedTextEndLineNumber(i);¶				for (int j = 0; j < newOpenMPPragmas.size(); j++) {¶					anOpenMPPragmas.pop();¶					aNumOpenBracesStack.pop();¶				}¶//				lastOpenMPPragma = null;¶//				lastReductionVariable = null;¶//				lastReductionOperation = null;¶				continue;¶			}					¶		}¶		return retVal;¶	}¶	public static void setReductionData (OpenMPPragma lastChild, String aStoredToken, int aLeftParenIndex, int aRightParenIndex) {¶		int aColonIndex = aStoredToken.indexOf(":");¶		if (aLeftParenIndex != -1 && aRightParenIndex != -1 && aColonIndex != -1) {¶			String anOperationString = aStoredToken.substring(aLeftParenIndex + 1, aColonIndex).trim();¶			String aVariableString = aStoredToken.substring(aColonIndex + 1, aRightParenIndex).trim();¶			((OpenMPForPragma) lastChild).setReductionVariable(aVariableString);¶			((OpenMPForPragma) lastChild).setReductionOperation(anOperationString);¶		}¶	}¶	public static void setSharedOrPrivateData (OpenMPPragma lastChild, String aStoredToken, int aLeftParenIndex, int aRightParenIndex, boolean isShared) {¶		int aColonIndex = aStoredToken.indexOf(":");¶		if (aLeftParenIndex != -1 && aRightParenIndex != -1 ) {¶			String aVariableDeclarations = aStoredToken.substring(aLeftParenIndex + 1, aRightParenIndex);¶			String[]"), Diff(DELETE,"¶			String anOperationString = aStoredToken.substring(aLeftParenIndex + 1, aColonIndex).trim();¶			String aVariableString = aStoredToken.substring(aColonIndex + 1, aRightParenIndex).trim();"), Diff(INSERT," aVariables = aVariableDeclarations.split(",");¶			if (isShared) {"), Diff(EQUAL,"¶			"), Diff(INSERT,"	"), Diff(DELETE,"((OpenMPForPragma) "), Diff(EQUAL,"lastChild"), Diff(DELETE,")"), Diff(EQUAL,".set"), Diff(DELETE,"Reduction"), Diff(INSERT,"Shared"), Diff(EQUAL,"Variable"), Diff(INSERT,"s"), Diff(EQUAL,"(aVariable"), Diff(DELETE,"String"), Diff(INSERT,"s"), Diff(EQUAL,");¶			"), Diff(DELETE,"((OpenMPForPragma) "), Diff(INSERT,"} else {¶				"), Diff(EQUAL,"lastChild"), Diff(DELETE,")"), Diff(EQUAL,".set"), Diff(DELETE,"ReductionOperation(anOperationString);"), Diff(INSERT,"PrivateVariables(aVariables);¶			}			"), Diff(EQUAL,"¶		}¶	}¶	public static List<OpenMPPragma> getOpenMPPragmas(String aFileLine, int aLineIndex) {¶		String[] aTokens = aFileLine.split("\\s+");¶		if (aTokens.length <= 2) {¶			return null;¶		}¶		if (!aTokens[1].equals("omp")) {¶			return null;¶		}¶		if (aTokens.length < 3) {¶			return null;¶		}¶		String aFirstToken = aTokens[2];¶		OpenMPKeywordEnum anOpenMPKeyword = stringToOpenMPKeyword.get(aFirstToken);¶		List<OpenMPPragma> retVal = new ArrayList();¶		OpenMPPragma lastChild;¶		int aStartIndex = 2;¶		switch (anOpenMPKeyword) {¶		case PARALLEL:¶			lastChild = new AnOpenMPParallelPragma(aLineIndex);¶			¶//			lastChild.setFirstOpenMPKeyword(stringToOpenMPKeyword.get(aFirstToken));	¶¶			retVal.add(lastChild);¶			if (aTokens.length > 3 && aTokens[3].equals("for")) {¶				OpenMPPragma aForChild = new AnOpenMPForPragma(aLineIndex);¶				retVal.add(aForChild);¶				lastChild = aForChild;¶				aStartIndex++;¶			}¶			break;¶		case FOR:¶			lastChild = new AnOpenMPForPragma(aLineIndex);¶			retVal.add (lastChild);¶			break;¶		case CRITICAL:¶			lastChild = new AnOpenMPCriticalPragma(aLineIndex);¶			retVal.add (lastChild);¶			break;¶			default: ¶				lastChild = new AnOpenMPPragma(aLineIndex);¶				retVal.add(lastChild);¶			¶		}¶//		retVal.setFirstOpenMPKeyword(stringToOpenMPKeyword.get(aFirstToken));	¶//		OpenMPPragma retVal = new AnOpenMPPragma(aLineIndex);¶¶¶		for (int i = aStartIndex; i < aTokens.length; i ++) {¶			String aStoredToken = aTokens[i].trim();¶			if (aStoredToken.isEmpty()) {¶				continue;¶			}¶			if (aStoredToken.startsWith("reduction") || aStoredToken.startsWith("shared") || aStoredToken.startsWith("private")) {¶				//combine all tokens until ")" into one for normalization¶				while (!aStoredToken.endsWith(")")) {¶					i++;¶					if (i >= aTokens.length) {¶						break;¶					}¶					String aNewToken = aTokens[i].trim();¶					aStoredToken += aNewToken; 					¶				}¶				int aLeftParenIndex = aStoredToken.indexOf("(");¶				int aRightParenIndex = aStoredToken.indexOf(")");¶				if (aStoredToken.startsWith("reduction")) {¶					setReductionData(lastChild, aStoredToken, aLeftParenIndex, aRightParenIndex);¶				} else if (aStoredToken.startsWith("private")) {¶					set"), Diff(DELETE,"PrivateOrShared"), Diff(INSERT,"SharedOrPrivate"), Diff(EQUAL,"Data(lastChild, aStoredToken, aLeftParenIndex, aRightParenIndex, true);¶¶				} else if "), Diff(DELETE,"("), Diff(EQUAL,"(aStoredToken.startsWith("shared")) {¶					set"), Diff(DELETE,"PrivateOrShared"), Diff(INSERT,"SharedOrPrivate"), Diff(EQUAL,"Data(lastChild, aStoredToken, aLeftParenIndex, aRightParenIndex, false);¶¶				}¶//				int aColonIndex = aStoredToken.indexOf(":");¶//				if (aLeftParenIndex != -1 && aRightParenIndex != -1 && aColonIndex != -1) {¶//					String anOperationString = aStoredToken.substring(aLeftParenIndex + 1, aColonIndex).trim();¶//					String aVariableString = aStoredToken.substring(aColonIndex + 1, aRightParenIndex).trim();¶//					((OpenMPForPragma) lastChild).setReductionVariable(aVariableString);¶//					((OpenMPForPragma) lastChild).setReductionOperation(anOperationString);¶//				}¶				¶			}¶			¶//			aTokens[i] = aStoredToken;¶			lastChild.getOpenMPTokens().add(aStoredToken);¶		}¶//		String aFirstToken = retVal.getOpenMPTokens().get(0);¶//		retVal.setFirstOpenMPKeyword(stringToOpenMPKeyword.get(aFirstToken));		¶		return retVal;¶		¶		¶	}¶	static {¶		stringToOpenMPKeyword.put("for", OpenMPKeywordEnum.FOR);¶		stringToOpenMPKeyword.put("parallel", OpenMPKeywordEnum.PARALLEL);¶		stringToOpenMPKeyword.put("reduce", OpenMPKeywordEnum.REDUCE);¶		stringToOpenMPKeyword.put("shared", OpenMPKeywordEnum.SHARED);¶		stringToOpenMPKeyword.put("private", OpenMPKeywordEnum.PRIVATE);¶		stringToOpenMPKeyword.put("critical", OpenMPKeywordEnum.CRITICAL);¶¶¶¶¶¶	}¶	¶¶}¶")]]]></diff>
    <snapshot><![CDATA[package gradingTools.shared.testcases.openmp;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Stack;


public class OpenMPUtils {
	
	protected static Map<String, OpenMPKeywordEnum> stringToOpenMPKeyword = new HashMap();
	protected static String[] typeNames = {"double", "float", "int", "short", "long"};
	protected static String[] openMPCalls = {"omp_get_thread_num()", "omp_get_num_threads()"};
	public static List<OpenMPPragma> getOpemMPPragmas(StringBuffer aFileBuffer) {
		String[] aFileLines = aFileBuffer.toString().split("\n");
		return getOpenMPPragmas(aFileLines);
	}
	
	public static boolean isCodeLine(String aLine) {
		return !aLine.isEmpty() && !aLine.startsWith("//");
	}
	public static boolean isBlockStart(String aLine) {
		return aLine.contains("{");
	}
	public static boolean isBlockEnd(String aLine) {
		return aLine.contains("}");
	}
	public static boolean isLoopStart(String aLine) {
		return aLine.startsWith("for");
	}
	public static boolean endsWithLoopHeader(String aLine) {
		return aLine.endsWith(")");
	}
	public static boolean isPragmaStart(String aLine) {
		return aLine.startsWith("#pragma");
	}
	public static void addToStack(Stack<OpenMPPragma> anOpenMPPragmas, String aFileLine, int aLineNumber) {
		for (OpenMPPragma anOpenMPPragma:anOpenMPPragmas) {
			anOpenMPPragma.addToAnnotatedText(aFileLine, aLineNumber);				
		}
		
	}
	public static ForHeader getForHeader(String aFileLine, int aLineNumber) {
		if (!aFileLine.startsWith("for"))
			return null;
		int aLeftParenIndex = aFileLine.indexOf("(");
		int aRightParenIndex = aFileLine.indexOf(")");
		if (aLeftParenIndex < 0 || aRightParenIndex < 0) {
			return null;
		}
		String aHeaderString = aFileLine.substring(aLeftParenIndex + 1, aRightParenIndex);
		String[] aForComponents = aHeaderString.split(";");
		return new AForHeader(aForComponents[0], aForComponents[1], aForComponents[2], aLineNumber);
	}
	public static List<String> getOMPCalls(String aFileLine) {
		List<String> retVal = new ArrayList();
		for (String anOpenMPCall:openMPCalls) {
			if (aFileLine.contains(anOpenMPCall)) {
				retVal.add(anOpenMPCall);
			}
		}
		return retVal;
	}
	
	public static void incrementStackTop (Stack<Integer> aNumOpenBracesStack) {
		int aTopIndex = aNumOpenBracesStack.size() - 1;
		Integer aCurrentValue = aNumOpenBracesStack.get(aTopIndex);
		aNumOpenBracesStack.set(aTopIndex, aCurrentValue + 1);
	}
	public static void decrementStackTop (Stack<Integer> aNumOpenBracesStack) {
		int aTopIndex = aNumOpenBracesStack.size() - 1;
		Integer aCurrentValue = aNumOpenBracesStack.get(aTopIndex);
		aNumOpenBracesStack.set(aTopIndex, aCurrentValue - 1);
	}
	
	public static boolean startsWithTypeName(String aLine) {
		for (String aTypeName:typeNames) {
			if (aLine.startsWith(aTypeName)) {
				return true;
			}
		}
		return false;
	}

	public static List<OpenMPPragma> getOpenMPPragmas(String[] aFileLines) {
		List<OpenMPPragma> retVal = new ArrayList();
		Stack<OpenMPPragma> anOpenMPPragmas = new Stack();
		Stack<Integer> aNumOpenBracesStack = new Stack();
//		OpenMPPragma lastOpenMPPragma = null;
//		String lastReductionVariable = null;
//		String lastReductionOperation = null;
//		int aNumOpenBraces = 0;
		boolean aNextCodeLineIsAPragmaBlock = false;
		List<OpenMPPragma> newOpenMPPragmas = null;
		for (int i = 0; i < aFileLines.length; i++) {
			String aFileLine = aFileLines[i].trim();
			if (!isCodeLine(aFileLine)) {
				continue;
			}
			addToStack(anOpenMPPragmas, aFileLine, i); // if it is empty add to none
//			if (lastReductionVariable != null) {
//				if (aFileLine.startsWith(lastReductionVariable)) {
//					lastOpenMPPragma.getReductionVariableAssignments().add(aFileLine);
//					if (lastReductionOperation != null) { // can it ever be not null
//						if (aFileLine.contains(lastReductionOperation)) {
//							lastOpenMPPragma.getReductionOperationUses().add(aFileLine);
//						}
//					}
//				}			
//			}
//			if (lastOpenMPPragma != null && lastOpenMPPragma.getFirstOpenMPKeyword() == OpenMPKeywordEnum.PARALLEL) {
//				if (startsWithTypeName(aFileLine)) {
//					lastOpenMPPragma.getVariableDeclarationsInParallel().add(aFileLine);
//				}
//			} 
//			else if (lastOpenMPPragma != null && lastOpenMPPragma.getFirstOpenMPKeyword() == OpenMPKeywordEnum.CRITICAL) {
//				String[] aTokens = aFileLine.split("\\s+");
//				lastOpenMPPragma.setAssignedVariableInCritical(aTokens[0]);				
//			}
			if (isPragmaStart(aFileLine)) {
				
				newOpenMPPragmas = getOpenMPPragmas(aFileLine, i);
				if (newOpenMPPragmas.size() != 0) {
					for (OpenMPPragma anOpenMPPragma:newOpenMPPragmas) {
						if (anOpenMPPragmas.size() > 0) {
						    anOpenMPPragma.setParent(anOpenMPPragmas.peek());
						}
						anOpenMPPragmas.push(anOpenMPPragma);
						aNumOpenBracesStack.push(0);
						retVal.add(anOpenMPPragma);

					}
//					anOpenMPPragmas.addAll(newOpenMPPragmas);
					aNumOpenBracesStack.add(0);
//					retVal.add(lastOpenMPPragma);					
					aNextCodeLineIsAPragmaBlock = true;
//					String lastReductionOperation = lastOpenMPPragma.getReductionOperation();
//					String lastReductionVariable = lastOpenMPPragma.getReductionVariable();
					continue;
				} 
			}
			if (anOpenMPPragmas.isEmpty()) {
				continue;
			}	
			if (aNextCodeLineIsAPragmaBlock) {				
				anOpenMPPragmas.peek().setAnnotatedTextStartLineNumber(i);				
				aNextCodeLineIsAPragmaBlock = false;
			}
//			anOpenMPPragmas.peek().getAnnotatedText().add(aFileLine);
			if (isBlockStart(aFileLine)) {
				incrementStackTop(aNumOpenBracesStack);
			}
//			} else 
			if (isBlockEnd(aFileLine)) {
				decrementStackTop(aNumOpenBracesStack);

			}
			if (isLoopStart(aFileLine) && endsWithLoopHeader(aFileLine)) {
				continue; // gather following block also
			}
			if (aNumOpenBracesStack.peek() == 0) {
				
				anOpenMPPragmas.peek().setAnnotatedTextEndLineNumber(i);
				for (int j = 0; j < newOpenMPPragmas.size(); j++) {
					anOpenMPPragmas.pop();
					aNumOpenBracesStack.pop();
				}
//				lastOpenMPPragma = null;
//				lastReductionVariable = null;
//				lastReductionOperation = null;
				continue;
			}					
		}
		return retVal;
	}
	public static void setReductionData (OpenMPPragma lastChild, String aStoredToken, int aLeftParenIndex, int aRightParenIndex) {
		int aColonIndex = aStoredToken.indexOf(":");
		if (aLeftParenIndex != -1 && aRightParenIndex != -1 && aColonIndex != -1) {
			String anOperationString = aStoredToken.substring(aLeftParenIndex + 1, aColonIndex).trim();
			String aVariableString = aStoredToken.substring(aColonIndex + 1, aRightParenIndex).trim();
			((OpenMPForPragma) lastChild).setReductionVariable(aVariableString);
			((OpenMPForPragma) lastChild).setReductionOperation(anOperationString);
		}
	}
	public static void setSharedOrPrivateData (OpenMPPragma lastChild, String aStoredToken, int aLeftParenIndex, int aRightParenIndex, boolean isShared) {
		int aColonIndex = aStoredToken.indexOf(":");
		if (aLeftParenIndex != -1 && aRightParenIndex != -1 ) {
			String aVariableDeclarations = aStoredToken.substring(aLeftParenIndex + 1, aRightParenIndex);
			String[] aVariables = aVariableDeclarations.split(",");
			if (isShared) {
				lastChild.setSharedVariables(aVariables);
			} else {
				lastChild.setPrivateVariables(aVariables);
			}			
		}
	}
	public static List<OpenMPPragma> getOpenMPPragmas(String aFileLine, int aLineIndex) {
		String[] aTokens = aFileLine.split("\\s+");
		if (aTokens.length <= 2) {
			return null;
		}
		if (!aTokens[1].equals("omp")) {
			return null;
		}
		if (aTokens.length < 3) {
			return null;
		}
		String aFirstToken = aTokens[2];
		OpenMPKeywordEnum anOpenMPKeyword = stringToOpenMPKeyword.get(aFirstToken);
		List<OpenMPPragma> retVal = new ArrayList();
		OpenMPPragma lastChild;
		int aStartIndex = 2;
		switch (anOpenMPKeyword) {
		case PARALLEL:
			lastChild = new AnOpenMPParallelPragma(aLineIndex);
			
//			lastChild.setFirstOpenMPKeyword(stringToOpenMPKeyword.get(aFirstToken));	

			retVal.add(lastChild);
			if (aTokens.length > 3 && aTokens[3].equals("for")) {
				OpenMPPragma aForChild = new AnOpenMPForPragma(aLineIndex);
				retVal.add(aForChild);
				lastChild = aForChild;
				aStartIndex++;
			}
			break;
		case FOR:
			lastChild = new AnOpenMPForPragma(aLineIndex);
			retVal.add (lastChild);
			break;
		case CRITICAL:
			lastChild = new AnOpenMPCriticalPragma(aLineIndex);
			retVal.add (lastChild);
			break;
			default: 
				lastChild = new AnOpenMPPragma(aLineIndex);
				retVal.add(lastChild);
			
		}
//		retVal.setFirstOpenMPKeyword(stringToOpenMPKeyword.get(aFirstToken));	
//		OpenMPPragma retVal = new AnOpenMPPragma(aLineIndex);


		for (int i = aStartIndex; i < aTokens.length; i ++) {
			String aStoredToken = aTokens[i].trim();
			if (aStoredToken.isEmpty()) {
				continue;
			}
			if (aStoredToken.startsWith("reduction") || aStoredToken.startsWith("shared") || aStoredToken.startsWith("private")) {
				//combine all tokens until ")" into one for normalization
				while (!aStoredToken.endsWith(")")) {
					i++;
					if (i >= aTokens.length) {
						break;
					}
					String aNewToken = aTokens[i].trim();
					aStoredToken += aNewToken; 					
				}
				int aLeftParenIndex = aStoredToken.indexOf("(");
				int aRightParenIndex = aStoredToken.indexOf(")");
				if (aStoredToken.startsWith("reduction")) {
					setReductionData(lastChild, aStoredToken, aLeftParenIndex, aRightParenIndex);
				} else if (aStoredToken.startsWith("private")) {
					setSharedOrPrivateData(lastChild, aStoredToken, aLeftParenIndex, aRightParenIndex, true);

				} else if (aStoredToken.startsWith("shared")) {
					setSharedOrPrivateData(lastChild, aStoredToken, aLeftParenIndex, aRightParenIndex, false);

				}
//				int aColonIndex = aStoredToken.indexOf(":");
//				if (aLeftParenIndex != -1 && aRightParenIndex != -1 && aColonIndex != -1) {
//					String anOperationString = aStoredToken.substring(aLeftParenIndex + 1, aColonIndex).trim();
//					String aVariableString = aStoredToken.substring(aColonIndex + 1, aRightParenIndex).trim();
//					((OpenMPForPragma) lastChild).setReductionVariable(aVariableString);
//					((OpenMPForPragma) lastChild).setReductionOperation(anOperationString);
//				}
				
			}
			
//			aTokens[i] = aStoredToken;
			lastChild.getOpenMPTokens().add(aStoredToken);
		}
//		String aFirstToken = retVal.getOpenMPTokens().get(0);
//		retVal.setFirstOpenMPKeyword(stringToOpenMPKeyword.get(aFirstToken));		
		return retVal;
		
		
	}
	static {
		stringToOpenMPKeyword.put("for", OpenMPKeywordEnum.FOR);
		stringToOpenMPKeyword.put("parallel", OpenMPKeywordEnum.PARALLEL);
		stringToOpenMPKeyword.put("reduce", OpenMPKeywordEnum.REDUCE);
		stringToOpenMPKeyword.put("shared", OpenMPKeywordEnum.SHARED);
		stringToOpenMPKeyword.put("private", OpenMPKeywordEnum.PRIVATE);
		stringToOpenMPKeyword.put("critical", OpenMPKeywordEnum.CRITICAL);





	}
	

}
]]></snapshot>
  </Command>
  <DocumentChange __id="67924" _type="Insert" date="Mon Dec 23 23:33:09 EST 2019" docASTNodeCount="1270" docActiveCodeLength="8780" docExpressionCount="793" docLength="11253" length="2" offset="7140" starttimestamp="1576666505112" timestamp="495484196">
    <text><![CDATA[//]]></text>
  </DocumentChange>
  <Command __id="67969" _type="DiffBasedFileOpenCommand" date="Mon Dec 23 23:33:16 EST 2019" projectName="null" starttimestamp="1576666505112" timestamp="495491769">
    <filePath><![CDATA[null]]></filePath>
    <diff><![CDATA[null]]></diff>
  </Command>
  <Command __id="67973" _type="DiffBasedFileOpenCommand" date="Mon Dec 23 23:33:19 EST 2019" docASTNodeCount="1270" docActiveCodeLength="8780" docExpressionCount="793" docLength="11253" projectName="GraderBasics" starttimestamp="1576666505112" timestamp="495494278">
    <filePath><![CDATA[D:\dewan_backup\Java\GraderBasics\src\gradingTools\shared\testcases\openmp\OpenMPUtils.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package gradingTools.shared.testcases.openmp;¶¶import java.util.ArrayList;¶import java.util.HashMap;¶import java.util.List;¶import java.util.Map;¶import java.util.Stack;¶¶¶public class OpenMPUtils {¶	¶	protected static Map<String, OpenMPKeywordEnum> stringToOpenMPKeyword = new HashMap();¶	protected static String[] typeNames = {"double", "float", "int", "short", "long"};¶	protected static String[] openMPCalls = {"omp_get_thread_num()", "omp_get_num_threads()"};¶	public static List<OpenMPPragma> getOpemMPPragmas(StringBuffer aFileBuffer) {¶		String[] aFileLines = aFileBuffer.toString().split("\n");¶		return getOpenMPPragmas(aFileLines);¶	}¶	¶	public static boolean isCodeLine(String aLine) {¶		return !aLine.isEmpty() && !aLine.startsWith("//");¶	}¶	public static boolean isBlockStart(String aLine) {¶		return aLine.contains("{");¶	}¶	public static boolean isBlockEnd(String aLine) {¶		return aLine.contains("}");¶	}¶	public static boolean isLoopStart(String aLine) {¶		return aLine.startsWith("for");¶	}¶	public static boolean endsWithLoopHeader(String aLine) {¶		return aLine.endsWith(")");¶	}¶	public static boolean isPragmaStart(String aLine) {¶		return aLine.startsWith("#pragma");¶	}¶	public static void addToStack(Stack<OpenMPPragma> anOpenMPPragmas, String aFileLine, int aLineNumber) {¶		for (OpenMPPragma anOpenMPPragma:anOpenMPPragmas) {¶			anOpenMPPragma.addToAnnotatedText(aFileLine, aLineNumber);				¶		}¶		¶	}¶	public static ForHeader getForHeader(String aFileLine, int aLineNumber) {¶		if (!aFileLine.startsWith("for"))¶			return null;¶		int aLeftParenIndex = aFileLine.indexOf("(");¶		int aRightParenIndex = aFileLine.indexOf(")");¶		if (aLeftParenIndex < 0 || aRightParenIndex < 0) {¶			return null;¶		}¶		String aHeaderString = aFileLine.substring(aLeftParenIndex + 1, aRightParenIndex);¶		String[] aForComponents = aHeaderString.split(";");¶		return new AForHeader(aForComponents[0], aForComponents[1], aForComponents[2], aLineNumber);¶	}¶	public static List<String> getOMPCalls(String aFileLine) {¶		List<String> retVal = new ArrayList();¶		for (String anOpenMPCall:openMPCalls) {¶			if (aFileLine.contains(anOpenMPCall)) {¶				retVal.add(anOpenMPCall);¶			}¶		}¶		return retVal;¶	}¶	¶	public static void incrementStackTop (Stack<Integer> aNumOpenBracesStack) {¶		int aTopIndex = aNumOpenBracesStack.size() - 1;¶		Integer aCurrentValue = aNumOpenBracesStack.get(aTopIndex);¶		aNumOpenBracesStack.set(aTopIndex, aCurrentValue + 1);¶	}¶	public static void decrementStackTop (Stack<Integer> aNumOpenBracesStack) {¶		int aTopIndex = aNumOpenBracesStack.size() - 1;¶		Integer aCurrentValue = aNumOpenBracesStack.get(aTopIndex);¶		aNumOpenBracesStack.set(aTopIndex, aCurrentValue - 1);¶	}¶	¶	public static boolean startsWithTypeName(String aLine) {¶		for (String aTypeName:typeNames) {¶			if (aLine.startsWith(aTypeName)) {¶				return true;¶			}¶		}¶		return false;¶	}¶¶	public static List<OpenMPPragma> getOpenMPPragmas(String[] aFileLines) {¶		List<OpenMPPragma> retVal = new ArrayList();¶		Stack<OpenMPPragma> anOpenMPPragmas = new Stack();¶		Stack<Integer> aNumOpenBracesStack = new Stack();¶//		OpenMPPragma lastOpenMPPragma = null;¶//		String lastReductionVariable = null;¶//		String lastReductionOperation = null;¶//		int aNumOpenBraces = 0;¶		boolean aNextCodeLineIsAPragmaBlock = false;¶		List<OpenMPPragma> newOpenMPPragmas = null;¶		for (int i = 0; i < aFileLines.length; i++) {¶			String aFileLine = aFileLines[i].trim();¶			if (!isCodeLine(aFileLine)) {¶				continue;¶			}¶			addToStack(anOpenMPPragmas, aFileLine, i); // if it is empty add to none¶//			if (lastReductionVariable != null) {¶//				if (aFileLine.startsWith(lastReductionVariable)) {¶//					lastOpenMPPragma.getReductionVariableAssignments().add(aFileLine);¶//					if (lastReductionOperation != null) { // can it ever be not null¶//						if (aFileLine.contains(lastReductionOperation)) {¶//							lastOpenMPPragma.getReductionOperationUses().add(aFileLine);¶//						}¶//					}¶//				}			¶//			}¶//			if (lastOpenMPPragma != null && lastOpenMPPragma.getFirstOpenMPKeyword() == OpenMPKeywordEnum.PARALLEL) {¶//				if (startsWithTypeName(aFileLine)) {¶//					lastOpenMPPragma.getVariableDeclarationsInParallel().add(aFileLine);¶//				}¶//			} ¶//			else if (lastOpenMPPragma != null && lastOpenMPPragma.getFirstOpenMPKeyword() == OpenMPKeywordEnum.CRITICAL) {¶//				String[] aTokens = aFileLine.split("\\s+");¶//				lastOpenMPPragma.setAssignedVariableInCritical(aTokens[0]);				¶//			}¶			if (isPragmaStart(aFileLine)) {¶				¶				newOpenMPPragmas = getOpenMPPragmas(aFileLine, i);¶				if (newOpenMPPragmas.size() != 0) {¶					for (OpenMPPragma anOpenMPPragma:newOpenMPPragmas) {¶						if (anOpenMPPragmas.size() > 0) {¶						    anOpenMPPragma.setParent(anOpenMPPragmas.peek());¶						}¶						anOpenMPPragmas.push(anOpenMPPragma);¶						aNumOpenBracesStack.push(0);¶						retVal.add(anOpenMPPragma);¶¶					}¶//					anOpenMPPragmas.addAll(newOpenMPPragmas);¶					aNumOpenBracesStack.add(0);¶//					retVal.add(lastOpenMPPragma);					¶					aNextCodeLineIsAPragmaBlock = true;¶//					String lastReductionOperation = lastOpenMPPragma.getReductionOperation();¶//					String lastReductionVariable = lastOpenMPPragma.getReductionVariable();¶					continue;¶				} ¶			}¶			if (anOpenMPPragmas.isEmpty()) {¶				continue;¶			}	¶			if (aNextCodeLineIsAPragmaBlock) {				¶				anOpenMPPragmas.peek().setAnnotatedTextStartLineNumber(i);				¶				aNextCodeLineIsAPragmaBlock = false;¶			}¶//			anOpenMPPragmas.peek().getAnnotatedText().add(aFileLine);¶			if (isBlockStart(aFileLine)) {¶				incrementStackTop(aNumOpenBracesStack);¶			}¶//			} else ¶			if (isBlockEnd(aFileLine)) {¶				decrementStackTop(aNumOpenBracesStack);¶¶			}¶			if (isLoopStart(aFileLine) && endsWithLoopHeader(aFileLine)) {¶				continue; // gather following block also¶			}¶			if (aNumOpenBracesStack.peek() == 0) {¶				¶				anOpenMPPragmas.peek().setAnnotatedTextEndLineNumber(i);¶				for (int j = 0; j < newOpenMPPragmas.size(); j++) {¶					anOpenMPPragmas.pop();¶					aNumOpenBracesStack.pop();¶				}¶//				lastOpenMPPragma = null;¶//				lastReductionVariable = null;¶//				lastReductionOperation = null;¶				continue;¶			}					¶		}¶		return retVal;¶	}¶	public static void setReductionData (OpenMPPragma lastChild, String aStoredToken, int aLeftParenIndex, int aRightParenIndex) {¶		int aColonIndex = aStoredToken.indexOf(":");¶		if (aLeftParenIndex != -1 && aRightParenIndex != -1 && aColonIndex != -1) {¶			String anOperationString = aStoredToken.substring(aLeftParenIndex + 1, aColonIndex).trim();¶			String aVariableString = aStoredToken.substring(aColonIndex + 1, aRightParenIndex).trim();¶			((OpenMPForPragma) lastChild).setReductionVariable(aVariableString);¶			((OpenMPForPragma) lastChild).setReductionOperation(anOperationString);¶		}¶	}¶	public static void setSharedOrPrivateData (OpenMPPragma lastChild, String aStoredToken, int aLeftParenIndex, int aRightParenIndex, boolean isShared) {¶"), Diff(INSERT,"//"), Diff(EQUAL,"		int aColonIndex = aStoredToken.indexOf(":");¶		if (aLeftParenIndex != -1 && aRightParenIndex != -1 ) {¶			String aVariableDeclarations = aStoredToken.substring(aLeftParenIndex + 1, aRightParenIndex);¶			String[] aVariables = aVariableDeclarations.split(",");¶			if (isShared) {¶				lastChild.setSharedVariables(aVariables);¶			} else {¶				lastChild.setPrivateVariables(aVariables);¶			}			¶		}¶	}¶	public static List<OpenMPPragma> getOpenMPPragmas(String aFileLine, int aLineIndex) {¶		String[] aTokens = aFileLine.split("\\s+");¶		if (aTokens.length <= 2) {¶			return null;¶		}¶		if (!aTokens[1].equals("omp")) {¶			return null;¶		}¶		if (aTokens.length < 3) {¶			return null;¶		}¶		String aFirstToken = aTokens[2];¶		OpenMPKeywordEnum anOpenMPKeyword = stringToOpenMPKeyword.get(aFirstToken);¶		List<OpenMPPragma> retVal = new ArrayList();¶		OpenMPPragma lastChild;¶		int aStartIndex = 2;¶		switch (anOpenMPKeyword) {¶		case PARALLEL:¶			lastChild = new AnOpenMPParallelPragma(aLineIndex);¶			¶//			lastChild.setFirstOpenMPKeyword(stringToOpenMPKeyword.get(aFirstToken));	¶¶			retVal.add(lastChild);¶			if (aTokens.length > 3 && aTokens[3].equals("for")) {¶				OpenMPPragma aForChild = new AnOpenMPForPragma(aLineIndex);¶				retVal.add(aForChild);¶				lastChild = aForChild;¶				aStartIndex++;¶			}¶			break;¶		case FOR:¶			lastChild = new AnOpenMPForPragma(aLineIndex);¶			retVal.add (lastChild);¶			break;¶		case CRITICAL:¶			lastChild = new AnOpenMPCriticalPragma(aLineIndex);¶			retVal.add (lastChild);¶			break;¶			default: ¶				lastChild = new AnOpenMPPragma(aLineIndex);¶				retVal.add(lastChild);¶			¶		}¶//		retVal.setFirstOpenMPKeyword(stringToOpenMPKeyword.get(aFirstToken));	¶//		OpenMPPragma retVal = new AnOpenMPPragma(aLineIndex);¶¶¶		for (int i = aStartIndex; i < aTokens.length; i ++) {¶			String aStoredToken = aTokens[i].trim();¶			if (aStoredToken.isEmpty()) {¶				continue;¶			}¶			if (aStoredToken.startsWith("reduction") || aStoredToken.startsWith("shared") || aStoredToken.startsWith("private")) {¶				//combine all tokens until ")" into one for normalization¶				while (!aStoredToken.endsWith(")")) {¶					i++;¶					if (i >= aTokens.length) {¶						break;¶					}¶					String aNewToken = aTokens[i].trim();¶					aStoredToken += aNewToken; 					¶				}¶				int aLeftParenIndex = aStoredToken.indexOf("(");¶				int aRightParenIndex = aStoredToken.indexOf(")");¶				if (aStoredToken.startsWith("reduction")) {¶					setReductionData(lastChild, aStoredToken, aLeftParenIndex, aRightParenIndex);¶				} else if (aStoredToken.startsWith("private")) {¶					setSharedOrPrivateData(lastChild, aStoredToken, aLeftParenIndex, aRightParenIndex, true);¶¶				} else if (aStoredToken.startsWith("shared")) {¶					setSharedOrPrivateData(lastChild, aStoredToken, aLeftParenIndex, aRightParenIndex, false);¶¶				}¶//				int aColonIndex = aStoredToken.indexOf(":");¶//				if (aLeftParenIndex != -1 && aRightParenIndex != -1 && aColonIndex != -1) {¶//					String anOperationString = aStoredToken.substring(aLeftParenIndex + 1, aColonIndex).trim();¶//					String aVariableString = aStoredToken.substring(aColonIndex + 1, aRightParenIndex).trim();¶//					((OpenMPForPragma) lastChild).setReductionVariable(aVariableString);¶//					((OpenMPForPragma) lastChild).setReductionOperation(anOperationString);¶//				}¶				¶			}¶			¶//			aTokens[i] = aStoredToken;¶			lastChild.getOpenMPTokens().add(aStoredToken);¶		}¶//		String aFirstToken = retVal.getOpenMPTokens().get(0);¶//		retVal.setFirstOpenMPKeyword(stringToOpenMPKeyword.get(aFirstToken));		¶		return retVal;¶		¶		¶	}¶	static {¶		stringToOpenMPKeyword.put("for", OpenMPKeywordEnum.FOR);¶		stringToOpenMPKeyword.put("parallel", OpenMPKeywordEnum.PARALLEL);¶		stringToOpenMPKeyword.put("reduce", OpenMPKeywordEnum.REDUCE);¶		stringToOpenMPKeyword.put("shared", OpenMPKeywordEnum.SHARED);¶		stringToOpenMPKeyword.put("private", OpenMPKeywordEnum.PRIVATE);¶		stringToOpenMPKeyword.put("critical", OpenMPKeywordEnum.CRITICAL);¶¶¶¶¶¶	}¶	¶¶}¶")]]]></diff>
    <snapshot><![CDATA[package gradingTools.shared.testcases.openmp;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Stack;


public class OpenMPUtils {
	
	protected static Map<String, OpenMPKeywordEnum> stringToOpenMPKeyword = new HashMap();
	protected static String[] typeNames = {"double", "float", "int", "short", "long"};
	protected static String[] openMPCalls = {"omp_get_thread_num()", "omp_get_num_threads()"};
	public static List<OpenMPPragma> getOpemMPPragmas(StringBuffer aFileBuffer) {
		String[] aFileLines = aFileBuffer.toString().split("\n");
		return getOpenMPPragmas(aFileLines);
	}
	
	public static boolean isCodeLine(String aLine) {
		return !aLine.isEmpty() && !aLine.startsWith("//");
	}
	public static boolean isBlockStart(String aLine) {
		return aLine.contains("{");
	}
	public static boolean isBlockEnd(String aLine) {
		return aLine.contains("}");
	}
	public static boolean isLoopStart(String aLine) {
		return aLine.startsWith("for");
	}
	public static boolean endsWithLoopHeader(String aLine) {
		return aLine.endsWith(")");
	}
	public static boolean isPragmaStart(String aLine) {
		return aLine.startsWith("#pragma");
	}
	public static void addToStack(Stack<OpenMPPragma> anOpenMPPragmas, String aFileLine, int aLineNumber) {
		for (OpenMPPragma anOpenMPPragma:anOpenMPPragmas) {
			anOpenMPPragma.addToAnnotatedText(aFileLine, aLineNumber);				
		}
		
	}
	public static ForHeader getForHeader(String aFileLine, int aLineNumber) {
		if (!aFileLine.startsWith("for"))
			return null;
		int aLeftParenIndex = aFileLine.indexOf("(");
		int aRightParenIndex = aFileLine.indexOf(")");
		if (aLeftParenIndex < 0 || aRightParenIndex < 0) {
			return null;
		}
		String aHeaderString = aFileLine.substring(aLeftParenIndex + 1, aRightParenIndex);
		String[] aForComponents = aHeaderString.split(";");
		return new AForHeader(aForComponents[0], aForComponents[1], aForComponents[2], aLineNumber);
	}
	public static List<String> getOMPCalls(String aFileLine) {
		List<String> retVal = new ArrayList();
		for (String anOpenMPCall:openMPCalls) {
			if (aFileLine.contains(anOpenMPCall)) {
				retVal.add(anOpenMPCall);
			}
		}
		return retVal;
	}
	
	public static void incrementStackTop (Stack<Integer> aNumOpenBracesStack) {
		int aTopIndex = aNumOpenBracesStack.size() - 1;
		Integer aCurrentValue = aNumOpenBracesStack.get(aTopIndex);
		aNumOpenBracesStack.set(aTopIndex, aCurrentValue + 1);
	}
	public static void decrementStackTop (Stack<Integer> aNumOpenBracesStack) {
		int aTopIndex = aNumOpenBracesStack.size() - 1;
		Integer aCurrentValue = aNumOpenBracesStack.get(aTopIndex);
		aNumOpenBracesStack.set(aTopIndex, aCurrentValue - 1);
	}
	
	public static boolean startsWithTypeName(String aLine) {
		for (String aTypeName:typeNames) {
			if (aLine.startsWith(aTypeName)) {
				return true;
			}
		}
		return false;
	}

	public static List<OpenMPPragma> getOpenMPPragmas(String[] aFileLines) {
		List<OpenMPPragma> retVal = new ArrayList();
		Stack<OpenMPPragma> anOpenMPPragmas = new Stack();
		Stack<Integer> aNumOpenBracesStack = new Stack();
//		OpenMPPragma lastOpenMPPragma = null;
//		String lastReductionVariable = null;
//		String lastReductionOperation = null;
//		int aNumOpenBraces = 0;
		boolean aNextCodeLineIsAPragmaBlock = false;
		List<OpenMPPragma> newOpenMPPragmas = null;
		for (int i = 0; i < aFileLines.length; i++) {
			String aFileLine = aFileLines[i].trim();
			if (!isCodeLine(aFileLine)) {
				continue;
			}
			addToStack(anOpenMPPragmas, aFileLine, i); // if it is empty add to none
//			if (lastReductionVariable != null) {
//				if (aFileLine.startsWith(lastReductionVariable)) {
//					lastOpenMPPragma.getReductionVariableAssignments().add(aFileLine);
//					if (lastReductionOperation != null) { // can it ever be not null
//						if (aFileLine.contains(lastReductionOperation)) {
//							lastOpenMPPragma.getReductionOperationUses().add(aFileLine);
//						}
//					}
//				}			
//			}
//			if (lastOpenMPPragma != null && lastOpenMPPragma.getFirstOpenMPKeyword() == OpenMPKeywordEnum.PARALLEL) {
//				if (startsWithTypeName(aFileLine)) {
//					lastOpenMPPragma.getVariableDeclarationsInParallel().add(aFileLine);
//				}
//			} 
//			else if (lastOpenMPPragma != null && lastOpenMPPragma.getFirstOpenMPKeyword() == OpenMPKeywordEnum.CRITICAL) {
//				String[] aTokens = aFileLine.split("\\s+");
//				lastOpenMPPragma.setAssignedVariableInCritical(aTokens[0]);				
//			}
			if (isPragmaStart(aFileLine)) {
				
				newOpenMPPragmas = getOpenMPPragmas(aFileLine, i);
				if (newOpenMPPragmas.size() != 0) {
					for (OpenMPPragma anOpenMPPragma:newOpenMPPragmas) {
						if (anOpenMPPragmas.size() > 0) {
						    anOpenMPPragma.setParent(anOpenMPPragmas.peek());
						}
						anOpenMPPragmas.push(anOpenMPPragma);
						aNumOpenBracesStack.push(0);
						retVal.add(anOpenMPPragma);

					}
//					anOpenMPPragmas.addAll(newOpenMPPragmas);
					aNumOpenBracesStack.add(0);
//					retVal.add(lastOpenMPPragma);					
					aNextCodeLineIsAPragmaBlock = true;
//					String lastReductionOperation = lastOpenMPPragma.getReductionOperation();
//					String lastReductionVariable = lastOpenMPPragma.getReductionVariable();
					continue;
				} 
			}
			if (anOpenMPPragmas.isEmpty()) {
				continue;
			}	
			if (aNextCodeLineIsAPragmaBlock) {				
				anOpenMPPragmas.peek().setAnnotatedTextStartLineNumber(i);				
				aNextCodeLineIsAPragmaBlock = false;
			}
//			anOpenMPPragmas.peek().getAnnotatedText().add(aFileLine);
			if (isBlockStart(aFileLine)) {
				incrementStackTop(aNumOpenBracesStack);
			}
//			} else 
			if (isBlockEnd(aFileLine)) {
				decrementStackTop(aNumOpenBracesStack);

			}
			if (isLoopStart(aFileLine) && endsWithLoopHeader(aFileLine)) {
				continue; // gather following block also
			}
			if (aNumOpenBracesStack.peek() == 0) {
				
				anOpenMPPragmas.peek().setAnnotatedTextEndLineNumber(i);
				for (int j = 0; j < newOpenMPPragmas.size(); j++) {
					anOpenMPPragmas.pop();
					aNumOpenBracesStack.pop();
				}
//				lastOpenMPPragma = null;
//				lastReductionVariable = null;
//				lastReductionOperation = null;
				continue;
			}					
		}
		return retVal;
	}
	public static void setReductionData (OpenMPPragma lastChild, String aStoredToken, int aLeftParenIndex, int aRightParenIndex) {
		int aColonIndex = aStoredToken.indexOf(":");
		if (aLeftParenIndex != -1 && aRightParenIndex != -1 && aColonIndex != -1) {
			String anOperationString = aStoredToken.substring(aLeftParenIndex + 1, aColonIndex).trim();
			String aVariableString = aStoredToken.substring(aColonIndex + 1, aRightParenIndex).trim();
			((OpenMPForPragma) lastChild).setReductionVariable(aVariableString);
			((OpenMPForPragma) lastChild).setReductionOperation(anOperationString);
		}
	}
	public static void setSharedOrPrivateData (OpenMPPragma lastChild, String aStoredToken, int aLeftParenIndex, int aRightParenIndex, boolean isShared) {
//		int aColonIndex = aStoredToken.indexOf(":");
		if (aLeftParenIndex != -1 && aRightParenIndex != -1 ) {
			String aVariableDeclarations = aStoredToken.substring(aLeftParenIndex + 1, aRightParenIndex);
			String[] aVariables = aVariableDeclarations.split(",");
			if (isShared) {
				lastChild.setSharedVariables(aVariables);
			} else {
				lastChild.setPrivateVariables(aVariables);
			}			
		}
	}
	public static List<OpenMPPragma> getOpenMPPragmas(String aFileLine, int aLineIndex) {
		String[] aTokens = aFileLine.split("\\s+");
		if (aTokens.length <= 2) {
			return null;
		}
		if (!aTokens[1].equals("omp")) {
			return null;
		}
		if (aTokens.length < 3) {
			return null;
		}
		String aFirstToken = aTokens[2];
		OpenMPKeywordEnum anOpenMPKeyword = stringToOpenMPKeyword.get(aFirstToken);
		List<OpenMPPragma> retVal = new ArrayList();
		OpenMPPragma lastChild;
		int aStartIndex = 2;
		switch (anOpenMPKeyword) {
		case PARALLEL:
			lastChild = new AnOpenMPParallelPragma(aLineIndex);
			
//			lastChild.setFirstOpenMPKeyword(stringToOpenMPKeyword.get(aFirstToken));	

			retVal.add(lastChild);
			if (aTokens.length > 3 && aTokens[3].equals("for")) {
				OpenMPPragma aForChild = new AnOpenMPForPragma(aLineIndex);
				retVal.add(aForChild);
				lastChild = aForChild;
				aStartIndex++;
			}
			break;
		case FOR:
			lastChild = new AnOpenMPForPragma(aLineIndex);
			retVal.add (lastChild);
			break;
		case CRITICAL:
			lastChild = new AnOpenMPCriticalPragma(aLineIndex);
			retVal.add (lastChild);
			break;
			default: 
				lastChild = new AnOpenMPPragma(aLineIndex);
				retVal.add(lastChild);
			
		}
//		retVal.setFirstOpenMPKeyword(stringToOpenMPKeyword.get(aFirstToken));	
//		OpenMPPragma retVal = new AnOpenMPPragma(aLineIndex);


		for (int i = aStartIndex; i < aTokens.length; i ++) {
			String aStoredToken = aTokens[i].trim();
			if (aStoredToken.isEmpty()) {
				continue;
			}
			if (aStoredToken.startsWith("reduction") || aStoredToken.startsWith("shared") || aStoredToken.startsWith("private")) {
				//combine all tokens until ")" into one for normalization
				while (!aStoredToken.endsWith(")")) {
					i++;
					if (i >= aTokens.length) {
						break;
					}
					String aNewToken = aTokens[i].trim();
					aStoredToken += aNewToken; 					
				}
				int aLeftParenIndex = aStoredToken.indexOf("(");
				int aRightParenIndex = aStoredToken.indexOf(")");
				if (aStoredToken.startsWith("reduction")) {
					setReductionData(lastChild, aStoredToken, aLeftParenIndex, aRightParenIndex);
				} else if (aStoredToken.startsWith("private")) {
					setSharedOrPrivateData(lastChild, aStoredToken, aLeftParenIndex, aRightParenIndex, true);

				} else if (aStoredToken.startsWith("shared")) {
					setSharedOrPrivateData(lastChild, aStoredToken, aLeftParenIndex, aRightParenIndex, false);

				}
//				int aColonIndex = aStoredToken.indexOf(":");
//				if (aLeftParenIndex != -1 && aRightParenIndex != -1 && aColonIndex != -1) {
//					String anOperationString = aStoredToken.substring(aLeftParenIndex + 1, aColonIndex).trim();
//					String aVariableString = aStoredToken.substring(aColonIndex + 1, aRightParenIndex).trim();
//					((OpenMPForPragma) lastChild).setReductionVariable(aVariableString);
//					((OpenMPForPragma) lastChild).setReductionOperation(anOperationString);
//				}
				
			}
			
//			aTokens[i] = aStoredToken;
			lastChild.getOpenMPTokens().add(aStoredToken);
		}
//		String aFirstToken = retVal.getOpenMPTokens().get(0);
//		retVal.setFirstOpenMPKeyword(stringToOpenMPKeyword.get(aFirstToken));		
		return retVal;
		
		
	}
	static {
		stringToOpenMPKeyword.put("for", OpenMPKeywordEnum.FOR);
		stringToOpenMPKeyword.put("parallel", OpenMPKeywordEnum.PARALLEL);
		stringToOpenMPKeyword.put("reduce", OpenMPKeywordEnum.REDUCE);
		stringToOpenMPKeyword.put("shared", OpenMPKeywordEnum.SHARED);
		stringToOpenMPKeyword.put("private", OpenMPKeywordEnum.PRIVATE);
		stringToOpenMPKeyword.put("critical", OpenMPKeywordEnum.CRITICAL);





	}
	

}
]]></snapshot>
  </Command>
  <Command __id="67983" _type="EclipseCommand" commandID="AUTOGEN:::org.eclipse.jdt.debug.CompilationUnitEditor.BreakpointRulerActions/org.eclipse.jdt.debug.ui.actions.ManageBreakpointRulerAction" date="Mon Dec 23 23:33:44 EST 2019" starttimestamp="1576666505112" timestamp="495519662" />
  <Command __id="67984" _type="BreakPointCommand" date="Mon Dec 23 23:33:44 EST 2019" lineNumber="194" starttimestamp="1576666505112" timestamp="495519662" type="BreakPointAdded" />
  <Command __id="69343" _type="DiffBasedFileOpenCommand" date="Mon Dec 23 23:55:02 EST 2019" docASTNodeCount="146" docActiveCodeLength="1259" docExpressionCount="84" docLength="1469" projectName="GraderBasics" starttimestamp="1576666505112" timestamp="496797424">
    <filePath><![CDATA[D:\dewan_backup\Java\GraderBasics\src\gradingTools\shared\testcases\openmp\AnOpenMPCriticalPragma.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package gradingTools.shared.testcases.openmp;¶¶public class AnOpenMPCriticalPragma extends AnOpenMPPragma implements OpenMPCriticalPragma {¶	protected String assignedVariableInCritical;// separate subclass for this variable?¶	protected String assignedExpressionInCritical;// separate subclass for this variable?¶¶¶	¶	public AnOpenMPCriticalPragma(int lineNumber) {¶		super(lineNumber);¶	}¶	@Override¶	public void addToAnnotatedText(String aFileLine, int aLineNumber) {¶		super.addToAnnotatedText(aFileLine, aLineNumber);¶		String[] aTokens = aFileLine.split("\\s+");¶		setAssignedVariableInCritical(aTokens[0]);¶		"), Diff(INSERT,"¶//		String anExpressionString = aFileLine.substring(aFileLine.indexOf("=") + 1, aFileLine.length());¶		"), Diff(EQUAL,"String anExpressionString = aFileLine.substring(aTokens[0].length(), aFileLine.length());"), Diff(INSERT," // keep the assignment operation¶"), Diff(EQUAL,"¶		setAssignedExpressionInCritical(anExpressionString);¶	}¶	@Override¶	public String getAssignedVariableInCritical() {¶		return assignedVariableInCritical;¶	}¶	@Override¶	public void setAssignedVariableInCritical(String assignedVariableInCritical) {¶		this.assignedVariableInCritical = assignedVariableInCritical;¶	}¶	@Override¶	public String getAssignedExpressionInCritical() {¶		return assignedExpressionInCritical;¶	}¶	@Override¶	public void setAssignedExpressionInCritical(String assignedExpressionInCritical) {¶		this.assignedExpressionInCritical = assignedExpressionInCritical;¶	}¶}¶")]]]></diff>
    <snapshot><![CDATA[package gradingTools.shared.testcases.openmp;

public class AnOpenMPCriticalPragma extends AnOpenMPPragma implements OpenMPCriticalPragma {
	protected String assignedVariableInCritical;// separate subclass for this variable?
	protected String assignedExpressionInCritical;// separate subclass for this variable?


	
	public AnOpenMPCriticalPragma(int lineNumber) {
		super(lineNumber);
	}
	@Override
	public void addToAnnotatedText(String aFileLine, int aLineNumber) {
		super.addToAnnotatedText(aFileLine, aLineNumber);
		String[] aTokens = aFileLine.split("\\s+");
		setAssignedVariableInCritical(aTokens[0]);
		
//		String anExpressionString = aFileLine.substring(aFileLine.indexOf("=") + 1, aFileLine.length());
		String anExpressionString = aFileLine.substring(aTokens[0].length(), aFileLine.length()); // keep the assignment operation

		setAssignedExpressionInCritical(anExpressionString);
	}
	@Override
	public String getAssignedVariableInCritical() {
		return assignedVariableInCritical;
	}
	@Override
	public void setAssignedVariableInCritical(String assignedVariableInCritical) {
		this.assignedVariableInCritical = assignedVariableInCritical;
	}
	@Override
	public String getAssignedExpressionInCritical() {
		return assignedExpressionInCritical;
	}
	@Override
	public void setAssignedExpressionInCritical(String assignedExpressionInCritical) {
		this.assignedExpressionInCritical = assignedExpressionInCritical;
	}
}
]]></snapshot>
  </Command>
  <Command __id="69344" _type="MoveCaretCommand" caretOffset="858" date="Mon Dec 23 23:55:02 EST 2019" docOffset="858" starttimestamp="1576666505112" timestamp="496797760" />
  <Command __id="69346" _type="MoveCaretCommand" caretOffset="336" date="Mon Dec 23 23:55:33 EST 2019" docOffset="336" starttimestamp="1576666505112" timestamp="496828132" />
  <Command __id="69347" _type="EclipseCommand" commandID="" date="Mon Dec 23 23:55:33 EST 2019" starttimestamp="1576666505112" timestamp="496828608" />
  <Command __id="69348" _type="EclipseCommand" commandID="" date="Mon Dec 23 23:55:33 EST 2019" starttimestamp="1576666505112" timestamp="496828728" />
  <Command __id="69345" _type="DiffBasedFileOpenCommand" date="Mon Dec 23 23:55:32 EST 2019" docASTNodeCount="1" docActiveCodeLength="658" docExpressionCount="0" docLength="746" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="496827801">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\my_sum_parallel_for_local_var.cpp]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"#include <iostream>¶#include <omp.h>¶¶using namespace std;¶¶void printSumWithTimes (int sum, int start, int end);¶void printNumThreads();¶void recordThreadIndex(int index);¶void sum_parallel_for_local_var(double* array, int size)¶{¶	cout << "sum_parallel_for_local_var\n";¶¶	double start = omp_get_wtime();¶¶	double sum = 0;¶¶	int a, b;¶//¶//	for (int i = 0; i < size; i++) {¶//			sum += array[i];¶//			recordThreadIndex(i);¶//	}¶    #pragma omp parallel shared (sum, start) private (a, b)¶	{¶		double local_sum = 0;¶¶		#pragma omp for¶		for(int i = 0; i < size; i++) {¶			local_sum += array[i];¶			recordThreadIndex(i);¶		}¶¶		#pragma omp critical¶		sum += local_sum;¶	}¶¶	double end = omp_get_wtime();¶¶	printSumWithTimes(sum, start, end);¶	¶}¶")]]]></diff>
  </Command>
  <DocumentChange __id="69350" _type="Delete" date="Mon Dec 23 23:55:40 EST 2019" docASTNodeCount="1" docActiveCodeLength="624" docExpressionCount="0" docLength="712" endLine="22" length="34" offset="455" startLine="22" starttimestamp="1576666505112" timestamp="496835017">
    <text><![CDATA[shared (sum, start) private (a, b)]]></text>
  </DocumentChange>
  <Command __id="69349" _type="SelectTextCommand" caretOffset="489" date="Mon Dec 23 23:55:39 EST 2019" end="489" start="455" starttimestamp="1576666505112" timestamp="496834448" />
  <Command __id="69351" _type="EclipseCommand" commandID="org.eclipse.ui.edit.delete" date="Mon Dec 23 23:55:40 EST 2019" starttimestamp="1576666505112" timestamp="496835040" />
  <Command __id="69353" _type="UndoCommand" date="Mon Dec 23 23:55:43 EST 2019" starttimestamp="1576666505112" timestamp="496838802" />
  <Command __id="69354" _type="MoveCaretCommand" caretOffset="668" date="Mon Dec 23 23:56:04 EST 2019" docOffset="668" starttimestamp="1576666505112" timestamp="496859241" />
  <Command __id="69355" _type="SelectTextCommand" caretOffset="627" date="Mon Dec 23 23:56:07 EST 2019" end="668" start="627" starttimestamp="1576666505112" timestamp="496862018" />
  <Command __id="69356" _type="CopyCommand" date="Mon Dec 23 23:56:08 EST 2019" starttimestamp="1576666505112" timestamp="496862903" />
  <Command __id="69357" _type="MoveCaretCommand" caretOffset="429" date="Mon Dec 23 23:56:09 EST 2019" docOffset="429" starttimestamp="1576666505112" timestamp="496864518" />
  <Command __id="69359" _type="InsertStringCommand" date="Mon Dec 23 23:56:10 EST 2019" starttimestamp="1576666505112" timestamp="496865325" timestamp2="496865325">
    <data><![CDATA[]]></data>
  </Command>
  <Command __id="69361" _type="PasteCommand" date="Mon Dec 23 23:56:11 EST 2019" starttimestamp="1576666505112" timestamp="496866143" />
  <Command __id="69362" _type="MoveCaretCommand" caretOffset="430" date="Mon Dec 23 23:56:13 EST 2019" docOffset="430" starttimestamp="1576666505112" timestamp="496868016" />
  <Command __id="69364" _type="InsertStringCommand" date="Mon Dec 23 23:56:13 EST 2019" starttimestamp="1576666505112" timestamp="496868586" timestamp2="496868586">
    <data><![CDATA[	]]></data>
  </Command>
  <Command __id="69365" _type="SelectTextCommand" caretOffset="469" date="Mon Dec 23 23:56:16 EST 2019" end="469" start="460" starttimestamp="1576666505112" timestamp="496870889" />
  <Command __id="69367" _type="InsertStringCommand" date="Mon Dec 23 23:56:16 EST 2019" starttimestamp="1576666505112" timestamp="496871647" timestamp2="496871647">
    <data><![CDATA[0]]></data>
  </Command>
  <Command __id="69368" _type="EclipseCommand" commandID="org.eclipse.ui.file.save" date="Mon Dec 23 23:56:17 EST 2019" starttimestamp="1576666505112" timestamp="496872685" />
  <Command __id="69369" _type="EclipseCommand" commandID="org.eclipse.debug.ui.commands.RunLast" date="Mon Dec 23 23:56:21 EST 2019" starttimestamp="1576666505112" timestamp="496875926" />
  <Command __id="69370" _type="RunCommand" date="Mon Dec 23 23:56:21 EST 2019" kind="HitBreakPoint" projectName="PL_Java" starttimestamp="1576666505112" timestamp="496876444" type="Run" />
  <Command __id="69371" _type="RunCommand" date="Mon Dec 23 23:56:21 EST 2019" kind="HitBreakPoint" projectName="PL_Java" starttimestamp="1576666505112" timestamp="496876444" type="Run" />
  <Command __id="69372" _type="EHExceptionCommand" date="Mon Dec 23 23:56:21 EST 2019" starttimestamp="1576666505112" timestamp="496876698" type="Exception">
    <outputString><![CDATA[I***Tracer: showInfo = true
Buffer traced nessages =false
]]></outputString>
  </Command>
  <Command __id="69373" _type="EHExceptionCommand" date="Mon Dec 23 23:56:22 EST 2019" starttimestamp="1576666505112" timestamp="496877406" type="Exception">
    <outputString><![CDATA[ObjectEditor(Version 22, built on Thu Dec 06 16:26:09 EST 2018). Copyright Prasun Dewan, 2012, All rights reserved. US Patent Appl. No.: 12/532,327
]]></outputString>
  </Command>
  <Command __id="69374" _type="ShellCommand" date="Mon Dec 23 23:56:22 EST 2019" starttimestamp="1576666505112" timestamp="496877801" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="69375" _type="ShellCommand" date="Mon Dec 23 23:56:24 EST 2019" starttimestamp="1576666505112" timestamp="496879330" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="69376" _type="MoveCaretCommand" caretOffset="451" date="Mon Dec 23 23:56:24 EST 2019" docOffset="451" starttimestamp="1576666505112" timestamp="496879457" />
  <Command __id="69377" _type="SelectTextCommand" caretOffset="430" date="Mon Dec 23 23:56:36 EST 2019" end="462" start="430" starttimestamp="1576666505112" timestamp="496890891" />
  <Command __id="69379" _type="EclipseCommand" commandID="org.eclipse.ui.edit.delete" date="Mon Dec 23 23:56:36 EST 2019" starttimestamp="1576666505112" timestamp="496891535" />
  <Command __id="69380" _type="EclipseCommand" commandID="org.eclipse.ui.file.save" date="Mon Dec 23 23:56:38 EST 2019" starttimestamp="1576666505112" timestamp="496893312" />
  <Command __id="69381" _type="ShellCommand" date="Mon Dec 23 23:58:22 EST 2019" starttimestamp="1576666505112" timestamp="496997689" type="ECLIPSE_LOST_FOCUS" />
  <DocumentChange __id="71055" _type="Insert" date="Tue Dec 24 07:08:07 EST 2019" docASTNodeCount="1271" docActiveCodeLength="8808" docExpressionCount="793" docLength="11329" length="1" offset="4971" starttimestamp="1576666505112" timestamp="522782419">
    <text><![CDATA[t]]></text>
  </DocumentChange>
  <DocumentChange __id="71058" _type="Insert" date="Tue Dec 24 07:08:07 EST 2019" docASTNodeCount="1271" docActiveCodeLength="8808" docExpressionCount="793" docLength="11330" length="1" offset="4972" starttimestamp="1576666505112" timestamp="522782614">
    <text><![CDATA[o]]></text>
  </DocumentChange>
  <DocumentChange __id="71061" _type="Insert" date="Tue Dec 24 07:08:07 EST 2019" docASTNodeCount="1271" docActiveCodeLength="8808" docExpressionCount="793" docLength="11331" length="1" offset="4973" starttimestamp="1576666505112" timestamp="522782771">
    <text><![CDATA[p]]></text>
  </DocumentChange>
  <DocumentChange __id="71064" _type="Insert" date="Tue Dec 24 07:08:08 EST 2019" docASTNodeCount="1271" docActiveCodeLength="8808" docExpressionCount="793" docLength="11332" length="1" offset="4974" starttimestamp="1576666505112" timestamp="522783042">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="71067" _type="Insert" date="Tue Dec 24 07:08:08 EST 2019" docASTNodeCount="1271" docActiveCodeLength="8808" docExpressionCount="793" docLength="11333" length="1" offset="4975" starttimestamp="1576666505112" timestamp="522783185">
    <text><![CDATA[l]]></text>
  </DocumentChange>
  <DocumentChange __id="71070" _type="Insert" date="Tue Dec 24 07:08:08 EST 2019" docASTNodeCount="1271" docActiveCodeLength="8808" docExpressionCount="793" docLength="11334" length="1" offset="4976" starttimestamp="1576666505112" timestamp="522783306">
    <text><![CDATA[e]]></text>
  </DocumentChange>
  <DocumentChange __id="71073" _type="Insert" date="Tue Dec 24 07:08:08 EST 2019" docASTNodeCount="1271" docActiveCodeLength="8808" docExpressionCount="793" docLength="11335" length="1" offset="4977" starttimestamp="1576666505112" timestamp="522783504">
    <text><![CDATA[v]]></text>
  </DocumentChange>
  <DocumentChange __id="71076" _type="Insert" date="Tue Dec 24 07:08:08 EST 2019" docASTNodeCount="1271" docActiveCodeLength="8808" docExpressionCount="793" docLength="11336" length="1" offset="4978" starttimestamp="1576666505112" timestamp="522783619">
    <text><![CDATA[e]]></text>
  </DocumentChange>
  <DocumentChange __id="71079" _type="Insert" date="Tue Dec 24 07:08:08 EST 2019" docASTNodeCount="1271" docActiveCodeLength="8808" docExpressionCount="793" docLength="11337" length="1" offset="4979" starttimestamp="1576666505112" timestamp="522783812">
    <text><![CDATA[l]]></text>
  </DocumentChange>
  <DocumentChange __id="71082" _type="Insert" date="Tue Dec 24 07:08:09 EST 2019" docASTNodeCount="1271" docActiveCodeLength="8808" docExpressionCount="793" docLength="11338" length="1" offset="4980" starttimestamp="1576666505112" timestamp="522783972">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="71085" _type="Insert" date="Tue Dec 24 07:08:09 EST 2019" docASTNodeCount="1271" docActiveCodeLength="8808" docExpressionCount="793" docLength="11339" length="1" offset="4981" starttimestamp="1576666505112" timestamp="522784183">
    <text><![CDATA[p]]></text>
  </DocumentChange>
  <DocumentChange __id="71088" _type="Insert" date="Tue Dec 24 07:08:09 EST 2019" docASTNodeCount="1271" docActiveCodeLength="8808" docExpressionCount="793" docLength="11340" length="1" offset="4982" starttimestamp="1576666505112" timestamp="522784386">
    <text><![CDATA[r]]></text>
  </DocumentChange>
  <DocumentChange __id="71091" _type="Insert" date="Tue Dec 24 07:08:09 EST 2019" docASTNodeCount="1271" docActiveCodeLength="8808" docExpressionCount="793" docLength="11341" length="1" offset="4983" starttimestamp="1576666505112" timestamp="522784706">
    <text><![CDATA[g]]></text>
  </DocumentChange>
  <DocumentChange __id="71094" _type="Insert" date="Tue Dec 24 07:08:10 EST 2019" docASTNodeCount="1271" docActiveCodeLength="8808" docExpressionCount="793" docLength="11342" length="1" offset="4984" starttimestamp="1576666505112" timestamp="522784893">
    <text><![CDATA[a]]></text>
  </DocumentChange>
  <DocumentChange __id="71097" _type="Insert" date="Tue Dec 24 07:08:10 EST 2019" docASTNodeCount="1271" docActiveCodeLength="8808" docExpressionCount="793" docLength="11343" length="1" offset="4985" starttimestamp="1576666505112" timestamp="522785088">
    <text><![CDATA[m]]></text>
  </DocumentChange>
  <DocumentChange __id="71100" _type="Insert" date="Tue Dec 24 07:08:10 EST 2019" docASTNodeCount="1271" docActiveCodeLength="8808" docExpressionCount="793" docLength="11344" length="1" offset="4986" starttimestamp="1576666505112" timestamp="522785296">
    <text><![CDATA[a]]></text>
  </DocumentChange>
  <DocumentChange __id="71103" _type="Insert" date="Tue Dec 24 07:08:10 EST 2019" docASTNodeCount="1271" docActiveCodeLength="8808" docExpressionCount="793" docLength="11345" length="1" offset="4987" starttimestamp="1576666505112" timestamp="522785621">
    <text><![CDATA[s]]></text>
  </DocumentChange>
  <Command __id="71141" _type="RunCommand" date="Tue Dec 24 07:08:14 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="522789147" type="Debug" />
  <Command __id="71142" _type="RunCommand" date="Tue Dec 24 07:08:14 EST 2019" kind="HitBreakPoint" projectName="PL_Java" starttimestamp="1576666505112" timestamp="522789147" type="Run" />
  <Command __id="71143" _type="RunCommand" date="Tue Dec 24 07:08:14 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="522789147" type="Debug" />
  <Command __id="71144" _type="RunCommand" date="Tue Dec 24 07:08:14 EST 2019" kind="HitBreakPoint" projectName="PL_Java" starttimestamp="1576666505112" timestamp="522789147" type="Run" />
  <Command __id="71146" _type="SelectTextCommand" caretOffset="501" date="Tue Dec 24 07:08:39 EST 2019" end="501" start="480" starttimestamp="1576666505112" timestamp="522813954" />
  <Command __id="71147" _type="EclipseCommand" commandID="" date="Tue Dec 24 07:08:39 EST 2019" starttimestamp="1576666505112" timestamp="522814598" />
  <Command __id="71148" _type="EclipseCommand" commandID="" date="Tue Dec 24 07:08:39 EST 2019" starttimestamp="1576666505112" timestamp="522814648" />
  <Command __id="71149" _type="SelectTextCommand" caretOffset="706" date="Tue Dec 24 07:08:54 EST 2019" end="747" start="706" starttimestamp="1576666505112" timestamp="522829751" />
  <Command __id="71150" _type="CopyCommand" date="Tue Dec 24 07:08:55 EST 2019" starttimestamp="1576666505112" timestamp="522830567" />
  <Command __id="71151" _type="MoveCaretCommand" caretOffset="375" date="Tue Dec 24 07:09:01 EST 2019" docOffset="375" starttimestamp="1576666505112" timestamp="522836812" />
  <Command __id="71153" _type="InsertStringCommand" date="Tue Dec 24 07:09:02 EST 2019" starttimestamp="1576666505112" timestamp="522837411" timestamp2="522837411">
    <data><![CDATA[]]></data>
  </Command>
  <Command __id="71155" _type="PasteCommand" date="Tue Dec 24 07:09:03 EST 2019" starttimestamp="1576666505112" timestamp="522838264" />
  <Command __id="71156" _type="MoveCaretCommand" caretOffset="376" date="Tue Dec 24 07:09:05 EST 2019" docOffset="376" starttimestamp="1576666505112" timestamp="522840481" />
  <Command __id="71158" _type="InsertStringCommand" date="Tue Dec 24 07:09:05 EST 2019" starttimestamp="1576666505112" timestamp="522840759" timestamp2="522840759">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="71160" _type="InsertStringCommand" date="Tue Dec 24 07:09:06 EST 2019" starttimestamp="1576666505112" timestamp="522841005" timestamp2="522841005">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="71162" _type="InsertStringCommand" date="Tue Dec 24 07:09:06 EST 2019" starttimestamp="1576666505112" timestamp="522841184" timestamp2="522841184">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="71163" _type="SelectTextCommand" caretOffset="417" date="Tue Dec 24 07:09:11 EST 2019" end="417" start="408" starttimestamp="1576666505112" timestamp="522846111" />
  <Command __id="71165" _type="InsertStringCommand" date="Tue Dec 24 07:09:11 EST 2019" starttimestamp="1576666505112" timestamp="522846820" timestamp2="522846820">
    <data><![CDATA[0]]></data>
  </Command>
  <Command __id="71166" _type="EclipseCommand" commandID="org.eclipse.ui.file.save" date="Tue Dec 24 07:09:14 EST 2019" starttimestamp="1576666505112" timestamp="522848923" />
  <Command __id="71167" _type="SelectTextCommand" caretOffset="297" date="Tue Dec 24 07:09:18 EST 2019" end="375" start="297" starttimestamp="1576666505112" timestamp="522853049" />
  <Command __id="71169" _type="EclipseCommand" commandID="org.eclipse.ui.edit.delete" date="Tue Dec 24 07:09:18 EST 2019" starttimestamp="1576666505112" timestamp="522853756" />
  <Command __id="71170" _type="EclipseCommand" commandID="org.eclipse.ui.file.save" date="Tue Dec 24 07:09:20 EST 2019" starttimestamp="1576666505112" timestamp="522855285" />
  <Command __id="71171" _type="MoveCaretCommand" caretOffset="301" date="Tue Dec 24 07:09:23 EST 2019" docOffset="301" starttimestamp="1576666505112" timestamp="522857895" />
  <Command __id="71173" _type="InsertStringCommand" date="Tue Dec 24 07:09:23 EST 2019" starttimestamp="1576666505112" timestamp="522858139" timestamp2="522858139">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="71627" _type="DiffBasedFileOpenCommand" date="Tue Dec 24 07:27:01 EST 2019" docASTNodeCount="346" docActiveCodeLength="2355" docExpressionCount="251" docLength="2362" projectName="DemoCourseLocalBasicChecks" starttimestamp="1576666505112" timestamp="523915964">
    <filePath><![CDATA[D:\dewan_backup\Java\DemoCourseLocalBasicChecks\src\gradingTools\comp123\assignment1\openmp\testcases\SequentialSumTestCase.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package gradingTools.comp123.assignment1.openmp.testcases;¶¶import java.util.Arrays;¶import java.util.List;¶import java.util.Map;¶import java.util.regex.Pattern;¶¶import grader.basics.execution.NotRunnableException;¶import grader.basics.execution.RunningProject;¶import grader.basics.junit.NotAutomatableException;¶import grader.basics.junit.TestCaseResult;¶import grader.basics.project.NotGradableException;¶import grader.basics.project.Project;¶import grader.basics.project.source.ABasicTextManager;¶import grader.basics.testcase.PassFailJUnitTestCase;¶import gradingTools.shared.testcases.SubstringSequenceChecker;¶import gradingTools.shared.testcases.openmp.OpenMPPragma;¶import gradingTools.shared.testcases.openmp.OpenMPUtils;¶import gradingTools.shared.testcases.utils.LinesMatchKind;¶import gradingTools.shared.testcases.utils.LinesMatcher;¶import gradingTools.utils.RunningProjectUtils;¶¶public class SequentialSumTestCase extends PassFailJUnitTestCase {¶	public static final int TIME_OUT_SECS = 1; // secs¶	protected SubstringSequenceChecker checker = new ASequentialSumChecker();	¶¶	public SequentialSumTestCase() {¶	}¶¶	¶¶	@Override¶	public TestCaseResult test(Project project, boolean autoGrade) throws NotAutomatableException,¶			NotGradableException {¶		try {¶			RunningProject aRunningProject = RunningProjectUtils.runProject(project, TIME_OUT_SECS);¶			String anOutput = aRunningProject.await();¶			LinesMatcher aLinesMatcher = aRunningProject.getLinesMatcher();¶			boolean aRetval = checker.check(aLinesMatcher, LinesMatchKind.ONE_TIME_LINE, Pattern.DOTALL);¶			String aSource = project.getSource();¶			Map<String, StringBuffer> aFileNameToContents = ABasicTextManager.extractFileContents(aSource);¶			for (String aFileName:aFileNameToContents.keySet()) {¶				StringBuffer aFileContents = aFileNameToContents.get(aFileName);¶				List<OpenMPPragma> anOpenMPPragmas = OpenMPUtils.getOpemMPPragmas(aFileContents);¶				System.out.println("file name:" + aFileName);¶				System.out.println("pragmas:" + anOpenMPPragmas);¶			}¶			String anExpectedLines = Arrays.toString(checker.getSubstrings());¶¶			if (!aRetval) {¶				return fail("Output  did not match:" + anExpectedLines);¶¶			}¶			return pass();¶			¶¶		} catch (NotRunnableException e) {¶			throw new NotGradableException();¶		}¶	}¶}¶")]]]></diff>
  </Command>
  <Command __id="71636" _type="DiffBasedFileOpenCommand" date="Tue Dec 24 07:27:05 EST 2019" docASTNodeCount="1268" docActiveCodeLength="8768" docExpressionCount="793" docLength="11466" projectName="GraderBasics" starttimestamp="1576666505112" timestamp="523920374">
    <filePath><![CDATA[D:\dewan_backup\Java\GraderBasics\src\gradingTools\shared\testcases\openmp\OpenMPUtils.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package gradingTools.shared.testcases.openmp;¶¶import java.util.ArrayList;¶import java.util.HashMap;¶import java.util.List;¶import java.util.Map;¶import java.util.Stack;¶¶¶public class OpenMPUtils {¶	¶	protected static Map<String, OpenMPKeywordEnum> stringToOpenMPKeyword = new HashMap();¶	protected static String[] typeNames = {"double", "float", "int", "short", "long"};¶	protected static String[] openMPCalls = {"omp_get_thread_num()", "omp_get_num_threads()"};¶	public static List<OpenMPPragma> getOpemMPPragmas(StringBuffer aFileBuffer) {¶		String[] aFileLines = aFileBuffer.toString().split("\n");¶		return getOpenMPPragmas(aFileLines);¶	}¶	¶	public static boolean isCodeLine(String aLine) {¶		return !aLine.isEmpty() && !aLine.startsWith("//");¶	}¶	public static boolean isBlockStart(String aLine) {¶		return aLine.contains("{");¶	}¶	public static boolean isBlockEnd(String aLine) {¶		return aLine.contains("}");¶	}¶	public static boolean isLoopStart(String aLine) {¶		return aLine.startsWith("for");¶	}¶	public static boolean endsWithLoopHeader(String aLine) {¶		return aLine.endsWith(")");¶	}¶	public static boolean isPragmaStart(String aLine) {¶		return aLine.startsWith("#pragma");¶	}¶	public static void addToStack(Stack<OpenMPPragma> anOpenMPPragmas, String aFileLine, int aLineNumber) {¶		if (anOpenMPPragmas.size() > 0) {¶			anOpenMPPragmas.peek().addToAnnotatedText(aFileLine, aLineNumber);¶		}¶//		for (OpenMPPragma anOpenMPPragma:anOpenMPPragmas) {¶//			anOpenMPPragma.addToAnnotatedText(aFileLine, aLineNumber);				¶//		}¶		¶	}¶	public static ForHeader getForHeader(String aFileLine, int aLineNumber) {¶		if (!aFileLine.startsWith("for"))¶			return null;¶		int aLeftParenIndex = aFileLine.indexOf("(");¶		int aRightParenIndex = aFileLine.indexOf(")");¶		if (aLeftParenIndex < 0 || aRightParenIndex < 0) {¶			return null;¶		}¶		String aHeaderString = aFileLine.substring(aLeftParenIndex + 1, aRightParenIndex);¶		String[] aForComponents = aHeaderString.split(";");¶		return new AForHeader(aForComponents[0], aForComponents[1], aForComponents[2], aLineNumber);¶	}¶	public static List<String> getOMPCalls(String aFileLine) {¶		List<String> retVal = new ArrayList();¶		for (String anOpenMPCall:openMPCalls) {¶			if (aFileLine.contains(anOpenMPCall)) {¶				retVal.add(anOpenMPCall);¶			}¶		}¶		return retVal;¶	}¶	¶	¶	¶	public static void incrementStackTop (Stack<Integer> aNumOpenBracesStack) {¶		int aTopIndex = aNumOpenBracesStack.size() - 1;¶		Integer aCurrentValue = aNumOpenBracesStack.get(aTopIndex);¶		aNumOpenBracesStack.set(aTopIndex, aCurrentValue + 1);¶	}¶	public static void decrementStackTop (Stack<Integer> aNumOpenBracesStack) {¶		int aTopIndex = aNumOpenBracesStack.size() - 1;¶		Integer aCurrentValue = aNumOpenBracesStack.get(aTopIndex);¶		aNumOpenBracesStack.set(aTopIndex, aCurrentValue - 1);¶	}¶	¶	public static boolean startsWithTypeName(String aLine) {¶		for (String aTypeName:typeNames) {¶			if (aLine.startsWith(aTypeName)) {¶				return true;¶			}¶		}¶		return false;¶	}¶¶	public static List<OpenMPPragma> getOpenMPPragmas(String[] aFileLines) {¶		List<OpenMPPragma> retVal = new ArrayList();¶		Stack<OpenMPPragma> anOpenMPPragmas = new Stack();¶		Stack<Integer> aNumOpenBracesStack = new Stack();¶//		OpenMPPragma lastOpenMPPragma = null;¶//		String lastReductionVariable = null;¶//		String lastReductionOperation = null;¶//		int aNumOpenBraces = 0;¶		boolean aNextCodeLineIsAPragmaBlock = false;¶		List<OpenMPPragma> newOpenMPPragmas = null;¶		for (int i = 0; i < aFileLines.length; i++) {¶			String aFileLine = aFileLines[i].trim();¶			if (!isCodeLine(aFileLine)) {¶				continue;¶			}¶			addToStack(anOpenMPPragmas, aFileLine, i); // if it is empty add to none¶//			if (lastReductionVariable != null) {¶//				if (aFileLine.startsWith(lastReductionVariable)) {¶//					lastOpenMPPragma.getReductionVariableAssignments().add(aFileLine);¶//					if (lastReductionOperation != null) { // can it ever be not null¶//						if (aFileLine.contains(lastReductionOperation)) {¶//							lastOpenMPPragma.getReductionOperationUses().add(aFileLine);¶//						}¶//					}¶//				}			¶//			}¶//			if (lastOpenMPPragma != null && lastOpenMPPragma.getFirstOpenMPKeyword() == OpenMPKeywordEnum.PARALLEL) {¶//				if (startsWithTypeName(aFileLine)) {¶//					lastOpenMPPragma.getVariableDeclarationsInParallel().add(aFileLine);¶//				}¶//			} ¶//			else if (lastOpenMPPragma != null && lastOpenMPPragma.getFirstOpenMPKeyword() == OpenMPKeywordEnum.CRITICAL) {¶//				String[] aTokens = aFileLine.split("\\s+");¶//				lastOpenMPPragma.setAssignedVariableInCritical(aTokens[0]);				¶//			}¶			if (isPragmaStart(aFileLine)) {¶				¶				newOpenMPPragmas = getOpenMPPragmas(aFileLine, i);¶				if (newOpenMPPragmas.size() != 0) {¶					for (OpenMPPragma anOpenMPPragma:newOpenMPPragmas) {¶						if (anOpenMPPragmas.size() > 0) {¶						    anOpenMPPragma.setParent(anOpenMPPragmas.peek());¶						} else {¶							retVal.add(anOpenMPPragma); // add only top level prgamas¶¶						}¶						anOpenMPPragmas.push(anOpenMPPragma);¶						aNumOpenBracesStack.push(0);¶//						retVal.add(anOpenMPPragma);¶¶					}¶//					anOpenMPPragmas.addAll(newOpenMPPragmas);¶"), Diff(INSERT,"//"), Diff(EQUAL,"					aNumOpenBracesStack.add(0);¶//					retVal.add(lastOpenMPPragma);					¶					aNextCodeLineIsAPragmaBlock = true;¶//					String lastReductionOperation = lastOpenMPPragma.getReductionOperation();¶//					String lastReductionVariable = lastOpenMPPragma.getReductionVariable();¶					continue;¶				} ¶			}¶			if (anOpenMPPragmas.isEmpty()) {¶				continue;¶			}	¶			if (aNextCodeLineIsAPragmaBlock) {				¶				anOpenMPPragmas.peek().setAnnotatedTextStartLineNumber(i);				¶				aNextCodeLineIsAPragmaBlock = false;¶			}¶//			anOpenMPPragmas.peek().getAnnotatedText().add(aFileLine);¶			if (isBlockStart(aFileLine)) {¶				incrementStackTop(aNumOpenBracesStack);¶			}¶//			} else ¶			if (isBlockEnd(aFileLine)) {¶				decrementStackTop(aNumOpenBracesStack);¶¶			}¶			if (isLoopStart(aFileLine) && endsWithLoopHeader(aFileLine)) {¶				continue; // gather following block also¶			}¶			if (aNumOpenBracesStack.peek() == 0) {¶				¶				anOpenMPPragmas.peek().setAnnotatedTextEndLineNumber(i);¶				for (int j = 0; j < newOpenMPPragmas.size(); j++) {¶					anOpenMPPragmas.pop();¶					aNumOpenBracesStack.pop();¶				}¶//				lastOpenMPPragma = null;¶//				lastReductionVariable = null;¶//				lastReductionOperation = null;¶				continue;¶			}					¶		}¶		return retVal;¶	}¶	public static void setReductionData (OpenMPPragma lastChild, String aStoredToken, int aLeftParenIndex, int aRightParenIndex) {¶		int aColonIndex = aStoredToken.indexOf(":");¶		if (aLeftParenIndex != -1 && aRightParenIndex != -1 && aColonIndex != -1) {¶			String anOperationString = aStoredToken.substring(aLeftParenIndex + 1, aColonIndex).trim();¶			String aVariableString = aStoredToken.substring(aColonIndex + 1, aRightParenIndex).trim();¶			((OpenMPForPragma) lastChild).setReductionVariable(aVariableString);¶			((OpenMPForPragma) lastChild).setReductionOperation(anOperationString);¶		}¶	}¶	public static void setSharedOrPrivateData (OpenMPPragma lastChild, String aStoredToken, int aLeftParenIndex, int aRightParenIndex, boolean isShared) {¶//		int aColonIndex = aStoredToken.indexOf(":");¶		if (aLeftParenIndex != -1 && aRightParenIndex != -1 ) {¶			String aVariableDeclarations = aStoredToken.substring(aLeftParenIndex + 1, aRightParenIndex);¶			String[] aVariables = aVariableDeclarations.split(",");¶			if (isShared) {¶				lastChild.setSharedVariables(aVariables);¶			} else {¶				lastChild.setPrivateVariables(aVariables);¶			}			¶		}¶	}¶	public static List<OpenMPPragma> getOpenMPPragmas(String aFileLine, int aLineIndex) {¶		String[] aTokens = aFileLine.split("\\s+");¶		if (aTokens.length <= 2) {¶			return null;¶		}¶		if (!aTokens[1].equals("omp")) {¶			return null;¶		}¶		if (aTokens.length < 3) {¶			return null;¶		}¶		String aFirstToken = aTokens[2];¶		OpenMPKeywordEnum anOpenMPKeyword = stringToOpenMPKeyword.get(aFirstToken);¶		List<OpenMPPragma> retVal = new ArrayList();¶		OpenMPPragma lastChild;¶		int aStartIndex = 2;¶		switch (anOpenMPKeyword) {¶		case PARALLEL:¶			lastChild = new AnOpenMPParallelPragma(aLineIndex);¶			¶//			lastChild.setFirstOpenMPKeyword(stringToOpenMPKeyword.get(aFirstToken));	¶¶			retVal.add(lastChild);¶			if (aTokens.length > 3 && aTokens[3].equals("for")) {¶				OpenMPPragma aForChild = new AnOpenMPForPragma(aLineIndex);¶				retVal.add(aForChild);¶				lastChild = aForChild;¶				aStartIndex++;¶			}¶			break;¶		case FOR:¶			lastChild = new AnOpenMPForPragma(aLineIndex);¶			retVal.add (lastChild);¶			break;¶		case CRITICAL:¶			lastChild = new AnOpenMPCriticalPragma(aLineIndex);¶			retVal.add (lastChild);¶			break;¶			default: ¶				lastChild = new AnOpenMPPragma(aLineIndex);¶				retVal.add(lastChild);¶			¶		}¶//		retVal.setFirstOpenMPKeyword(stringToOpenMPKeyword.get(aFirstToken));	¶//		OpenMPPragma retVal = new AnOpenMPPragma(aLineIndex);¶¶¶		for (int i = aStartIndex; i < aTokens.length; i ++) {¶			String aStoredToken = aTokens[i].trim();¶			if (aStoredToken.isEmpty()) {¶				continue;¶			}¶			if (aStoredToken.startsWith("reduction") || aStoredToken.startsWith("shared") || aStoredToken.startsWith("private")) {¶				//combine all tokens until ")" into one for normalization¶				while (!aStoredToken.endsWith(")")) {¶					i++;¶					if (i >= aTokens.length) {¶						break;¶					}¶					String aNewToken = aTokens[i].trim();¶					aStoredToken += aNewToken; 					¶				}¶				int aLeftParenIndex = aStoredToken.indexOf("(");¶				int aRightParenIndex = aStoredToken.indexOf(")");¶				if (aStoredToken.startsWith("reduction")) {¶					setReductionData(lastChild, aStoredToken, aLeftParenIndex, aRightParenIndex);¶				} else if (aStoredToken.startsWith("private")) {¶					setSharedOrPrivateData(lastChild, aStoredToken, aLeftParenIndex, aRightParenIndex, false);¶¶				} else if (aStoredToken.startsWith("shared")) {¶					setSharedOrPrivateData(lastChild, aStoredToken, aLeftParenIndex, aRightParenIndex, true);¶¶				}¶//				int aColonIndex = aStoredToken.indexOf(":");¶//				if (aLeftParenIndex != -1 && aRightParenIndex != -1 && aColonIndex != -1) {¶//					String anOperationString = aStoredToken.substring(aLeftParenIndex + 1, aColonIndex).trim();¶//					String aVariableString = aStoredToken.substring(aColonIndex + 1, aRightParenIndex).trim();¶//					((OpenMPForPragma) lastChild).setReductionVariable(aVariableString);¶//					((OpenMPForPragma) lastChild).setReductionOperation(anOperationString);¶//				}¶				¶			}¶			¶//			aTokens[i] = aStoredToken;¶			lastChild.getOpenMPTokens().add(aStoredToken);¶		}¶//		String aFirstToken = retVal.getOpenMPTokens().get(0);¶//		retVal.setFirstOpenMPKeyword(stringToOpenMPKeyword.get(aFirstToken));		¶		return retVal;¶		¶		¶	}¶	static {¶		stringToOpenMPKeyword.put("for", OpenMPKeywordEnum.FOR);¶		stringToOpenMPKeyword.put("parallel", OpenMPKeywordEnum.PARALLEL);¶		stringToOpenMPKeyword.put("reduce", OpenMPKeywordEnum.REDUCE);¶		stringToOpenMPKeyword.put("shared", OpenMPKeywordEnum.SHARED);¶		stringToOpenMPKeyword.put("private", OpenMPKeywordEnum.PRIVATE);¶		stringToOpenMPKeyword.put("critical", OpenMPKeywordEnum.CRITICAL);¶¶¶¶¶¶	}¶	¶¶}¶")]]]></diff>
    <snapshot><![CDATA[package gradingTools.shared.testcases.openmp;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Stack;


public class OpenMPUtils {
	
	protected static Map<String, OpenMPKeywordEnum> stringToOpenMPKeyword = new HashMap();
	protected static String[] typeNames = {"double", "float", "int", "short", "long"};
	protected static String[] openMPCalls = {"omp_get_thread_num()", "omp_get_num_threads()"};
	public static List<OpenMPPragma> getOpemMPPragmas(StringBuffer aFileBuffer) {
		String[] aFileLines = aFileBuffer.toString().split("\n");
		return getOpenMPPragmas(aFileLines);
	}
	
	public static boolean isCodeLine(String aLine) {
		return !aLine.isEmpty() && !aLine.startsWith("//");
	}
	public static boolean isBlockStart(String aLine) {
		return aLine.contains("{");
	}
	public static boolean isBlockEnd(String aLine) {
		return aLine.contains("}");
	}
	public static boolean isLoopStart(String aLine) {
		return aLine.startsWith("for");
	}
	public static boolean endsWithLoopHeader(String aLine) {
		return aLine.endsWith(")");
	}
	public static boolean isPragmaStart(String aLine) {
		return aLine.startsWith("#pragma");
	}
	public static void addToStack(Stack<OpenMPPragma> anOpenMPPragmas, String aFileLine, int aLineNumber) {
		if (anOpenMPPragmas.size() > 0) {
			anOpenMPPragmas.peek().addToAnnotatedText(aFileLine, aLineNumber);
		}
//		for (OpenMPPragma anOpenMPPragma:anOpenMPPragmas) {
//			anOpenMPPragma.addToAnnotatedText(aFileLine, aLineNumber);				
//		}
		
	}
	public static ForHeader getForHeader(String aFileLine, int aLineNumber) {
		if (!aFileLine.startsWith("for"))
			return null;
		int aLeftParenIndex = aFileLine.indexOf("(");
		int aRightParenIndex = aFileLine.indexOf(")");
		if (aLeftParenIndex < 0 || aRightParenIndex < 0) {
			return null;
		}
		String aHeaderString = aFileLine.substring(aLeftParenIndex + 1, aRightParenIndex);
		String[] aForComponents = aHeaderString.split(";");
		return new AForHeader(aForComponents[0], aForComponents[1], aForComponents[2], aLineNumber);
	}
	public static List<String> getOMPCalls(String aFileLine) {
		List<String> retVal = new ArrayList();
		for (String anOpenMPCall:openMPCalls) {
			if (aFileLine.contains(anOpenMPCall)) {
				retVal.add(anOpenMPCall);
			}
		}
		return retVal;
	}
	
	
	
	public static void incrementStackTop (Stack<Integer> aNumOpenBracesStack) {
		int aTopIndex = aNumOpenBracesStack.size() - 1;
		Integer aCurrentValue = aNumOpenBracesStack.get(aTopIndex);
		aNumOpenBracesStack.set(aTopIndex, aCurrentValue + 1);
	}
	public static void decrementStackTop (Stack<Integer> aNumOpenBracesStack) {
		int aTopIndex = aNumOpenBracesStack.size() - 1;
		Integer aCurrentValue = aNumOpenBracesStack.get(aTopIndex);
		aNumOpenBracesStack.set(aTopIndex, aCurrentValue - 1);
	}
	
	public static boolean startsWithTypeName(String aLine) {
		for (String aTypeName:typeNames) {
			if (aLine.startsWith(aTypeName)) {
				return true;
			}
		}
		return false;
	}

	public static List<OpenMPPragma> getOpenMPPragmas(String[] aFileLines) {
		List<OpenMPPragma> retVal = new ArrayList();
		Stack<OpenMPPragma> anOpenMPPragmas = new Stack();
		Stack<Integer> aNumOpenBracesStack = new Stack();
//		OpenMPPragma lastOpenMPPragma = null;
//		String lastReductionVariable = null;
//		String lastReductionOperation = null;
//		int aNumOpenBraces = 0;
		boolean aNextCodeLineIsAPragmaBlock = false;
		List<OpenMPPragma> newOpenMPPragmas = null;
		for (int i = 0; i < aFileLines.length; i++) {
			String aFileLine = aFileLines[i].trim();
			if (!isCodeLine(aFileLine)) {
				continue;
			}
			addToStack(anOpenMPPragmas, aFileLine, i); // if it is empty add to none
//			if (lastReductionVariable != null) {
//				if (aFileLine.startsWith(lastReductionVariable)) {
//					lastOpenMPPragma.getReductionVariableAssignments().add(aFileLine);
//					if (lastReductionOperation != null) { // can it ever be not null
//						if (aFileLine.contains(lastReductionOperation)) {
//							lastOpenMPPragma.getReductionOperationUses().add(aFileLine);
//						}
//					}
//				}			
//			}
//			if (lastOpenMPPragma != null && lastOpenMPPragma.getFirstOpenMPKeyword() == OpenMPKeywordEnum.PARALLEL) {
//				if (startsWithTypeName(aFileLine)) {
//					lastOpenMPPragma.getVariableDeclarationsInParallel().add(aFileLine);
//				}
//			} 
//			else if (lastOpenMPPragma != null && lastOpenMPPragma.getFirstOpenMPKeyword() == OpenMPKeywordEnum.CRITICAL) {
//				String[] aTokens = aFileLine.split("\\s+");
//				lastOpenMPPragma.setAssignedVariableInCritical(aTokens[0]);				
//			}
			if (isPragmaStart(aFileLine)) {
				
				newOpenMPPragmas = getOpenMPPragmas(aFileLine, i);
				if (newOpenMPPragmas.size() != 0) {
					for (OpenMPPragma anOpenMPPragma:newOpenMPPragmas) {
						if (anOpenMPPragmas.size() > 0) {
						    anOpenMPPragma.setParent(anOpenMPPragmas.peek());
						} else {
							retVal.add(anOpenMPPragma); // add only top level prgamas

						}
						anOpenMPPragmas.push(anOpenMPPragma);
						aNumOpenBracesStack.push(0);
//						retVal.add(anOpenMPPragma);

					}
//					anOpenMPPragmas.addAll(newOpenMPPragmas);
//					aNumOpenBracesStack.add(0);
//					retVal.add(lastOpenMPPragma);					
					aNextCodeLineIsAPragmaBlock = true;
//					String lastReductionOperation = lastOpenMPPragma.getReductionOperation();
//					String lastReductionVariable = lastOpenMPPragma.getReductionVariable();
					continue;
				} 
			}
			if (anOpenMPPragmas.isEmpty()) {
				continue;
			}	
			if (aNextCodeLineIsAPragmaBlock) {				
				anOpenMPPragmas.peek().setAnnotatedTextStartLineNumber(i);				
				aNextCodeLineIsAPragmaBlock = false;
			}
//			anOpenMPPragmas.peek().getAnnotatedText().add(aFileLine);
			if (isBlockStart(aFileLine)) {
				incrementStackTop(aNumOpenBracesStack);
			}
//			} else 
			if (isBlockEnd(aFileLine)) {
				decrementStackTop(aNumOpenBracesStack);

			}
			if (isLoopStart(aFileLine) && endsWithLoopHeader(aFileLine)) {
				continue; // gather following block also
			}
			if (aNumOpenBracesStack.peek() == 0) {
				
				anOpenMPPragmas.peek().setAnnotatedTextEndLineNumber(i);
				for (int j = 0; j < newOpenMPPragmas.size(); j++) {
					anOpenMPPragmas.pop();
					aNumOpenBracesStack.pop();
				}
//				lastOpenMPPragma = null;
//				lastReductionVariable = null;
//				lastReductionOperation = null;
				continue;
			}					
		}
		return retVal;
	}
	public static void setReductionData (OpenMPPragma lastChild, String aStoredToken, int aLeftParenIndex, int aRightParenIndex) {
		int aColonIndex = aStoredToken.indexOf(":");
		if (aLeftParenIndex != -1 && aRightParenIndex != -1 && aColonIndex != -1) {
			String anOperationString = aStoredToken.substring(aLeftParenIndex + 1, aColonIndex).trim();
			String aVariableString = aStoredToken.substring(aColonIndex + 1, aRightParenIndex).trim();
			((OpenMPForPragma) lastChild).setReductionVariable(aVariableString);
			((OpenMPForPragma) lastChild).setReductionOperation(anOperationString);
		}
	}
	public static void setSharedOrPrivateData (OpenMPPragma lastChild, String aStoredToken, int aLeftParenIndex, int aRightParenIndex, boolean isShared) {
//		int aColonIndex = aStoredToken.indexOf(":");
		if (aLeftParenIndex != -1 && aRightParenIndex != -1 ) {
			String aVariableDeclarations = aStoredToken.substring(aLeftParenIndex + 1, aRightParenIndex);
			String[] aVariables = aVariableDeclarations.split(",");
			if (isShared) {
				lastChild.setSharedVariables(aVariables);
			} else {
				lastChild.setPrivateVariables(aVariables);
			}			
		}
	}
	public static List<OpenMPPragma> getOpenMPPragmas(String aFileLine, int aLineIndex) {
		String[] aTokens = aFileLine.split("\\s+");
		if (aTokens.length <= 2) {
			return null;
		}
		if (!aTokens[1].equals("omp")) {
			return null;
		}
		if (aTokens.length < 3) {
			return null;
		}
		String aFirstToken = aTokens[2];
		OpenMPKeywordEnum anOpenMPKeyword = stringToOpenMPKeyword.get(aFirstToken);
		List<OpenMPPragma> retVal = new ArrayList();
		OpenMPPragma lastChild;
		int aStartIndex = 2;
		switch (anOpenMPKeyword) {
		case PARALLEL:
			lastChild = new AnOpenMPParallelPragma(aLineIndex);
			
//			lastChild.setFirstOpenMPKeyword(stringToOpenMPKeyword.get(aFirstToken));	

			retVal.add(lastChild);
			if (aTokens.length > 3 && aTokens[3].equals("for")) {
				OpenMPPragma aForChild = new AnOpenMPForPragma(aLineIndex);
				retVal.add(aForChild);
				lastChild = aForChild;
				aStartIndex++;
			}
			break;
		case FOR:
			lastChild = new AnOpenMPForPragma(aLineIndex);
			retVal.add (lastChild);
			break;
		case CRITICAL:
			lastChild = new AnOpenMPCriticalPragma(aLineIndex);
			retVal.add (lastChild);
			break;
			default: 
				lastChild = new AnOpenMPPragma(aLineIndex);
				retVal.add(lastChild);
			
		}
//		retVal.setFirstOpenMPKeyword(stringToOpenMPKeyword.get(aFirstToken));	
//		OpenMPPragma retVal = new AnOpenMPPragma(aLineIndex);


		for (int i = aStartIndex; i < aTokens.length; i ++) {
			String aStoredToken = aTokens[i].trim();
			if (aStoredToken.isEmpty()) {
				continue;
			}
			if (aStoredToken.startsWith("reduction") || aStoredToken.startsWith("shared") || aStoredToken.startsWith("private")) {
				//combine all tokens until ")" into one for normalization
				while (!aStoredToken.endsWith(")")) {
					i++;
					if (i >= aTokens.length) {
						break;
					}
					String aNewToken = aTokens[i].trim();
					aStoredToken += aNewToken; 					
				}
				int aLeftParenIndex = aStoredToken.indexOf("(");
				int aRightParenIndex = aStoredToken.indexOf(")");
				if (aStoredToken.startsWith("reduction")) {
					setReductionData(lastChild, aStoredToken, aLeftParenIndex, aRightParenIndex);
				} else if (aStoredToken.startsWith("private")) {
					setSharedOrPrivateData(lastChild, aStoredToken, aLeftParenIndex, aRightParenIndex, false);

				} else if (aStoredToken.startsWith("shared")) {
					setSharedOrPrivateData(lastChild, aStoredToken, aLeftParenIndex, aRightParenIndex, true);

				}
//				int aColonIndex = aStoredToken.indexOf(":");
//				if (aLeftParenIndex != -1 && aRightParenIndex != -1 && aColonIndex != -1) {
//					String anOperationString = aStoredToken.substring(aLeftParenIndex + 1, aColonIndex).trim();
//					String aVariableString = aStoredToken.substring(aColonIndex + 1, aRightParenIndex).trim();
//					((OpenMPForPragma) lastChild).setReductionVariable(aVariableString);
//					((OpenMPForPragma) lastChild).setReductionOperation(anOperationString);
//				}
				
			}
			
//			aTokens[i] = aStoredToken;
			lastChild.getOpenMPTokens().add(aStoredToken);
		}
//		String aFirstToken = retVal.getOpenMPTokens().get(0);
//		retVal.setFirstOpenMPKeyword(stringToOpenMPKeyword.get(aFirstToken));		
		return retVal;
		
		
	}
	static {
		stringToOpenMPKeyword.put("for", OpenMPKeywordEnum.FOR);
		stringToOpenMPKeyword.put("parallel", OpenMPKeywordEnum.PARALLEL);
		stringToOpenMPKeyword.put("reduce", OpenMPKeywordEnum.REDUCE);
		stringToOpenMPKeyword.put("shared", OpenMPKeywordEnum.SHARED);
		stringToOpenMPKeyword.put("private", OpenMPKeywordEnum.PRIVATE);
		stringToOpenMPKeyword.put("critical", OpenMPKeywordEnum.CRITICAL);





	}
	

}
]]></snapshot>
  </Command>
  <Command __id="71650" _type="EclipseCommand" commandID="org.eclipse.debug.ui.commands.Terminate" date="Tue Dec 24 07:41:20 EST 2019" starttimestamp="1576666505112" timestamp="524775832" />
  <Command __id="71651" _type="RunCommand" date="Tue Dec 24 07:41:20 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="524775862" type="Debug" />
  <Command __id="71652" _type="RunCommand" date="Tue Dec 24 07:41:20 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="524775862" type="Debug" />
  <Command __id="71653" _type="RunCommand" date="Tue Dec 24 07:41:20 EST 2019" kind="HitBreakPoint" projectName="PL_Java" starttimestamp="1576666505112" timestamp="524775862" type="Run" />
  <Command __id="71655" _type="MoveCaretCommand" caretOffset="302" date="Tue Dec 24 07:41:31 EST 2019" docOffset="302" starttimestamp="1576666505112" timestamp="524786599" />
  <Command __id="71656" _type="MoveCaretCommand" caretOffset="322" date="Tue Dec 24 07:41:36 EST 2019" docOffset="322" starttimestamp="1576666505112" timestamp="524791204" />
  <Command __id="71658" _type="InsertStringCommand" date="Tue Dec 24 07:41:36 EST 2019" starttimestamp="1576666505112" timestamp="524791502" timestamp2="524791502">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="71660" _type="InsertStringCommand" date="Tue Dec 24 07:41:37 EST 2019" starttimestamp="1576666505112" timestamp="524792090" timestamp2="524792090">
    <data><![CDATA[{]]></data>
  </Command>
  <Command __id="71654" _type="DiffBasedFileOpenCommand" date="Tue Dec 24 07:41:31 EST 2019" docASTNodeCount="1" docActiveCodeLength="783" docExpressionCount="0" docLength="783" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="524786471">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\my_sum_parallel.cpp]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"#include <iostream>¶#include <omp.h>¶¶using namespace std;¶¶void printSumWithTimes(int sum, int start, int end);¶void printNumThreads();¶void recordThreadIndex(int index);¶void sum_parallel(double* array, int size) {¶	cout << "sum_parallel\n";¶¶	double start = omp_get_wtime();¶¶	double sum = 0;¶¶"), Diff(DELETE,"//	"), Diff(INSERT,"¶    "), Diff(EQUAL,"#pragma omp "), Diff(DELETE,"parallel¶//	for (int i = 0; i < size; i++)¶//		sum += array[i]"), Diff(INSERT,"critical¶	sum += 0"), Diff(EQUAL,";¶    #pragma omp parallel¶	{¶		double local_sum = 0;¶¶		int rank = omp_get_thread_num();¶		int threads = omp_get_num_threads();¶¶		int start_index = (size/threads)*rank;¶		int end_index = (size/threads)*(rank+1);¶¶		if(rank==threads-1)¶			end_index=size;¶¶		for(int i = start_index; i < end_index; i++)¶			local_sum += array[i];¶¶		#pragma omp critical¶		sum += local_sum;¶	}¶¶	double end = omp_get_wtime();¶¶	printSumWithTimes(sum, start, end);¶¶¶}¶")]]]></diff>
    <snapshot><![CDATA[#include <iostream>
#include <omp.h>

using namespace std;

void printSumWithTimes(int sum, int start, int end);
void printNumThreads();
void recordThreadIndex(int index);
void sum_parallel(double* array, int size) {
	cout << "sum_parallel\n";

	double start = omp_get_wtime();

	double sum = 0;


    #pragma omp critical
	sum += 0;
    #pragma omp parallel
	{
		double local_sum = 0;

		int rank = omp_get_thread_num();
		int threads = omp_get_num_threads();

		int start_index = (size/threads)*rank;
		int end_index = (size/threads)*(rank+1);

		if(rank==threads-1)
			end_index=size;

		for(int i = start_index; i < end_index; i++)
			local_sum += array[i];

		#pragma omp critical
		sum += local_sum;
	}

	double end = omp_get_wtime();

	printSumWithTimes(sum, start, end);


}
]]></snapshot>
  </Command>
  <DocumentChange __id="71657" _type="Insert" date="Tue Dec 24 07:41:36 EST 2019" docASTNodeCount="1" docActiveCodeLength="784" docExpressionCount="0" docLength="784" length="1" offset="322" starttimestamp="1576666505112" timestamp="524791498">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="71659" _type="Insert" date="Tue Dec 24 07:41:37 EST 2019" docASTNodeCount="1" docActiveCodeLength="785" docExpressionCount="0" docLength="785" length="1" offset="323" starttimestamp="1576666505112" timestamp="524792087">
    <text><![CDATA[{]]></text>
  </DocumentChange>
  <DocumentChange __id="71662" _type="Insert" date="Tue Dec 24 07:41:38 EST 2019" docASTNodeCount="1" docActiveCodeLength="787" docExpressionCount="0" docLength="787" length="2" offset="335" starttimestamp="1576666505112" timestamp="524793884">
    <text><![CDATA[
	]]></text>
  </DocumentChange>
  <Command __id="71661" _type="MoveCaretCommand" caretOffset="335" date="Tue Dec 24 07:41:38 EST 2019" docOffset="335" starttimestamp="1576666505112" timestamp="524793464" />
  <Command __id="71663" _type="InsertStringCommand" date="Tue Dec 24 07:41:39 EST 2019" starttimestamp="1576666505112" timestamp="524793889" timestamp2="524793889">
    <data><![CDATA[]]></data>
  </Command>
  <Command __id="71665" _type="InsertStringCommand" date="Tue Dec 24 07:41:40 EST 2019" starttimestamp="1576666505112" timestamp="524795672" timestamp2="524795672">
    <data><![CDATA[}]]></data>
  </Command>
  <Command __id="71666" _type="MoveCaretCommand" caretOffset="336" date="Tue Dec 24 07:41:43 EST 2019" docOffset="336" starttimestamp="1576666505112" timestamp="524798185" />
  <Command __id="71668" _type="InsertStringCommand" date="Tue Dec 24 07:41:43 EST 2019" starttimestamp="1576666505112" timestamp="524798420" timestamp2="524798420">
    <data><![CDATA[	]]></data>
  </Command>
  <DocumentChange __id="71664" _type="Replace" date="Tue Dec 24 07:41:40 EST 2019" docASTNodeCount="1" docActiveCodeLength="787" docExpressionCount="0" docLength="787" endLine="18" insertionLength="1" int_docASTNodeCount="1" int_docActiveCodeLength="786" int_docExpressionCount="0" int_docLength="786" length="1" offset="336" startLine="18" starttimestamp="1576666505112" timestamp="524795666">
    <deletedText><![CDATA[	]]></deletedText>
    <insertedText><![CDATA[}]]></insertedText>
  </DocumentChange>
  <DocumentChange __id="71667" _type="Insert" date="Tue Dec 24 07:41:43 EST 2019" docASTNodeCount="1" docActiveCodeLength="788" docExpressionCount="0" docLength="788" length="1" offset="336" starttimestamp="1576666505112" timestamp="524798414">
    <text><![CDATA[	]]></text>
  </DocumentChange>
  <DocumentChange __id="71670" _type="Insert" date="Tue Dec 24 07:41:45 EST 2019" docASTNodeCount="1" docActiveCodeLength="790" docExpressionCount="0" docLength="790" length="2" offset="323" starttimestamp="1576666505112" timestamp="524800628">
    <text><![CDATA[
	]]></text>
  </DocumentChange>
  <Command __id="71669" _type="MoveCaretCommand" caretOffset="323" date="Tue Dec 24 07:41:45 EST 2019" docOffset="323" starttimestamp="1576666505112" timestamp="524800207" />
  <Command __id="71671" _type="InsertStringCommand" date="Tue Dec 24 07:41:45 EST 2019" starttimestamp="1576666505112" timestamp="524800697" timestamp2="524800697">
    <data><![CDATA[]]></data>
  </Command>
  <Command __id="71673" _type="EclipseCommand" commandID="org.eclipse.ui.file.save" date="Tue Dec 24 07:41:48 EST 2019" starttimestamp="1576666505112" timestamp="524803328" />
  <Command __id="71674" _type="MoveCaretCommand" caretOffset="327" date="Tue Dec 24 07:41:51 EST 2019" docOffset="327" starttimestamp="1576666505112" timestamp="524805995" />
  <Command __id="71676" _type="InsertStringCommand" date="Tue Dec 24 07:41:51 EST 2019" starttimestamp="1576666505112" timestamp="524806612" timestamp2="524806612">
    <data><![CDATA[d]]></data>
  </Command>
  <Command __id="71678" _type="InsertStringCommand" date="Tue Dec 24 07:41:51 EST 2019" starttimestamp="1576666505112" timestamp="524806701" timestamp2="524806701">
    <data><![CDATA[o]]></data>
  </Command>
  <Command __id="71680" _type="InsertStringCommand" date="Tue Dec 24 07:41:52 EST 2019" starttimestamp="1576666505112" timestamp="524806972" timestamp2="524806972">
    <data><![CDATA[u]]></data>
  </Command>
  <Command __id="71682" _type="InsertStringCommand" date="Tue Dec 24 07:41:52 EST 2019" starttimestamp="1576666505112" timestamp="524807200" timestamp2="524807200">
    <data><![CDATA[b]]></data>
  </Command>
  <Command __id="71684" _type="InsertStringCommand" date="Tue Dec 24 07:41:52 EST 2019" starttimestamp="1576666505112" timestamp="524807516" timestamp2="524807516">
    <data><![CDATA[l]]></data>
  </Command>
  <Command __id="71686" _type="InsertStringCommand" date="Tue Dec 24 07:41:52 EST 2019" starttimestamp="1576666505112" timestamp="524807625" timestamp2="524807625">
    <data><![CDATA[e]]></data>
  </Command>
  <Command __id="71688" _type="InsertStringCommand" date="Tue Dec 24 07:41:53 EST 2019" starttimestamp="1576666505112" timestamp="524807926" timestamp2="524807926">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="71689" _type="EclipseCommand" commandID="org.eclipse.ui.file.save" date="Tue Dec 24 07:41:53 EST 2019" starttimestamp="1576666505112" timestamp="524808599" />
  <Command __id="71690" _type="MoveCaretCommand" caretOffset="339" date="Tue Dec 24 07:42:03 EST 2019" docOffset="339" starttimestamp="1576666505112" timestamp="524818715" />
  <Command __id="71692" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Tue Dec 24 07:42:04 EST 2019" starttimestamp="1576666505112" timestamp="524819528" />
  <Command __id="71693" _type="EclipseCommand" commandID="org.eclipse.ui.file.save" date="Tue Dec 24 07:42:06 EST 2019" starttimestamp="1576666505112" timestamp="524821233" />
  <Command __id="71694" _type="MoveCaretCommand" caretOffset="339" date="Tue Dec 24 07:42:08 EST 2019" docOffset="339" starttimestamp="1576666505112" timestamp="524823732" />
  <Command __id="71695" _type="ShellCommand" date="Tue Dec 24 07:42:27 EST 2019" starttimestamp="1576666505112" timestamp="524842100" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="71696" _type="ShellCommand" date="Tue Dec 24 07:42:27 EST 2019" starttimestamp="1576666505112" timestamp="524842203" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="71697" _type="ShellCommand" date="Tue Dec 24 07:42:27 EST 2019" starttimestamp="1576666505112" timestamp="524842363" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="71700" _type="RunCommand" date="Tue Dec 24 07:42:34 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="524849528" type="Run" />
  <Command __id="71701" _type="RunCommand" date="Tue Dec 24 07:42:34 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="524849546" type="Run" />
  <Command __id="71702" _type="RunCommand" date="Tue Dec 24 07:42:34 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="524849844" type="Run" />
  <DocumentChange __id="71672" _type="Delete" date="Tue Dec 24 07:41:48 EST 2019" docASTNodeCount="1" docActiveCodeLength="789" docExpressionCount="0" docLength="789" endLine="16" length="1" offset="322" startLine="16" starttimestamp="1576666505112" timestamp="524803281">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="71675" _type="Insert" date="Tue Dec 24 07:41:51 EST 2019" docASTNodeCount="1" docActiveCodeLength="790" docExpressionCount="0" docLength="790" length="1" offset="327" starttimestamp="1576666505112" timestamp="524806604">
    <text><![CDATA[d]]></text>
  </DocumentChange>
  <DocumentChange __id="71677" _type="Insert" date="Tue Dec 24 07:41:51 EST 2019" docASTNodeCount="1" docActiveCodeLength="791" docExpressionCount="0" docLength="791" length="1" offset="328" starttimestamp="1576666505112" timestamp="524806698">
    <text><![CDATA[o]]></text>
  </DocumentChange>
  <DocumentChange __id="71679" _type="Insert" date="Tue Dec 24 07:41:52 EST 2019" docASTNodeCount="1" docActiveCodeLength="792" docExpressionCount="0" docLength="792" length="1" offset="329" starttimestamp="1576666505112" timestamp="524806969">
    <text><![CDATA[u]]></text>
  </DocumentChange>
  <DocumentChange __id="71681" _type="Insert" date="Tue Dec 24 07:41:52 EST 2019" docASTNodeCount="1" docActiveCodeLength="793" docExpressionCount="0" docLength="793" length="1" offset="330" starttimestamp="1576666505112" timestamp="524807197">
    <text><![CDATA[b]]></text>
  </DocumentChange>
  <DocumentChange __id="71683" _type="Insert" date="Tue Dec 24 07:41:52 EST 2019" docASTNodeCount="1" docActiveCodeLength="794" docExpressionCount="0" docLength="794" length="1" offset="331" starttimestamp="1576666505112" timestamp="524807506">
    <text><![CDATA[l]]></text>
  </DocumentChange>
  <DocumentChange __id="71685" _type="Insert" date="Tue Dec 24 07:41:52 EST 2019" docASTNodeCount="1" docActiveCodeLength="795" docExpressionCount="0" docLength="795" length="1" offset="332" starttimestamp="1576666505112" timestamp="524807622">
    <text><![CDATA[e]]></text>
  </DocumentChange>
  <DocumentChange __id="71687" _type="Insert" date="Tue Dec 24 07:41:53 EST 2019" docASTNodeCount="1" docActiveCodeLength="796" docExpressionCount="0" docLength="796" length="1" offset="333" starttimestamp="1576666505112" timestamp="524807923">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="71691" _type="Delete" date="Tue Dec 24 07:42:04 EST 2019" docASTNodeCount="1" docActiveCodeLength="795" docExpressionCount="0" docLength="795" endLine="18" length="1" offset="338" startLine="18" starttimestamp="1576666505112" timestamp="524819521">
    <text><![CDATA[+]]></text>
  </DocumentChange>
  <Command __id="71703" _type="EclipseCommand" commandID="org.eclipse.debug.ui.commands.Resume" date="Tue Dec 24 07:42:40 EST 2019" starttimestamp="1576666505112" timestamp="524855490" />
  <Command __id="71704" _type="EHExceptionCommand" date="Tue Dec 24 07:42:40 EST 2019" starttimestamp="1576666505112" timestamp="524855703" type="Exception">
    <outputString><![CDATA[sum_sequential
Sum: 499500
Took: 0
thread:0 lastIndex:999
_____________________________
sum_parallel_for_reduction
Sum: 499500
Took: 0
thread:0 lastIndex:124
thread:1 lastIndex:249
thread:2 lastIndex:374
thread:3 lastIndex:499
thread:4 lastIndex:624
thread:5 lastIndex:749
thread:6 lastIndex:874
thread:7 lastIndex:999
_____________________________
]]></outputString>
  </Command>
  <Command __id="71706" _type="MoveCaretCommand" caretOffset="571" date="Tue Dec 24 07:42:44 EST 2019" docOffset="571" starttimestamp="1576666505112" timestamp="524859760" />
  <Command __id="71707" _type="BreakPointCommand" date="Tue Dec 24 07:42:44 EST 2019" lineNumber="30" starttimestamp="1576666505112" timestamp="524859764" type="BreakPointRemoved" />
  <Command __id="71708" _type="EclipseCommand" commandID="AUTOGEN:::org.eclipse.cdt.debug.ui.CEditor.BreakpointRulerActions/org.eclipse.cdt.debug.ui.CEditor.RulerTobbleBreakpointAction" date="Tue Dec 24 07:42:44 EST 2019" starttimestamp="1576666505112" timestamp="524859774" />
  <Command __id="71709" _type="EclipseCommand" commandID="org.eclipse.debug.ui.commands.Resume" date="Tue Dec 24 07:42:45 EST 2019" starttimestamp="1576666505112" timestamp="524860386" />
  <Command __id="71710" _type="RunCommand" date="Tue Dec 24 07:42:45 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="524860401" type="Debug" />
  <Command __id="71711" _type="RunCommand" date="Tue Dec 24 07:42:45 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="524860401" type="Run" />
  <Command __id="71712" _type="RunCommand" date="Tue Dec 24 07:42:45 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="524860401" type="Debug" />
  <Command __id="71713" _type="RunCommand" date="Tue Dec 24 07:42:45 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="524860401" type="Run" />
  <Command __id="71714" _type="EHExceptionCommand" date="Tue Dec 24 07:42:45 EST 2019" starttimestamp="1576666505112" timestamp="524860467" type="Exception">
    <outputString><![CDATA[sum_parallel_for_local_var
Sum: 499500
Took: 5
thread:0 lastIndex:124
thread:1 lastIndex:249
thread:2 lastIndex:374
thread:3 lastIndex:499
thread:4 lastIndex:624
thread:5 lastIndex:749
thread:6 lastIndex:874
thread:7 lastIndex:999
_____________________________
sum_parallel
Sum: 499500
Took: 0
_____________________________
]]></outputString>
  </Command>
  <Command __id="71715" _type="RunCommand" date="Tue Dec 24 07:42:46 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="524860941" type="Debug" />
  <Command __id="71716" _type="RunCommand" date="Tue Dec 24 07:42:46 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="524860941" type="Run" />
  <Command __id="71717" _type="RunCommand" date="Tue Dec 24 07:42:46 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="524860941" type="Debug" />
  <Command __id="71718" _type="RunCommand" date="Tue Dec 24 07:42:46 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="524860941" type="Run" />
  <Command __id="71705" _type="DiffBasedFileOpenCommand" date="Tue Dec 24 07:42:44 EST 2019" docASTNodeCount="1" docActiveCodeLength="659" docExpressionCount="0" docLength="747" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="524859572">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\my_sum_parallel_for_local_var.cpp]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"#include <iostream>¶#include <omp.h>¶¶using namespace std;¶¶void printSumWithTimes (int sum, int start, int end);¶void printNumThreads();¶void recordThreadIndex(int index);¶void sum_parallel_for_local_var(double* array, int size)¶{¶	cout << "sum_parallel_for_local_var\n";¶¶	double start = omp_get_wtime();¶¶	double sum = 0;¶¶	int a, b;¶//¶//	for (int i = 0; i < size; i++) {¶//			sum += array[i];¶//			recordThreadIndex(i);¶//	}¶"), Diff(INSERT,"¶"), Diff(EQUAL,"    #pragma omp parallel shared (sum, start) private (a, b)¶	{¶		double local_sum = 0;¶¶		#pragma omp for¶		for(int i = 0; i < size; i++) {¶			local_sum += array[i];¶			recordThreadIndex(i);¶		}¶¶		#pragma omp critical¶		sum += local_sum;¶	}¶¶	double end = omp_get_wtime();¶¶	printSumWithTimes(sum, start, end);¶	¶}¶")]]]></diff>
    <snapshot><![CDATA[#include <iostream>
#include <omp.h>

using namespace std;

void printSumWithTimes (int sum, int start, int end);
void printNumThreads();
void recordThreadIndex(int index);
void sum_parallel_for_local_var(double* array, int size)
{
	cout << "sum_parallel_for_local_var\n";

	double start = omp_get_wtime();

	double sum = 0;

	int a, b;
//
//	for (int i = 0; i < size; i++) {
//			sum += array[i];
//			recordThreadIndex(i);
//	}

    #pragma omp parallel shared (sum, start) private (a, b)
	{
		double local_sum = 0;

		#pragma omp for
		for(int i = 0; i < size; i++) {
			local_sum += array[i];
			recordThreadIndex(i);
		}

		#pragma omp critical
		sum += local_sum;
	}

	double end = omp_get_wtime();

	printSumWithTimes(sum, start, end);
	
}
]]></snapshot>
  </Command>
  <Command __id="71719" _type="SelectTextCommand" caretOffset="493" date="Tue Dec 24 07:43:07 EST 2019" end="493" start="468" starttimestamp="1576666505112" timestamp="524881989" />
  <Command __id="71720" _type="DiffBasedFileOpenCommand" date="Tue Dec 24 07:43:51 EST 2019" docASTNodeCount="1" docActiveCodeLength="1642" docExpressionCount="0" docLength="1924" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="524926189">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\my_sum_main.cpp]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"#include <iostream>¶#include <omp.h>¶¶using namespace std;¶//need to declare headers of external functions called¶void sum_sequential(double* array, int size);¶void sum_parallel_for_reduction(double* array, int size);¶void sum_parallel(double* array, int size);¶void sum_parallel_for_local_var(double* array, int size);¶¶// if this main is used to call functions to do other computations¶// then those headers should also be declared here¶¶const int SIZE = 1000;¶void initArray (double* array, int size ) {¶	for(int i = 0; i < size; i++)¶			array[i]=i;¶}¶/**¶ * Called by each of the summing alternatives¶ */¶void printSumWithTimes (int sum, int start, int end) {¶	cout << "Sum: " << sum << endl;¶	cout << "Took: " << end - start << endl;¶}¶void printNumThreads() {¶	cout << "threads:" << omp_get_num_threads() << endl;¶}¶/**¶ * an array to learn how much concurrency occcurred¶ */¶int MAX_THREADS = 100;¶double* threadsLastIndex = new double[MAX_THREADS];¶int numThreads;¶¶¶void recordThreadIndex(int index) {¶	int thread =  omp_get_thread_num();¶	if (thread >= MAX_THREADS) {¶		return;¶	}¶	threadsLastIndex[thread] = index;¶	numThreads = omp_get_num_threads();¶}¶void initThreadRecording() {¶	numThreads = 0;¶	for (int i = 0; i < MAX_THREADS; i++) {¶		threadsLastIndex[i] = -1;¶	}¶}¶¶void printThreadLastIndex() {¶	for (int i = 0; i < numThreads; i++) {¶		cout << "thread:" << i << " lastIndex:" << threadsLastIndex[i] << endl;¶	}¶	cout << "_____________________________" << endl;¶}¶¶¶int main()¶{¶	double* array = new double[SIZE];¶	initArray(array, SIZE);¶	initThreadRecording();¶	sum_sequential(array, SIZE);¶	printThreadLastIndex();¶	initThreadRecording();¶	sum_parallel_for_reduction(array, SIZE);¶	printThreadLastIndex();¶	initThreadRecording();¶	sum_parallel_for_local_var(array, SIZE);¶	printThreadLastIndex();¶	initThreadRecording();¶	sum_parallel(array, SIZE);¶	printThreadLastIndex();¶	initThreadRecording();¶}¶")]]]></diff>
  </Command>
  <Command __id="71721" _type="MoveCaretCommand" caretOffset="1500" date="Tue Dec 24 07:43:51 EST 2019" docOffset="1500" starttimestamp="1576666505112" timestamp="524926314" />
  <Command __id="71722" _type="DiffBasedFileOpenCommand" date="Tue Dec 24 07:43:52 EST 2019" docASTNodeCount="1" docActiveCodeLength="659" docExpressionCount="0" docLength="747" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="524927776">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\my_sum_parallel_for_local_var.cpp]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"#include <iostream>¶#include <omp.h>¶¶using namespace std;¶¶void printSumWithTimes (int sum, int start, int end);¶void printNumThreads();¶void recordThreadIndex(int index);¶void sum_parallel_for_local_var(double* array, int size)¶{¶	cout << "sum_parallel_for_local_var\n";¶¶	double start = omp_get_wtime();¶¶	double sum = 0;¶¶	int a, b;¶//¶//	for (int i = 0; i < size; i++) {¶//			sum += array[i];¶//			recordThreadIndex(i);¶//	}¶¶    #pragma omp parallel shared (sum, start) private (a, b)¶	{¶		double local_sum = 0;¶¶		#pragma omp for¶		for(int i = 0; i < size; i++) {¶			local_sum += array[i];¶			recordThreadIndex(i);¶		}¶¶		#pragma omp critical¶		sum += local_sum;¶	}¶¶	double end = omp_get_wtime();¶¶	printSumWithTimes(sum, start, end);¶	¶}¶")]]]></diff>
  </Command>
  <Command __id="71723" _type="SelectTextCommand" caretOffset="493" date="Tue Dec 24 07:43:53 EST 2019" end="493" start="468" starttimestamp="1576666505112" timestamp="524928050" />
  <Command __id="71728" _type="DiffBasedFileOpenCommand" date="Tue Dec 24 07:43:57 EST 2019" projectName="null" starttimestamp="1576666505112" timestamp="524932441">
    <filePath><![CDATA[null]]></filePath>
    <diff><![CDATA[null]]></diff>
  </Command>
  <Command __id="72279" _type="DiffBasedFileOpenCommand" date="Tue Dec 24 07:52:51 EST 2019" docASTNodeCount="20" docActiveCodeLength="147" docExpressionCount="14" docLength="227" projectName="GraderBasics" starttimestamp="1576666505112" timestamp="525466472">
    <filePath><![CDATA[D:\dewan_backup\Java\GraderBasics\src\gradingTools\shared\testcases\openmp\OpenMPParallelPragma.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package gradingTools.shared.testcases.openmp;¶¶import java.util.List;¶¶public interface OpenMPParallelPragma extends OpenMPPragma{¶"), Diff(INSERT,"//"), Diff(EQUAL,"	List<String> getVariableDeclarations();¶"), Diff(DELETE,"¶"), Diff(INSERT,"//¶//"), Diff(EQUAL,"	List<String> getLocalVariables();¶¶}¶")]]]></diff>
    <snapshot><![CDATA[package gradingTools.shared.testcases.openmp;

import java.util.List;

public interface OpenMPParallelPragma extends OpenMPPragma{
//	List<String> getVariableDeclarations();
//
//	List<String> getLocalVariables();

}
]]></snapshot>
  </Command>
  <Command __id="72305" _type="EclipseCommand" commandID="" date="Tue Dec 24 07:52:54 EST 2019" starttimestamp="1576666505112" timestamp="525469280" />
  <Command __id="72306" _type="EclipseCommand" commandID="" date="Tue Dec 24 07:52:54 EST 2019" starttimestamp="1576666505112" timestamp="525469281" />
  <Command __id="72307" _type="EclipseCommand" commandID="" date="Tue Dec 24 07:52:54 EST 2019" starttimestamp="1576666505112" timestamp="525469290" />
  <Command __id="72308" _type="EclipseCommand" commandID="" date="Tue Dec 24 07:52:54 EST 2019" starttimestamp="1576666505112" timestamp="525469290" />
  <Command __id="72309" _type="EclipseCommand" commandID="" date="Tue Dec 24 07:52:54 EST 2019" starttimestamp="1576666505112" timestamp="525469292" />
  <Command __id="72310" _type="EclipseCommand" commandID="" date="Tue Dec 24 07:52:54 EST 2019" starttimestamp="1576666505112" timestamp="525469292" />
  <Command __id="72311" _type="EclipseCommand" commandID="" date="Tue Dec 24 07:52:54 EST 2019" starttimestamp="1576666505112" timestamp="525469307" />
  <Command __id="72312" _type="EclipseCommand" commandID="" date="Tue Dec 24 07:52:54 EST 2019" starttimestamp="1576666505112" timestamp="525469307" />
  <Command __id="72313" _type="EclipseCommand" commandID="" date="Tue Dec 24 07:52:54 EST 2019" starttimestamp="1576666505112" timestamp="525469311" />
  <Command __id="72314" _type="EclipseCommand" commandID="" date="Tue Dec 24 07:52:54 EST 2019" starttimestamp="1576666505112" timestamp="525469311" />
  <Command __id="72315" _type="EclipseCommand" commandID="" date="Tue Dec 24 07:52:54 EST 2019" starttimestamp="1576666505112" timestamp="525469315" />
  <Command __id="72317" _type="MoveCaretCommand" caretOffset="399" date="Tue Dec 24 07:53:13 EST 2019" docOffset="399" starttimestamp="1576666505112" timestamp="525488287" />
  <Command __id="72318" _type="EclipseCommand" commandID="" date="Tue Dec 24 07:53:13 EST 2019" starttimestamp="1576666505112" timestamp="525488846" />
  <Command __id="72319" _type="EclipseCommand" commandID="" date="Tue Dec 24 07:53:14 EST 2019" starttimestamp="1576666505112" timestamp="525488938" />
  <Command __id="72316" _type="DiffBasedFileOpenCommand" date="Tue Dec 24 07:53:13 EST 2019" docASTNodeCount="1" docActiveCodeLength="530" docExpressionCount="0" docLength="554" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="525487964">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\my_sum_parallel_for_reduction.cpp]]></filePath>
    <diff><![CDATA[null]]></diff>
    <snapshot><![CDATA[#include <iostream>
#include <omp.h>

using namespace std;

//const int SIZE = 1000;
void printSumWithTimes(int sum, int start, int end);
void printNumThreads();
void recordThreadIndex(int index);
void sum_parallel_for_reduction(double* array, int size) {
	cout << "sum_parallel_for_reduction\n";

	double start = omp_get_wtime();

	double sum = 0;
    #pragma omp  parallel for reduction ( + : sum )
	for (int i = 0; i < size; i++) {
		sum += array[i];
		recordThreadIndex(i);
	}

	double end = omp_get_wtime();

	printSumWithTimes(sum, start, end);

}
]]></snapshot>
  </Command>
  <Command __id="72320" _type="MoveCaretCommand" caretOffset="368" date="Tue Dec 24 07:53:17 EST 2019" docOffset="368" starttimestamp="1576666505112" timestamp="525492137" />
  <Command __id="72321" _type="SelectTextCommand" caretOffset="374" date="Tue Dec 24 07:53:17 EST 2019" end="374" start="366" starttimestamp="1576666505112" timestamp="525492440" />
  <Command __id="72323" _type="EclipseCommand" commandID="org.eclipse.ui.edit.delete" date="Tue Dec 24 07:53:19 EST 2019" starttimestamp="1576666505112" timestamp="525494314" />
  <Command __id="72324" _type="EclipseCommand" commandID="org.eclipse.ui.file.save" date="Tue Dec 24 07:53:21 EST 2019" starttimestamp="1576666505112" timestamp="525496450" />
  <Command __id="72325" _type="MoveCaretCommand" caretOffset="368" date="Tue Dec 24 07:53:23 EST 2019" docOffset="368" starttimestamp="1576666505112" timestamp="525498627" />
  <Command __id="72326" _type="MoveCaretCommand" caretOffset="368" date="Tue Dec 24 07:53:25 EST 2019" docOffset="368" starttimestamp="1576666505112" timestamp="525500225" />
  <Command __id="72327" _type="ShellCommand" date="Tue Dec 24 07:53:34 EST 2019" starttimestamp="1576666505112" timestamp="525509467" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="72328" _type="ShellCommand" date="Tue Dec 24 07:53:34 EST 2019" starttimestamp="1576666505112" timestamp="525509652" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="72329" _type="ShellCommand" date="Tue Dec 24 07:53:34 EST 2019" starttimestamp="1576666505112" timestamp="525509772" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="72330" _type="ShellCommand" date="Tue Dec 24 07:53:38 EST 2019" starttimestamp="1576666505112" timestamp="525513333" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="72331" _type="EclipseCommand" commandID="org.eclipse.cdt.debug.ui.localCShortcut.run" date="Tue Dec 24 07:53:38 EST 2019" starttimestamp="1576666505112" timestamp="525513357" />
  <Command __id="72332" _type="ShellCommand" date="Tue Dec 24 07:53:39 EST 2019" starttimestamp="1576666505112" timestamp="525514292" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="72333" _type="ShellCommand" date="Tue Dec 24 07:53:41 EST 2019" starttimestamp="1576666505112" timestamp="525516238" type="ECLIPSE_GAINED_FOCUS" />
  <DocumentChange __id="72322" _type="Delete" date="Tue Dec 24 07:53:19 EST 2019" docASTNodeCount="1" docActiveCodeLength="522" docExpressionCount="0" docLength="546" endLine="15" length="8" offset="366" startLine="15" starttimestamp="1576666505112" timestamp="525494297">
    <text><![CDATA[parallel]]></text>
  </DocumentChange>
  <Command __id="72334" _type="MoveCaretCommand" caretOffset="360" date="Tue Dec 24 07:54:12 EST 2019" docOffset="360" starttimestamp="1576666505112" timestamp="525547319" />
  <Command __id="72336" _type="UndoCommand" date="Tue Dec 24 07:54:13 EST 2019" starttimestamp="1576666505112" timestamp="525548808" />
  <Command __id="72337" _type="EclipseCommand" commandID="org.eclipse.ui.file.save" date="Tue Dec 24 07:54:15 EST 2019" starttimestamp="1576666505112" timestamp="525550816" />
  <Command __id="72338" _type="MoveCaretCommand" caretOffset="327" date="Tue Dec 24 07:54:21 EST 2019" docOffset="327" starttimestamp="1576666505112" timestamp="525556877" />
  <DocumentChange __id="75272" _type="Insert" date="Tue Dec 24 08:28:20 EST 2019" docASTNodeCount="166" docActiveCodeLength="1144" docExpressionCount="104" docLength="1246" length="1" offset="876" starttimestamp="1576666505112" timestamp="527595610">
    <text><![CDATA[t]]></text>
  </DocumentChange>
  <DocumentChange __id="75275" _type="Delete" date="Tue Dec 24 08:28:23 EST 2019" docASTNodeCount="166" docActiveCodeLength="1143" docExpressionCount="104" docLength="1245" endLine="28" length="1" offset="857" startLine="28" starttimestamp="1576666505112" timestamp="527598289">
    <text><![CDATA[P]]></text>
  </DocumentChange>
  <DocumentChange __id="75277" _type="Insert" date="Tue Dec 24 08:28:23 EST 2019" docASTNodeCount="166" docActiveCodeLength="1144" docExpressionCount="104" docLength="1246" length="1" offset="857" starttimestamp="1576666505112" timestamp="527598658">
    <text><![CDATA[p]]></text>
  </DocumentChange>
  <Command __id="75303" _type="EclipseCommand" commandID="" date="Tue Dec 24 08:28:25 EST 2019" starttimestamp="1576666505112" timestamp="527600575" />
  <Command __id="75304" _type="EclipseCommand" commandID="" date="Tue Dec 24 08:28:25 EST 2019" starttimestamp="1576666505112" timestamp="527600575" />
  <Command __id="75305" _type="EclipseCommand" commandID="" date="Tue Dec 24 08:28:25 EST 2019" starttimestamp="1576666505112" timestamp="527600585" />
  <Command __id="75306" _type="EclipseCommand" commandID="" date="Tue Dec 24 08:28:25 EST 2019" starttimestamp="1576666505112" timestamp="527600585" />
  <Command __id="75307" _type="EclipseCommand" commandID="" date="Tue Dec 24 08:28:25 EST 2019" starttimestamp="1576666505112" timestamp="527600587" />
  <Command __id="75308" _type="EclipseCommand" commandID="" date="Tue Dec 24 08:28:25 EST 2019" starttimestamp="1576666505112" timestamp="527600587" />
  <Command __id="75309" _type="EclipseCommand" commandID="" date="Tue Dec 24 08:28:25 EST 2019" starttimestamp="1576666505112" timestamp="527600605" />
  <Command __id="75310" _type="EclipseCommand" commandID="" date="Tue Dec 24 08:28:25 EST 2019" starttimestamp="1576666505112" timestamp="527600606" />
  <Command __id="75311" _type="EclipseCommand" commandID="" date="Tue Dec 24 08:28:25 EST 2019" starttimestamp="1576666505112" timestamp="527600610" />
  <Command __id="75312" _type="EclipseCommand" commandID="" date="Tue Dec 24 08:28:25 EST 2019" starttimestamp="1576666505112" timestamp="527600611" />
  <Command __id="75313" _type="EclipseCommand" commandID="" date="Tue Dec 24 08:28:25 EST 2019" starttimestamp="1576666505112" timestamp="527600617" />
  <Command __id="75314" _type="MoveCaretCommand" caretOffset="873" date="Tue Dec 24 08:28:25 EST 2019" docOffset="873" starttimestamp="1576666505112" timestamp="527600830" />
  <Command __id="75315" _type="SelectTextCommand" caretOffset="877" date="Tue Dec 24 08:28:26 EST 2019" end="877" start="871" starttimestamp="1576666505112" timestamp="527601105" />
  <Command __id="75317" _type="MoveCaretCommand" caretOffset="327" date="Tue Dec 24 08:28:29 EST 2019" docOffset="327" starttimestamp="1576666505112" timestamp="527604413" />
  <Command __id="75318" _type="EclipseCommand" commandID="" date="Tue Dec 24 08:28:30 EST 2019" starttimestamp="1576666505112" timestamp="527605325" />
  <Command __id="75319" _type="EclipseCommand" commandID="" date="Tue Dec 24 08:28:30 EST 2019" starttimestamp="1576666505112" timestamp="527605391" />
  <Command __id="75320" _type="MoveCaretCommand" caretOffset="371" date="Tue Dec 24 08:28:32 EST 2019" docOffset="371" starttimestamp="1576666505112" timestamp="527607665" />
  <Command __id="75321" _type="SelectTextCommand" caretOffset="374" date="Tue Dec 24 08:28:33 EST 2019" end="374" start="366" starttimestamp="1576666505112" timestamp="527608120" />
  <Command __id="75322" _type="MoveCaretCommand" caretOffset="376" date="Tue Dec 24 08:28:39 EST 2019" docOffset="376" starttimestamp="1576666505112" timestamp="527614287" />
  <Command __id="75323" _type="SelectTextCommand" caretOffset="378" date="Tue Dec 24 08:28:39 EST 2019" end="378" start="375" starttimestamp="1576666505112" timestamp="527614547" />
  <Command __id="75324" _type="SelectTextCommand" caretOffset="401" date="Tue Dec 24 08:28:39 EST 2019" end="401" start="349" starttimestamp="1576666505112" timestamp="527614864" />
  <Command __id="75325" _type="CopyCommand" date="Tue Dec 24 08:28:41 EST 2019" starttimestamp="1576666505112" timestamp="527616027" />
  <Command __id="75326" _type="MoveCaretCommand" caretOffset="400" date="Tue Dec 24 08:28:43 EST 2019" docOffset="400" starttimestamp="1576666505112" timestamp="527617926" />
  <Command __id="75328" _type="InsertStringCommand" date="Tue Dec 24 08:28:43 EST 2019" starttimestamp="1576666505112" timestamp="527618357" timestamp2="527618357">
    <data><![CDATA[]]></data>
  </Command>
  <Command __id="75330" _type="PasteCommand" date="Tue Dec 24 08:28:44 EST 2019" starttimestamp="1576666505112" timestamp="527619121" />
  <Command __id="75331" _type="MoveCaretCommand" caretOffset="401" date="Tue Dec 24 08:28:46 EST 2019" docOffset="401" starttimestamp="1576666505112" timestamp="527621237" />
  <Command __id="75333" _type="InsertStringCommand" date="Tue Dec 24 08:28:46 EST 2019" starttimestamp="1576666505112" timestamp="527621482" timestamp2="527621482">
    <data><![CDATA[	]]></data>
  </Command>
  <Command __id="75334" _type="MoveCaretCommand" caretOffset="351" date="Tue Dec 24 08:28:48 EST 2019" docOffset="351" starttimestamp="1576666505112" timestamp="527623233" />
  <Command __id="75336" _type="EclipseCommand" commandID="org.eclipse.cdt.ui.edit.text.c.toggle.comment" date="Tue Dec 24 08:28:49 EST 2019" starttimestamp="1576666505112" timestamp="527624101" />
  <Command __id="75337" _type="MoveCaretCommand" caretOffset="422" date="Tue Dec 24 08:28:53 EST 2019" docOffset="422" starttimestamp="1576666505112" timestamp="527628394" />
  <Command __id="75338" _type="SelectTextCommand" caretOffset="425" date="Tue Dec 24 08:28:53 EST 2019" end="425" start="417" starttimestamp="1576666505112" timestamp="527628637" />
  <Command __id="75340" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Tue Dec 24 08:28:54 EST 2019" starttimestamp="1576666505112" timestamp="527629012" />
  <Command __id="75342" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Tue Dec 24 08:28:54 EST 2019" starttimestamp="1576666505112" timestamp="527629303" />
  <Command __id="75348" _type="RunCommand" date="Tue Dec 24 08:29:09 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="527644220" type="Run" />
  <Command __id="75349" _type="RunCommand" date="Tue Dec 24 08:29:09 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="527644220" type="Run" />
  <Command __id="75350" _type="RunCommand" date="Tue Dec 24 08:29:09 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="527644254" type="Debug" />
  <Command __id="75351" _type="RunCommand" date="Tue Dec 24 08:29:09 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="527644255" type="Run" />
  <Command __id="75352" _type="RunCommand" date="Tue Dec 24 08:29:09 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="527644255" type="Debug" />
  <Command __id="75353" _type="RunCommand" date="Tue Dec 24 08:29:09 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="527644255" type="Run" />
  <Command __id="75354" _type="EHExceptionCommand" date="Tue Dec 24 08:29:09 EST 2019" starttimestamp="1576666505112" timestamp="527644368" type="Exception">
    <outputString><![CDATA[sum_sequential
Sum: 499500
Took: 0
thread:0 lastIndex:999
_____________________________
sum_parallel_for_reduction
Sum: 499500
Took: 0
thread:0 lastIndex:999
_____________________________
sum_parallel_for_local_var
Sum: 499500
Took: 0
thread:0 lastIndex:124
thread:1 lastIndex:249
thread:2 lastIndex:374
thread:3 lastIndex:499
thread:4 lastIndex:624
thread:5 lastIndex:749
thread:6 lastIndex:874
thread:7 lastIndex:999
_____________________________
sum_parallel
Sum: 499500
Took: 0
_____________________________
]]></outputString>
  </Command>
  <Command __id="75316" _type="DiffBasedFileOpenCommand" date="Tue Dec 24 08:28:29 EST 2019" docASTNodeCount="1" docActiveCodeLength="530" docExpressionCount="0" docLength="554" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="527604300">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\my_sum_parallel_for_reduction.cpp]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"#include <iostream>¶#include <omp.h>¶¶using namespace std;¶¶//const int SIZE = 1000;¶void printSumWithTimes(int sum, int start, int end);¶void printNumThreads();¶void recordThreadIndex(int index);¶void sum_parallel_for_reduction(double* array, int size) {¶	cout << "sum_parallel_for_reduction\n";¶¶	double start = omp_get_wtime();¶¶	double sum = 0;¶    #pragma omp  parallel for reduction ( + : sum )¶	for (int i = 0; i < size; i++) {¶		sum += array[i];¶		recordThreadIndex(i);¶	}¶¶	double end = omp_get_wtime();¶¶	printSumWithTimes(sum, start, end);¶¶}¶")]]]></diff>
  </Command>
  <DocumentChange __id="75327" _type="Insert" date="Tue Dec 24 08:28:43 EST 2019" docASTNodeCount="1" docActiveCodeLength="532" docExpressionCount="0" docLength="556" length="2" offset="400" starttimestamp="1576666505112" timestamp="527618352">
    <text><![CDATA[
	]]></text>
  </DocumentChange>
  <DocumentChange __id="75329" _type="Replace" date="Tue Dec 24 08:28:44 EST 2019" docASTNodeCount="1" docActiveCodeLength="579" docExpressionCount="0" docLength="603" endLine="16" insertionLength="48" int_docASTNodeCount="1" int_docActiveCodeLength="531" int_docExpressionCount="0" int_docLength="555" length="1" offset="401" startLine="16" starttimestamp="1576666505112" timestamp="527619110">
    <deletedText><![CDATA[	]]></deletedText>
    <insertedText><![CDATA[#pragma omp  parallel for reduction ( + : sum )
]]></insertedText>
  </DocumentChange>
  <DocumentChange __id="75332" _type="Insert" date="Tue Dec 24 08:28:46 EST 2019" docASTNodeCount="1" docActiveCodeLength="580" docExpressionCount="0" docLength="604" length="1" offset="401" starttimestamp="1576666505112" timestamp="527621478">
    <text><![CDATA[	]]></text>
  </DocumentChange>
  <DocumentChange __id="75335" _type="Insert" date="Tue Dec 24 08:28:49 EST 2019" docASTNodeCount="1" docActiveCodeLength="529" docExpressionCount="0" docLength="606" length="2" offset="349" starttimestamp="1576666505112" timestamp="527624090">
    <text><![CDATA[//]]></text>
  </DocumentChange>
  <DocumentChange __id="75339" _type="Delete" date="Tue Dec 24 08:28:54 EST 2019" docASTNodeCount="1" docActiveCodeLength="521" docExpressionCount="0" docLength="598" endLine="16" length="8" offset="417" startLine="16" starttimestamp="1576666505112" timestamp="527629007">
    <text><![CDATA[parallel]]></text>
  </DocumentChange>
  <DocumentChange __id="75341" _type="Delete" date="Tue Dec 24 08:28:54 EST 2019" docASTNodeCount="1" docActiveCodeLength="520" docExpressionCount="0" docLength="597" endLine="16" length="1" offset="416" startLine="16" starttimestamp="1576666505112" timestamp="527629300">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="75344" _type="Delete" date="Tue Dec 24 08:28:58 EST 2019" docASTNodeCount="1" docActiveCodeLength="499" docExpressionCount="0" docLength="576" endLine="16" length="21" offset="421" startLine="16" starttimestamp="1576666505112" timestamp="527633022">
    <text><![CDATA[reduction ( + : sum )]]></text>
  </DocumentChange>
  <DocumentChange __id="75346" _type="Delete" date="Tue Dec 24 08:28:58 EST 2019" docASTNodeCount="1" docActiveCodeLength="498" docExpressionCount="0" docLength="575" endLine="16" length="1" offset="420" startLine="16" starttimestamp="1576666505112" timestamp="527633869">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <Command __id="75355" _type="MoveCaretCommand" caretOffset="403" date="Tue Dec 24 08:29:51 EST 2019" docOffset="403" starttimestamp="1576666505112" timestamp="527685940" />
  <Command __id="75357" _type="EclipseCommand" commandID="org.eclipse.cdt.ui.edit.text.c.toggle.comment" date="Tue Dec 24 08:29:52 EST 2019" starttimestamp="1576666505112" timestamp="527686956" />
  <Command __id="106702" _type="DiffBasedFileOpenCommand" date="Wed Dec 25 11:40:28 EST 2019" docASTNodeCount="355" docActiveCodeLength="2389" docExpressionCount="261" docLength="2483" projectName="DemoCourseLocalBasicChecks" starttimestamp="1576666505112" timestamp="625523076">
    <filePath><![CDATA[D:\dewan_backup\Java\DemoCourseLocalBasicChecks\src\gradingTools\comp123\assignment1\openmp\testcases\SequentialSumTestCase.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package gradingTools.comp123.assignment1.openmp.testcases;¶¶import java.util.Arrays;¶import java.util.List;¶import java.util.Map;¶import java.util.regex.Pattern;¶¶import grader.basics.execution.NotRunnableException;¶import grader.basics.execution.RunningProject;¶import grader.basics.junit.NotAutomatableException;¶import grader.basics.junit.TestCaseResult;¶import grader.basics.project.NotGradableException;¶import grader.basics.project.Project;¶import grader.basics.project.source.ABasicTextManager;¶import grader.basics.testcase.PassFailJUnitTestCase;¶import gradingTools.shared.testcases.SubstringSequenceChecker;¶import gradingTools.shared.testcases.openmp.OpenMPPragma;¶import gradingTools.shared.testcases.openmp.OpenMPUtils;¶import gradingTools.shared.testcases.openmp.scannedTree.SNode;¶import gradingTools.shared.testcases.utils.LinesMatchKind;¶import gradingTools.shared.testcases.utils.LinesMatcher;¶import gradingTools.utils.RunningProjectUtils;¶¶public class SequentialSumTestCase extends PassFailJUnitTestCase {¶	public static final int TIME_OUT_SECS = 1; // secs¶	protected SubstringSequenceChecker checker = new ASequentialSumChecker();	¶¶	public SequentialSumTestCase() {¶	}¶¶	¶¶	@Override¶	public TestCaseResult test(Project project, boolean autoGrade) throws NotAutomatableException,¶			NotGradableException {¶		try {¶			RunningProject aRunningProject = RunningProjectUtils.runProject(project, TIME_OUT_SECS);¶			String anOutput = aRunningProject.await();¶			LinesMatcher aLinesMatcher = aRunningProject.getLinesMatcher();¶			boolean aRetval = checker.check(aLinesMatcher, LinesMatchKind.ONE_TIME_LINE, Pattern.DOTALL);¶			String aSource = project.getSource();¶			Map<String, StringBuffer> aFileNameToContents = ABasicTextManager.extractFileContents(aSource);¶			for (String aFileName:aFileNameToContents.keySet()) {¶				StringBuffer aFileContents = aFileNameToContents.get(aFileName);¶//				List<OpenMPPragma> anOpenMPPragmas = OpenMPUtils.getOpemMPPragmas(aFileContents);¶				SNode anSNode = OpenMPUtils.getSNode(aFileLines);¶				System.out.println("file name:" + aFileName);¶				System.out.println("pragmas:" + anOpenMPPragmas);¶			}¶			String anExpectedLines = Arrays.toString(checker.getSubstrings());¶¶			if (!aRetval) {¶				return fail("Output  did not match:" + anExpectedLines);¶¶			}¶			return pass();¶			¶¶		} catch (NotRunnableException e) {¶			throw new NotGradableException();¶		}¶	}¶}¶")]]]></diff>
  </Command>
  <DocumentChange __id="106709" _type="Replace" date="Wed Dec 25 11:40:35 EST 2019" docASTNodeCount="355" docActiveCodeLength="2381" docExpressionCount="261" docLength="2475" endLine="47" insertionLength="7" int_docASTNodeCount="353" int_docActiveCodeLength="2374" int_docExpressionCount="259" int_docLength="2468" length="15" offset="2181" startLine="47" starttimestamp="1576666505112" timestamp="625529987">
    <deletedText><![CDATA[anOpenMPPragmas]]></deletedText>
    <insertedText><![CDATA[anSNode]]></insertedText>
  </DocumentChange>
  <DocumentChange __id="106725" _type="Replace" date="Wed Dec 25 11:40:43 EST 2019" docASTNodeCount="355" docActiveCodeLength="2384" docExpressionCount="261" docLength="2478" endLine="45" insertionLength="13" int_docASTNodeCount="354" int_docActiveCodeLength="2371" int_docExpressionCount="260" int_docLength="2465" length="10" offset="2080" startLine="45" starttimestamp="1576666505112" timestamp="625538793">
    <deletedText><![CDATA[aFileLines]]></deletedText>
    <insertedText><![CDATA[aFileContents]]></insertedText>
  </DocumentChange>
  <Command __id="106737" _type="RunCommand" date="Wed Dec 25 11:40:55 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="625550142" type="Run" />
  <Command __id="106738" _type="RunCommand" date="Wed Dec 25 11:40:55 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="625550142" type="Run" />
  <Command __id="106739" _type="RunCommand" date="Wed Dec 25 11:40:55 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="625550527" type="Run" />
  <Command __id="106741" _type="MoveCaretCommand" caretOffset="1500" date="Wed Dec 25 11:40:57 EST 2019" docOffset="1500" starttimestamp="1576666505112" timestamp="625552755" />
  <Command __id="106751" _type="RunCommand" date="Wed Dec 25 11:41:08 EST 2019" kind="HitBreakPoint" projectName="PL_Java" starttimestamp="1576666505112" timestamp="625563564" type="Run" />
  <Command __id="106752" _type="RunCommand" date="Wed Dec 25 11:41:08 EST 2019" kind="HitBreakPoint" projectName="PL_Java" starttimestamp="1576666505112" timestamp="625563564" type="Run" />
  <Command __id="106753" _type="RunCommand" date="Wed Dec 25 11:41:08 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="625563790" type="Run" />
  <Command __id="106754" _type="RunCommand" date="Wed Dec 25 11:41:09 EST 2019" kind="StepInto" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="625563928" type="Run" />
  <Command __id="106755" _type="RunCommand" date="Wed Dec 25 11:41:09 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="625564081" type="Run" />
  <Command __id="106756" _type="EHExceptionCommand" date="Wed Dec 25 11:41:09 EST 2019" starttimestamp="1576666505112" timestamp="625564176" type="Exception">
    <outputString><![CDATA[I***Tracer: showInfo = true
]]></outputString>
  </Command>
  <Command __id="106757" _type="EHExceptionCommand" date="Wed Dec 25 11:41:09 EST 2019" starttimestamp="1576666505112" timestamp="625564343" type="Exception">
    <outputString><![CDATA[Buffer traced nessages =false
]]></outputString>
  </Command>
  <Command __id="106758" _type="RunCommand" date="Wed Dec 25 11:41:10 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="625565288" type="Run" />
  <Command __id="106759" _type="RunCommand" date="Wed Dec 25 11:41:10 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="625565289" type="Run" />
  <Command __id="106760" _type="RunCommand" date="Wed Dec 25 11:41:10 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="625565290" type="Run" />
  <Command __id="106761" _type="RunCommand" date="Wed Dec 25 11:41:10 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="625565291" type="Run" />
  <Command __id="106762" _type="EHExceptionCommand" date="Wed Dec 25 11:41:10 EST 2019" starttimestamp="1576666505112" timestamp="625565767" type="Exception">
    <outputString><![CDATA[ObjectEditor(Version 22, built on Thu Dec 06 16:26:09 EST 2018). Copyright Prasun Dewan, 2012, All rights reserved. US Patent Appl. No.: 12/532,327
]]></outputString>
  </Command>
  <Command __id="106763" _type="ShellCommand" date="Wed Dec 25 11:41:11 EST 2019" starttimestamp="1576666505112" timestamp="625566498" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="106764" _type="EHExceptionCommand" date="Wed Dec 25 11:41:14 EST 2019" starttimestamp="1576666505112" timestamp="625569704" type="Exception">
    <outputString><![CDATA[I***(TestCaseResult) ### SequentialSumTestCase: 1.0
]]></outputString>
  </Command>
  <Command __id="106765" _type="RunCommand" date="Wed Dec 25 11:41:14 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="625569723" type="Run" />
  <Command __id="106766" _type="EHExceptionCommand" date="Wed Dec 25 11:41:14 EST 2019" starttimestamp="1576666505112" timestamp="625569757" type="Exception">
    <outputString><![CDATA[Returning first of multiple entry points:[MyOpenMPTraining.exe, OpenMPTraining.exe]
I***(BasicProcessRunner) Running command:D:\dewan_backup\C\MyOpenMPTraining\Debug\MyOpenMPTraining.exe
I***(BasicProcessRunner) Running in folder: D:\dewan_backup\C\MyOpenMPTraining\Debug
]]></outputString>
  </Command>
  <Command __id="106767" _type="RunCommand" date="Wed Dec 25 11:41:14 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="625569815" type="Run" />
  <Command __id="106768" _type="RunCommand" date="Wed Dec 25 11:41:14 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="625569827" type="Run" />
  <Command __id="106769" _type="EHExceptionCommand" date="Wed Dec 25 11:41:14 EST 2019" starttimestamp="1576666505112" timestamp="625569837" type="Exception">
    <outputString><![CDATA[I***(BasicProcessRunner)  Process started: D:\dewan_backup\C\MyOpenMPTraining\Debug\MyOpenMPTraining.exe folder: D:\dewan_backup\C\MyOpenMPTraining\Debug entry point: null class path: D:\dewan_backup\Java\PLTeaching\PL_Java\bin;D:\dewan_backup\Java\lib\oeall22.jar;C:\Users\dewan\.p2\pool\plugins\org.junit_4.12.0.v201504281640\junit.jar;C:\Users\dewan\.p2\pool\plugins\org.hamcrest.core_1.3.0.v20180420-1519.jar;D:\dewan_backup\Java\GraderBasics\lib\commons-configuration-1.9.jar;D:\dewan_backup\Java\GraderBasics\lib\commons-lang-2.6.jar;D:\dewan_backup\Java\GraderBasics\lib\commons-logging-1.1.1.jar;G:\My Drive\Java\lib\Herrmes\lib\weka3_6.jar;D:\dewan_backup\Java\GraderBasics\target\classes;D:\dewan_backup\Java\DemoCourseLocalBasicChecks\bin
I***(BasicRunningProject) 1577292074929:Received output from main: sum_sequential
I***(BasicRunningProject) 1577292074941:Processing line from main: sum_sequential
I***(BasicRunningProject) 1577292074941:Received output from main: Sum: 499500
I***(BasicRunningProject) 1577292074941:Processing line from main: Sum: 499500
I***(BasicRunningProject) 1577292074942:Received output from main: Took: 0
I***(BasicRunningProject) 1577292074942:Processing line from main: Took: 0
I***(BasicRunningProject) 1577292074942:Received output from main: thread:0 lastIndex:999
I***(BasicRunningProject) 1577292074942:Processing line from main: thread:0 lastIndex:999
I***(BasicRunningProject) 1577292074942:Received output from main: _____________________________
I***(BasicRunningProject) 1577292074942:Processing line from main: _____________________________
I***(BasicRunningProject) 1577292074943:Received output from main: sum_parallel_for_reduction
I***(BasicRunningProject) 1577292074943:Processing line from main: sum_parallel_for_reduction
I***(BasicRunningProject) 1577292074943:Received output from main: Sum: 499500
I***(BasicRunningProject) 1577292074943:Processing line from main: Sum: 499500
I***(BasicRunningProject) 1577292074943:Received output from main: Took: 0
I***(BasicRunningProject) 1577292074943:Processing line from main: Took: 0
I***(BasicRunningProject) 1577292074943:Received output from main: thread:0 lastIndex:124
I***(BasicRunningProject) 1577292074943:Processing line from main: thread:0 lastIndex:124
I***(BasicRunningProject) 1577292074943:Received output from main: thread:1 lastIndex:249
I***(BasicRunningProject) 1577292074943:Processing line from main: thread:1 lastIndex:249
I***(BasicRunningProject) 1577292074944:Received output from main: thread:2 lastIndex:374
I***(BasicRunningProject) 1577292074944:Processing line from main: thread:2 lastIndex:374
I***(BasicRunningProject) 1577292074944:Received output from main: thread:3 lastIndex:499
I***(BasicRunningProject) 1577292074944:Processing line from main: thread:3 lastIndex:499
I***(BasicRunningProject) 1577292074944:Received output from main: thread:4 lastIndex:624
I***(BasicRunningProject) 1577292074944:Processing line from main: thread:4 lastIndex:624
I***(BasicRunningProject) 1577292074944:Received output from main: thread:5 lastIndex:749
I***(BasicRunningProject) 1577292074944:Processing line from main: thread:5 lastIndex:749
I***(BasicRunningProject) 1577292074944:Received output from main: thread:6 lastIndex:874
I***(BasicRunningProject) 1577292074945:Processing line from main: thread:6 lastIndex:874
I***(BasicRunningProject) 1577292074945:Received output from main: thread:7 lastIndex:999
I***(BasicRunningProject) 1577292074945:Processing line from main: thread:7 lastIndex:999
I***(BasicRunningProject) 1577292074945:Received output from main: _____________________________
I***(BasicRunningProject) 1577292074945:Processing line from main: _____________________________
I***(BasicRunningProject) 1577292074945:Received output from main: sum_parallel_for_local_var
I***(BasicRunningProject) 1577292074945:Processing line from main: sum_parallel_for_local_var
I***(BasicRunningProject) 1577292074945:Received output from main: Sum: 499500
I***(BasicRunningProject) 1577292074945:Processing line from main: Sum: 499500
I***(BasicRunningProject) 1577292074945:Received output from main: Took: 0
I***(BasicRunningProject) 1577292074945:Processing line from main: Took: 0
I***(BasicRunningProject) 1577292074946:Received output from main: thread:0 lastIndex:124
I***(BasicRunningProject) 1577292074946:Processing line from main: thread:0 lastIndex:124
I***(BasicRunningProject) 1577292074946:Received output from main: thread:1 lastIndex:249
I***(BasicRunningProject) 1577292074946:Processing line from main: thread:1 lastIndex:249
I***(BasicRunningProject) 1577292074946:Received output from main: thread:2 lastIndex:374
I***(BasicRunningProject) 1577292074946:Processing line from main: thread:2 lastIndex:374
I***(BasicRunningProject) 1577292074946:Received output from main: thread:3 lastIndex:499
I***(BasicRunningProject) 1577292074946:Processing line from main: thread:3 lastIndex:499
I***(BasicRunningProject) 1577292074946:Received output from main: thread:4 lastIndex:624
I***(BasicRunningProject) 1577292074946:Processing line from main: thread:4 lastIndex:624
I***(BasicRunningProject) 1577292074946:Received output from main: thread:5 lastIndex:749
I***(BasicRunningProject) 1577292074947:Processing line from main: thread:5 lastIndex:749
I***(BasicRunningProject) 1577292074947:Received output from main: thread:6 lastIndex:874
I***(BasicRunningProject) 1577292074947:Processing line from main: thread:6 lastIndex:874
I***(BasicRunningProject) 1577292074947:Received output from main: thread:7 lastIndex:999
I***(BasicRunningProject) 1577292074947:Processing line from main: thread:7 lastIndex:999
I***(BasicRunningProject) 1577292074947:Received output from main: _____________________________
I***(BasicRunningProject) 1577292074947:Processing line from main: _____________________________
I***(BasicRunningProject) 1577292074947:Received output from main: sum_parallel
I***(BasicRunningProject) 1577292074947:Processing line from main: sum_parallel
I***(BasicRunningProject) 1577292074947:Received output from main: Sum: 499500
I***(BasicRunningProject) 1577292074948:Processing line from main: Sum: 499500
I***(BasicRunningProject) 1577292074948:Received output from main: Took: 0
I***(BasicRunningProject) 1577292074948:Processing line from main: Took: 0
I***(BasicRunningProject) 1577292074948:Received output from main: _____________________________
I***(BasicRunningProject) 1577292074948:Processing line from main: _____________________________]]></outputString>
  </Command>
  <Command __id="106770" _type="EHExceptionCommand" date="Wed Dec 25 11:41:15 EST 2019" starttimestamp="1576666505112" timestamp="625569915" type="Exception">
    <outputString><![CDATA[
I***(ARunnerInputStreamProcessor) Provided Input:
I***(BasicProcessRunner)  Process finished; folder: D:\dewan_backup\C\MyOpenMPTraining\Debug entry point: null class path: D:\dewan_backup\Java\PLTeaching\PL_Java\bin;D:\dewan_backup\Java\lib\oeall22.jar;C:\Users\dewan\.p2\pool\plugins\org.junit_4.12.0.v201504281640\junit.jar;C:\Users\dewan\.p2\pool\plugins\org.hamcrest.core_1.3.0.v20180420-1519.jar;D:\dewan_backup\Java\GraderBasics\lib\commons-configuration-1.9.jar;D:\dewan_backup\Java\GraderBasics\lib\commons-lang-2.6.jar;D:\dewan_backup\Java\GraderBasics\lib\commons-logging-1.1.1.jar;G:\My Drive\Java\lib\Herrmes\lib\weka3_6.jar;D:\dewan_backup\Java\GraderBasics\target\classes;D:\dewan_backup\Java\DemoCourseLocalBasicChecks\bin
I***(BasicRunningProject) Thread[AWT-EventQueue-0,6,main] sleeping for ms:2000 waiting for pending output from threads 
]]></outputString>
  </Command>
  <DocumentChange __id="119703" _type="Insert" date="Thu Dec 26 00:20:54 EST 2019" docASTNodeCount="229" docActiveCodeLength="1693" docExpressionCount="124" docLength="2192" length="5" offset="790" starttimestamp="1576666505112" timestamp="671149089">
    <text><![CDATA[
			]]></text>
  </DocumentChange>
  <Command __id="119704" _type="InsertStringCommand" date="Thu Dec 26 00:20:54 EST 2019" starttimestamp="1576666505112" timestamp="671149095" timestamp2="671149095">
    <data><![CDATA[]]></data>
  </Command>
  <Command __id="119705" _type="DiffBasedFileOpenCommand" date="Thu Dec 26 00:21:53 EST 2019" docASTNodeCount="1" docActiveCodeLength="659" docExpressionCount="0" docLength="747" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="671208520">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\my_sum_parallel_for_local_var.cpp]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"#include <iostream>¶#include <omp.h>¶¶using namespace std;¶¶void printSumWithTimes (int sum, int start, int end);¶void printNumThreads();¶void recordThreadIndex(int index);¶void sum_parallel_for_local_var(double* array, int size)¶{¶	cout << "sum_parallel_for_local_var\n";¶¶	double start = omp_get_wtime();¶¶	double sum = 0;¶¶	int a, b;¶//¶//	for (int i = 0; i < size; i++) {¶//			sum += array[i];¶//			recordThreadIndex(i);¶//	}¶¶    #pragma omp parallel shared (sum, start) private (a, b)¶	{¶		double local_sum = 0;¶¶		#pragma omp for¶		for(int i = 0; i < size; i++) {¶			local_sum += array[i];¶			recordThreadIndex(i);¶		}¶¶		#pragma omp critical¶		sum += local_sum;¶	}¶¶	double end = omp_get_wtime();¶¶	printSumWithTimes(sum, start, end);¶	¶}¶")]]]></diff>
  </Command>
  <Command __id="119706" _type="SelectTextCommand" caretOffset="493" date="Thu Dec 26 00:21:53 EST 2019" end="493" start="468" starttimestamp="1576666505112" timestamp="671208722" />
  <Command __id="119707" _type="EclipseCommand" commandID="" date="Thu Dec 26 00:21:54 EST 2019" starttimestamp="1576666505112" timestamp="671209622" />
  <Command __id="119708" _type="EclipseCommand" commandID="" date="Thu Dec 26 00:21:54 EST 2019" starttimestamp="1576666505112" timestamp="671209727" />
  <Command __id="119709" _type="DiffBasedFileOpenCommand" date="Thu Dec 26 00:21:56 EST 2019" docASTNodeCount="1" docActiveCodeLength="795" docExpressionCount="0" docLength="795" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="671211516">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\my_sum_parallel.cpp]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"#include <iostream>¶#include <omp.h>¶¶using namespace std;¶¶void printSumWithTimes(int sum, int start, int end);¶void printNumThreads();¶void recordThreadIndex(int index);¶void sum_parallel(double* array, int size) {¶	cout << "sum_parallel\n";¶¶	double start = omp_get_wtime();¶¶	double sum = 0;¶¶¶    #pragma omp critical¶	{¶	double sum = 0;¶	}¶    #pragma omp parallel¶	{¶		double local_sum = 0;¶¶		int rank = omp_get_thread_num();¶		int threads = omp_get_num_threads();¶¶		int start_index = (size/threads)*rank;¶		int end_index = (size/threads)*(rank+1);¶¶		if(rank==threads-1)¶			end_index=size;¶¶		for(int i = start_index; i < end_index; i++)¶			local_sum += array[i];¶¶		#pragma omp critical¶		sum += local_sum;¶	}¶¶	double end = omp_get_wtime();¶¶	printSumWithTimes(sum, start, end);¶¶¶}¶")]]]></diff>
  </Command>
  <Command __id="119710" _type="MoveCaretCommand" caretOffset="339" date="Thu Dec 26 00:21:56 EST 2019" docOffset="339" starttimestamp="1576666505112" timestamp="671211708" />
  <Command __id="119712" _type="MoveCaretCommand" caretOffset="349" date="Thu Dec 26 00:21:59 EST 2019" docOffset="349" starttimestamp="1576666505112" timestamp="671214551" />
  <Command __id="119711" _type="DiffBasedFileOpenCommand" date="Thu Dec 26 00:21:59 EST 2019" docASTNodeCount="1" docActiveCodeLength="532" docExpressionCount="0" docLength="575" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="671214368">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\my_sum_parallel_for_reduction.cpp]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"#include <iostream>¶#include <omp.h>¶¶using namespace std;¶¶//const int SIZE = 1000;¶void printSumWithTimes(int sum, int start, int end);¶void printNumThreads();¶void recordThreadIndex(int index);¶void sum_parallel_for_reduction(double* array, int size) {¶	cout << "sum_parallel_for_reduction\n";¶¶	double start = omp_get_wtime();¶¶	double sum = 0;¶    #pragma omp  parallel for reduction ( + : sum )¶"), Diff(INSERT,"//	#pragma omp  for¶¶"), Diff(EQUAL,"	for (int i = 0; i < size; i++) {¶		sum += array[i];¶		recordThreadIndex(i);¶	}¶¶	double end = omp_get_wtime();¶¶	printSumWithTimes(sum, start, end);¶¶}¶")]]]></diff>
    <snapshot><![CDATA[#include <iostream>
#include <omp.h>

using namespace std;

//const int SIZE = 1000;
void printSumWithTimes(int sum, int start, int end);
void printNumThreads();
void recordThreadIndex(int index);
void sum_parallel_for_reduction(double* array, int size) {
	cout << "sum_parallel_for_reduction\n";

	double start = omp_get_wtime();

	double sum = 0;
    #pragma omp  parallel for reduction ( + : sum )
//	#pragma omp  for

	for (int i = 0; i < size; i++) {
		sum += array[i];
		recordThreadIndex(i);
	}

	double end = omp_get_wtime();

	printSumWithTimes(sum, start, end);

}
]]></snapshot>
  </Command>
  <Command __id="119713" _type="MoveCaretCommand" caretOffset="378" date="Thu Dec 26 00:22:14 EST 2019" docOffset="378" starttimestamp="1576666505112" timestamp="671229838" />
  <DocumentChange __id="119714" _type="Insert" date="Thu Dec 26 00:22:15 EST 2019" docASTNodeCount="1" docActiveCodeLength="533" docExpressionCount="0" docLength="576" length="1" offset="378" starttimestamp="1576666505112" timestamp="671230866">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <Command __id="119715" _type="InsertStringCommand" date="Thu Dec 26 00:22:15 EST 2019" starttimestamp="1576666505112" timestamp="671230869" timestamp2="671230869">
    <data><![CDATA[ ]]></data>
  </Command>
  <DocumentChange __id="119716" _type="Insert" date="Thu Dec 26 00:22:16 EST 2019" docASTNodeCount="1" docActiveCodeLength="534" docExpressionCount="0" docLength="577" length="1" offset="379" starttimestamp="1576666505112" timestamp="671231258">
    <text><![CDATA[s]]></text>
  </DocumentChange>
  <Command __id="119717" _type="InsertStringCommand" date="Thu Dec 26 00:22:16 EST 2019" starttimestamp="1576666505112" timestamp="671231258" timestamp2="671231258">
    <data><![CDATA[s]]></data>
  </Command>
  <DocumentChange __id="119718" _type="Insert" date="Thu Dec 26 00:22:16 EST 2019" docASTNodeCount="1" docActiveCodeLength="535" docExpressionCount="0" docLength="578" length="1" offset="380" starttimestamp="1576666505112" timestamp="671231324">
    <text><![CDATA[h]]></text>
  </DocumentChange>
  <Command __id="119719" _type="InsertStringCommand" date="Thu Dec 26 00:22:16 EST 2019" starttimestamp="1576666505112" timestamp="671231324" timestamp2="671231324">
    <data><![CDATA[h]]></data>
  </Command>
  <DocumentChange __id="119720" _type="Insert" date="Thu Dec 26 00:22:16 EST 2019" docASTNodeCount="1" docActiveCodeLength="536" docExpressionCount="0" docLength="579" length="1" offset="381" starttimestamp="1576666505112" timestamp="671231527">
    <text><![CDATA[a]]></text>
  </DocumentChange>
  <Command __id="119721" _type="InsertStringCommand" date="Thu Dec 26 00:22:16 EST 2019" starttimestamp="1576666505112" timestamp="671231527" timestamp2="671231527">
    <data><![CDATA[a]]></data>
  </Command>
  <DocumentChange __id="119722" _type="Insert" date="Thu Dec 26 00:22:16 EST 2019" docASTNodeCount="1" docActiveCodeLength="537" docExpressionCount="0" docLength="580" length="1" offset="382" starttimestamp="1576666505112" timestamp="671231708">
    <text><![CDATA[r]]></text>
  </DocumentChange>
  <Command __id="119723" _type="InsertStringCommand" date="Thu Dec 26 00:22:16 EST 2019" starttimestamp="1576666505112" timestamp="671231724" timestamp2="671231724">
    <data><![CDATA[r]]></data>
  </Command>
  <DocumentChange __id="119724" _type="Insert" date="Thu Dec 26 00:22:16 EST 2019" docASTNodeCount="1" docActiveCodeLength="538" docExpressionCount="0" docLength="581" length="1" offset="383" starttimestamp="1576666505112" timestamp="671231790">
    <text><![CDATA[e]]></text>
  </DocumentChange>
  <Command __id="119725" _type="InsertStringCommand" date="Thu Dec 26 00:22:16 EST 2019" starttimestamp="1576666505112" timestamp="671231793" timestamp2="671231793">
    <data><![CDATA[e]]></data>
  </Command>
  <DocumentChange __id="119726" _type="Insert" date="Thu Dec 26 00:22:17 EST 2019" docASTNodeCount="1" docActiveCodeLength="539" docExpressionCount="0" docLength="582" length="1" offset="384" starttimestamp="1576666505112" timestamp="671231979">
    <text><![CDATA[d]]></text>
  </DocumentChange>
  <Command __id="119727" _type="InsertStringCommand" date="Thu Dec 26 00:22:17 EST 2019" starttimestamp="1576666505112" timestamp="671231982" timestamp2="671231982">
    <data><![CDATA[d]]></data>
  </Command>
  <DocumentChange __id="119728" _type="Insert" date="Thu Dec 26 00:22:17 EST 2019" docASTNodeCount="1" docActiveCodeLength="540" docExpressionCount="0" docLength="583" length="1" offset="385" starttimestamp="1576666505112" timestamp="671232653">
    <text><![CDATA[(]]></text>
  </DocumentChange>
  <Command __id="119729" _type="InsertStringCommand" date="Thu Dec 26 00:22:17 EST 2019" starttimestamp="1576666505112" timestamp="671232656" timestamp2="671232656">
    <data><![CDATA[(]]></data>
  </Command>
  <DocumentChange __id="119730" _type="Insert" date="Thu Dec 26 00:22:18 EST 2019" docASTNodeCount="1" docActiveCodeLength="541" docExpressionCount="0" docLength="584" length="1" offset="386" starttimestamp="1576666505112" timestamp="671232907">
    <text><![CDATA[i]]></text>
  </DocumentChange>
  <Command __id="119731" _type="InsertStringCommand" date="Thu Dec 26 00:22:18 EST 2019" starttimestamp="1576666505112" timestamp="671232915" timestamp2="671232915">
    <data><![CDATA[i]]></data>
  </Command>
  <Command __id="119733" _type="InsertStringCommand" date="Thu Dec 26 00:22:19 EST 2019" starttimestamp="1576666505112" timestamp="671234223" timestamp2="671234223">
    <data><![CDATA[)]]></data>
  </Command>
  <Command __id="119734" _type="EclipseCommand" commandID="org.eclipse.ui.file.save" date="Thu Dec 26 00:22:21 EST 2019" starttimestamp="1576666505112" timestamp="671236604" />
  <Command __id="119735" _type="MoveCaretCommand" caretOffset="378" date="Thu Dec 26 00:22:24 EST 2019" docOffset="378" starttimestamp="1576666505112" timestamp="671239031" />
  <Command __id="119736" _type="MoveCaretCommand" caretOffset="378" date="Thu Dec 26 00:22:26 EST 2019" docOffset="378" starttimestamp="1576666505112" timestamp="671241005" />
  <Command __id="119737" _type="ShellCommand" date="Thu Dec 26 00:22:35 EST 2019" starttimestamp="1576666505112" timestamp="671250171" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="119738" _type="ShellCommand" date="Thu Dec 26 00:22:36 EST 2019" starttimestamp="1576666505112" timestamp="671251802" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="119739" _type="SelectTextCommand" caretOffset="379" date="Thu Dec 26 00:22:42 EST 2019" end="388" start="379" starttimestamp="1576666505112" timestamp="671257665" />
  <Command __id="119741" _type="EclipseCommand" commandID="org.eclipse.ui.edit.delete" date="Thu Dec 26 00:22:43 EST 2019" starttimestamp="1576666505112" timestamp="671258235" />
  <Command __id="119743" _type="EclipseCommand" commandID="org.eclipse.ui.edit.delete" date="Thu Dec 26 00:22:44 EST 2019" starttimestamp="1576666505112" timestamp="671259236" />
  <DocumentChange __id="151304" _type="Delete" date="Sat Dec 28 10:26:48 EST 2019" docASTNodeCount="2764" docActiveCodeLength="18446" docExpressionCount="1782" docLength="20986" endLine="593" length="14" offset="20979" startLine="592" starttimestamp="1576666505112" timestamp="880302913">
    <text><![CDATA[
	public stat]]></text>
  </DocumentChange>
  <Command __id="151312" _type="ShellCommand" date="Sat Dec 28 10:27:34 EST 2019" starttimestamp="1576666505112" timestamp="880348906" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="151314" _type="MoveCaretCommand" caretOffset="1500" date="Sat Dec 28 10:27:44 EST 2019" docOffset="1500" starttimestamp="1576666505112" timestamp="880358932" />
  <Command __id="151315" _type="SelectTextCommand" caretOffset="1165" date="Sat Dec 28 10:27:50 EST 2019" end="1284" start="1165" starttimestamp="1576666505112" timestamp="880365354" />
  <Command __id="151316" _type="CopyCommand" date="Sat Dec 28 10:27:51 EST 2019" starttimestamp="1576666505112" timestamp="880366042" />
  <Command __id="151323" _type="EclipseCommand" commandID="org.eclipse.cdt.ui.edit.text.c.toggle.comment" date="Sat Dec 28 10:27:52 EST 2019" starttimestamp="1576666505112" timestamp="880366891" />
  <Command __id="151324" _type="MoveCaretCommand" caretOffset="1935" date="Sat Dec 28 10:27:57 EST 2019" docOffset="1935" starttimestamp="1576666505112" timestamp="880372363" />
  <Command __id="151326" _type="InsertStringCommand" date="Sat Dec 28 10:27:58 EST 2019" starttimestamp="1576666505112" timestamp="880372960" timestamp2="880372960">
    <data><![CDATA[]]></data>
  </Command>
  <Command __id="151328" _type="PasteCommand" date="Sat Dec 28 10:27:58 EST 2019" starttimestamp="1576666505112" timestamp="880373585" />
  <Command __id="151313" _type="DiffBasedFileOpenCommand" date="Sat Dec 28 10:27:43 EST 2019" docASTNodeCount="1" docActiveCodeLength="1642" docExpressionCount="0" docLength="1924" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="880358704">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\my_sum_main.cpp]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"#include <iostream>¶#include <omp.h>¶¶using namespace std;¶//need to declare headers of external functions called¶void sum_sequential(double* array, int size);¶void sum_parallel_for_reduction(double* array, int size);¶void sum_parallel(double* array, int size);¶void sum_parallel_for_local_var(double* array, int size);¶¶// if this main is used to call functions to do other computations¶// then those headers should also be declared here¶¶const int SIZE = 1000;¶void initArray (double* array, int size ) {¶	for(int i = 0; i < size; i++)¶			array[i]=i;¶}¶/**¶ * Called by each of the summing alternatives¶ */¶void printSumWithTimes (int sum, int start, int end) {¶	cout << "Sum: " << sum << endl;¶	cout << "Took: " << end - start << endl;¶}¶void printNumThreads() {¶	cout << "threads:" << omp_get_num_threads() << endl;¶}¶/**¶ * an array to learn how much concurrency occcurred¶ */¶int MAX_THREADS = 100;¶double* threadsLastIndex = new double[MAX_THREADS];¶int numThreads;¶¶¶void recordThreadIndex(int index) {¶	int thread =  omp_get_thread_num();¶	if (thread >= MAX_THREADS) {¶		return;¶	}¶	threadsLastIndex[thread] = index;¶	numThreads = omp_get_num_threads();¶}¶void initThreadRecording() {¶	numThreads = 0;¶	for (int i = 0; i < MAX_THREADS; i++) {¶		threadsLastIndex[i] = -1;¶	}¶}¶¶void printThreadLastIndex() {¶	for (int i = 0; i < numThreads; i++) {¶		cout << "thread:" << i << " lastIndex:" << threadsLastIndex[i] << endl;¶	}¶	cout << "_____________________________" << endl;¶}¶¶¶int main()¶{¶	double* array = new double[SIZE];¶	initArray(array, SIZE);¶	initThreadRecording();¶	sum_sequential(array, SIZE);¶	printThreadLastIndex();¶	initThreadRecording();¶	sum_parallel_for_reduction(array, SIZE);¶	printThreadLastIndex();¶	initThreadRecording();¶	sum_parallel_for_local_var(array, SIZE);¶	printThreadLastIndex();¶	initThreadRecording();¶	sum_parallel(array, SIZE);¶	printThreadLastIndex();¶	initThreadRecording();¶}¶")]]]></diff>
  </Command>
  <DocumentChange __id="151317" _type="Insert" date="Sat Dec 28 10:27:51 EST 2019" docASTNodeCount="1" docActiveCodeLength="1614" docExpressionCount="0" docLength="1926" length="2" offset="1165" starttimestamp="1576666505112" timestamp="880366854">
    <text><![CDATA[//]]></text>
  </DocumentChange>
  <DocumentChange __id="151318" _type="Insert" date="Sat Dec 28 10:27:51 EST 2019" docASTNodeCount="1" docActiveCodeLength="1598" docExpressionCount="0" docLength="1928" length="2" offset="1196" starttimestamp="1576666505112" timestamp="880366857">
    <text><![CDATA[//]]></text>
  </DocumentChange>
  <DocumentChange __id="151319" _type="Insert" date="Sat Dec 28 10:27:51 EST 2019" docASTNodeCount="1" docActiveCodeLength="1558" docExpressionCount="0" docLength="1930" length="2" offset="1215" starttimestamp="1576666505112" timestamp="880366860">
    <text><![CDATA[//]]></text>
  </DocumentChange>
  <DocumentChange __id="151320" _type="Insert" date="Sat Dec 28 10:27:51 EST 2019" docASTNodeCount="1" docActiveCodeLength="1531" docExpressionCount="0" docLength="1932" length="2" offset="1258" starttimestamp="1576666505112" timestamp="880366863">
    <text><![CDATA[//]]></text>
  </DocumentChange>
  <DocumentChange __id="151321" _type="Insert" date="Sat Dec 28 10:27:51 EST 2019" docASTNodeCount="1" docActiveCodeLength="1529" docExpressionCount="0" docLength="1934" length="2" offset="1288" starttimestamp="1576666505112" timestamp="880366866">
    <text><![CDATA[//]]></text>
  </DocumentChange>
  <DocumentChange __id="151322" _type="Insert" date="Sat Dec 28 10:27:51 EST 2019" docASTNodeCount="1" docActiveCodeLength="1528" docExpressionCount="0" docLength="1936" length="2" offset="1293" starttimestamp="1576666505112" timestamp="880366869">
    <text><![CDATA[//]]></text>
  </DocumentChange>
  <DocumentChange __id="151325" _type="Insert" date="Sat Dec 28 10:27:58 EST 2019" docASTNodeCount="1" docActiveCodeLength="1529" docExpressionCount="0" docLength="1937" length="1" offset="1935" starttimestamp="1576666505112" timestamp="880372955">
    <text><![CDATA[
]]></text>
  </DocumentChange>
  <DocumentChange __id="151327" _type="Insert" date="Sat Dec 28 10:27:58 EST 2019" docASTNodeCount="1" docActiveCodeLength="1648" docExpressionCount="0" docLength="2056" length="119" offset="1936" starttimestamp="1576666505112" timestamp="880373568">
    <text><![CDATA[void initThreadRecording() {
	numThreads = 0;
	for (int i = 0; i < MAX_THREADS; i++) {
		threadsLastIndex[i] = -1;
	}
}]]></text>
  </DocumentChange>
  <Command __id="151329" _type="EclipseCommand" commandID="org.eclipse.ui.file.save" date="Sat Dec 28 10:28:00 EST 2019" starttimestamp="1576666505112" timestamp="880375625" />
  <DocumentChange __id="151330" _type="Delete" date="Sat Dec 28 10:28:02 EST 2019" docASTNodeCount="1" docActiveCodeLength="1529" docExpressionCount="0" docLength="1937" endLine="82" length="119" offset="1936" startLine="77" starttimestamp="1576666505112" timestamp="880377676">
    <text><![CDATA[void initThreadRecording() {
	numThreads = 0;
	for (int i = 0; i < MAX_THREADS; i++) {
		threadsLastIndex[i] = -1;
	}
}]]></text>
  </DocumentChange>
  <Command __id="151331" _type="UndoCommand" date="Sat Dec 28 10:28:02 EST 2019" starttimestamp="1576666505112" timestamp="880377697" />
  <DocumentChange __id="151332" _type="Delete" date="Sat Dec 28 10:28:03 EST 2019" docASTNodeCount="1" docActiveCodeLength="1528" docExpressionCount="0" docLength="1936" endLine="77" length="1" offset="1935" startLine="76" starttimestamp="1576666505112" timestamp="880378246">
    <text><![CDATA[
]]></text>
  </DocumentChange>
  <Command __id="151333" _type="UndoCommand" date="Sat Dec 28 10:28:03 EST 2019" starttimestamp="1576666505112" timestamp="880378263" />
  <Command __id="151340" _type="UndoCommand" date="Sat Dec 28 10:28:03 EST 2019" starttimestamp="1576666505112" timestamp="880378804" />
  <DocumentChange __id="155741" _type="Insert" date="Sat Dec 28 23:53:09 EST 2019" docASTNodeCount="35" docActiveCodeLength="258" docExpressionCount="18" docLength="297" length="1" offset="176" starttimestamp="1576666505112" timestamp="928684050">
    <text><![CDATA[;]]></text>
  </DocumentChange>
  <DocumentChange __id="155744" _type="Delete" date="Sat Dec 28 23:53:14 EST 2019" docASTNodeCount="35" docActiveCodeLength="257" docExpressionCount="18" docLength="296" endLine="4" length="1" offset="145" startLine="4" starttimestamp="1576666505112" timestamp="928688977">
    <text><![CDATA[r]]></text>
  </DocumentChange>
  <Command __id="155784" _type="ShellCommand" date="Sat Dec 28 23:54:05 EST 2019" starttimestamp="1576666505112" timestamp="928739933" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="155786" _type="MoveCaretCommand" caretOffset="339" date="Sat Dec 28 23:55:40 EST 2019" docOffset="339" starttimestamp="1576666505112" timestamp="928835036" />
  <Command __id="155787" _type="EclipseCommand" commandID="" date="Sat Dec 28 23:55:40 EST 2019" starttimestamp="1576666505112" timestamp="928835646" />
  <Command __id="155788" _type="EclipseCommand" commandID="" date="Sat Dec 28 23:55:40 EST 2019" starttimestamp="1576666505112" timestamp="928835769" />
  <Command __id="155789" _type="SelectTextCommand" caretOffset="431" date="Sat Dec 28 23:55:44 EST 2019" end="431" start="412" starttimestamp="1576666505112" timestamp="928839873" />
  <Command __id="155790" _type="SelectTextCommand" caretOffset="431" date="Sat Dec 28 23:55:44 EST 2019" end="431" start="412" starttimestamp="1576666505112" timestamp="928839873" />
  <Command __id="155791" _type="SelectTextCommand" caretOffset="430" date="Sat Dec 28 23:55:50 EST 2019" end="430" start="411" starttimestamp="1576666505112" timestamp="928845388" />
  <Command __id="155792" _type="SelectTextCommand" caretOffset="430" date="Sat Dec 28 23:55:50 EST 2019" end="430" start="411" starttimestamp="1576666505112" timestamp="928845388" />
  <DocumentChange __id="155813" _type="Insert" date="Sat Dec 28 23:56:31 EST 2019" docASTNodeCount="35" docActiveCodeLength="265" docExpressionCount="18" docLength="304" length="1" offset="141" starttimestamp="1576666505112" timestamp="928886297">
    <text><![CDATA[_]]></text>
  </DocumentChange>
  <Command __id="155814" _type="InsertStringCommand" date="Sat Dec 28 23:56:31 EST 2019" starttimestamp="1576666505112" timestamp="928886301" timestamp2="928886301">
    <data><![CDATA[_]]></data>
  </Command>
  <Command __id="155816" _type="SelectTextCommand" caretOffset="430" date="Sat Dec 28 23:56:35 EST 2019" end="430" start="411" starttimestamp="1576666505112" timestamp="928890529" />
  <Command __id="156081" _type="EclipseCommand" commandID="" date="Sun Dec 29 00:01:07 EST 2019" starttimestamp="1576666505112" timestamp="929162411" />
  <Command __id="156082" _type="EclipseCommand" commandID="" date="Sun Dec 29 00:01:07 EST 2019" starttimestamp="1576666505112" timestamp="929162414" />
  <Command __id="156083" _type="EclipseCommand" commandID="" date="Sun Dec 29 00:01:07 EST 2019" starttimestamp="1576666505112" timestamp="929162426" />
  <Command __id="156084" _type="EclipseCommand" commandID="" date="Sun Dec 29 00:01:07 EST 2019" starttimestamp="1576666505112" timestamp="929162426" />
  <Command __id="156085" _type="EclipseCommand" commandID="" date="Sun Dec 29 00:01:07 EST 2019" starttimestamp="1576666505112" timestamp="929162427" />
  <Command __id="156086" _type="EclipseCommand" commandID="" date="Sun Dec 29 00:01:07 EST 2019" starttimestamp="1576666505112" timestamp="929162427" />
  <Command __id="156087" _type="EclipseCommand" commandID="" date="Sun Dec 29 00:01:07 EST 2019" starttimestamp="1576666505112" timestamp="929162442" />
  <Command __id="156088" _type="EclipseCommand" commandID="" date="Sun Dec 29 00:01:07 EST 2019" starttimestamp="1576666505112" timestamp="929162442" />
  <Command __id="156089" _type="EclipseCommand" commandID="" date="Sun Dec 29 00:01:07 EST 2019" starttimestamp="1576666505112" timestamp="929162446" />
  <Command __id="156090" _type="EclipseCommand" commandID="" date="Sun Dec 29 00:01:07 EST 2019" starttimestamp="1576666505112" timestamp="929162450" />
  <Command __id="156091" _type="EclipseCommand" commandID="" date="Sun Dec 29 00:01:07 EST 2019" starttimestamp="1576666505112" timestamp="929162456" />
  <Command __id="156093" _type="EclipseCommand" commandID="" date="Sun Dec 29 00:06:07 EST 2019" starttimestamp="1576666505112" timestamp="929462176" />
  <Command __id="156094" _type="EclipseCommand" commandID="" date="Sun Dec 29 00:06:07 EST 2019" starttimestamp="1576666505112" timestamp="929462329" />
  <Command __id="157294" _type="DiffBasedFileOpenCommand" date="Sun Dec 29 00:24:30 EST 2019" docASTNodeCount="367" docActiveCodeLength="2458" docExpressionCount="272" docLength="2552" projectName="DemoCourseLocalBasicChecks" starttimestamp="1576666505112" timestamp="930564896">
    <filePath><![CDATA[D:\dewan_backup\Java\DemoCourseLocalBasicChecks\src\gradingTools\comp123\assignment1\openmp\testcases\SequentialSumTestCase.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package gradingTools.comp123.assignment1.openmp.testcases;¶¶import java.util.Arrays;¶import java.util.List;¶import java.util.Map;¶import java.util.regex.Pattern;¶¶import grader.basics.execution.NotRunnableException;¶import grader.basics.execution.RunningProject;¶import grader.basics.junit.NotAutomatableException;¶import grader.basics.junit.TestCaseResult;¶import grader.basics.project.NotGradableException;¶import grader.basics.project.Project;¶import grader.basics.project.source.ABasicTextManager;¶import grader.basics.testcase.PassFailJUnitTestCase;¶import gradingTools.shared.testcases.SubstringSequenceChecker;¶import gradingTools.shared.testcases.openmp.OpenMPPragma;¶import gradingTools.shared.testcases.openmp.OpenMPUtils;¶import gradingTools.shared.testcases.openmp.scannedTree.OMPSNodeUtils;¶import gradingTools.shared.testcases.openmp.scannedTree.SNode;¶import gradingTools.shared.testcases.utils.LinesMatchKind;¶import gradingTools.shared.testcases.utils.LinesMatcher;¶import gradingTools.utils.RunningProjectUtils;¶¶public class SequentialSumTestCase extends PassFailJUnitTestCase {¶	public static final int TIME_OUT_SECS = 1; // secs¶	protected SubstringSequenceChecker checker = new ASequentialSumChecker();	¶¶	public SequentialSumTestCase() {¶	}¶¶	¶¶	@Override¶	public TestCaseResult test(Project project, boolean autoGrade) throws NotAutomatableException,¶			NotGradableException {¶		try {¶			RunningProject aRunningProject = RunningProjectUtils.runProject(project, TIME_OUT_SECS);¶			String anOutput = aRunningProject.await();¶			LinesMatcher aLinesMatcher = aRunningProject.getLinesMatcher();¶			boolean aRetval = checker.check(aLinesMatcher, LinesMatchKind.ONE_TIME_LINE, Pattern.DOTALL);¶			String aSource = project.getSource();¶			Map<String, StringBuffer> aFileNameToContents = ABasicTextManager.extractFileContents(aSource);¶			for (String aFileName:aFileNameToContents.keySet()) {¶				StringBuffer aFileContents = aFileNameToContents.get(aFileName);¶//				List<OpenMPPragma> anOpenMPPragmas = OpenMPUtils.getOpemMPPragmas(aFileContents);¶				SNode anSNode = OMPSNodeUtils.getSNode(aFileContents);¶				System.out.println("file name:" + aFileName);¶				System.out.println("pragmas:" + anSNode);¶			}¶			String anExpectedLines = Arrays.toString(checker.getSubstrings());¶¶			if (!aRetval) {¶				return fail("Output  did not match:" + anExpectedLines);¶¶			}¶			return pass();¶			¶¶		} catch (NotRunnableException e) {¶			throw new NotGradableException();¶		}¶	}¶}¶")]]]></diff>
  </Command>
  <DocumentChange __id="157297" _type="Insert" date="Sun Dec 29 00:24:42 EST 2019" docASTNodeCount="367" docActiveCodeLength="2459" docExpressionCount="272" docLength="2553" length="1" offset="2154" starttimestamp="1576666505112" timestamp="930576926">
    <text><![CDATA[a]]></text>
  </DocumentChange>
  <DocumentChange __id="157299" _type="Insert" date="Sun Dec 29 00:24:42 EST 2019" docASTNodeCount="367" docActiveCodeLength="2460" docExpressionCount="272" docLength="2554" length="1" offset="2155" starttimestamp="1576666505112" timestamp="930577499">
    <text><![CDATA[F]]></text>
  </DocumentChange>
  <DocumentChange __id="157301" _type="Insert" date="Sun Dec 29 00:24:43 EST 2019" docASTNodeCount="367" docActiveCodeLength="2461" docExpressionCount="272" docLength="2555" length="1" offset="2156" starttimestamp="1576666505112" timestamp="930578018">
    <text><![CDATA[i]]></text>
  </DocumentChange>
  <DocumentChange __id="157303" _type="Insert" date="Sun Dec 29 00:24:43 EST 2019" docASTNodeCount="367" docActiveCodeLength="2462" docExpressionCount="272" docLength="2556" length="1" offset="2157" starttimestamp="1576666505112" timestamp="930578235">
    <text><![CDATA[l]]></text>
  </DocumentChange>
  <DocumentChange __id="157305" _type="Insert" date="Sun Dec 29 00:24:43 EST 2019" docASTNodeCount="367" docActiveCodeLength="2463" docExpressionCount="272" docLength="2557" length="1" offset="2158" starttimestamp="1576666505112" timestamp="930578307">
    <text><![CDATA[e]]></text>
  </DocumentChange>
  <DocumentChange __id="157307" _type="Insert" date="Sun Dec 29 00:24:43 EST 2019" docASTNodeCount="367" docActiveCodeLength="2464" docExpressionCount="272" docLength="2558" length="1" offset="2159" starttimestamp="1576666505112" timestamp="930578835">
    <text><![CDATA[N]]></text>
  </DocumentChange>
  <DocumentChange __id="157309" _type="Insert" date="Sun Dec 29 00:24:44 EST 2019" docASTNodeCount="367" docActiveCodeLength="2465" docExpressionCount="272" docLength="2559" length="1" offset="2160" starttimestamp="1576666505112" timestamp="930579031">
    <text><![CDATA[a]]></text>
  </DocumentChange>
  <DocumentChange __id="157311" _type="Insert" date="Sun Dec 29 00:24:44 EST 2019" docASTNodeCount="367" docActiveCodeLength="2466" docExpressionCount="272" docLength="2560" length="1" offset="2161" starttimestamp="1576666505112" timestamp="930579218">
    <text><![CDATA[m]]></text>
  </DocumentChange>
  <DocumentChange __id="157313" _type="Insert" date="Sun Dec 29 00:24:44 EST 2019" docASTNodeCount="367" docActiveCodeLength="2467" docExpressionCount="272" docLength="2561" length="1" offset="2162" starttimestamp="1576666505112" timestamp="930579376">
    <text><![CDATA[e]]></text>
  </DocumentChange>
  <DocumentChange __id="157315" _type="Insert" date="Sun Dec 29 00:24:45 EST 2019" docASTNodeCount="368" docActiveCodeLength="2468" docExpressionCount="273" docLength="2562" length="1" offset="2163" starttimestamp="1576666505112" timestamp="930579898">
    <text><![CDATA[,]]></text>
  </DocumentChange>
  <DocumentChange __id="157317" _type="Insert" date="Sun Dec 29 00:24:45 EST 2019" docASTNodeCount="368" docActiveCodeLength="2469" docExpressionCount="273" docLength="2563" length="1" offset="2164" starttimestamp="1576666505112" timestamp="930580192">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <Command __id="157328" _type="EclipseCommand" commandID="AUTOGEN:::org.eclipse.jdt.debug.CompilationUnitEditor.BreakpointRulerActions/org.eclipse.jdt.debug.ui.actions.ManageBreakpointRulerAction" date="Sun Dec 29 00:25:19 EST 2019" starttimestamp="1576666505112" timestamp="930614502" />
  <Command __id="157329" _type="BreakPointCommand" date="Sun Dec 29 00:25:19 EST 2019" lineNumber="47" starttimestamp="1576666505112" timestamp="930614506" type="BreakPointAdded" />
  <Command __id="177316" _type="DiffBasedFileOpenCommand" date="Mon Dec 30 00:18:11 EST 2019" docASTNodeCount="143" docActiveCodeLength="1149" docExpressionCount="84" docLength="1188" projectName="GraderBasics" starttimestamp="1576666505112" timestamp="1016586570">
    <filePath><![CDATA[D:\dewan_backup\Java\GraderBasics\src\gradingTools\shared\testcases\openmp\scannedTree\ARootOfFileSNode.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package gradingTools.shared.testcases.openmp.scannedTree;¶¶import java.util.ArrayList;¶import java.util.List;¶¶public class ARootOfFileSNode extends AnSNode implements RootOfFileSNode{¶	String fileName;¶	ExternalMethodSNode  omp_get_thread_num_SNode;¶	¶	ExternalMethodSNode omp_get_num_threads_SNode;¶	public ARootOfFileSNode(String aFileName) {¶		super(0);¶		fileName = aFileName;¶		omp_get_thread_num_SNode = new AnOMPPredefinedExternalMethodSNode("int", "omp_get_thread_num");¶		omp_get_num_threads_SNode = new AnOMPPredefinedExternalMethodSNode("int", "omp_get_num_threads");¶		¶		// TODO Auto-generated constructor stub¶	}¶	@Override¶	public ExternalMethodSNode getOmp_get_thread_num_SNode() {¶		return omp_get_thread_num_SNode;¶	}¶	@Override¶	public ExternalMethodSNode getOmp_get_num_threads_SNode() {¶		return omp_get_num_threads_SNode;¶	}¶	@Override¶	public String getFileName() {¶		return fileName;¶	}¶	public void setFileName(String fileName) {¶		this.fileName = fileName;¶	}¶	public void setParent(SNode aParent) {¶		super.setParent(aParent);¶		omp_get_thread_num_SNode.setParent(this);¶		omp_get_num_threads_SNode.setParent(this);¶	}¶}¶")]]]></diff>
  </Command>
  <DocumentChange __id="177321" _type="Insert" date="Mon Dec 30 00:18:59 EST 2019" docASTNodeCount="138" docActiveCodeLength="1106" docExpressionCount="80" docLength="1190" length="2" offset="1090" starttimestamp="1576666505112" timestamp="1016634512">
    <text><![CDATA[//]]></text>
  </DocumentChange>
  <DocumentChange __id="177322" _type="Insert" date="Mon Dec 30 00:18:59 EST 2019" docASTNodeCount="133" docActiveCodeLength="1062" docExpressionCount="76" docLength="1192" length="2" offset="1137" starttimestamp="1576666505112" timestamp="1016634513">
    <text><![CDATA[//]]></text>
  </DocumentChange>
  <DocumentChange __id="177325" _type="Insert" date="Mon Dec 30 00:19:07 EST 2019" docASTNodeCount="133" docActiveCodeLength="1066" docExpressionCount="76" docLength="1196" length="4" offset="593" starttimestamp="1576666505112" timestamp="1016642056">
    <text><![CDATA[
		]]></text>
  </DocumentChange>
  <DocumentChange __id="177327" _type="Replace" date="Mon Dec 30 00:19:08 EST 2019" docASTNodeCount="143" docActiveCodeLength="1153" docExpressionCount="84" docLength="1283" endLine="15" insertionLength="89" int_docASTNodeCount="133" int_docActiveCodeLength="1064" int_docExpressionCount="76" int_docLength="1194" length="2" offset="595" startLine="15" starttimestamp="1576666505112" timestamp="1016642992">
    <deletedText><![CDATA[		]]></deletedText>
    <insertedText><![CDATA[		omp_get_thread_num_SNode.setParent(this);
		omp_get_num_threads_SNode.setParent(this);]]></insertedText>
  </DocumentChange>
  <DocumentChange __id="177388" _type="Delete" date="Mon Dec 30 00:19:26 EST 2019" docASTNodeCount="143" docActiveCodeLength="1151" docExpressionCount="84" docLength="1281" endLine="8" length="2" offset="257" startLine="7" starttimestamp="1576666505112" timestamp="1016661612">
    <text><![CDATA[
]]></text>
  </DocumentChange>
  <Command __id="177390" _type="MoveCaretCommand" caretOffset="307" date="Mon Dec 30 00:19:28 EST 2019" docOffset="307" starttimestamp="1576666505112" timestamp="1016663510" />
  <Command __id="177392" _type="SelectTextCommand" caretOffset="471" date="Mon Dec 30 00:21:23 EST 2019" end="471" start="450" starttimestamp="1576666505112" timestamp="1016777991" />
  <Command __id="177391" _type="DiffBasedFileOpenCommand" date="Mon Dec 30 00:21:22 EST 2019" docASTNodeCount="1" docActiveCodeLength="795" docExpressionCount="0" docLength="795" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="1016777665">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\my_sum_parallel.cpp]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"#include <iostream>¶#include <omp.h>¶¶using namespace std;¶¶void printSumWithTimes(int sum, int start, int end);¶void printNumThreads();¶void recordThreadIndex(int index);¶void sum_parallel(double* array, int size) {¶	cout << "sum_parallel\n";¶¶	double start = omp_get_wtime();¶¶	double sum = 0;¶¶¶    #pragma omp critical¶	{¶	double sum = 0;¶	}¶    #pragma omp parallel¶	{¶		double local_sum = 0;¶¶		int rank = omp_get_thread_num();¶		int threads = omp_get_num_threads();¶¶		int start_index = (size/threads)*rank;¶		int end_index = (size/threads)*(rank+1);¶¶		if(rank==threads-1)¶			end_index=size;¶¶		for(int i = start_index; i < end_index; i++)¶			local_sum += array[i];¶¶		#pragma omp critical¶		sum += local_sum;¶	}¶¶	double end = omp_get_wtime();¶¶	printSumWithTimes(sum, start, end);¶¶¶}¶")]]]></diff>
  </Command>
  <Command __id="177394" _type="ShellCommand" date="Mon Dec 30 00:21:36 EST 2019" starttimestamp="1576666505112" timestamp="1016791186" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="177395" _type="EclipseCommand" commandID="org.eclipse.ui.edit.delete" date="Mon Dec 30 00:21:36 EST 2019" starttimestamp="1576666505112" timestamp="1016791219" />
  <Command __id="177397" _type="MoveCaretCommand" caretOffset="312" date="Mon Dec 30 00:21:46 EST 2019" docOffset="312" starttimestamp="1576666505112" timestamp="1016801057" />
  <DocumentChange __id="177408" _type="Replace" date="Mon Dec 30 00:22:13 EST 2019" docASTNodeCount="143" docActiveCodeLength="1154" docExpressionCount="84" docLength="1284" endLine="10" insertionLength="1" int_docASTNodeCount="143" int_docActiveCodeLength="1153" int_docExpressionCount="84" int_docLength="1283" length="87" offset="309" startLine="9" starttimestamp="1576666505112" timestamp="1016828397">
    <deletedText><![CDATA[	omp_get_thread_num_SNode.setParent(this);
	omp_get_num_threads_SNode.setParent(this);]]></deletedText>
    <insertedText><![CDATA[	]]></insertedText>
  </DocumentChange>
  <Command __id="177409" _type="UndoCommand" date="Mon Dec 30 00:22:13 EST 2019" starttimestamp="1576666505112" timestamp="1016828423" />
  <Command __id="177411" _type="SelectTextCommand" caretOffset="280" date="Mon Dec 30 00:22:18 EST 2019" end="280" start="265" starttimestamp="1576666505112" timestamp="1016833201" />
  <DocumentChange __id="177609" _type="Insert" date="Mon Dec 30 00:23:51 EST 2019" docASTNodeCount="142" docActiveCodeLength="1127" docExpressionCount="78" docLength="1127" length="1" offset="287" starttimestamp="1576666505112" timestamp="1016926849">
    <text><![CDATA[N]]></text>
  </DocumentChange>
  <DocumentChange __id="177611" _type="Insert" date="Mon Dec 30 00:23:52 EST 2019" docASTNodeCount="142" docActiveCodeLength="1128" docExpressionCount="78" docLength="1128" length="1" offset="288" starttimestamp="1576666505112" timestamp="1016927124">
    <text><![CDATA[o]]></text>
  </DocumentChange>
  <DocumentChange __id="177613" _type="Insert" date="Mon Dec 30 00:23:52 EST 2019" docASTNodeCount="142" docActiveCodeLength="1129" docExpressionCount="78" docLength="1129" length="1" offset="289" starttimestamp="1576666505112" timestamp="1016927242">
    <text><![CDATA[d]]></text>
  </DocumentChange>
  <DocumentChange __id="177615" _type="Insert" date="Mon Dec 30 00:23:52 EST 2019" docASTNodeCount="142" docActiveCodeLength="1130" docExpressionCount="78" docLength="1130" length="1" offset="290" starttimestamp="1576666505112" timestamp="1016927390">
    <text><![CDATA[e]]></text>
  </DocumentChange>
  <DocumentChange __id="177617" _type="Insert" date="Mon Dec 30 00:23:52 EST 2019" docASTNodeCount="144" docActiveCodeLength="1131" docExpressionCount="79" docLength="1131" length="1" offset="291" starttimestamp="1576666505112" timestamp="1016927622">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="177621" _type="Delete" date="Mon Dec 30 00:23:56 EST 2019" docASTNodeCount="118" docActiveCodeLength="1130" docExpressionCount="67" docLength="1130" endLine="9" length="1" offset="316" startLine="9" starttimestamp="1576666505112" timestamp="1016931085">
    <text><![CDATA[;]]></text>
  </DocumentChange>
  <DocumentChange __id="177623" _type="Delete" date="Mon Dec 30 00:23:56 EST 2019" docASTNodeCount="127" docActiveCodeLength="1129" docExpressionCount="71" docLength="1129" endLine="9" length="1" offset="315" startLine="9" starttimestamp="1576666505112" timestamp="1016931252">
    <text><![CDATA[)]]></text>
  </DocumentChange>
  <DocumentChange __id="177625" _type="Delete" date="Mon Dec 30 00:23:57 EST 2019" docASTNodeCount="145" docActiveCodeLength="1128" docExpressionCount="79" docLength="1128" endLine="9" length="1" offset="314" startLine="9" starttimestamp="1576666505112" timestamp="1016931907">
    <text><![CDATA[(]]></text>
  </DocumentChange>
  <DocumentChange __id="177627" _type="Insert" date="Mon Dec 30 00:23:57 EST 2019" docASTNodeCount="145" docActiveCodeLength="1129" docExpressionCount="79" docLength="1129" length="1" offset="314" starttimestamp="1576666505112" timestamp="1016932622">
    <text><![CDATA[;]]></text>
  </DocumentChange>
  <Command __id="177629" _type="EclipseCommand" commandID="" date="Mon Dec 30 00:24:11 EST 2019" starttimestamp="1576666505112" timestamp="1016945986" />
  <Command __id="177630" _type="EclipseCommand" commandID="" date="Mon Dec 30 00:24:11 EST 2019" starttimestamp="1576666505112" timestamp="1016946658" />
  <Command __id="182041" _type="DiffBasedFileOpenCommand" date="Mon Dec 30 08:23:59 EST 2019" docASTNodeCount="3827" docActiveCodeLength="27193" docExpressionCount="2434" docLength="31379" projectName="GraderBasics" starttimestamp="1576666505112" timestamp="1045734660">
    <filePath><![CDATA[D:\dewan_backup\Java\GraderBasics\src\gradingTools\shared\testcases\openmp\scannedTree\OMPSNodeUtils.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package gradingTools.shared.testcases.openmp.scannedTree;¶¶import java.util.ArrayList;¶import java.util.Arrays;¶import java.util.HashMap;¶import java.util.List;¶import java.util.Map;¶import java.util.Stack;¶import java.util.regex.Matcher;¶import java.util.regex.Pattern;¶¶import org.apache.commons.lang.StringUtils;¶¶import grader.basics.project.source.ABasicTextManager;¶import gradingTools.shared.testcases.openmp.OpenMPKeywordEnum;¶import gradingTools.shared.testcases.openmp.OpenMPParallelPragma;¶import gradingTools.shared.testcases.openmp.OpenMPUtils;¶import gradingTools.shared.testcases.openmp.scannedTree.ADeclarationSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.ADeclaringAssignmentSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.AForSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.ATextSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.AnAssignmentSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.AnOMPCriticalSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.AnOMPForSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.AnOMPParallelSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.AnOMPSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.AnSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.AssignmentSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.DeclarationSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.DeclaringAssignmentSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.ForSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.OMPForSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.OMPSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.SNode;¶¶public class OMPSNodeUtils extends OpenMPUtils {¶¶	public static RootOfFileSNode getSNode(String aFileName, StringBuffer aFileBuffer) {¶		String[] aFileLines = aFileBuffer.toString().split("\n");¶		return getSNode(aFileName, aFileLines);¶	}¶¶	public static AssignmentSNode getAssignmentSNode(int aLineNumber, String aString) {¶		if (aString == null) {¶			return null;¶		}¶		String[] aTokens = aString.split("=");¶		if (aTokens.length == 1) {¶			return new AnAssignmentSNode(aLineNumber, aTokens[0], null);¶		} else {¶		return new AnAssignmentSNode(aLineNumber, aTokens[0], aTokens[1]);¶		}¶	}¶¶	public static DeclarationSNode getDeclarationSNode(int aLineNumber, String aString) {¶		String[] aTokens = aString.split(" ");¶		return new ADeclarationSNode(aLineNumber, aTokens[0], aTokens[1]);¶	}¶¶	public static DeclaringAssignmentSNode getDeclaringAssignmentSNode(int aLineNumber, String aString) {¶		String[] anLHSAndRHS = aString.split("=");¶		String[] aTypeAndVariable = anLHSAndRHS[0].split(" ");¶		return new ADeclaringAssignmentSNode(aLineNumber, aTypeAndVariable[0], aTypeAndVariable[1], anLHSAndRHS[1]);¶	}¶¶	public static boolean isDeclaringAssignment(String aFileLine) {¶		return startsWithTypeName(aFileLine) && aFileLine.contains("=");¶	}¶	public static boolean isMethodDeclaration(String aFileLine) {¶		return startsWithTypeName(aFileLine) && ¶				aFileLine.contains("(") &&¶				!aFileLine.contains("=");¶	}¶	public static boolean isExternalMethodDeclaration(String aFileLine) {¶		return isMethodDeclaration(aFileLine) && aFileLine.endsWith(";");¶	}¶¶¶	public static boolean isVariableDeclaration(String aFileLine) {¶¶		return startsWithTypeName(aFileLine) && !aFileLine.contains("(");¶	}¶¶	public static boolean isAssignment(String aFileLine) {¶		return aFileLine.contains("=");¶	}¶¶	public static boolean isForNode(String aFileLine) {¶		return aFileLine.startsWith("for");¶	}¶¶	public static ForSNode getForSNode(int aLineNumber, String aFileLine) {¶¶		int aLeftParenIndex = aFileLine.indexOf("(");¶		int aRightParenIndex = aFileLine.indexOf(")");¶		if (aLeftParenIndex < 0 || aRightParenIndex < 0) {¶			return null;¶		}¶		String aHeaderString = aFileLine.substring(aLeftParenIndex + 1, aRightParenIndex);¶		String[] aForComponents = aHeaderString.split(";");¶		AssignmentSNode anAssignmentSNode = null;¶		String aForInitializaton = aForComponents[0];¶		if (!aForInitializaton.isEmpty() && aForInitializaton.contains("=")) {¶			if (isDeclaringAssignment(aForInitializaton)) {¶				anAssignmentSNode = getDeclaringAssignmentSNode(aLineNumber, aForInitializaton);¶			} else {¶				anAssignmentSNode = getAssignmentSNode(aLineNumber, aForInitializaton);¶			}¶¶		}		¶		return new AForSNode(aLineNumber, anAssignmentSNode, aForComponents[1], getAssignmentSNode(aLineNumber, aForComponents[2]));¶	}¶	static String[] emptyArray = {};¶	public static MethodSNode getMethodSNode(int aLineNumber, String aFileLine, boolean isInternal) {¶¶		int aLeftParenIndex = aFileLine.indexOf("(");¶		int aRightParenIndex = aFileLine.indexOf(")");¶		if (aLeftParenIndex < 0 || aRightParenIndex < 0) {¶			return null;¶		}¶		String aMethodNameAndType = aFileLine.substring(0, aLeftParenIndex);¶		String[] aMethodNameAndTypeTokens = aMethodNameAndType.split("\\s+"); ¶		¶		String aMethodParameters = aFileLine.substring(aLeftParenIndex +1 , aRightParenIndex);¶		String[] aMethodParameterTokens = aMethodParameters.isEmpty()?emptyArray:¶		 aMethodParameters.split(",");¶		¶//		String[] aMethodParameterTypes = new String[aMethodParameterTokens.length];¶//		String[] aMethodParameterNames = new String[aMethodParameterTokens.length];¶		List<DeclarationSNode> aDeclarationSNodeList = new ArrayList();¶		for (int i = 0; i < aMethodParameterTokens.length; i++ ) {¶			String[] aTypeAndName = aMethodParameterTokens[i].trim().split("\\s+");¶			if (aTypeAndName.length < 2) {¶				continue;¶			}¶			aDeclarationSNodeList.add(new ADeclarationSNode(aLineNumber, aTypeAndName[0].trim(), aTypeAndName[1].trim()));¶//			aMethodParameterTypes[i] = aTypeAndName[0].trim();¶//			aMethodParameterNames[i] = aTypeAndName[1].trim();¶		}¶		if (isInternal)¶//		return new AMethodSNode(aLineNumber, aMethodNameAndTypeTokens[0], aMethodNameAndTypeTokens[1], aMethodParameterTypes,aMethodParameterNames );¶			return new AMethodSNode(aLineNumber, aMethodNameAndTypeTokens[0], aMethodNameAndTypeTokens[1], aDeclarationSNodeList );¶		else¶			return new AnExternalMethodSNode(aLineNumber, aMethodNameAndTypeTokens[0], aMethodNameAndTypeTokens[1], aDeclarationSNodeList );¶	}¶¶	public static void setReductionData(OMPForSNode lastChild, String aStoredToken, int aLeftParenIndex,¶			int aRightParenIndex) {¶		int aColonIndex = aStoredToken.indexOf(":");¶		if (aLeftParenIndex != -1 && aRightParenIndex != -1 && aColonIndex != -1) {¶			String anOperationString = aStoredToken.substring(aLeftParenIndex + 1, aColonIndex).trim();¶			String aVariableString = aStoredToken.substring(aColonIndex + 1, aRightParenIndex).trim();¶			((OMPForSNode) lastChild).setReductionVariable(aVariableString);¶			((OMPForSNode) lastChild).setReductionOperation(anOperationString);¶		}¶	}¶¶	public static void setSharedOrPrivateData(OMPSNode lastChild, String aStoredToken, int aLeftParenIndex,¶			int aRightParenIndex, boolean isShared) {¶//		int aColonIndex = aStoredToken.indexOf(":");¶		if (aLeftParenIndex != -1 && aRightParenIndex != -1) {¶			String aVariableDeclarations = aStoredToken.substring(aLeftParenIndex + 1, aRightParenIndex);¶			String[] aVariables = aVariableDeclarations.split(",");¶			if (isShared) {¶				lastChild.setSharedVariables(aVariables);¶			} else {¶				lastChild.setPrivateVariables(aVariables);¶			}¶		}¶	}¶¶	public static RootOfFileSNode getSNode(String aFileName, String[] aFileLines) {¶		Stack<SNode> anSNodes = new Stack();¶¶		RootOfFileSNode retVal = new ARootOfFileSNode(aFileName);¶		anSNodes.add(retVal);¶		SNode previousHeaderNode = null;¶		for (int i = 0; i < aFileLines.length; i++) {¶			String aFileLine = aFileLines[i].trim();¶			if (!isCodeLine(aFileLine)) {¶				continue;¶			}¶			if (isForNode(aFileLine)) {¶				ForSNode aForSNode = getForSNode(i, aFileLine);¶				aForSNode.setParent(anSNodes.peek());¶//				anSNodes.push(aForSNode);¶				previousHeaderNode = aForSNode;¶				if (aFileLine.endsWith(")")) {¶					continue;¶				}¶			}¶			if (isExternalMethodDeclaration(aFileLine)) {¶				MethodSNode aMethodSNode = getMethodSNode(i, aFileLine, false);¶				aMethodSNode.setParent(anSNodes.peek());¶//				anSNodes.push(aForSNode);¶				previousHeaderNode = aMethodSNode;¶				if (aFileLine.endsWith(")")) {¶					continue;¶				}¶			}¶			if (isMethodDeclaration(aFileLine)) {¶				MethodSNode aMethodSNode = getMethodSNode(i, aFileLine, true);¶				aMethodSNode.setParent(anSNodes.peek());¶//				anSNodes.push(aForSNode);¶				previousHeaderNode = aMethodSNode;¶				if (aFileLine.endsWith(")")) {¶					continue;¶				}¶			}¶			if (isPragmaStart(aFileLine)) {¶				OMPSNode anOMPSNode = getOMPSNode(i, anSNodes.peek(), aFileLine);¶//				anSNodes.push(anOMPSNode);¶				previousHeaderNode = anOMPSNode;¶				continue;¶			}¶			if (isBlockStart(aFileLine)) {¶				SNode aBlockSNode = new AnSNode(i);¶				if (previousHeaderNode != null) {¶					aBlockSNode.setParent(previousHeaderNode);¶				} else {¶					aBlockSNode.setParent(anSNodes.peek());¶				}¶				anSNodes.push(aBlockSNode);¶				previousHeaderNode = null;¶				continue;¶			}¶//			} else ¶			if (isBlockEnd(aFileLine)) {¶				anSNodes.pop();¶				continue;¶			}¶			SNode aNewLeafNode = null;¶			if (isDeclaringAssignment(aFileLine)) {¶				aNewLeafNode = getDeclaringAssignmentSNode(i, aFileLine);¶¶			} else if (isAssignment(aFileLine)) {¶				aNewLeafNode = getAssignmentSNode(i, aFileLine);¶			} else if (isVariableDeclaration(aFileLine)) {¶				aNewLeafNode = getDeclarationSNode(i, aFileLine);¶			} else {¶				List<MethodCall> aCalls = callsIn(i, aFileLine, null); // parent will be assigned below¶				if (aCalls != null && aCalls.size() == 1) {¶					aNewLeafNode = aCalls.get(0);¶				} else {¶					aNewLeafNode = new ATextSNode(i, aFileLine);¶				}¶			}¶//			else {¶//				aNewLeafNode = new ATextSNode(i, aFileLine);¶//			}¶			if (previousHeaderNode != null) {¶				aNewLeafNode.setParent(previousHeaderNode);¶			} else {¶				aNewLeafNode.setParent(anSNodes.peek());¶			}¶¶		}¶¶		return retVal;¶	}¶¶	public static OMPSNode getOMPSNode(int aLineIndex, SNode aParentNode, String aFileLine) {¶		String[] aTokens = aFileLine.split("\\s+");¶		if (aTokens.length <= 2) {¶			return null;¶		}¶		if (!aTokens[1].equals("omp")) {¶			return null;¶		}¶		if (aTokens.length < 3) {¶			return null;¶		}¶		String aFirstToken = aTokens[2];¶		OpenMPKeywordEnum anOpenMPKeyword = stringToOpenMPKeyword.get(aFirstToken);¶//		List<OpenMPPragma> retVal = new ArrayList();¶		OMPSNode lastChild = null;¶		int aStartIndex = 2;¶		OMPSNode aNewNode = null;¶		OMPForSNode aForChild = null;¶		switch (anOpenMPKeyword) {¶		case PARALLEL:¶			aNewNode = new AnOMPParallelSNode(aLineIndex);¶¶			if (aTokens.length > 3 && aTokens[3].equals("for")) {¶				aForChild = new AnOMPForSNode(aLineIndex);¶				aForChild.setParent(aNewNode);¶¶				aStartIndex++;¶			}¶			break;¶		case FOR:¶			aNewNode = new AnOMPForSNode(aLineIndex);¶			;¶			break;¶		case CRITICAL:¶			aNewNode = new AnOMPCriticalSNode(aLineIndex);¶//			retVal.add (lastChild);¶			break;¶		default:¶			aNewNode = new AnOMPSNode(aLineIndex);¶¶		}¶¶		if (lastChild != null) {¶			aNewNode.setParent(lastChild);¶		} else {¶			aNewNode.setParent(aParentNode);¶		}¶		lastChild = aForChild == null ? aNewNode : aForChild;¶¶		for (int i = aStartIndex; i < aTokens.length; i++) {¶			String aStoredToken = aTokens[i].trim();¶			if (aStoredToken.isEmpty()) {¶				continue;¶			}¶			if (aStoredToken.startsWith("reduction") || aStoredToken.startsWith("shared")¶					|| aStoredToken.startsWith("private")) {¶				// combine all tokens until ")" into one for normalization¶				while (!aStoredToken.endsWith(")")) {¶					i++;¶					if (i >= aTokens.length) {¶						break;¶					}¶					String aNewToken = aTokens[i].trim();¶					aStoredToken += aNewToken;¶				}¶				int aLeftParenIndex = aStoredToken.indexOf("(");¶				int aRightParenIndex = aStoredToken.indexOf(")");¶				if (aStoredToken.startsWith("reduction")) {¶					setReductionData((OMPForSNode) lastChild, aStoredToken, aLeftParenIndex, aRightParenIndex);¶				} else if (aStoredToken.startsWith("private")) {¶					setSharedOrPrivateData((OMPSNode) lastChild, aStoredToken, aLeftParenIndex, aRightParenIndex,¶							false);¶¶				} else if (aStoredToken.startsWith("shared")) {¶					setSharedOrPrivateData(lastChild, aStoredToken, aLeftParenIndex, aRightParenIndex, true);¶¶				}¶¶			}¶¶			lastChild.getOpenMPTokens().add(aStoredToken);¶		}¶¶		return lastChild;¶¶	}¶¶	public static boolean hasParallelAncestor(SNode anSNode) {¶		if (anSNode == null) {¶			return false;¶		}¶		if (anSNode instanceof OMPParallelSNode) {¶			return true;¶		}¶		return hasParallelAncestor(anSNode.getParent());¶	}¶¶	public static Boolean isDeclaredShared(OMPSNode anOMPSNode, String anLHS) {¶		if (Arrays.asList(anOMPSNode.getSharedVariables()).contains(anLHS)) {¶			return true;¶		}¶		if (Arrays.asList(anOMPSNode.getPrivateVariables()).contains(anLHS)) {¶			return false;¶		}¶		return null;¶¶	}¶¶	public static boolean isSharedVariable(SNode anSNode, String anLHS) {¶		if (anSNode == null) {¶			return false;¶		}¶		if (anSNode.getLocalVariables().contains(anLHS)) {¶			if (!(anSNode instanceof OMPSNode)) { // no shared and private declarations¶				return !hasParallelAncestor(anSNode); // shared if not inParallel¶			}¶			OMPSNode anOMPSNode = (OMPSNode) anSNode;¶			return (Arrays.asList(anOMPSNode.getSharedVariables()).contains(anLHS)); // private unless declared shared¶		}¶		if (anSNode instanceof OMPSNode) {¶			OMPSNode anOMPSNode = (OMPSNode) anSNode;¶			// the variable is global to this scope, check if it has have been made shared¶			// or private by this scope¶			Boolean isDeclaredShared = isDeclaredShared(anOMPSNode, anLHS);¶			if (isDeclaredShared != null) {¶				return isDeclaredShared;¶			}¶		}¶		// check the parent¶		return isSharedVariable(anSNode.getParent(), anLHS);¶	}¶¶	public static List<SNode> getAllLeafNodes(SNode aTopNode) {¶		List<SNode> retVal = new ArrayList();¶		addLeafNodes(aTopNode, retVal);¶		return retVal;¶	}¶¶	public static void addLeafNodes(SNode aTopNode, List<SNode> retVal) {¶		for (SNode aChild : aTopNode.getChildren()) {¶			if (aChild.isLeaf()) {¶				retVal.add(aChild);¶			} else {¶				addLeafNodes(aChild, retVal);¶			}¶		}¶	}¶¶	public static List<SNode> getNonParallelLeafNodes(SNode aTopNode) {¶		List<SNode> retVal = new ArrayList();¶		addNonParallelLeafNodes(aTopNode, retVal);¶		return retVal;¶	}¶¶	public static void addNonParallelLeafNodes(SNode aTopNode, List<SNode> retVal) {¶		if (aTopNode.isInParallel()) {¶			return;¶		}¶		for (SNode aChild : aTopNode.getChildren()) {¶			if (aChild.isLeaf()) {¶				retVal.add(aChild);¶			} else {¶				addLeafNodes(aChild, retVal);¶			}¶		}¶	}¶	static String callRegex = "([a-zA-Z_$][a-zA-Z_$0-9]*)\\(.*?\\)";¶	static Pattern callPattern = Pattern.compile(callRegex);¶¶	static String identifierRegex = "[a-zA-Z_$][a-zA-Z_$0-9]*";¶	static Pattern identifierPattern = Pattern.compile(identifierRegex);¶	public static List<String> identifiersIn(String aString) {¶		if (aString == null)¶			return null;¶//		Pattern mypattern = Pattern.compile("[a-zA-Z_$][a-zA-Z_$0-9]*");¶//		Matcher mymatcher = mypattern.matcher(aString);¶		Matcher mymatcher = identifierPattern.matcher(aString);¶		List<String> retVal = new ArrayList();¶		while (mymatcher.find()) {¶			String find = mymatcher.group(0);¶			retVal.add(find);¶		}¶		return retVal;¶	}¶	public static List<MethodCall> callsIn(int aLineNumber, String aString, SNode aParent) {¶		if (aString == null)¶			return null;¶//		Pattern mypattern = Pattern.compile("[a-zA-Z_$][a-zA-Z_$0-9]*");¶//		Matcher mymatcher = mypattern.matcher(aString);¶		Matcher mymatcher = callPattern.matcher(aString);¶		List<MethodCall> retVal = new ArrayList();¶		while (mymatcher.find()) {¶			String find = mymatcher.group(0);¶			int aLeftParenIndex = find.indexOf("(");¶			int aRightParenIndex = find.indexOf(")");¶			String aMethodName = find.substring(0, aLeftParenIndex).trim();¶			String aParameters = find.substring(aLeftParenIndex + 1, aRightParenIndex);¶			List<String> aParameterList = new ArrayList();¶			String[] aParameterTokens = aParameters.split(",");¶			for (String aParameter:aParameterTokens) {¶				String aParameterTrimmed = aParameter.trim();¶				if (!aParameterTrimmed.isEmpty())¶				aParameterList.add(aParameterTrimmed);¶			}¶			retVal.add(new AMethodCall(aLineNumber, aMethodName, aParameterList, aParent));¶¶//			aCallStrings.add(find);¶		}¶		return retVal;¶	}¶	static String numberRegex = "(\\d+\\.\\d+)|(\\d+)";¶	static Pattern numberPattern = Pattern.compile(numberRegex);¶	public static List<String> numbersIn(String aString) {¶		if (aString == null)¶			return null;¶//		String regex = "(\\d+\\.\\d+)|(\\d+)";¶//¶//		Matcher m = Pattern.compile(regex).matcher(aString);¶		Matcher m =numberPattern.matcher(aString);¶¶¶		List<String> retVal = new ArrayList();¶¶		while (m.find()) {¶			retVal.add(m.group());¶		}¶		return retVal;¶	}¶¶	public static String subscriptIn(String aString) {¶		if (aString == null)¶			return null;¶		return StringUtils.substringBetween(aString, "[", "]");¶	}¶	public static String[] subscriptsIn(String aString) {¶		if (aString == null)¶			return null;¶		return StringUtils.substringsBetween(aString, "[", "]");¶	}¶	static  String operatorRegex = "([+-/*///^])|([/(/)])";¶	static Pattern operatorPattern = Pattern.compile(operatorRegex);¶¶	public static List<String> operatorsIn(String aString) {¶		if (aString == null)¶			return null;¶//		String operatorRegex = "([+-/*///^])|([/(/)])";¶//¶//		Matcher m = Pattern.compile(operatorRegex).matcher(aString);¶		¶		Matcher m = operatorPattern.matcher(aString);¶¶¶		List<String> retVal = new ArrayList();¶¶		while (m.find()) {¶			retVal.add(m.group());¶		}¶		return retVal;¶	}¶	¶	public static int numberOfNestingFors (SNode anSNode) {¶		if (anSNode == null) {¶			return 0;¶		}¶		int retVal = numberOfNestingFors (anSNode.getParent()) ;¶¶		if (anSNode instanceof ForSNode) {¶			retVal++;¶		} else if (anSNode instanceof MethodSNode) {¶			List<MethodCall> aMethodCalls = ((MethodSNode) anSNode).getCalls();¶			int aMaxNestingLevel = 0;¶			for (MethodCall aMethodCall:aMethodCalls) {¶				MethodSNode aCallerMethodSNode = getDeclarationOfCalledMethod(anSNode, aMethodCall);¶				int aCallerNumberOfNestingFors = numberOfNestingFors(aCallerMethodSNode);¶				aMaxNestingLevel = Math.max(aCallerNumberOfNestingFors, aMaxNestingLevel);				¶			}¶			return retVal + aMaxNestingLevel;¶		}¶		return retVal;¶	}¶	public static boolean hasOperator (SNode anSNode, String anOperator) {¶		boolean retVal = false;¶		if (anSNode instanceof AssignmentSNode) {¶			AssignmentSNode anAssignmentSNode = (AssignmentSNode) anSNode;¶			 retVal = (anAssignmentSNode.getLhsOperators().contains(anOperator) || ¶					anAssignmentSNode.getRhsOperators().contains(anOperator)) ;¶			if (retVal) {¶				return retVal;¶			} else {¶				List<MethodCall> aMethodCalls = anAssignmentSNode.getRhsCalls();¶				for (MethodCall aMethodCall:aMethodCalls) {¶					MethodSNode aMethodSNode = getDeclarationOfCalledMethod(anSNode, aMethodCall);¶					retVal = hasOperator(aMethodSNode, anOperator);¶					if (retVal) {¶						return retVal;¶					}¶					¶				}¶				return false;¶			}¶			¶		}¶		for (SNode aChild:anSNode.getChildren()) {¶			retVal = hasOperator(aChild, anOperator);¶			if (retVal) {¶				return retVal;¶			}¶		}¶		return false;¶	}¶	public static boolean hasMethodCall (SNode anSNode, String anOperator) {¶		boolean retVal = false;¶		if (anSNode instanceof AssignmentSNode) {¶			AssignmentSNode anAssignmentSNode = (AssignmentSNode) anSNode;¶			 retVal = (anAssignmentSNode.getLhsOperators().contains(anOperator) || ¶					anAssignmentSNode.getRhsOperators().contains(anOperator)) ;¶			if (retVal) {¶				return retVal;¶			} else {¶				List<MethodCall> aMethodCalls = anAssignmentSNode.getRhsCalls();¶				for (MethodCall aMethodCall:aMethodCalls) {¶					MethodSNode aMethodSNode = getDeclarationOfCalledMethod(anSNode, aMethodCall);¶					retVal = hasOperator(aMethodSNode, anOperator);¶					if (retVal) {¶						return retVal;¶					}¶					¶				}¶				return false;¶			}¶			¶		}¶		for (SNode aChild:anSNode.getChildren()) {¶			retVal = hasOperator(aChild, anOperator);¶			if (retVal) {¶				return retVal;¶			}¶		}¶		return false;¶	}¶	public static boolean dependsOn (AssignmentSNode anAssignmentSNode, String aVariable, String aCallIdentifier) {¶		// This assignment does not change aVariable¶		if (!aVariable.equals(anAssignmentSNode.getLhsVariable())) {¶			return false;¶		}¶		return dependsOn(anAssignmentSNode.getExpressionSNode(), aCallIdentifier);¶//		List<String> aCallIdentifiers = anAssignmentSNode.getRhsCallIdentifiers();¶//		boolean retVal = false;¶//		if (aCallIdentifiers != null && aCallIdentifiers.contains(aCallIdentifier)) {¶//			return true; // this assignment has aCallIdentifier in the rhs¶//		}¶//		// check if some referenced rhs variable depends on aCallIdentifier¶//		List<String> aReferencedVariableIdentifiers = anAssignmentSNode.getRhsVariableIdentifiers();¶//		SNode anAssignmentParent = anAssignmentSNode.getParent();¶//		if (anAssignmentParent == null) { // should never be trye¶//			return false;¶//		}¶//		int aLineNumber = anAssignmentSNode.getLineNumber();¶//		for (String aReferencedVariableIdentifier:aReferencedVariableIdentifiers ) {¶//			if (dependsOn (anAssignmentParent, aLineNumber, aReferencedVariableIdentifier, aCallIdentifier)) {¶//				return true;¶//			}¶//		}¶//		return false;¶	}¶	public static boolean dependsOn (ExpressionSNode anExpressionSNode, String aCallIdentifier) {¶		// This assignment does not change aVariable¶		¶		List<String> aCallIdentifiers = anExpressionSNode.getRhsCallIdentifiers();¶		boolean retVal = false;¶		if (aCallIdentifiers != null && aCallIdentifiers.contains(aCallIdentifier)) {¶			return true; // this assignment has aCallIdentifier in the rhs¶		}¶		// check if some referenced rhs variable depends on aCallIdentifier¶		List<String> aReferencedVariableIdentifiers = anExpressionSNode.getRhsVariableIdentifiers();¶		SNode anAssignmentParent = anExpressionSNode.getParent().getParent();¶		if (anAssignmentParent == null) { // should never be trye¶			return false;¶		}¶		int aLineNumber = anExpressionSNode.getLineNumber();¶		for (String aReferencedVariableIdentifier:aReferencedVariableIdentifiers ) {¶			if (dependsOn (anAssignmentParent, aLineNumber, aReferencedVariableIdentifier, aCallIdentifier)) {¶				return true;¶			}¶		}¶		return false;¶	}¶	public static List<AssignmentSNode> assignmentsToShared(SNode anSNode) {¶		List<AssignmentSNode> retVal =  new ArrayList();¶		fillAssignmentsToShared(anSNode, retVal);¶		return retVal;¶		¶	}¶    public static void fillAssignmentsToShared(SNode anSNode, List<AssignmentSNode> retVal) {¶    	if (anSNode instanceof AssignmentSNode) {¶			AssignmentSNode anAssignmentSNode = (AssignmentSNode) anSNode;¶			String anLHS = anAssignmentSNode.getLhsVariable();¶			if (isSharedVariable(anSNode, anLHS)) {¶				retVal.add(anAssignmentSNode);¶				return;¶			}¶		}¶    	for (SNode aChild:anSNode.getChildren()) {¶    		fillAssignmentsToShared(aChild, retVal);¶    	}¶		¶	}¶	public static boolean dependsOn (SNode anSNode, int aVariableLineNumber, String aVariable, String aCallIdentifier) {¶		List<SNode> aListSNodes = anSNode.getChildren();¶		boolean retVal = false;¶		/*¶		 * Should probably ignore line number as it assumes straight line code¶		 */¶		for (int i = aVariableLineNumber; i >= 0; i--) {¶			SNode anSNodeChild = aListSNodes.get(i);¶			if (anSNodeChild instanceof AssignmentSNode) {¶				// does this statement in anSNode directly invoke aCallIdentifier ¶				if (dependsOn((AssignmentSNode) anSNodeChild, aVariable, aCallIdentifier))¶					return true;¶			} else if (!anSNode.isLeaf()) {¶					// child is overriding the variable so forget checking its assignment statements¶					if (anSNodeChild.getLocalVariables().contains(aVariable)) {¶						continue;¶					}¶					// some subblock of anSNode that has access to aVariable changes variable¶¶					if (dependsOn(anSNodeChild, anSNodeChild.getChildren().size() - 1, aVariable, aCallIdentifier)) {¶						return true;¶					}¶			}¶			¶		}¶		// none of the statements in anSNode or its descendents  have the required call¶		// is the variable a  method parameter ¶		if (anSNode instanceof MethodSNode) {¶			MethodSNode aMethodSNode = (MethodSNode) anSNode;¶			¶			int aParameterNumber = aMethodSNode.getLocalVariables().indexOf(aVariable);¶			if (aParameterNumber != -1) {¶				List <MethodCall> aCalls = aMethodSNode.getCalls();¶				for (MethodCall aCall:aCalls) {¶					MethodSNode aCallerSNode = getDeclarationOfCalledMethod(aMethodSNode, aCall);¶					boolean aCallerDepends = dependsOn(aMethodSNode, aCallerSNode.getLineNumber(), aVariable, aCallIdentifier);¶				    if (aCallerDepends) {¶				    	return true;¶				    }¶				}¶				return false;¶				// need to find all callers of method and see if any of the aliases for the variable in these¶				// calls depend on aCallIndentifier¶			}			¶			¶		} else if (anSNode.getLocalVariables().contains(aVariable)) {¶			// before going to the parent node, let us see if aVariable is declared here as a non  parameter ¶¶			return false; // no point going to parent¶		}¶		// not a local variable (parameter or declarated variable)¶		SNode anSNodeParent = anSNode.getParent() ;¶		if (anSNodeParent == null)  {¶			return false;¶		}¶		int anSNodeLineNumber = anSNodeParent.getChildren().indexOf(anSNode);¶		return dependsOn(anSNodeParent, anSNodeLineNumber, aVariable, aCallIdentifier);¶		¶	}¶	public static RootOfFileSNode getRootOfFileNode(SNode aCurrentSNode ) {¶		if (aCurrentSNode instanceof RootOfFileSNode) {¶			return (RootOfFileSNode) aCurrentSNode;¶		}¶		SNode aParentSNode = aCurrentSNode.getParent() ;¶		¶		if (aParentSNode == null) {¶			return null;¶		}¶		¶		return getRootOfFileNode(aParentSNode);¶		¶	}¶	public static boolean match (MethodSNode aMethodSNode, MethodCall aMethodCall) {¶		return aMethodSNode.getMethodName().equals(aMethodCall.getMethodName()) ¶				&& aMethodSNode.getLocalVariables().size() == aMethodCall.getMethodActuals().size();¶	}¶	¶	public static MethodSNode getDeclarationOfCalledMethod(SNode aCurrentSNode, MethodCall aMethodCall ) {¶		SNode aRootNode = getRootOfFileNode(aCurrentSNode);¶		for (SNode aChild:aRootNode.getChildren()) {¶			if (aChild instanceof MethodSNode) {¶				MethodSNode aMethodSNode = (MethodSNode) aChild;¶				if (match (aMethodSNode, aMethodCall)) {¶					return aMethodSNode;¶				}¶			}¶		}¶		return null; // this should never happen;¶	}¶	¶	public static RootOfProgramSNode getRootOfProgramSNode(String aSource) {¶		RootOfProgramSNode retVal = new ARootOfProgramSNode();¶		Map<String, StringBuffer> aFileNameToContents = ABasicTextManager.extractFileContents(aSource);¶		for (String aFileName:aFileNameToContents.keySet()) {¶			StringBuffer aFileContents = aFileNameToContents.get(aFileName);¶//			List<OpenMPPragma> anOpenMPPragmas = OpenMPUtils.getOpemMPPragmas(aFileContents);¶			RootOfFileSNode anSNode = OMPSNodeUtils.getSNode(aFileName, aFileContents);¶			retVal.getFileNameToSNode().put(aFileName, anSNode);¶			anSNode.setParent(retVal);¶//			System.out.println("file name:" + aFileName);¶//			System.out.println("pragmas:" + anSNode);¶		}¶		processExternalMethodSNodes(retVal);¶		return retVal;¶	}¶	public static void processExternalMethodSNodes (RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode) {¶		for (SNode anSNode:aRootOfFileSNode.getChildren()) {¶			if (anSNode instanceof ExternalMethodSNode) {¶				processExternalMethodSNode(aRootOfProgramSNode, aRootOfFileSNode, (ExternalMethodSNode) anSNode);¶			}¶		}¶	}¶	public static void processExternalMethodSNode (RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode, ExternalMethodSNode anExternalMethodSNode) {¶		MethodSNode aMethodSNode = aRootOfProgramSNode.getExternalToInternalMethod().get(anExternalMethodSNode.toString());¶		if (aMethodSNode == null) {¶			aMethodSNode = findMethodSNode(aRootOfProgramSNode, aRootOfFileSNode, anExternalMethodSNode);¶			if (aMethodSNode != null) {¶				aRootOfProgramSNode.getExternalToInternalMethod().put(anExternalMethodSNode.toString(),aMethodSNode );¶			}¶		}¶		if (aMethodSNode != null) {¶			anExternalMethodSNode.setActualMethodSNode(aMethodSNode);¶			aMethodSNode.getCalls().addAll(anExternalMethodSNode.getLocalCalls());¶		}¶	}¶	public static MethodSNode findMethodSNode (RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode, ExternalMethodSNode anExternalMethodSNode) {¶//		MethodSNode foundMethodSNode = null;¶		for (String aFileName:aRootOfProgramSNode.getFileNameToSNode().keySet()) {¶			if (aFileName.equals(aRootOfFileSNode.getFileName()))¶				continue;¶			¶			RootOfFileSNode aSearchedRootOfFileSNode = aRootOfProgramSNode.getFileNameToSNode().get(aFileName);¶			 for (SNode anSNode:aSearchedRootOfFileSNode.getChildren()) {¶				if (anSNode instanceof MethodSNode && !(anSNode instanceof ExternalMethodSNode)) {¶					if (anSNode.toString().equals(anExternalMethodSNode.toString())) {¶						return (MethodSNode) anSNode;¶						¶					}¶//					processExternalMethodSNode(aRootOfProgramSNode, aRootOfFileSNode, (ExternalMethodSNode) anSNode);¶				}¶			}¶		}¶		return null;¶	}¶	public static void processExternalMethodSNodes (RootOfProgramSNode aRootOfProgramSNode) {¶		for (String aFileName:aRootOfProgramSNode.getFileNameToSNode().keySet()) {¶			RootOfFileSNode aRootOfFileSNode = aRootOfProgramSNode.getFileNameToSNode().get(aFileName);¶			processExternalMethodSNodes(aRootOfProgramSNode, aRootOfFileSNode);¶			aRootOfFileSNode.getOmp_get_num_threads_SNode().¶				setActualMethodSNode(aRootOfProgramSNode.getOmp_get_num_threads_SNode());¶			aRootOfFileSNode.getOmp_get_thread_num_SNode().¶				setActualMethodSNode(aRootOfProgramSNode.getOmp_get_thread_num_SNode());¶			aRootOfFileSNode.getOmp_get_wtime_SNode().¶			setActualMethodSNode(aRootOfProgramSNode.getOmp_get_wtime_SNode());¶		}¶¶	}¶	¶¶//	public static void main(String[] args) {¶//		List<MethodCall> aTokens = callsIn("foo(bar, hgf)/foo2()*foo3(b, a c,)");¶//		System.out.println(aTokens);¶//		¶//		¶////		List<String> aTokens = identifiersIn("a[i] + b*2/3");¶////		System.out.println(aTokens);¶////		aTokens = numbersIn("a[i] + b*2/3");¶////		System.out.println(aTokens);¶////		aTokens = operatorsIn("a[i] + b*2/3");¶////		System.out.println(aTokens);¶////¶////		System.out.println(StringUtils.substringBetween("a", "[", "]"));¶//	}¶¶}¶")]]]></diff>
  </Command>
  <Command __id="182053" _type="EclipseCommand" commandID="org.eclipse.jdt.ui.edit.text.java.open.editor" date="Mon Dec 30 08:25:11 EST 2019" starttimestamp="1576666505112" timestamp="1045806674" />
  <Command __id="182054" _type="DiffBasedFileOpenCommand" date="Mon Dec 30 08:25:32 EST 2019" docASTNodeCount="1" docActiveCodeLength="453" docExpressionCount="0" docLength="453" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="1045827813">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\my_sum_sequential.cpp]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"#include <iostream>¶#include <omp.h>¶¶using namespace std;¶void printSumWithTimes(int sum, int start, int end);¶void printNumThreads();¶void recordThreadIndex(int index);¶void sum_sequential(double* array, int size) {¶¶	cout << "sum_sequential\n";¶¶	double start = omp_get_wtime();¶¶	double sum = 0;¶¶	for (int i = 0; i < size; i++) {¶		sum += array[i];¶		recordThreadIndex(i);¶	}¶¶	double end = omp_get_wtime();¶¶	printSumWithTimes(sum, start, end);¶}¶")]]]></diff>
  </Command>
  <Command __id="182055" _type="SelectTextCommand" caretOffset="280" date="Mon Dec 30 08:25:33 EST 2019" end="280" start="265" starttimestamp="1576666505112" timestamp="1045828022" />
  <Command __id="182057" _type="MoveCaretCommand" caretOffset="1165" date="Mon Dec 30 08:25:46 EST 2019" docOffset="1165" starttimestamp="1576666505112" timestamp="1045841709" />
  <Command __id="182071" _type="RunCommand" date="Mon Dec 30 08:26:07 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="1045862115" type="Run" />
  <Command __id="182072" _type="RunCommand" date="Mon Dec 30 08:26:07 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="1045862150" type="Run" />
  <Command __id="182073" _type="RunCommand" date="Mon Dec 30 08:26:07 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="1045862152" type="Run" />
  <Command __id="182074" _type="EHExceptionCommand" date="Mon Dec 30 08:26:07 EST 2019" starttimestamp="1576666505112" timestamp="1045862154" type="Exception">
    <outputString><![CDATA[I***(TestCaseResult) ### SequentialSumTestCase: 1.0
I***(BasicProcessRunner) Running command:D:\dewan_backup\C\MyOpenMPTraining\Debug\MyOpenMPTraining.exe
I***(BasicProcessRunner) Running in folder: D:\dewan_backup\C\MyOpenMPTraining\Debug
I***(BasicProcessRunner)  Process started: D:\dewan_backup\C\MyOpenMPTraining\Debug\MyOpenMPTraining.exe folder: D:\dewan_backup\C\MyOpenMPTraining\Debug entry point: null class path: D:\dewan_backup\Java\PLTeaching\PL_Java\bin;D:\dewan_backup\Java\lib\oeall22.jar;C:\Users\dewan\.p2\pool\plugins\org.junit_4.12.0.v201504281640\junit.jar;C:\Users\dewan\.p2\pool\plugins\org.hamcrest.core_1.3.0.v20180420-1519.jar;D:\dewan_backup\Java\GraderBasics\lib\commons-configuration-1.9.jar;D:\dewan_backup\Java\GraderBasics\lib\commons-lang-2.6.jar;D:\dewan_backup\Java\GraderBasics\lib\commons-logging-1.1.1.jar;G:\My Drive\Java\lib\Herrmes\lib\weka3_6.jar;D:\dewan_backup\Java\GraderBasics\target\classes;D:\dewan_backup\Java\DemoCourseLocalBasicChecks\bin
I***(ARunnerInputStreamProcessor) Provided Input:
]]></outputString>
  </Command>
  <Command __id="182075" _type="EHExceptionCommand" date="Mon Dec 30 08:26:07 EST 2019" starttimestamp="1576666505112" timestamp="1045862213" type="Exception">
    <outputString><![CDATA[I***(BasicRunningProject) 1577712367274:Received output from main: sum_sequential
I***(BasicRunningProject) 1577712367275:Processing line from main: sum_sequential
I***(BasicRunningProject) 1577712367275:Received output from main: Sum: 499500
I***(BasicRunningProject) 1577712367275:Processing line from main: Sum: 499500
I***(BasicRunningProject) 1577712367276:Received output from main: Took: 0
I***(BasicRunningProject) 1577712367276:Processing line from main: Took: 0
I***(BasicRunningProject) 1577712367276:Received output from main: thread:0 lastIndex:999
I***(BasicRunningProject) 1577712367276:Processing line from main: thread:0 lastIndex:999
I***(BasicRunningProject) 1577712367276:Received output from main: _____________________________
I***(BasicRunningProject) 1577712367276:Processing line from main: _____________________________
I***(BasicRunningProject) 1577712367277:Received output from main: sum_parallel_for_reduction
I***(BasicRunningProject) 1577712367277:Processing line from main: sum_parallel_for_reduction
I***(BasicRunningProject) 1577712367277:Received output from main: Sum: 499500
I***(BasicRunningProject) 1577712367277:Processing line from main: Sum: 499500
I***(BasicRunningProject) 1577712367278:Received output from main: Took: 0
I***(BasicRunningProject) 1577712367278:Processing line from main: Took: 0
I***(BasicRunningProject) 1577712367278:Received output from main: thread:0 lastIndex:124
I***(BasicRunningProject) 1577712367278:Processing line from main: thread:0 lastIndex:124
I***(BasicRunningProject) 1577712367278:Received output from main: thread:1 lastIndex:249
I***(BasicRunningProject) 1577712367278:Processing line from main: thread:1 lastIndex:249
I***(BasicRunningProject) 1577712367278:Received output from main: thread:2 lastIndex:374
I***(BasicRunningProject) 1577712367278:Processing line from main: thread:2 lastIndex:374
I***(BasicRunningProject) 1577712367278:Received output from main: thread:3 lastIndex:499
I***(BasicRunningProject) 1577712367278:Processing line from main: thread:3 lastIndex:499
I***(BasicRunningProject) 1577712367279:Received output from main: thread:4 lastIndex:624
I***(BasicRunningProject) 1577712367279:Processing line from main: thread:4 lastIndex:624
I***(BasicRunningProject) 1577712367279:Received output from main: thread:5 lastIndex:749
I***(BasicRunningProject) 1577712367279:Processing line from main: thread:5 lastIndex:749
I***(BasicRunningProject) 1577712367279:Received output from main: thread:6 lastIndex:874
I***(BasicProcessRunner)  Process finished; folder: D:\dewan_backup\C\MyOpenMPTraining\Debug entry point: null class path: D:\dewan_backup\Java\PLTeaching\PL_Java\bin;D:\dewan_backup\Java\lib\oeall22.jar;C:\Users\dewan\.p2\pool\plugins\org.junit_4.12.0.v201504281640\junit.jar;C:\Users\dewan\.p2\pool\plugins\org.hamcrest.core_1.3.0.v20180420-1519.jar;D:\dewan_backup\Java\GraderBasics\lib\commons-configuration-1.9.jar;D:\dewan_backup\Java\GraderBasics\lib\commons-lang-2.6.jar;D:\dewan_backup\Java\GraderBasics\lib\commons-logging-1.1.1.jar;G:\My Drive\Java\lib\Herrmes\lib\weka3_6.jar;D:\dewan_backup\Java\GraderBasics\target\classes;D:\dewan_backup\Java\DemoCourseLocalBasicChecks\bin
I***(BasicRunningProject) 1577712367279:Processing line from main: thread:6 lastIndex:874
I***(BasicRunningProject) 1577712367279:Received output from main: thread:7 lastIndex:999
I***(BasicRunningProject) 1577712367280:Processing line from main: thread:7 lastIndex:999
I***(BasicRunningProject) 1577712367280:Received output from main: _____________________________
I***(BasicRunningProject) 1577712367280:Processing line from main: _____________________________
I***(BasicRunningProject) 1577712367280:Received output from main: sum_parallel_for_local_var
I***(BasicRunningProject) 1577712367280:Processing line from main: sum_parallel_for_local_var
I***(BasicRunningProject) 1577712367280:Received output from main: Sum: 499500
I***(BasicRunningProject) 1577712367280:Processing line from main: Sum: 499500
I***(BasicRunningProject) 1577712367280:Received output from main: Took: 0
I***(BasicRunningProject) 1577712367280:Processing line from main: Took: 0
I***(BasicRunningProject) 1577712367280:Received output from main: thread:0 lastIndex:124
I***(BasicRunningProject) 1577712367281:Processing line from main: thread:0 lastIndex:124
I***(BasicRunningProject) 1577712367281:Received output from main: thread:1 lastIndex:249
I***(BasicRunningProject) 1577712367281:Processing line from main: thread:1 lastIndex:249
I***(BasicRunningProject) 1577712367281:Received output from main: thread:2 lastIndex:374
I***(BasicRunningProject) 1577712367281:Processing line from main: thread:2 lastIndex:374
I***(BasicRunningProject) 1577712367281:Received output from main: thread:3 lastIndex:499
I***(BasicRunningProject) 1577712367281:Processing line from main: thread:3 lastIndex:499
I***(BasicRunningProject) 1577712367281:Received output from main: thread:4 lastIndex:624
I***(BasicRunningProject) 1577712367281:Processing line from main: thread:4 lastIndex:624
I***(BasicRunningProject) 1577712367282:Received output from main: thread:5 lastIndex:749
I***(BasicRunningProject) 1577712367282:Processing line from main: thread:5 lastIndex:749
I***(BasicRunningProject) 1577712367282:Received output from main: thread:6 lastIndex:874
I***(BasicRunningProject) 1577712367282:Processing line from main: thread:6 lastIndex:874
I***(BasicRunningProject) 1577712367282:Received output from main: thread:7 lastIndex:999
I***(BasicRunningProject) 1577712367282:Processing line from main: thread:7 lastIndex:999
I***(BasicRunningProject) 1577712367282:Received output from main: _____________________________
I***(BasicRunningProject) 1577712367282:Processing line from main: _____________________________
I***(BasicRunningProject) 1577712367283:Received output from main: sum_parallel
I***(BasicRunningProject) 1577712367283:Processing line from main: sum_parallel
I***(BasicRunningProject) 1577712367283:Received output from main: Sum: 499500
I***(BasicRunningProject) 1577712367283:Processing line from main: Sum: 499500
I***(BasicRunningProject) 1577712367283:Received output from main: Took: 0
I***(BasicRunningProject) 1577712367283:Processing line from main: Took: 0
I***(BasicRunningProject) 1577712367283:Received output from main: _____________________________
I***(BasicRunningProject) 1577712367283:Processing line from main: _____________________________
I***(BasicRunningProject) Thread[AWT-EventQueue-0,6,main] sleeping for ms:2000 waiting for pending output from threads 
]]></outputString>
  </Command>
  <DocumentChange __id="184470" _type="Insert" date="Mon Dec 30 10:04:12 EST 2019" docASTNodeCount="403" docActiveCodeLength="2907" docExpressionCount="311" docLength="5658" length="1" offset="3010" starttimestamp="1576666505112" timestamp="1051747811">
    <text><![CDATA[t]]></text>
  </DocumentChange>
  <DocumentChange __id="184472" _type="Insert" date="Mon Dec 30 10:04:13 EST 2019" docASTNodeCount="403" docActiveCodeLength="2908" docExpressionCount="311" docLength="5659" length="1" offset="3011" starttimestamp="1576666505112" timestamp="1051748079">
    <text><![CDATA[i]]></text>
  </DocumentChange>
  <DocumentChange __id="184475" _type="Replace" date="Mon Dec 30 10:04:13 EST 2019" docASTNodeCount="406" docActiveCodeLength="2928" docExpressionCount="314" docLength="5679" endLine="58" insertionLength="44" int_docASTNodeCount="403" int_docActiveCodeLength="2884" int_docExpressionCount="311" int_docLength="5635" length="24" offset="2988" startLine="58" starttimestamp="1576666505112" timestamp="1051748777">
    <deletedText><![CDATA[assignmentsToSharedCriti]]></deletedText>
    <insertedText><![CDATA[assignmentsToParallelSharedCritical(anSNode)]]></insertedText>
  </DocumentChange>
  <DocumentChange __id="184480" _type="Delete" date="Mon Dec 30 10:04:17 EST 2019" docASTNodeCount="405" docActiveCodeLength="2927" docExpressionCount="313" docLength="5678" endLine="58" length="1" offset="3031" startLine="58" starttimestamp="1576666505112" timestamp="1051752472">
    <text><![CDATA[)]]></text>
  </DocumentChange>
  <DocumentChange __id="184482" _type="Delete" date="Mon Dec 30 10:04:17 EST 2019" docASTNodeCount="405" docActiveCodeLength="2926" docExpressionCount="313" docLength="5677" endLine="58" length="1" offset="3030" startLine="58" starttimestamp="1576666505112" timestamp="1051752649">
    <text><![CDATA[e]]></text>
  </DocumentChange>
  <DocumentChange __id="184484" _type="Delete" date="Mon Dec 30 10:04:17 EST 2019" docASTNodeCount="405" docActiveCodeLength="2925" docExpressionCount="313" docLength="5676" endLine="58" length="1" offset="3029" startLine="58" starttimestamp="1576666505112" timestamp="1051752836">
    <text><![CDATA[d]]></text>
  </DocumentChange>
  <DocumentChange __id="184486" _type="Delete" date="Mon Dec 30 10:04:18 EST 2019" docASTNodeCount="405" docActiveCodeLength="2924" docExpressionCount="313" docLength="5675" endLine="58" length="1" offset="3028" startLine="58" starttimestamp="1576666505112" timestamp="1051753012">
    <text><![CDATA[o]]></text>
  </DocumentChange>
  <DocumentChange __id="184488" _type="Delete" date="Mon Dec 30 10:04:18 EST 2019" docASTNodeCount="405" docActiveCodeLength="2923" docExpressionCount="313" docLength="5674" endLine="58" length="1" offset="3027" startLine="58" starttimestamp="1576666505112" timestamp="1051753189">
    <text><![CDATA[N]]></text>
  </DocumentChange>
  <DocumentChange __id="184490" _type="Delete" date="Mon Dec 30 10:04:18 EST 2019" docASTNodeCount="405" docActiveCodeLength="2922" docExpressionCount="313" docLength="5673" endLine="58" length="1" offset="3026" startLine="58" starttimestamp="1576666505112" timestamp="1051753371">
    <text><![CDATA[S]]></text>
  </DocumentChange>
  <DocumentChange __id="184492" _type="Delete" date="Mon Dec 30 10:04:18 EST 2019" docASTNodeCount="405" docActiveCodeLength="2921" docExpressionCount="313" docLength="5672" endLine="58" length="1" offset="3025" startLine="58" starttimestamp="1576666505112" timestamp="1051753548">
    <text><![CDATA[n]]></text>
  </DocumentChange>
  <DocumentChange __id="184494" _type="Delete" date="Mon Dec 30 10:04:18 EST 2019" docASTNodeCount="404" docActiveCodeLength="2920" docExpressionCount="312" docLength="5671" endLine="58" length="1" offset="3024" startLine="58" starttimestamp="1576666505112" timestamp="1051753722">
    <text><![CDATA[a]]></text>
  </DocumentChange>
  <DocumentChange __id="184496" _type="Delete" date="Mon Dec 30 10:04:19 EST 2019" docASTNodeCount="403" docActiveCodeLength="2919" docExpressionCount="311" docLength="5670" endLine="58" length="1" offset="3023" startLine="58" starttimestamp="1576666505112" timestamp="1051753939">
    <text><![CDATA[(]]></text>
  </DocumentChange>
  <Command __id="184526" _type="DiffBasedFileOpenCommand" date="Mon Dec 30 10:04:51 EST 2019" docASTNodeCount="3984" docActiveCodeLength="28378" docExpressionCount="2515" docLength="32564" projectName="GraderBasics" starttimestamp="1576666505112" timestamp="1051786641">
    <filePath><![CDATA[D:\dewan_backup\Java\GraderBasics\src\gradingTools\shared\testcases\openmp\scannedTree\OMPSNodeUtils.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package gradingTools.shared.testcases.openmp.scannedTree;¶¶import java.util.ArrayList;¶import java.util.Arrays;¶import java.util.HashMap;¶import java.util.List;¶import java.util.Map;¶import java.util.Stack;¶import java.util.regex.Matcher;¶import java.util.regex.Pattern;¶¶import org.apache.commons.lang.StringUtils;¶¶import grader.basics.project.source.ABasicTextManager;¶import gradingTools.shared.testcases.openmp.OpenMPKeywordEnum;¶import gradingTools.shared.testcases.openmp.OpenMPParallelPragma;¶import gradingTools.shared.testcases.openmp.OpenMPUtils;¶import gradingTools.shared.testcases.openmp.scannedTree.ADeclarationSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.ADeclaringAssignmentSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.AForSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.ATextSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.AnAssignmentSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.AnOMPCriticalSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.AnOMPForSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.AnOMPParallelSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.AnOMPSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.AnSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.AssignmentSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.DeclarationSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.DeclaringAssignmentSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.ForSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.OMPForSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.OMPSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.SNode;¶¶public class OMPSNodeUtils extends OpenMPUtils {¶¶	public static RootOfFileSNode getSNode(String aFileName, StringBuffer aFileBuffer) {¶		String[] aFileLines = aFileBuffer.toString().split("\n");¶		return getSNode(aFileName, aFileLines);¶	}¶¶	public static AssignmentSNode getAssignmentSNode(int aLineNumber, String aString) {¶		if (aString == null) {¶			return null;¶		}¶		String[] aTokens = aString.split("=");¶		if (aTokens.length == 1) {¶			return new AnAssignmentSNode(aLineNumber, aTokens[0], null);¶		} else {¶		return new AnAssignmentSNode(aLineNumber, aTokens[0], aTokens[1]);¶		}¶	}¶¶	public static DeclarationSNode getDeclarationSNode(int aLineNumber, String aString) {¶		String[] aTokens = aString.split(" ");¶		return new ADeclarationSNode(aLineNumber, aTokens[0], aTokens[1]);¶	}¶¶	public static DeclaringAssignmentSNode getDeclaringAssignmentSNode(int aLineNumber, String aString) {¶		String[] anLHSAndRHS = aString.split("=");¶		String[] aTypeAndVariable = anLHSAndRHS[0].split(" ");¶		return new ADeclaringAssignmentSNode(aLineNumber, aTypeAndVariable[0], aTypeAndVariable[1], anLHSAndRHS[1]);¶	}¶¶	public static boolean isDeclaringAssignment(String aFileLine) {¶		return startsWithTypeName(aFileLine) && aFileLine.contains("=");¶	}¶	public static boolean isMethodDeclaration(String aFileLine) {¶		return startsWithTypeName(aFileLine) && ¶				aFileLine.contains("(") &&¶				!aFileLine.contains("=");¶	}¶	public static boolean isExternalMethodDeclaration(String aFileLine) {¶		return isMethodDeclaration(aFileLine) && aFileLine.endsWith(";");¶	}¶¶¶	public static boolean isVariableDeclaration(String aFileLine) {¶¶		return startsWithTypeName(aFileLine) && !aFileLine.contains("(");¶	}¶¶	public static boolean isAssignment(String aFileLine) {¶		return aFileLine.contains("=");¶	}¶¶	public static boolean isForNode(String aFileLine) {¶		return aFileLine.startsWith("for");¶	}¶¶	public static ForSNode getForSNode(int aLineNumber, String aFileLine) {¶¶		int aLeftParenIndex = aFileLine.indexOf("(");¶		int aRightParenIndex = aFileLine.indexOf(")");¶		if (aLeftParenIndex < 0 || aRightParenIndex < 0) {¶			return null;¶		}¶		String aHeaderString = aFileLine.substring(aLeftParenIndex + 1, aRightParenIndex);¶		String[] aForComponents = aHeaderString.split(";");¶		AssignmentSNode anAssignmentSNode = null;¶		String aForInitializaton = aForComponents[0];¶		if (!aForInitializaton.isEmpty() && aForInitializaton.contains("=")) {¶			if (isDeclaringAssignment(aForInitializaton)) {¶				anAssignmentSNode = getDeclaringAssignmentSNode(aLineNumber, aForInitializaton);¶			} else {¶				anAssignmentSNode = getAssignmentSNode(aLineNumber, aForInitializaton);¶			}¶¶		}		¶		return new AForSNode(aLineNumber, anAssignmentSNode, aForComponents[1], getAssignmentSNode(aLineNumber, aForComponents[2]));¶	}¶	static String[] emptyArray = {};¶	public static MethodSNode getMethodSNode(int aLineNumber, String aFileLine, boolean isInternal) {¶¶		int aLeftParenIndex = aFileLine.indexOf("(");¶		int aRightParenIndex = aFileLine.indexOf(")");¶		if (aLeftParenIndex < 0 || aRightParenIndex < 0) {¶			return null;¶		}¶		String aMethodNameAndType = aFileLine.substring(0, aLeftParenIndex);¶		String[] aMethodNameAndTypeTokens = aMethodNameAndType.split("\\s+"); ¶		¶		String aMethodParameters = aFileLine.substring(aLeftParenIndex +1 , aRightParenIndex);¶		String[] aMethodParameterTokens = aMethodParameters.isEmpty()?emptyArray:¶		 aMethodParameters.split(",");¶		¶//		String[] aMethodParameterTypes = new String[aMethodParameterTokens.length];¶//		String[] aMethodParameterNames = new String[aMethodParameterTokens.length];¶		List<DeclarationSNode> aDeclarationSNodeList = new ArrayList();¶		for (int i = 0; i < aMethodParameterTokens.length; i++ ) {¶			String[] aTypeAndName = aMethodParameterTokens[i].trim().split("\\s+");¶			if (aTypeAndName.length < 2) {¶				continue;¶			}¶			aDeclarationSNodeList.add(new ADeclarationSNode(aLineNumber, aTypeAndName[0].trim(), aTypeAndName[1].trim()));¶//			aMethodParameterTypes[i] = aTypeAndName[0].trim();¶//			aMethodParameterNames[i] = aTypeAndName[1].trim();¶		}¶		if (isInternal)¶//		return new AMethodSNode(aLineNumber, aMethodNameAndTypeTokens[0], aMethodNameAndTypeTokens[1], aMethodParameterTypes,aMethodParameterNames );¶			return new AMethodSNode(aLineNumber, aMethodNameAndTypeTokens[0], aMethodNameAndTypeTokens[1], aDeclarationSNodeList );¶		else¶			return new AnExternalMethodSNode(aLineNumber, aMethodNameAndTypeTokens[0], aMethodNameAndTypeTokens[1], aDeclarationSNodeList );¶	}¶¶	public static void setReductionData(OMPForSNode lastChild, String aStoredToken, int aLeftParenIndex,¶			int aRightParenIndex) {¶		int aColonIndex = aStoredToken.indexOf(":");¶		if (aLeftParenIndex != -1 && aRightParenIndex != -1 && aColonIndex != -1) {¶			String anOperationString = aStoredToken.substring(aLeftParenIndex + 1, aColonIndex).trim();¶			String aVariableString = aStoredToken.substring(aColonIndex + 1, aRightParenIndex).trim();¶			((OMPForSNode) lastChild).setReductionVariable(aVariableString);¶			((OMPForSNode) lastChild).setReductionOperation(anOperationString);¶		}¶	}¶¶	public static void setSharedOrPrivateData(OMPSNode lastChild, String aStoredToken, int aLeftParenIndex,¶			int aRightParenIndex, boolean isShared) {¶//		int aColonIndex = aStoredToken.indexOf(":");¶		if (aLeftParenIndex != -1 && aRightParenIndex != -1) {¶			String aVariableDeclarations = aStoredToken.substring(aLeftParenIndex + 1, aRightParenIndex);¶			String[] aVariables = aVariableDeclarations.split(",");¶			if (isShared) {¶				lastChild.setSharedVariables(aVariables);¶			} else {¶				lastChild.setPrivateVariables(aVariables);¶			}¶		}¶	}¶¶	public static RootOfFileSNode getSNode(String aFileName, String[] aFileLines) {¶		Stack<SNode> anSNodes = new Stack();¶¶		RootOfFileSNode retVal = new ARootOfFileSNode(aFileName);¶		anSNodes.add(retVal);¶		SNode previousHeaderNode = null;¶		for (int i = 0; i < aFileLines.length; i++) {¶			String aFileLine = aFileLines[i].trim();¶			if (!isCodeLine(aFileLine)) {¶				continue;¶			}¶			if (isForNode(aFileLine)) {¶				ForSNode aForSNode = getForSNode(i, aFileLine);¶				aForSNode.setParent(anSNodes.peek());¶//				anSNodes.push(aForSNode);¶				previousHeaderNode = aForSNode;¶				if (aFileLine.endsWith(")")) {¶					continue;¶				}¶			}¶			if (isExternalMethodDeclaration(aFileLine)) {¶				MethodSNode aMethodSNode = getMethodSNode(i, aFileLine, false);¶				aMethodSNode.setParent(anSNodes.peek());¶//				anSNodes.push(aForSNode);¶				previousHeaderNode = aMethodSNode;¶				if (aFileLine.endsWith(")")) {¶					continue;¶				}¶			}¶			if (isMethodDeclaration(aFileLine)) {¶				MethodSNode aMethodSNode = getMethodSNode(i, aFileLine, true);¶				aMethodSNode.setParent(anSNodes.peek());¶//				anSNodes.push(aForSNode);¶				previousHeaderNode = aMethodSNode;¶				if (aFileLine.endsWith(")")) {¶					continue;¶				}¶			}¶			if (isPragmaStart(aFileLine)) {¶				OMPSNode anOMPSNode = getOMPSNode(i, anSNodes.peek(), aFileLine);¶//				anSNodes.push(anOMPSNode);¶				previousHeaderNode = anOMPSNode;¶				continue;¶			}¶			if (isBlockStart(aFileLine)) {¶				SNode aBlockSNode = new AnSNode(i);¶				if (previousHeaderNode != null) {¶					aBlockSNode.setParent(previousHeaderNode);¶				} else {¶					aBlockSNode.setParent(anSNodes.peek());¶				}¶				anSNodes.push(aBlockSNode);¶				previousHeaderNode = null;¶				continue;¶			}¶//			} else ¶			if (isBlockEnd(aFileLine)) {¶				anSNodes.pop();¶				continue;¶			}¶			SNode aNewLeafNode = null;¶			if (isDeclaringAssignment(aFileLine)) {¶				aNewLeafNode = getDeclaringAssignmentSNode(i, aFileLine);¶¶			} else if (isAssignment(aFileLine)) {¶				aNewLeafNode = getAssignmentSNode(i, aFileLine);¶			} else if (isVariableDeclaration(aFileLine)) {¶				aNewLeafNode = getDeclarationSNode(i, aFileLine);¶			} else {¶				List<MethodCall> aCalls = callsIn(i, aFileLine, null); // parent will be assigned below¶				if (aCalls != null && aCalls.size() == 1) {¶					aNewLeafNode = aCalls.get(0);¶				} else {¶					aNewLeafNode = new ATextSNode(i, aFileLine);¶				}¶			}¶//			else {¶//				aNewLeafNode = new ATextSNode(i, aFileLine);¶//			}¶			if (previousHeaderNode != null) {¶				aNewLeafNode.setParent(previousHeaderNode);¶			} else {¶				aNewLeafNode.setParent(anSNodes.peek());¶			}¶¶		}¶¶		return retVal;¶	}¶¶	public static OMPSNode getOMPSNode(int aLineIndex, SNode aParentNode, String aFileLine) {¶		String[] aTokens = aFileLine.split("\\s+");¶		if (aTokens.length <= 2) {¶			return null;¶		}¶		if (!aTokens[1].equals("omp")) {¶			return null;¶		}¶		if (aTokens.length < 3) {¶			return null;¶		}¶		String aFirstToken = aTokens[2];¶		OpenMPKeywordEnum anOpenMPKeyword = stringToOpenMPKeyword.get(aFirstToken);¶//		List<OpenMPPragma> retVal = new ArrayList();¶		OMPSNode lastChild = null;¶		int aStartIndex = 2;¶		OMPSNode aNewNode = null;¶		OMPForSNode aForChild = null;¶		switch (anOpenMPKeyword) {¶		case PARALLEL:¶			aNewNode = new AnOMPParallelSNode(aLineIndex);¶¶			if (aTokens.length > 3 && aTokens[3].equals("for")) {¶				aForChild = new AnOMPForSNode(aLineIndex);¶				aForChild.setParent(aNewNode);¶¶				aStartIndex++;¶			}¶			break;¶		case FOR:¶			aNewNode = new AnOMPForSNode(aLineIndex);¶			;¶			break;¶		case CRITICAL:¶			aNewNode = new AnOMPCriticalSNode(aLineIndex);¶//			retVal.add (lastChild);¶			break;¶		default:¶			aNewNode = new AnOMPSNode(aLineIndex);¶¶		}¶¶		if (lastChild != null) {¶			aNewNode.setParent(lastChild);¶		} else {¶			aNewNode.setParent(aParentNode);¶		}¶		lastChild = aForChild == null ? aNewNode : aForChild;¶¶		for (int i = aStartIndex; i < aTokens.length; i++) {¶			String aStoredToken = aTokens[i].trim();¶			if (aStoredToken.isEmpty()) {¶				continue;¶			}¶			if (aStoredToken.startsWith("reduction") || aStoredToken.startsWith("shared")¶					|| aStoredToken.startsWith("private")) {¶				// combine all tokens until ")" into one for normalization¶				while (!aStoredToken.endsWith(")")) {¶					i++;¶					if (i >= aTokens.length) {¶						break;¶					}¶					String aNewToken = aTokens[i].trim();¶					aStoredToken += aNewToken;¶				}¶				int aLeftParenIndex = aStoredToken.indexOf("(");¶				int aRightParenIndex = aStoredToken.indexOf(")");¶				if (aStoredToken.startsWith("reduction")) {¶					setReductionData((OMPForSNode) lastChild, aStoredToken, aLeftParenIndex, aRightParenIndex);¶				} else if (aStoredToken.startsWith("private")) {¶					setSharedOrPrivateData((OMPSNode) lastChild, aStoredToken, aLeftParenIndex, aRightParenIndex,¶							false);¶¶				} else if (aStoredToken.startsWith("shared")) {¶					setSharedOrPrivateData(lastChild, aStoredToken, aLeftParenIndex, aRightParenIndex, true);¶¶				}¶¶			}¶¶			lastChild.getOpenMPTokens().add(aStoredToken);¶		}¶¶		return lastChild;¶¶	}¶¶	public static boolean hasParallelAncestor(SNode anSNode) {¶		if (anSNode == null) {¶			return false;¶		}¶		if (anSNode instanceof OMPParallelSNode) {¶			return true;¶		}¶		return hasParallelAncestor(anSNode.getParent());¶	}¶	public static boolean hasCriticalAncestor(SNode anSNode) {¶		if (anSNode == null) {¶			return false;¶		}¶		if (anSNode instanceof OMPCriticalSNode) {¶			return true;¶		}¶		return hasCriticalAncestor(anSNode.getParent());¶	}¶¶¶	public static Boolean isDeclaredShared(OMPSNode anOMPSNode, String anLHS) {¶		if (Arrays.asList(anOMPSNode.getSharedVariables()).contains(anLHS)) {¶			return true;¶		}¶		if (Arrays.asList(anOMPSNode.getPrivateVariables()).contains(anLHS)) {¶			return false;¶		}¶		return null;¶¶	}¶¶	public static boolean isSharedVariable(SNode anSNode, String anLHS) {¶		if (anSNode == null) {¶			return false;¶		}¶		if (anSNode.getLocalVariables().contains(anLHS)) {¶			if (!(anSNode instanceof OMPSNode)) { // no shared and private declarations¶				return !hasParallelAncestor(anSNode); // shared if not inParallel¶			}¶			OMPSNode anOMPSNode = (OMPSNode) anSNode;¶			return (Arrays.asList(anOMPSNode.getSharedVariables()).contains(anLHS)); // private unless declared shared¶		}¶		if (anSNode instanceof OMPSNode) {¶			OMPSNode anOMPSNode = (OMPSNode) anSNode;¶			// the variable is global to this scope, check if it has have been made shared¶			// or private by this scope¶			Boolean isDeclaredShared = isDeclaredShared(anOMPSNode, anLHS);¶			if (isDeclaredShared != null) {¶				return isDeclaredShared;¶			}¶		}¶		// check the parent¶		return isSharedVariable(anSNode.getParent(), anLHS);¶	}¶¶	public static List<SNode> getAllLeafNodes(SNode aTopNode) {¶		List<SNode> retVal = new ArrayList();¶		addLeafNodes(aTopNode, retVal);¶		return retVal;¶	}¶¶	public static void addLeafNodes(SNode aTopNode, List<SNode> retVal) {¶		for (SNode aChild : aTopNode.getChildren()) {¶			if (aChild.isLeaf()) {¶				retVal.add(aChild);¶			} else {¶				addLeafNodes(aChild, retVal);¶			}¶		}¶	}¶¶	public static List<SNode> getNonParallelLeafNodes(SNode aTopNode) {¶		List<SNode> retVal = new ArrayList();¶		addNonParallelLeafNodes(aTopNode, retVal);¶		return retVal;¶	}¶¶	public static void addNonParallelLeafNodes(SNode aTopNode, List<SNode> retVal) {¶		if (aTopNode.isInParallel()) {¶			return;¶		}¶		for (SNode aChild : aTopNode.getChildren()) {¶			if (aChild.isLeaf()) {¶				retVal.add(aChild);¶			} else {¶				addLeafNodes(aChild, retVal);¶			}¶		}¶	}¶	static String callRegex = "([a-zA-Z_$][a-zA-Z_$0-9]*)\\(.*?\\)";¶	static Pattern callPattern = Pattern.compile(callRegex);¶¶	static String identifierRegex = "[a-zA-Z_$][a-zA-Z_$0-9]*";¶	static Pattern identifierPattern = Pattern.compile(identifierRegex);¶	public static List<String> identifiersIn(String aString) {¶		if (aString == null)¶			return null;¶//		Pattern mypattern = Pattern.compile("[a-zA-Z_$][a-zA-Z_$0-9]*");¶//		Matcher mymatcher = mypattern.matcher(aString);¶		Matcher mymatcher = identifierPattern.matcher(aString);¶		List<String> retVal = new ArrayList();¶		while (mymatcher.find()) {¶			String find = mymatcher.group(0);¶			retVal.add(find);¶		}¶		return retVal;¶	}¶	public static List<MethodCall> callsIn(int aLineNumber, String aString, SNode aParent) {¶		if (aString == null)¶			return null;¶//		Pattern mypattern = Pattern.compile("[a-zA-Z_$][a-zA-Z_$0-9]*");¶//		Matcher mymatcher = mypattern.matcher(aString);¶		Matcher mymatcher = callPattern.matcher(aString);¶		List<MethodCall> retVal = new ArrayList();¶		while (mymatcher.find()) {¶			String find = mymatcher.group(0);¶			int aLeftParenIndex = find.indexOf("(");¶			int aRightParenIndex = find.indexOf(")");¶			String aMethodName = find.substring(0, aLeftParenIndex).trim();¶			String aParameters = find.substring(aLeftParenIndex + 1, aRightParenIndex);¶			List<String> aParameterList = new ArrayList();¶			String[] aParameterTokens = aParameters.split(",");¶			for (String aParameter:aParameterTokens) {¶				String aParameterTrimmed = aParameter.trim();¶				if (!aParameterTrimmed.isEmpty())¶				aParameterList.add(aParameterTrimmed);¶			}¶			retVal.add(new AMethodCall(aLineNumber, aMethodName, aParameterList, aParent));¶¶//			aCallStrings.add(find);¶		}¶		return retVal;¶	}¶	static String numberRegex = "(\\d+\\.\\d+)|(\\d+)";¶	static Pattern numberPattern = Pattern.compile(numberRegex);¶	public static List<String> numbersIn(String aString) {¶		if (aString == null)¶			return null;¶//		String regex = "(\\d+\\.\\d+)|(\\d+)";¶//¶//		Matcher m = Pattern.compile(regex).matcher(aString);¶		Matcher m =numberPattern.matcher(aString);¶¶¶		List<String> retVal = new ArrayList();¶¶		while (m.find()) {¶			retVal.add(m.group());¶		}¶		return retVal;¶	}¶¶	public static String subscriptIn(String aString) {¶		if (aString == null)¶			return null;¶		return StringUtils.substringBetween(aString, "[", "]");¶	}¶	static String[] emptyStringArray = {};¶	public static String[] subscriptsIn(String aString) {¶		if (aString == null)¶			return emptyStringArray;¶		return StringUtils.substringsBetween(aString, "[", "]");¶	}¶	static  String operatorRegex = "([+-/*///^])|([/(/)])";¶	static Pattern operatorPattern = Pattern.compile(operatorRegex);¶¶	public static List<String> operatorsIn(String aString) {¶		if (aString == null)¶			return null;¶//		String operatorRegex = "([+-/*///^])|([/(/)])";¶//¶//		Matcher m = Pattern.compile(operatorRegex).matcher(aString);¶		¶		Matcher m = operatorPattern.matcher(aString);¶¶¶		List<String> retVal = new ArrayList();¶¶		while (m.find()) {¶			retVal.add(m.group());¶		}¶		return retVal;¶	}¶	¶	public static int numberOfNestingFors (SNode anSNode) {¶		if (anSNode == null) {¶			return 0;¶		}¶		int retVal = numberOfNestingFors (anSNode.getParent()) ;¶¶		if (anSNode instanceof ForSNode) {¶			retVal++;¶		} else if (anSNode instanceof MethodSNode) {¶			List<MethodCall> aMethodCalls = ((MethodSNode) anSNode).getCalls();¶			int aMaxNestingLevel = 0;¶			for (MethodCall aMethodCall:aMethodCalls) {¶				MethodSNode aCallerMethodSNode = getDeclarationOfCalledMethod(anSNode, aMethodCall);¶				int aCallerNumberOfNestingFors = numberOfNestingFors(aCallerMethodSNode);¶				aMaxNestingLevel = Math.max(aCallerNumberOfNestingFors, aMaxNestingLevel);				¶			}¶			return retVal + aMaxNestingLevel;¶		}¶		return retVal;¶	}¶	public static boolean hasOperator (SNode anSNode, String anOperator) {¶		boolean retVal = false;¶		if (anSNode instanceof AssignmentSNode) {¶			AssignmentSNode anAssignmentSNode = (AssignmentSNode) anSNode;¶			 retVal = (anAssignmentSNode.getLhsOperators().contains(anOperator) || ¶					anAssignmentSNode.getRhsOperators().contains(anOperator)) ;¶			if (retVal) {¶				return retVal;¶			} else {¶				List<MethodCall> aMethodCalls = anAssignmentSNode.getRhsCalls();¶				for (MethodCall aMethodCall:aMethodCalls) {¶					MethodSNode aMethodSNode = getDeclarationOfCalledMethod(anSNode, aMethodCall);¶					retVal = hasOperator(aMethodSNode, anOperator);¶					if (retVal) {¶						return retVal;¶					}¶					¶				}¶				return false;¶			}¶			¶		}¶		for (SNode aChild:anSNode.getChildren()) {¶			retVal = hasOperator(aChild, anOperator);¶			if (retVal) {¶				return retVal;¶			}¶		}¶		return false;¶	}¶	public static boolean hasMethodCall (SNode anSNode, String anOperator) {¶		boolean retVal = false;¶		if (anSNode instanceof AssignmentSNode) {¶			AssignmentSNode anAssignmentSNode = (AssignmentSNode) anSNode;¶			 retVal = (anAssignmentSNode.getLhsOperators().contains(anOperator) || ¶					anAssignmentSNode.getRhsOperators().contains(anOperator)) ;¶			if (retVal) {¶				return retVal;¶			} else {¶				List<MethodCall> aMethodCalls = anAssignmentSNode.getRhsCalls();¶				for (MethodCall aMethodCall:aMethodCalls) {¶					MethodSNode aMethodSNode = getDeclarationOfCalledMethod(anSNode, aMethodCall);¶					retVal = hasOperator(aMethodSNode, anOperator);¶					if (retVal) {¶						return retVal;¶					}¶					¶				}¶				return false;¶			}¶			¶		}¶		for (SNode aChild:anSNode.getChildren()) {¶			retVal = hasOperator(aChild, anOperator);¶			if (retVal) {¶				return retVal;¶			}¶		}¶		return false;¶	}¶	public static boolean dependsOn (AssignmentSNode anAssignmentSNode, String aVariable, String aCallIdentifier) {¶		// This assignment does not change aVariable¶		if (!aVariable.equals(anAssignmentSNode.getLhsVariable())) {¶			return false;¶		}¶		return dependsOn(anAssignmentSNode.getExpressionSNode(), aCallIdentifier);¶//		List<String> aCallIdentifiers = anAssignmentSNode.getRhsCallIdentifiers();¶//		boolean retVal = false;¶//		if (aCallIdentifiers != null && aCallIdentifiers.contains(aCallIdentifier)) {¶//			return true; // this assignment has aCallIdentifier in the rhs¶//		}¶//		// check if some referenced rhs variable depends on aCallIdentifier¶//		List<String> aReferencedVariableIdentifiers = anAssignmentSNode.getRhsVariableIdentifiers();¶//		SNode anAssignmentParent = anAssignmentSNode.getParent();¶//		if (anAssignmentParent == null) { // should never be trye¶//			return false;¶//		}¶//		int aLineNumber = anAssignmentSNode.getLineNumber();¶//		for (String aReferencedVariableIdentifier:aReferencedVariableIdentifiers ) {¶//			if (dependsOn (anAssignmentParent, aLineNumber, aReferencedVariableIdentifier, aCallIdentifier)) {¶//				return true;¶//			}¶//		}¶//		return false;¶	}¶	public static boolean dependsOn (ExpressionSNode anExpressionSNode, String aCallIdentifier) {¶		// This assignment does not change aVariable¶		¶		List<String> aCallIdentifiers = anExpressionSNode.getRhsCallIdentifiers();¶		boolean retVal = false;¶		if (aCallIdentifiers != null && aCallIdentifiers.contains(aCallIdentifier)) {¶			return true; // this assignment has aCallIdentifier in the rhs¶		}¶		// check if some referenced rhs variable depends on aCallIdentifier¶		List<String> aReferencedVariableIdentifiers = anExpressionSNode.getRhsVariableIdentifiers();¶		SNode anAssignmentParent = anExpressionSNode.getParent().getParent();¶		if (anAssignmentParent == null) { // should never be trye¶			return false;¶		}¶		int aLineNumber = anExpressionSNode.getLineNumber();¶		for (String aReferencedVariableIdentifier:aReferencedVariableIdentifiers ) {¶			if (dependsOn (anAssignmentParent, aLineNumber, aReferencedVariableIdentifier, aCallIdentifier)) {¶				return true;¶			}¶		}¶		return false;¶	}¶	public static List<AssignmentSNode> assignmentsToSharedVariables(SNode anSNode) {¶		List<AssignmentSNode> retVal =  new ArrayList();¶		fillAssignmentsToShared(anSNode, retVal);¶		return retVal;¶		¶	}¶	public static List<AssignmentSNode> assignmentsToSharedArrays(SNode anSNode) {¶		List<AssignmentSNode> anAllSharedAssignments =  assignmentsToSharedVariables(anSNode);¶		List<AssignmentSNode> aRetVal = new ArrayList();¶		for (AssignmentSNode anAssignmentSNode:anAllSharedAssignments) {¶			if (anAssignmentSNode.getLhsSubscripts().length > 0) {¶				aRetVal.add(anAssignmentSNode);¶			}¶		}¶		return aRetVal;¶		¶	}¶	public static List<AssignmentSNode> assignmentsToParallelSharedCritical(SNode anSNode) {¶		List<AssignmentSNode> anAllSharedAssignments =  assignmentsToSharedVariables(anSNode);¶		List<AssignmentSNode> aRetVal = new ArrayList();¶		for (AssignmentSNode anAssignmentSNode:anAllSharedAssignments) {¶			if (anAssignmentSNode.isInParallel() &&¶					anAssignmentSNode.isInC"), Diff(INSERT,"ritical()"), Diff(EQUAL,") {¶				aRetVal.add(anAssignmentSNode);¶			}¶		}¶		return aRetVal;¶		¶	}¶    public static void fillAssignmentsToShared(SNode anSNode, List<AssignmentSNode> retVal) {¶    	if (anSNode instanceof AssignmentSNode) {¶			AssignmentSNode anAssignmentSNode = (AssignmentSNode) anSNode;¶			String anLHS = anAssignmentSNode.getLhsVariable();¶			if (isSharedVariable(anSNode, anLHS)) {¶				retVal.add(anAssignmentSNode);¶				return;¶			}¶		}¶    	for (SNode aChild:anSNode.getChildren()) {¶    		fillAssignmentsToShared(aChild, retVal);¶    	}¶		¶	}¶	public static boolean dependsOn (SNode anSNode, int aVariableLineNumber, String aVariable, String aCallIdentifier) {¶		List<SNode> aListSNodes = anSNode.getChildren();¶		boolean retVal = false;¶		/*¶		 * Should probably ignore line number as it assumes straight line code¶		 */¶		for (int i = aVariableLineNumber; i >= 0; i--) {¶			SNode anSNodeChild = aListSNodes.get(i);¶			if (anSNodeChild instanceof AssignmentSNode) {¶				// does this statement in anSNode directly invoke aCallIdentifier ¶				if (dependsOn((AssignmentSNode) anSNodeChild, aVariable, aCallIdentifier))¶					return true;¶			} else if (!anSNode.isLeaf()) {¶					// child is overriding the variable so forget checking its assignment statements¶					if (anSNodeChild.getLocalVariables().contains(aVariable)) {¶						continue;¶					}¶					// some subblock of anSNode that has access to aVariable changes variable¶¶					if (dependsOn(anSNodeChild, anSNodeChild.getChildren().size() - 1, aVariable, aCallIdentifier)) {¶						return true;¶					}¶			}¶			¶		}¶		// none of the statements in anSNode or its descendents  have the required call¶		// is the variable a  method parameter ¶		if (anSNode instanceof MethodSNode) {¶			MethodSNode aMethodSNode = (MethodSNode) anSNode;¶			¶			int aParameterNumber = aMethodSNode.getLocalVariables().indexOf(aVariable);¶			if (aParameterNumber != -1) {¶				List <MethodCall> aCalls = aMethodSNode.getCalls();¶				for (MethodCall aCall:aCalls) {¶					MethodSNode aCallerSNode = getDeclarationOfCalledMethod(aMethodSNode, aCall);¶					boolean aCallerDepends = dependsOn(aMethodSNode, aCallerSNode.getLineNumber(), aVariable, aCallIdentifier);¶				    if (aCallerDepends) {¶				    	return true;¶				    }¶				}¶				return false;¶				// need to find all callers of method and see if any of the aliases for the variable in these¶				// calls depend on aCallIndentifier¶			}			¶			¶		} else if (anSNode.getLocalVariables().contains(aVariable)) {¶			// before going to the parent node, let us see if aVariable is declared here as a non  parameter ¶¶			return false; // no point going to parent¶		}¶		// not a local variable (parameter or declarated variable)¶		SNode anSNodeParent = anSNode.getParent() ;¶		if (anSNodeParent == null)  {¶			return false;¶		}¶		int anSNodeLineNumber = anSNodeParent.getChildren().indexOf(anSNode);¶		return dependsOn(anSNodeParent, anSNodeLineNumber, aVariable, aCallIdentifier);¶		¶	}¶	public static RootOfFileSNode getRootOfFileNode(SNode aCurrentSNode ) {¶		if (aCurrentSNode instanceof RootOfFileSNode) {¶			return (RootOfFileSNode) aCurrentSNode;¶		}¶		SNode aParentSNode = aCurrentSNode.getParent() ;¶		¶		if (aParentSNode == null) {¶			return null;¶		}¶		¶		return getRootOfFileNode(aParentSNode);¶		¶	}¶	public static boolean match (MethodSNode aMethodSNode, MethodCall aMethodCall) {¶		return aMethodSNode.getMethodName().equals(aMethodCall.getMethodName()) ¶				&& aMethodSNode.getLocalVariables().size() == aMethodCall.getMethodActuals().size();¶	}¶	¶	public static MethodSNode getDeclarationOfCalledMethod(SNode aCurrentSNode, MethodCall aMethodCall ) {¶		SNode aRootNode = getRootOfFileNode(aCurrentSNode);¶		for (SNode aChild:aRootNode.getChildren()) {¶			if (aChild instanceof MethodSNode) {¶				MethodSNode aMethodSNode = (MethodSNode) aChild;¶				if (match (aMethodSNode, aMethodCall)) {¶					return aMethodSNode;¶				}¶			}¶		}¶		return null; // this should never happen;¶	}¶	¶	public static RootOfProgramSNode getRootOfProgramSNode(String aSource) {¶		RootOfProgramSNode retVal = new ARootOfProgramSNode();¶		Map<String, StringBuffer> aFileNameToContents = ABasicTextManager.extractFileContents(aSource);¶		for (String aFileName:aFileNameToContents.keySet()) {¶			StringBuffer aFileContents = aFileNameToContents.get(aFileName);¶//			List<OpenMPPragma> anOpenMPPragmas = OpenMPUtils.getOpemMPPragmas(aFileContents);¶			RootOfFileSNode anSNode = OMPSNodeUtils.getSNode(aFileName, aFileContents);¶			retVal.getFileNameToSNode().put(aFileName, anSNode);¶			anSNode.setParent(retVal);¶//			System.out.println("file name:" + aFileName);¶//			System.out.println("pragmas:" + anSNode);¶		}¶		processExternalMethodSNodes(retVal);¶		return retVal;¶	}¶	public static void processExternalMethodSNodes (RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode) {¶		for (SNode anSNode:aRootOfFileSNode.getChildren()) {¶			if (anSNode instanceof ExternalMethodSNode) {¶				processExternalMethodSNode(aRootOfProgramSNode, aRootOfFileSNode, (ExternalMethodSNode) anSNode);¶			}¶		}¶	}¶	public static void processExternalMethodSNode (RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode, ExternalMethodSNode anExternalMethodSNode) {¶		MethodSNode aMethodSNode = aRootOfProgramSNode.getExternalToInternalMethod().get(anExternalMethodSNode.toString());¶		if (aMethodSNode == null) {¶			aMethodSNode = findMethodSNode(aRootOfProgramSNode, aRootOfFileSNode, anExternalMethodSNode);¶			if (aMethodSNode != null) {¶				aRootOfProgramSNode.getExternalToInternalMethod().put(anExternalMethodSNode.toString(),aMethodSNode );¶			}¶		}¶		if (aMethodSNode != null) {¶			anExternalMethodSNode.setActualMethodSNode(aMethodSNode);¶			aMethodSNode.getCalls().addAll(anExternalMethodSNode.getLocalCalls());¶		}¶	}¶	public static MethodSNode findMethodSNode (RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode, ExternalMethodSNode anExternalMethodSNode) {¶//		MethodSNode foundMethodSNode = null;¶		for (String aFileName:aRootOfProgramSNode.getFileNameToSNode().keySet()) {¶			if (aFileName.equals(aRootOfFileSNode.getFileName()))¶				continue;¶			¶			RootOfFileSNode aSearchedRootOfFileSNode = aRootOfProgramSNode.getFileNameToSNode().get(aFileName);¶			 for (SNode anSNode:aSearchedRootOfFileSNode.getChildren()) {¶				if (anSNode instanceof MethodSNode && !(anSNode instanceof ExternalMethodSNode)) {¶					if (anSNode.toString().equals(anExternalMethodSNode.toString())) {¶						return (MethodSNode) anSNode;¶						¶					}¶//					processExternalMethodSNode(aRootOfProgramSNode, aRootOfFileSNode, (ExternalMethodSNode) anSNode);¶				}¶			}¶		}¶		return null;¶	}¶	public static void processExternalMethodSNodes (RootOfProgramSNode aRootOfProgramSNode) {¶		for (String aFileName:aRootOfProgramSNode.getFileNameToSNode().keySet()) {¶			RootOfFileSNode aRootOfFileSNode = aRootOfProgramSNode.getFileNameToSNode().get(aFileName);¶			processExternalMethodSNodes(aRootOfProgramSNode, aRootOfFileSNode);¶			aRootOfFileSNode.getOmp_get_num_threads_SNode().¶				setActualMethodSNode(aRootOfProgramSNode.getOmp_get_num_threads_SNode());¶			aRootOfFileSNode.getOmp_get_thread_num_SNode().¶				setActualMethodSNode(aRootOfProgramSNode.getOmp_get_thread_num_SNode());¶			aRootOfFileSNode.getOmp_get_wtime_SNode().¶			setActualMethodSNode(aRootOfProgramSNode.getOmp_get_wtime_SNode());¶		}¶¶	}¶	¶¶//	public static void main(String[] args) {¶//		List<MethodCall> aTokens = callsIn("foo(bar, hgf)/foo2()*foo3(b, a c,)");¶//		System.out.println(aTokens);¶//		¶//		¶////		List<String> aTokens = identifiersIn("a[i] + b*2/3");¶////		System.out.println(aTokens);¶////		aTokens = numbersIn("a[i] + b*2/3");¶////		System.out.println(aTokens);¶////		aTokens = operatorsIn("a[i] + b*2/3");¶////		System.out.println(aTokens);¶////¶////		System.out.println(StringUtils.substringBetween("a", "[", "]"));¶//	}¶¶}¶")]]]></diff>
    <snapshot><![CDATA[package gradingTools.shared.testcases.openmp.scannedTree;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Stack;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.apache.commons.lang.StringUtils;

import grader.basics.project.source.ABasicTextManager;
import gradingTools.shared.testcases.openmp.OpenMPKeywordEnum;
import gradingTools.shared.testcases.openmp.OpenMPParallelPragma;
import gradingTools.shared.testcases.openmp.OpenMPUtils;
import gradingTools.shared.testcases.openmp.scannedTree.ADeclarationSNode;
import gradingTools.shared.testcases.openmp.scannedTree.ADeclaringAssignmentSNode;
import gradingTools.shared.testcases.openmp.scannedTree.AForSNode;
import gradingTools.shared.testcases.openmp.scannedTree.ATextSNode;
import gradingTools.shared.testcases.openmp.scannedTree.AnAssignmentSNode;
import gradingTools.shared.testcases.openmp.scannedTree.AnOMPCriticalSNode;
import gradingTools.shared.testcases.openmp.scannedTree.AnOMPForSNode;
import gradingTools.shared.testcases.openmp.scannedTree.AnOMPParallelSNode;
import gradingTools.shared.testcases.openmp.scannedTree.AnOMPSNode;
import gradingTools.shared.testcases.openmp.scannedTree.AnSNode;
import gradingTools.shared.testcases.openmp.scannedTree.AssignmentSNode;
import gradingTools.shared.testcases.openmp.scannedTree.DeclarationSNode;
import gradingTools.shared.testcases.openmp.scannedTree.DeclaringAssignmentSNode;
import gradingTools.shared.testcases.openmp.scannedTree.ForSNode;
import gradingTools.shared.testcases.openmp.scannedTree.OMPForSNode;
import gradingTools.shared.testcases.openmp.scannedTree.OMPSNode;
import gradingTools.shared.testcases.openmp.scannedTree.SNode;

public class OMPSNodeUtils extends OpenMPUtils {

	public static RootOfFileSNode getSNode(String aFileName, StringBuffer aFileBuffer) {
		String[] aFileLines = aFileBuffer.toString().split("\n");
		return getSNode(aFileName, aFileLines);
	}

	public static AssignmentSNode getAssignmentSNode(int aLineNumber, String aString) {
		if (aString == null) {
			return null;
		}
		String[] aTokens = aString.split("=");
		if (aTokens.length == 1) {
			return new AnAssignmentSNode(aLineNumber, aTokens[0], null);
		} else {
		return new AnAssignmentSNode(aLineNumber, aTokens[0], aTokens[1]);
		}
	}

	public static DeclarationSNode getDeclarationSNode(int aLineNumber, String aString) {
		String[] aTokens = aString.split(" ");
		return new ADeclarationSNode(aLineNumber, aTokens[0], aTokens[1]);
	}

	public static DeclaringAssignmentSNode getDeclaringAssignmentSNode(int aLineNumber, String aString) {
		String[] anLHSAndRHS = aString.split("=");
		String[] aTypeAndVariable = anLHSAndRHS[0].split(" ");
		return new ADeclaringAssignmentSNode(aLineNumber, aTypeAndVariable[0], aTypeAndVariable[1], anLHSAndRHS[1]);
	}

	public static boolean isDeclaringAssignment(String aFileLine) {
		return startsWithTypeName(aFileLine) && aFileLine.contains("=");
	}
	public static boolean isMethodDeclaration(String aFileLine) {
		return startsWithTypeName(aFileLine) && 
				aFileLine.contains("(") &&
				!aFileLine.contains("=");
	}
	public static boolean isExternalMethodDeclaration(String aFileLine) {
		return isMethodDeclaration(aFileLine) && aFileLine.endsWith(";");
	}


	public static boolean isVariableDeclaration(String aFileLine) {

		return startsWithTypeName(aFileLine) && !aFileLine.contains("(");
	}

	public static boolean isAssignment(String aFileLine) {
		return aFileLine.contains("=");
	}

	public static boolean isForNode(String aFileLine) {
		return aFileLine.startsWith("for");
	}

	public static ForSNode getForSNode(int aLineNumber, String aFileLine) {

		int aLeftParenIndex = aFileLine.indexOf("(");
		int aRightParenIndex = aFileLine.indexOf(")");
		if (aLeftParenIndex < 0 || aRightParenIndex < 0) {
			return null;
		}
		String aHeaderString = aFileLine.substring(aLeftParenIndex + 1, aRightParenIndex);
		String[] aForComponents = aHeaderString.split(";");
		AssignmentSNode anAssignmentSNode = null;
		String aForInitializaton = aForComponents[0];
		if (!aForInitializaton.isEmpty() && aForInitializaton.contains("=")) {
			if (isDeclaringAssignment(aForInitializaton)) {
				anAssignmentSNode = getDeclaringAssignmentSNode(aLineNumber, aForInitializaton);
			} else {
				anAssignmentSNode = getAssignmentSNode(aLineNumber, aForInitializaton);
			}

		}		
		return new AForSNode(aLineNumber, anAssignmentSNode, aForComponents[1], getAssignmentSNode(aLineNumber, aForComponents[2]));
	}
	static String[] emptyArray = {};
	public static MethodSNode getMethodSNode(int aLineNumber, String aFileLine, boolean isInternal) {

		int aLeftParenIndex = aFileLine.indexOf("(");
		int aRightParenIndex = aFileLine.indexOf(")");
		if (aLeftParenIndex < 0 || aRightParenIndex < 0) {
			return null;
		}
		String aMethodNameAndType = aFileLine.substring(0, aLeftParenIndex);
		String[] aMethodNameAndTypeTokens = aMethodNameAndType.split("\\s+"); 
		
		String aMethodParameters = aFileLine.substring(aLeftParenIndex +1 , aRightParenIndex);
		String[] aMethodParameterTokens = aMethodParameters.isEmpty()?emptyArray:
		 aMethodParameters.split(",");
		
//		String[] aMethodParameterTypes = new String[aMethodParameterTokens.length];
//		String[] aMethodParameterNames = new String[aMethodParameterTokens.length];
		List<DeclarationSNode> aDeclarationSNodeList = new ArrayList();
		for (int i = 0; i < aMethodParameterTokens.length; i++ ) {
			String[] aTypeAndName = aMethodParameterTokens[i].trim().split("\\s+");
			if (aTypeAndName.length < 2) {
				continue;
			}
			aDeclarationSNodeList.add(new ADeclarationSNode(aLineNumber, aTypeAndName[0].trim(), aTypeAndName[1].trim()));
//			aMethodParameterTypes[i] = aTypeAndName[0].trim();
//			aMethodParameterNames[i] = aTypeAndName[1].trim();
		}
		if (isInternal)
//		return new AMethodSNode(aLineNumber, aMethodNameAndTypeTokens[0], aMethodNameAndTypeTokens[1], aMethodParameterTypes,aMethodParameterNames );
			return new AMethodSNode(aLineNumber, aMethodNameAndTypeTokens[0], aMethodNameAndTypeTokens[1], aDeclarationSNodeList );
		else
			return new AnExternalMethodSNode(aLineNumber, aMethodNameAndTypeTokens[0], aMethodNameAndTypeTokens[1], aDeclarationSNodeList );
	}

	public static void setReductionData(OMPForSNode lastChild, String aStoredToken, int aLeftParenIndex,
			int aRightParenIndex) {
		int aColonIndex = aStoredToken.indexOf(":");
		if (aLeftParenIndex != -1 && aRightParenIndex != -1 && aColonIndex != -1) {
			String anOperationString = aStoredToken.substring(aLeftParenIndex + 1, aColonIndex).trim();
			String aVariableString = aStoredToken.substring(aColonIndex + 1, aRightParenIndex).trim();
			((OMPForSNode) lastChild).setReductionVariable(aVariableString);
			((OMPForSNode) lastChild).setReductionOperation(anOperationString);
		}
	}

	public static void setSharedOrPrivateData(OMPSNode lastChild, String aStoredToken, int aLeftParenIndex,
			int aRightParenIndex, boolean isShared) {
//		int aColonIndex = aStoredToken.indexOf(":");
		if (aLeftParenIndex != -1 && aRightParenIndex != -1) {
			String aVariableDeclarations = aStoredToken.substring(aLeftParenIndex + 1, aRightParenIndex);
			String[] aVariables = aVariableDeclarations.split(",");
			if (isShared) {
				lastChild.setSharedVariables(aVariables);
			} else {
				lastChild.setPrivateVariables(aVariables);
			}
		}
	}

	public static RootOfFileSNode getSNode(String aFileName, String[] aFileLines) {
		Stack<SNode> anSNodes = new Stack();

		RootOfFileSNode retVal = new ARootOfFileSNode(aFileName);
		anSNodes.add(retVal);
		SNode previousHeaderNode = null;
		for (int i = 0; i < aFileLines.length; i++) {
			String aFileLine = aFileLines[i].trim();
			if (!isCodeLine(aFileLine)) {
				continue;
			}
			if (isForNode(aFileLine)) {
				ForSNode aForSNode = getForSNode(i, aFileLine);
				aForSNode.setParent(anSNodes.peek());
//				anSNodes.push(aForSNode);
				previousHeaderNode = aForSNode;
				if (aFileLine.endsWith(")")) {
					continue;
				}
			}
			if (isExternalMethodDeclaration(aFileLine)) {
				MethodSNode aMethodSNode = getMethodSNode(i, aFileLine, false);
				aMethodSNode.setParent(anSNodes.peek());
//				anSNodes.push(aForSNode);
				previousHeaderNode = aMethodSNode;
				if (aFileLine.endsWith(")")) {
					continue;
				}
			}
			if (isMethodDeclaration(aFileLine)) {
				MethodSNode aMethodSNode = getMethodSNode(i, aFileLine, true);
				aMethodSNode.setParent(anSNodes.peek());
//				anSNodes.push(aForSNode);
				previousHeaderNode = aMethodSNode;
				if (aFileLine.endsWith(")")) {
					continue;
				}
			}
			if (isPragmaStart(aFileLine)) {
				OMPSNode anOMPSNode = getOMPSNode(i, anSNodes.peek(), aFileLine);
//				anSNodes.push(anOMPSNode);
				previousHeaderNode = anOMPSNode;
				continue;
			}
			if (isBlockStart(aFileLine)) {
				SNode aBlockSNode = new AnSNode(i);
				if (previousHeaderNode != null) {
					aBlockSNode.setParent(previousHeaderNode);
				} else {
					aBlockSNode.setParent(anSNodes.peek());
				}
				anSNodes.push(aBlockSNode);
				previousHeaderNode = null;
				continue;
			}
//			} else 
			if (isBlockEnd(aFileLine)) {
				anSNodes.pop();
				continue;
			}
			SNode aNewLeafNode = null;
			if (isDeclaringAssignment(aFileLine)) {
				aNewLeafNode = getDeclaringAssignmentSNode(i, aFileLine);

			} else if (isAssignment(aFileLine)) {
				aNewLeafNode = getAssignmentSNode(i, aFileLine);
			} else if (isVariableDeclaration(aFileLine)) {
				aNewLeafNode = getDeclarationSNode(i, aFileLine);
			} else {
				List<MethodCall> aCalls = callsIn(i, aFileLine, null); // parent will be assigned below
				if (aCalls != null && aCalls.size() == 1) {
					aNewLeafNode = aCalls.get(0);
				} else {
					aNewLeafNode = new ATextSNode(i, aFileLine);
				}
			}
//			else {
//				aNewLeafNode = new ATextSNode(i, aFileLine);
//			}
			if (previousHeaderNode != null) {
				aNewLeafNode.setParent(previousHeaderNode);
			} else {
				aNewLeafNode.setParent(anSNodes.peek());
			}

		}

		return retVal;
	}

	public static OMPSNode getOMPSNode(int aLineIndex, SNode aParentNode, String aFileLine) {
		String[] aTokens = aFileLine.split("\\s+");
		if (aTokens.length <= 2) {
			return null;
		}
		if (!aTokens[1].equals("omp")) {
			return null;
		}
		if (aTokens.length < 3) {
			return null;
		}
		String aFirstToken = aTokens[2];
		OpenMPKeywordEnum anOpenMPKeyword = stringToOpenMPKeyword.get(aFirstToken);
//		List<OpenMPPragma> retVal = new ArrayList();
		OMPSNode lastChild = null;
		int aStartIndex = 2;
		OMPSNode aNewNode = null;
		OMPForSNode aForChild = null;
		switch (anOpenMPKeyword) {
		case PARALLEL:
			aNewNode = new AnOMPParallelSNode(aLineIndex);

			if (aTokens.length > 3 && aTokens[3].equals("for")) {
				aForChild = new AnOMPForSNode(aLineIndex);
				aForChild.setParent(aNewNode);

				aStartIndex++;
			}
			break;
		case FOR:
			aNewNode = new AnOMPForSNode(aLineIndex);
			;
			break;
		case CRITICAL:
			aNewNode = new AnOMPCriticalSNode(aLineIndex);
//			retVal.add (lastChild);
			break;
		default:
			aNewNode = new AnOMPSNode(aLineIndex);

		}

		if (lastChild != null) {
			aNewNode.setParent(lastChild);
		} else {
			aNewNode.setParent(aParentNode);
		}
		lastChild = aForChild == null ? aNewNode : aForChild;

		for (int i = aStartIndex; i < aTokens.length; i++) {
			String aStoredToken = aTokens[i].trim();
			if (aStoredToken.isEmpty()) {
				continue;
			}
			if (aStoredToken.startsWith("reduction") || aStoredToken.startsWith("shared")
					|| aStoredToken.startsWith("private")) {
				// combine all tokens until ")" into one for normalization
				while (!aStoredToken.endsWith(")")) {
					i++;
					if (i >= aTokens.length) {
						break;
					}
					String aNewToken = aTokens[i].trim();
					aStoredToken += aNewToken;
				}
				int aLeftParenIndex = aStoredToken.indexOf("(");
				int aRightParenIndex = aStoredToken.indexOf(")");
				if (aStoredToken.startsWith("reduction")) {
					setReductionData((OMPForSNode) lastChild, aStoredToken, aLeftParenIndex, aRightParenIndex);
				} else if (aStoredToken.startsWith("private")) {
					setSharedOrPrivateData((OMPSNode) lastChild, aStoredToken, aLeftParenIndex, aRightParenIndex,
							false);

				} else if (aStoredToken.startsWith("shared")) {
					setSharedOrPrivateData(lastChild, aStoredToken, aLeftParenIndex, aRightParenIndex, true);

				}

			}

			lastChild.getOpenMPTokens().add(aStoredToken);
		}

		return lastChild;

	}

	public static boolean hasParallelAncestor(SNode anSNode) {
		if (anSNode == null) {
			return false;
		}
		if (anSNode instanceof OMPParallelSNode) {
			return true;
		}
		return hasParallelAncestor(anSNode.getParent());
	}
	public static boolean hasCriticalAncestor(SNode anSNode) {
		if (anSNode == null) {
			return false;
		}
		if (anSNode instanceof OMPCriticalSNode) {
			return true;
		}
		return hasCriticalAncestor(anSNode.getParent());
	}


	public static Boolean isDeclaredShared(OMPSNode anOMPSNode, String anLHS) {
		if (Arrays.asList(anOMPSNode.getSharedVariables()).contains(anLHS)) {
			return true;
		}
		if (Arrays.asList(anOMPSNode.getPrivateVariables()).contains(anLHS)) {
			return false;
		}
		return null;

	}

	public static boolean isSharedVariable(SNode anSNode, String anLHS) {
		if (anSNode == null) {
			return false;
		}
		if (anSNode.getLocalVariables().contains(anLHS)) {
			if (!(anSNode instanceof OMPSNode)) { // no shared and private declarations
				return !hasParallelAncestor(anSNode); // shared if not inParallel
			}
			OMPSNode anOMPSNode = (OMPSNode) anSNode;
			return (Arrays.asList(anOMPSNode.getSharedVariables()).contains(anLHS)); // private unless declared shared
		}
		if (anSNode instanceof OMPSNode) {
			OMPSNode anOMPSNode = (OMPSNode) anSNode;
			// the variable is global to this scope, check if it has have been made shared
			// or private by this scope
			Boolean isDeclaredShared = isDeclaredShared(anOMPSNode, anLHS);
			if (isDeclaredShared != null) {
				return isDeclaredShared;
			}
		}
		// check the parent
		return isSharedVariable(anSNode.getParent(), anLHS);
	}

	public static List<SNode> getAllLeafNodes(SNode aTopNode) {
		List<SNode> retVal = new ArrayList();
		addLeafNodes(aTopNode, retVal);
		return retVal;
	}

	public static void addLeafNodes(SNode aTopNode, List<SNode> retVal) {
		for (SNode aChild : aTopNode.getChildren()) {
			if (aChild.isLeaf()) {
				retVal.add(aChild);
			} else {
				addLeafNodes(aChild, retVal);
			}
		}
	}

	public static List<SNode> getNonParallelLeafNodes(SNode aTopNode) {
		List<SNode> retVal = new ArrayList();
		addNonParallelLeafNodes(aTopNode, retVal);
		return retVal;
	}

	public static void addNonParallelLeafNodes(SNode aTopNode, List<SNode> retVal) {
		if (aTopNode.isInParallel()) {
			return;
		}
		for (SNode aChild : aTopNode.getChildren()) {
			if (aChild.isLeaf()) {
				retVal.add(aChild);
			} else {
				addLeafNodes(aChild, retVal);
			}
		}
	}
	static String callRegex = "([a-zA-Z_$][a-zA-Z_$0-9]*)\\(.*?\\)";
	static Pattern callPattern = Pattern.compile(callRegex);

	static String identifierRegex = "[a-zA-Z_$][a-zA-Z_$0-9]*";
	static Pattern identifierPattern = Pattern.compile(identifierRegex);
	public static List<String> identifiersIn(String aString) {
		if (aString == null)
			return null;
//		Pattern mypattern = Pattern.compile("[a-zA-Z_$][a-zA-Z_$0-9]*");
//		Matcher mymatcher = mypattern.matcher(aString);
		Matcher mymatcher = identifierPattern.matcher(aString);
		List<String> retVal = new ArrayList();
		while (mymatcher.find()) {
			String find = mymatcher.group(0);
			retVal.add(find);
		}
		return retVal;
	}
	public static List<MethodCall> callsIn(int aLineNumber, String aString, SNode aParent) {
		if (aString == null)
			return null;
//		Pattern mypattern = Pattern.compile("[a-zA-Z_$][a-zA-Z_$0-9]*");
//		Matcher mymatcher = mypattern.matcher(aString);
		Matcher mymatcher = callPattern.matcher(aString);
		List<MethodCall> retVal = new ArrayList();
		while (mymatcher.find()) {
			String find = mymatcher.group(0);
			int aLeftParenIndex = find.indexOf("(");
			int aRightParenIndex = find.indexOf(")");
			String aMethodName = find.substring(0, aLeftParenIndex).trim();
			String aParameters = find.substring(aLeftParenIndex + 1, aRightParenIndex);
			List<String> aParameterList = new ArrayList();
			String[] aParameterTokens = aParameters.split(",");
			for (String aParameter:aParameterTokens) {
				String aParameterTrimmed = aParameter.trim();
				if (!aParameterTrimmed.isEmpty())
				aParameterList.add(aParameterTrimmed);
			}
			retVal.add(new AMethodCall(aLineNumber, aMethodName, aParameterList, aParent));

//			aCallStrings.add(find);
		}
		return retVal;
	}
	static String numberRegex = "(\\d+\\.\\d+)|(\\d+)";
	static Pattern numberPattern = Pattern.compile(numberRegex);
	public static List<String> numbersIn(String aString) {
		if (aString == null)
			return null;
//		String regex = "(\\d+\\.\\d+)|(\\d+)";
//
//		Matcher m = Pattern.compile(regex).matcher(aString);
		Matcher m =numberPattern.matcher(aString);


		List<String> retVal = new ArrayList();

		while (m.find()) {
			retVal.add(m.group());
		}
		return retVal;
	}

	public static String subscriptIn(String aString) {
		if (aString == null)
			return null;
		return StringUtils.substringBetween(aString, "[", "]");
	}
	static String[] emptyStringArray = {};
	public static String[] subscriptsIn(String aString) {
		if (aString == null)
			return emptyStringArray;
		return StringUtils.substringsBetween(aString, "[", "]");
	}
	static  String operatorRegex = "([+-/*///^])|([/(/)])";
	static Pattern operatorPattern = Pattern.compile(operatorRegex);

	public static List<String> operatorsIn(String aString) {
		if (aString == null)
			return null;
//		String operatorRegex = "([+-/*///^])|([/(/)])";
//
//		Matcher m = Pattern.compile(operatorRegex).matcher(aString);
		
		Matcher m = operatorPattern.matcher(aString);


		List<String> retVal = new ArrayList();

		while (m.find()) {
			retVal.add(m.group());
		}
		return retVal;
	}
	
	public static int numberOfNestingFors (SNode anSNode) {
		if (anSNode == null) {
			return 0;
		}
		int retVal = numberOfNestingFors (anSNode.getParent()) ;

		if (anSNode instanceof ForSNode) {
			retVal++;
		} else if (anSNode instanceof MethodSNode) {
			List<MethodCall> aMethodCalls = ((MethodSNode) anSNode).getCalls();
			int aMaxNestingLevel = 0;
			for (MethodCall aMethodCall:aMethodCalls) {
				MethodSNode aCallerMethodSNode = getDeclarationOfCalledMethod(anSNode, aMethodCall);
				int aCallerNumberOfNestingFors = numberOfNestingFors(aCallerMethodSNode);
				aMaxNestingLevel = Math.max(aCallerNumberOfNestingFors, aMaxNestingLevel);				
			}
			return retVal + aMaxNestingLevel;
		}
		return retVal;
	}
	public static boolean hasOperator (SNode anSNode, String anOperator) {
		boolean retVal = false;
		if (anSNode instanceof AssignmentSNode) {
			AssignmentSNode anAssignmentSNode = (AssignmentSNode) anSNode;
			 retVal = (anAssignmentSNode.getLhsOperators().contains(anOperator) || 
					anAssignmentSNode.getRhsOperators().contains(anOperator)) ;
			if (retVal) {
				return retVal;
			} else {
				List<MethodCall> aMethodCalls = anAssignmentSNode.getRhsCalls();
				for (MethodCall aMethodCall:aMethodCalls) {
					MethodSNode aMethodSNode = getDeclarationOfCalledMethod(anSNode, aMethodCall);
					retVal = hasOperator(aMethodSNode, anOperator);
					if (retVal) {
						return retVal;
					}
					
				}
				return false;
			}
			
		}
		for (SNode aChild:anSNode.getChildren()) {
			retVal = hasOperator(aChild, anOperator);
			if (retVal) {
				return retVal;
			}
		}
		return false;
	}
	public static boolean hasMethodCall (SNode anSNode, String anOperator) {
		boolean retVal = false;
		if (anSNode instanceof AssignmentSNode) {
			AssignmentSNode anAssignmentSNode = (AssignmentSNode) anSNode;
			 retVal = (anAssignmentSNode.getLhsOperators().contains(anOperator) || 
					anAssignmentSNode.getRhsOperators().contains(anOperator)) ;
			if (retVal) {
				return retVal;
			} else {
				List<MethodCall> aMethodCalls = anAssignmentSNode.getRhsCalls();
				for (MethodCall aMethodCall:aMethodCalls) {
					MethodSNode aMethodSNode = getDeclarationOfCalledMethod(anSNode, aMethodCall);
					retVal = hasOperator(aMethodSNode, anOperator);
					if (retVal) {
						return retVal;
					}
					
				}
				return false;
			}
			
		}
		for (SNode aChild:anSNode.getChildren()) {
			retVal = hasOperator(aChild, anOperator);
			if (retVal) {
				return retVal;
			}
		}
		return false;
	}
	public static boolean dependsOn (AssignmentSNode anAssignmentSNode, String aVariable, String aCallIdentifier) {
		// This assignment does not change aVariable
		if (!aVariable.equals(anAssignmentSNode.getLhsVariable())) {
			return false;
		}
		return dependsOn(anAssignmentSNode.getExpressionSNode(), aCallIdentifier);
//		List<String> aCallIdentifiers = anAssignmentSNode.getRhsCallIdentifiers();
//		boolean retVal = false;
//		if (aCallIdentifiers != null && aCallIdentifiers.contains(aCallIdentifier)) {
//			return true; // this assignment has aCallIdentifier in the rhs
//		}
//		// check if some referenced rhs variable depends on aCallIdentifier
//		List<String> aReferencedVariableIdentifiers = anAssignmentSNode.getRhsVariableIdentifiers();
//		SNode anAssignmentParent = anAssignmentSNode.getParent();
//		if (anAssignmentParent == null) { // should never be trye
//			return false;
//		}
//		int aLineNumber = anAssignmentSNode.getLineNumber();
//		for (String aReferencedVariableIdentifier:aReferencedVariableIdentifiers ) {
//			if (dependsOn (anAssignmentParent, aLineNumber, aReferencedVariableIdentifier, aCallIdentifier)) {
//				return true;
//			}
//		}
//		return false;
	}
	public static boolean dependsOn (ExpressionSNode anExpressionSNode, String aCallIdentifier) {
		// This assignment does not change aVariable
		
		List<String> aCallIdentifiers = anExpressionSNode.getRhsCallIdentifiers();
		boolean retVal = false;
		if (aCallIdentifiers != null && aCallIdentifiers.contains(aCallIdentifier)) {
			return true; // this assignment has aCallIdentifier in the rhs
		}
		// check if some referenced rhs variable depends on aCallIdentifier
		List<String> aReferencedVariableIdentifiers = anExpressionSNode.getRhsVariableIdentifiers();
		SNode anAssignmentParent = anExpressionSNode.getParent().getParent();
		if (anAssignmentParent == null) { // should never be trye
			return false;
		}
		int aLineNumber = anExpressionSNode.getLineNumber();
		for (String aReferencedVariableIdentifier:aReferencedVariableIdentifiers ) {
			if (dependsOn (anAssignmentParent, aLineNumber, aReferencedVariableIdentifier, aCallIdentifier)) {
				return true;
			}
		}
		return false;
	}
	public static List<AssignmentSNode> assignmentsToSharedVariables(SNode anSNode) {
		List<AssignmentSNode> retVal =  new ArrayList();
		fillAssignmentsToShared(anSNode, retVal);
		return retVal;
		
	}
	public static List<AssignmentSNode> assignmentsToSharedArrays(SNode anSNode) {
		List<AssignmentSNode> anAllSharedAssignments =  assignmentsToSharedVariables(anSNode);
		List<AssignmentSNode> aRetVal = new ArrayList();
		for (AssignmentSNode anAssignmentSNode:anAllSharedAssignments) {
			if (anAssignmentSNode.getLhsSubscripts().length > 0) {
				aRetVal.add(anAssignmentSNode);
			}
		}
		return aRetVal;
		
	}
	public static List<AssignmentSNode> assignmentsToParallelSharedCritical(SNode anSNode) {
		List<AssignmentSNode> anAllSharedAssignments =  assignmentsToSharedVariables(anSNode);
		List<AssignmentSNode> aRetVal = new ArrayList();
		for (AssignmentSNode anAssignmentSNode:anAllSharedAssignments) {
			if (anAssignmentSNode.isInParallel() &&
					anAssignmentSNode.isInCritical()) {
				aRetVal.add(anAssignmentSNode);
			}
		}
		return aRetVal;
		
	}
    public static void fillAssignmentsToShared(SNode anSNode, List<AssignmentSNode> retVal) {
    	if (anSNode instanceof AssignmentSNode) {
			AssignmentSNode anAssignmentSNode = (AssignmentSNode) anSNode;
			String anLHS = anAssignmentSNode.getLhsVariable();
			if (isSharedVariable(anSNode, anLHS)) {
				retVal.add(anAssignmentSNode);
				return;
			}
		}
    	for (SNode aChild:anSNode.getChildren()) {
    		fillAssignmentsToShared(aChild, retVal);
    	}
		
	}
	public static boolean dependsOn (SNode anSNode, int aVariableLineNumber, String aVariable, String aCallIdentifier) {
		List<SNode> aListSNodes = anSNode.getChildren();
		boolean retVal = false;
		/*
		 * Should probably ignore line number as it assumes straight line code
		 */
		for (int i = aVariableLineNumber; i >= 0; i--) {
			SNode anSNodeChild = aListSNodes.get(i);
			if (anSNodeChild instanceof AssignmentSNode) {
				// does this statement in anSNode directly invoke aCallIdentifier 
				if (dependsOn((AssignmentSNode) anSNodeChild, aVariable, aCallIdentifier))
					return true;
			} else if (!anSNode.isLeaf()) {
					// child is overriding the variable so forget checking its assignment statements
					if (anSNodeChild.getLocalVariables().contains(aVariable)) {
						continue;
					}
					// some subblock of anSNode that has access to aVariable changes variable

					if (dependsOn(anSNodeChild, anSNodeChild.getChildren().size() - 1, aVariable, aCallIdentifier)) {
						return true;
					}
			}
			
		}
		// none of the statements in anSNode or its descendents  have the required call
		// is the variable a  method parameter 
		if (anSNode instanceof MethodSNode) {
			MethodSNode aMethodSNode = (MethodSNode) anSNode;
			
			int aParameterNumber = aMethodSNode.getLocalVariables().indexOf(aVariable);
			if (aParameterNumber != -1) {
				List <MethodCall> aCalls = aMethodSNode.getCalls();
				for (MethodCall aCall:aCalls) {
					MethodSNode aCallerSNode = getDeclarationOfCalledMethod(aMethodSNode, aCall);
					boolean aCallerDepends = dependsOn(aMethodSNode, aCallerSNode.getLineNumber(), aVariable, aCallIdentifier);
				    if (aCallerDepends) {
				    	return true;
				    }
				}
				return false;
				// need to find all callers of method and see if any of the aliases for the variable in these
				// calls depend on aCallIndentifier
			}			
			
		} else if (anSNode.getLocalVariables().contains(aVariable)) {
			// before going to the parent node, let us see if aVariable is declared here as a non  parameter 

			return false; // no point going to parent
		}
		// not a local variable (parameter or declarated variable)
		SNode anSNodeParent = anSNode.getParent() ;
		if (anSNodeParent == null)  {
			return false;
		}
		int anSNodeLineNumber = anSNodeParent.getChildren().indexOf(anSNode);
		return dependsOn(anSNodeParent, anSNodeLineNumber, aVariable, aCallIdentifier);
		
	}
	public static RootOfFileSNode getRootOfFileNode(SNode aCurrentSNode ) {
		if (aCurrentSNode instanceof RootOfFileSNode) {
			return (RootOfFileSNode) aCurrentSNode;
		}
		SNode aParentSNode = aCurrentSNode.getParent() ;
		
		if (aParentSNode == null) {
			return null;
		}
		
		return getRootOfFileNode(aParentSNode);
		
	}
	public static boolean match (MethodSNode aMethodSNode, MethodCall aMethodCall) {
		return aMethodSNode.getMethodName().equals(aMethodCall.getMethodName()) 
				&& aMethodSNode.getLocalVariables().size() == aMethodCall.getMethodActuals().size();
	}
	
	public static MethodSNode getDeclarationOfCalledMethod(SNode aCurrentSNode, MethodCall aMethodCall ) {
		SNode aRootNode = getRootOfFileNode(aCurrentSNode);
		for (SNode aChild:aRootNode.getChildren()) {
			if (aChild instanceof MethodSNode) {
				MethodSNode aMethodSNode = (MethodSNode) aChild;
				if (match (aMethodSNode, aMethodCall)) {
					return aMethodSNode;
				}
			}
		}
		return null; // this should never happen;
	}
	
	public static RootOfProgramSNode getRootOfProgramSNode(String aSource) {
		RootOfProgramSNode retVal = new ARootOfProgramSNode();
		Map<String, StringBuffer> aFileNameToContents = ABasicTextManager.extractFileContents(aSource);
		for (String aFileName:aFileNameToContents.keySet()) {
			StringBuffer aFileContents = aFileNameToContents.get(aFileName);
//			List<OpenMPPragma> anOpenMPPragmas = OpenMPUtils.getOpemMPPragmas(aFileContents);
			RootOfFileSNode anSNode = OMPSNodeUtils.getSNode(aFileName, aFileContents);
			retVal.getFileNameToSNode().put(aFileName, anSNode);
			anSNode.setParent(retVal);
//			System.out.println("file name:" + aFileName);
//			System.out.println("pragmas:" + anSNode);
		}
		processExternalMethodSNodes(retVal);
		return retVal;
	}
	public static void processExternalMethodSNodes (RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode) {
		for (SNode anSNode:aRootOfFileSNode.getChildren()) {
			if (anSNode instanceof ExternalMethodSNode) {
				processExternalMethodSNode(aRootOfProgramSNode, aRootOfFileSNode, (ExternalMethodSNode) anSNode);
			}
		}
	}
	public static void processExternalMethodSNode (RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode, ExternalMethodSNode anExternalMethodSNode) {
		MethodSNode aMethodSNode = aRootOfProgramSNode.getExternalToInternalMethod().get(anExternalMethodSNode.toString());
		if (aMethodSNode == null) {
			aMethodSNode = findMethodSNode(aRootOfProgramSNode, aRootOfFileSNode, anExternalMethodSNode);
			if (aMethodSNode != null) {
				aRootOfProgramSNode.getExternalToInternalMethod().put(anExternalMethodSNode.toString(),aMethodSNode );
			}
		}
		if (aMethodSNode != null) {
			anExternalMethodSNode.setActualMethodSNode(aMethodSNode);
			aMethodSNode.getCalls().addAll(anExternalMethodSNode.getLocalCalls());
		}
	}
	public static MethodSNode findMethodSNode (RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode, ExternalMethodSNode anExternalMethodSNode) {
//		MethodSNode foundMethodSNode = null;
		for (String aFileName:aRootOfProgramSNode.getFileNameToSNode().keySet()) {
			if (aFileName.equals(aRootOfFileSNode.getFileName()))
				continue;
			
			RootOfFileSNode aSearchedRootOfFileSNode = aRootOfProgramSNode.getFileNameToSNode().get(aFileName);
			 for (SNode anSNode:aSearchedRootOfFileSNode.getChildren()) {
				if (anSNode instanceof MethodSNode && !(anSNode instanceof ExternalMethodSNode)) {
					if (anSNode.toString().equals(anExternalMethodSNode.toString())) {
						return (MethodSNode) anSNode;
						
					}
//					processExternalMethodSNode(aRootOfProgramSNode, aRootOfFileSNode, (ExternalMethodSNode) anSNode);
				}
			}
		}
		return null;
	}
	public static void processExternalMethodSNodes (RootOfProgramSNode aRootOfProgramSNode) {
		for (String aFileName:aRootOfProgramSNode.getFileNameToSNode().keySet()) {
			RootOfFileSNode aRootOfFileSNode = aRootOfProgramSNode.getFileNameToSNode().get(aFileName);
			processExternalMethodSNodes(aRootOfProgramSNode, aRootOfFileSNode);
			aRootOfFileSNode.getOmp_get_num_threads_SNode().
				setActualMethodSNode(aRootOfProgramSNode.getOmp_get_num_threads_SNode());
			aRootOfFileSNode.getOmp_get_thread_num_SNode().
				setActualMethodSNode(aRootOfProgramSNode.getOmp_get_thread_num_SNode());
			aRootOfFileSNode.getOmp_get_wtime_SNode().
			setActualMethodSNode(aRootOfProgramSNode.getOmp_get_wtime_SNode());
		}

	}
	

//	public static void main(String[] args) {
//		List<MethodCall> aTokens = callsIn("foo(bar, hgf)/foo2()*foo3(b, a c,)");
//		System.out.println(aTokens);
//		
//		
////		List<String> aTokens = identifiersIn("a[i] + b*2/3");
////		System.out.println(aTokens);
////		aTokens = numbersIn("a[i] + b*2/3");
////		System.out.println(aTokens);
////		aTokens = operatorsIn("a[i] + b*2/3");
////		System.out.println(aTokens);
////
////		System.out.println(StringUtils.substringBetween("a", "[", "]"));
//	}

}
]]></snapshot>
  </Command>
  <Command __id="184556" _type="DiffBasedFileOpenCommand" date="Mon Dec 30 10:05:34 EST 2019" docASTNodeCount="403" docActiveCodeLength="2919" docExpressionCount="311" docLength="5670" projectName="DemoCourseLocalBasicChecks" starttimestamp="1576666505112" timestamp="1051829193">
    <filePath><![CDATA[D:\dewan_backup\Java\DemoCourseLocalBasicChecks\src\gradingTools\comp123\assignment1\openmp\testcases\SequentialSumTestCase.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package gradingTools.comp123.assignment1.openmp.testcases;¶¶import java.util.Arrays;¶import java.util.List;¶import java.util.Map;¶import java.util.regex.Pattern;¶¶import grader.basics.execution.NotRunnableException;¶import grader.basics.execution.RunningProject;¶import grader.basics.junit.NotAutomatableException;¶import grader.basics.junit.TestCaseResult;¶import grader.basics.project.NotGradableException;¶import grader.basics.project.Project;¶import grader.basics.project.source.ABasicTextManager;¶import grader.basics.testcase.PassFailJUnitTestCase;¶import gradingTools.shared.testcases.SubstringSequenceChecker;¶import gradingTools.shared.testcases.openmp.OpenMPPragma;¶import gradingTools.shared.testcases.openmp.OpenMPUtils;¶import gradingTools.shared.testcases.openmp.scannedTree.AssignmentSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.ExternalMethodSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.MethodSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.OMPSNodeUtils;¶import gradingTools.shared.testcases.openmp.scannedTree.RootOfFileSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.RootOfProgramSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.SNode;¶import gradingTools.shared.testcases.utils.LinesMatchKind;¶import gradingTools.shared.testcases.utils.LinesMatcher;¶import gradingTools.utils.RunningProjectUtils;¶¶public class SequentialSumTestCase extends PassFailJUnitTestCase {¶	public static final int TIME_OUT_SECS = 1; // secs¶	protected SubstringSequenceChecker checker = new ASequentialSumChecker();	¶¶	public SequentialSumTestCase() {¶	}¶¶	¶¶	@Override¶	public TestCaseResult test(Project project, boolean autoGrade) throws NotAutomatableException,¶			NotGradableException {¶		try {¶			RunningProject aRunningProject = RunningProjectUtils.runProject(project, TIME_OUT_SECS);¶			String anOutput = aRunningProject.await();¶			LinesMatcher aLinesMatcher = aRunningProject.getLinesMatcher();¶			boolean aRetval = checker.check(aLinesMatcher, LinesMatchKind.ONE_TIME_LINE, Pattern.DOTALL);¶			String aSource = project.getSource();¶//			Map<String, StringBuffer> aFileNameToContents = ABasicTextManager.extractFileContents(aSource);¶//			for (String aFileName:aFileNameToContents.keySet()) {¶//				StringBuffer aFileContents = aFileNameToContents.get(aFileName);¶////				List<OpenMPPragma> anOpenMPPragmas = OpenMPUtils.getOpemMPPragmas(aFileContents);¶//				SNode anSNode = OMPSNodeUtils.getSNode(aFileName, aFileContents);¶//				System.out.println("file name:" + aFileName);¶//				System.out.println("pragmas:" + anSNode);¶//			}¶			RootOfProgramSNode aRootOfProgramSNode = OMPSNodeUtils.getRootOfProgramSNode(aSource);¶			List<AssignmentSNode> anAssignments = OMPSNodeUtils.assignmentsToSharedVariables(aRootOfProgramSNode);¶			anAssignments = OMPSNodeUtils.assignmentsToSharedArrays(aRootOfProgramSNode);¶"), Diff(INSERT,"			anAssignments = OMPSNodeUtils.assignmentsToParallelSharedCritical(aRootOfProgramSNode);¶¶"), Diff(EQUAL,"			String anExpectedLines = Arrays.toString(checker.getSubstrings());¶¶			if (!aRetval) {¶				return fail("Output  did not match:" + anExpectedLines);¶¶			}¶			return pass();¶			¶¶		} catch (NotRunnableException e) {¶			throw new NotGradableException();¶		}¶	}¶//	public static void processExternalMethodSNodes (RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode) {¶//		for (SNode anSNode:aRootOfFileSNode.getChildren()) {¶//			if (anSNode instanceof ExternalMethodSNode) {¶//				processExternalMethodSNode(aRootOfProgramSNode, aRootOfFileSNode, (ExternalMethodSNode) anSNode);¶//			}¶//		}¶//	}¶//	public static void processExternalMethodSNode (RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode, ExternalMethodSNode anExternalMethodSNode) {¶//		MethodSNode aMethodSNode = aRootOfProgramSNode.getExternalToInternalMethod().get(anExternalMethodSNode.toString());¶//		if (aMethodSNode == null) {¶//			aMethodSNode = findMethodSNode(aRootOfProgramSNode, aRootOfFileSNode, anExternalMethodSNode);¶//			if (aMethodSNode != null) {¶//				aRootOfProgramSNode.getExternalToInternalMethod().put(anExternalMethodSNode.toString(),aMethodSNode );¶//			}¶//		}¶//		if (aMethodSNode != null) {¶//			anExternalMethodSNode.setActualMethodSNode(aMethodSNode);¶//		}¶//	}¶//	public static MethodSNode findMethodSNode (RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode, ExternalMethodSNode anExternalMethodSNode) {¶////		MethodSNode foundMethodSNode = null;¶//		for (String aFileName:aRootOfProgramSNode.getFileNameToSNode().keySet()) {¶//			if (aFileName.equals(aRootOfFileSNode.getFileName()))¶//				continue;¶//			¶//			RootOfFileSNode aSearchedRootOfFileSNode = aRootOfProgramSNode.getFileNameToSNode().get(aFileName);¶//			 for (SNode anSNode:aSearchedRootOfFileSNode.getChildren()) {¶//				if (anSNode instanceof MethodSNode && !(anSNode instanceof ExternalMethodSNode)) {¶//					if (anSNode.toString().equals(anExternalMethodSNode)) {¶//						return (MethodSNode) anSNode;¶//						¶//					}¶////					processExternalMethodSNode(aRootOfProgramSNode, aRootOfFileSNode, (ExternalMethodSNode) anSNode);¶//				}¶//			}¶//		}¶//		return null;¶//	}¶//	public static void processExternalMethodSNodes (RootOfProgramSNode aRootOfProgramSNode) {¶//		for (String aFileName:aRootOfProgramSNode.getFileNameToSNode().keySet()) {¶//			RootOfFileSNode aRootOfFileSNode = aRootOfProgramSNode.getFileNameToSNode().get(aFileName);¶//			processExternalMethodSNodes(aRootOfProgramSNode, aRootOfFileSNode);¶//			¶//		}¶//¶//	}¶}¶")]]]></diff>
    <snapshot><![CDATA[package gradingTools.comp123.assignment1.openmp.testcases;

import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.regex.Pattern;

import grader.basics.execution.NotRunnableException;
import grader.basics.execution.RunningProject;
import grader.basics.junit.NotAutomatableException;
import grader.basics.junit.TestCaseResult;
import grader.basics.project.NotGradableException;
import grader.basics.project.Project;
import grader.basics.project.source.ABasicTextManager;
import grader.basics.testcase.PassFailJUnitTestCase;
import gradingTools.shared.testcases.SubstringSequenceChecker;
import gradingTools.shared.testcases.openmp.OpenMPPragma;
import gradingTools.shared.testcases.openmp.OpenMPUtils;
import gradingTools.shared.testcases.openmp.scannedTree.AssignmentSNode;
import gradingTools.shared.testcases.openmp.scannedTree.ExternalMethodSNode;
import gradingTools.shared.testcases.openmp.scannedTree.MethodSNode;
import gradingTools.shared.testcases.openmp.scannedTree.OMPSNodeUtils;
import gradingTools.shared.testcases.openmp.scannedTree.RootOfFileSNode;
import gradingTools.shared.testcases.openmp.scannedTree.RootOfProgramSNode;
import gradingTools.shared.testcases.openmp.scannedTree.SNode;
import gradingTools.shared.testcases.utils.LinesMatchKind;
import gradingTools.shared.testcases.utils.LinesMatcher;
import gradingTools.utils.RunningProjectUtils;

public class SequentialSumTestCase extends PassFailJUnitTestCase {
	public static final int TIME_OUT_SECS = 1; // secs
	protected SubstringSequenceChecker checker = new ASequentialSumChecker();	

	public SequentialSumTestCase() {
	}

	

	@Override
	public TestCaseResult test(Project project, boolean autoGrade) throws NotAutomatableException,
			NotGradableException {
		try {
			RunningProject aRunningProject = RunningProjectUtils.runProject(project, TIME_OUT_SECS);
			String anOutput = aRunningProject.await();
			LinesMatcher aLinesMatcher = aRunningProject.getLinesMatcher();
			boolean aRetval = checker.check(aLinesMatcher, LinesMatchKind.ONE_TIME_LINE, Pattern.DOTALL);
			String aSource = project.getSource();
//			Map<String, StringBuffer> aFileNameToContents = ABasicTextManager.extractFileContents(aSource);
//			for (String aFileName:aFileNameToContents.keySet()) {
//				StringBuffer aFileContents = aFileNameToContents.get(aFileName);
////				List<OpenMPPragma> anOpenMPPragmas = OpenMPUtils.getOpemMPPragmas(aFileContents);
//				SNode anSNode = OMPSNodeUtils.getSNode(aFileName, aFileContents);
//				System.out.println("file name:" + aFileName);
//				System.out.println("pragmas:" + anSNode);
//			}
			RootOfProgramSNode aRootOfProgramSNode = OMPSNodeUtils.getRootOfProgramSNode(aSource);
			List<AssignmentSNode> anAssignments = OMPSNodeUtils.assignmentsToSharedVariables(aRootOfProgramSNode);
			anAssignments = OMPSNodeUtils.assignmentsToSharedArrays(aRootOfProgramSNode);
			anAssignments = OMPSNodeUtils.assignmentsToParallelSharedCritical(aRootOfProgramSNode);

			String anExpectedLines = Arrays.toString(checker.getSubstrings());

			if (!aRetval) {
				return fail("Output  did not match:" + anExpectedLines);

			}
			return pass();
			

		} catch (NotRunnableException e) {
			throw new NotGradableException();
		}
	}
//	public static void processExternalMethodSNodes (RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode) {
//		for (SNode anSNode:aRootOfFileSNode.getChildren()) {
//			if (anSNode instanceof ExternalMethodSNode) {
//				processExternalMethodSNode(aRootOfProgramSNode, aRootOfFileSNode, (ExternalMethodSNode) anSNode);
//			}
//		}
//	}
//	public static void processExternalMethodSNode (RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode, ExternalMethodSNode anExternalMethodSNode) {
//		MethodSNode aMethodSNode = aRootOfProgramSNode.getExternalToInternalMethod().get(anExternalMethodSNode.toString());
//		if (aMethodSNode == null) {
//			aMethodSNode = findMethodSNode(aRootOfProgramSNode, aRootOfFileSNode, anExternalMethodSNode);
//			if (aMethodSNode != null) {
//				aRootOfProgramSNode.getExternalToInternalMethod().put(anExternalMethodSNode.toString(),aMethodSNode );
//			}
//		}
//		if (aMethodSNode != null) {
//			anExternalMethodSNode.setActualMethodSNode(aMethodSNode);
//		}
//	}
//	public static MethodSNode findMethodSNode (RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode, ExternalMethodSNode anExternalMethodSNode) {
////		MethodSNode foundMethodSNode = null;
//		for (String aFileName:aRootOfProgramSNode.getFileNameToSNode().keySet()) {
//			if (aFileName.equals(aRootOfFileSNode.getFileName()))
//				continue;
//			
//			RootOfFileSNode aSearchedRootOfFileSNode = aRootOfProgramSNode.getFileNameToSNode().get(aFileName);
//			 for (SNode anSNode:aSearchedRootOfFileSNode.getChildren()) {
//				if (anSNode instanceof MethodSNode && !(anSNode instanceof ExternalMethodSNode)) {
//					if (anSNode.toString().equals(anExternalMethodSNode)) {
//						return (MethodSNode) anSNode;
//						
//					}
////					processExternalMethodSNode(aRootOfProgramSNode, aRootOfFileSNode, (ExternalMethodSNode) anSNode);
//				}
//			}
//		}
//		return null;
//	}
//	public static void processExternalMethodSNodes (RootOfProgramSNode aRootOfProgramSNode) {
//		for (String aFileName:aRootOfProgramSNode.getFileNameToSNode().keySet()) {
//			RootOfFileSNode aRootOfFileSNode = aRootOfProgramSNode.getFileNameToSNode().get(aFileName);
//			processExternalMethodSNodes(aRootOfProgramSNode, aRootOfFileSNode);
//			
//		}
//
//	}
}
]]></snapshot>
  </Command>
  <Command __id="184558" _type="RunCommand" date="Mon Dec 30 10:05:37 EST 2019" kind="StepInto" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="1051832380" type="Run" />
  <Command __id="184559" _type="RunCommand" date="Mon Dec 30 10:05:37 EST 2019" kind="StepInto" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="1051832391" type="Run" />
  <Command __id="184560" _type="DiffBasedFileOpenCommand" date="Mon Dec 30 10:05:59 EST 2019" docASTNodeCount="1" docActiveCodeLength="659" docExpressionCount="0" docLength="747" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="1051854749">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\my_sum_parallel_for_local_var.cpp]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"#include <iostream>¶#include <omp.h>¶¶using namespace std;¶¶void printSumWithTimes (int sum, int start, int end);¶void printNumThreads();¶void recordThreadIndex(int index);¶void sum_parallel_for_local_var(double* array, int size)¶{¶	cout << "sum_parallel_for_local_var\n";¶¶	double start = omp_get_wtime();¶¶	double sum = 0;¶¶	int a, b;¶//¶//	for (int i = 0; i < size; i++) {¶//			sum += array[i];¶//			recordThreadIndex(i);¶//	}¶¶    #pragma omp parallel shared (sum, start) private (a, b)¶	{¶		double local_sum = 0;¶¶		#pragma omp for¶		for(int i = 0; i < size; i++) {¶			local_sum += array[i];¶			recordThreadIndex(i);¶		}¶¶		#pragma omp critical¶		sum += local_sum;¶	}¶¶	double end = omp_get_wtime();¶¶	printSumWithTimes(sum, start, end);¶	¶}¶")]]]></diff>
  </Command>
  <Command __id="184561" _type="SelectTextCommand" caretOffset="493" date="Mon Dec 30 10:06:00 EST 2019" end="493" start="468" starttimestamp="1576666505112" timestamp="1051854950" />
  <Command __id="184562" _type="DiffBasedFileOpenCommand" date="Mon Dec 30 10:06:03 EST 2019" docASTNodeCount="1" docActiveCodeLength="453" docExpressionCount="0" docLength="453" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="1051858421">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\my_sum_sequential.cpp]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"#include <iostream>¶#include <omp.h>¶¶using namespace std;¶void printSumWithTimes(int sum, int start, int end);¶void printNumThreads();¶void recordThreadIndex(int index);¶void sum_sequential(double* array, int size) {¶¶	cout << "sum_sequential\n";¶¶	double start = omp_get_wtime();¶¶	double sum = 0;¶¶	for (int i = 0; i < size; i++) {¶		sum += array[i];¶		recordThreadIndex(i);¶	}¶¶	double end = omp_get_wtime();¶¶	printSumWithTimes(sum, start, end);¶}¶")]]]></diff>
  </Command>
  <Command __id="184563" _type="SelectTextCommand" caretOffset="280" date="Mon Dec 30 10:06:03 EST 2019" end="280" start="265" starttimestamp="1576666505112" timestamp="1051858608" />
  <Command __id="184564" _type="DiffBasedFileOpenCommand" date="Mon Dec 30 10:06:10 EST 2019" docASTNodeCount="1" docActiveCodeLength="795" docExpressionCount="0" docLength="795" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="1051865707">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\my_sum_parallel.cpp]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"#include <iostream>¶#include <omp.h>¶¶using namespace std;¶¶void printSumWithTimes(int sum, int start, int end);¶void printNumThreads();¶void recordThreadIndex(int index);¶void sum_parallel(double* array, int size) {¶	cout << "sum_parallel\n";¶¶	double start = omp_get_wtime();¶¶	double sum = 0;¶¶¶    #pragma omp critical¶	{¶	double sum = 0;¶	}¶    #pragma omp parallel¶	{¶		double local_sum = 0;¶¶		int rank = omp_get_thread_num();¶		int threads = omp_get_num_threads();¶¶		int start_index = (size/threads)*rank;¶		int end_index = (size/threads)*(rank+1);¶¶		if(rank==threads-1)¶			end_index=size;¶¶		for(int i = start_index; i < end_index; i++)¶			local_sum += array[i];¶¶		#pragma omp critical¶		sum += local_sum;¶	}¶¶	double end = omp_get_wtime();¶¶	printSumWithTimes(sum, start, end);¶¶¶}¶")]]]></diff>
  </Command>
  <Command __id="184565" _type="SelectTextCommand" caretOffset="471" date="Mon Dec 30 10:06:11 EST 2019" end="471" start="450" starttimestamp="1576666505112" timestamp="1051865905" />
  <Command __id="184566" _type="DiffBasedFileOpenCommand" date="Mon Dec 30 10:06:31 EST 2019" docASTNodeCount="1" docActiveCodeLength="532" docExpressionCount="0" docLength="575" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="1051886444">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\my_sum_parallel_for_reduction.cpp]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"#include <iostream>¶#include <omp.h>¶¶using namespace std;¶¶//const int SIZE = 1000;¶void printSumWithTimes(int sum, int start, int end);¶void printNumThreads();¶void recordThreadIndex(int index);¶void sum_parallel_for_reduction(double* array, int size) {¶	cout << "sum_parallel_for_reduction\n";¶¶	double start = omp_get_wtime();¶¶	double sum = 0;¶    #pragma omp  parallel for reduction ( + : sum )¶//	#pragma omp  for¶¶	for (int i = 0; i < size; i++) {¶		sum += array[i];¶		recordThreadIndex(i);¶	}¶¶	double end = omp_get_wtime();¶¶	printSumWithTimes(sum, start, end);¶¶}¶")]]]></diff>
  </Command>
  <Command __id="184567" _type="MoveCaretCommand" caretOffset="379" date="Mon Dec 30 10:06:31 EST 2019" docOffset="379" starttimestamp="1576666505112" timestamp="1051886654" />
  <Command __id="184568" _type="DiffBasedFileOpenCommand" date="Mon Dec 30 10:06:41 EST 2019" docASTNodeCount="1" docActiveCodeLength="659" docExpressionCount="0" docLength="747" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="1051896471">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\my_sum_parallel_for_local_var.cpp]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"#include <iostream>¶#include <omp.h>¶¶using namespace std;¶¶void printSumWithTimes (int sum, int start, int end);¶void printNumThreads();¶void recordThreadIndex(int index);¶void sum_parallel_for_local_var(double* array, int size)¶{¶	cout << "sum_parallel_for_local_var\n";¶¶	double start = omp_get_wtime();¶¶	double sum = 0;¶¶	int a, b;¶//¶//	for (int i = 0; i < size; i++) {¶//			sum += array[i];¶//			recordThreadIndex(i);¶//	}¶¶    #pragma omp parallel shared (sum, start) private (a, b)¶	{¶		double local_sum = 0;¶¶		#pragma omp for¶		for(int i = 0; i < size; i++) {¶			local_sum += array[i];¶			recordThreadIndex(i);¶		}¶¶		#pragma omp critical¶		sum += local_sum;¶	}¶¶	double end = omp_get_wtime();¶¶	printSumWithTimes(sum, start, end);¶	¶}¶")]]]></diff>
  </Command>
  <Command __id="184569" _type="SelectTextCommand" caretOffset="493" date="Mon Dec 30 10:06:41 EST 2019" end="493" start="468" starttimestamp="1576666505112" timestamp="1051896642" />
  <Command __id="184570" _type="DiffBasedFileOpenCommand" date="Mon Dec 30 10:06:52 EST 2019" docASTNodeCount="1" docActiveCodeLength="453" docExpressionCount="0" docLength="453" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="1051907794">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\my_sum_sequential.cpp]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"#include <iostream>¶#include <omp.h>¶¶using namespace std;¶void printSumWithTimes(int sum, int start, int end);¶void printNumThreads();¶void recordThreadIndex(int index);¶void sum_sequential(double* array, int size) {¶¶	cout << "sum_sequential\n";¶¶	double start = omp_get_wtime();¶¶	double sum = 0;¶¶	for (int i = 0; i < size; i++) {¶		sum += array[i];¶		recordThreadIndex(i);¶	}¶¶	double end = omp_get_wtime();¶¶	printSumWithTimes(sum, start, end);¶}¶")]]]></diff>
  </Command>
  <Command __id="184571" _type="SelectTextCommand" caretOffset="280" date="Mon Dec 30 10:06:53 EST 2019" end="280" start="265" starttimestamp="1576666505112" timestamp="1051907956" />
  <Command __id="184572" _type="DiffBasedFileOpenCommand" date="Mon Dec 30 10:06:58 EST 2019" docASTNodeCount="1" docActiveCodeLength="795" docExpressionCount="0" docLength="795" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="1051913834">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\my_sum_parallel.cpp]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"#include <iostream>¶#include <omp.h>¶¶using namespace std;¶¶void printSumWithTimes(int sum, int start, int end);¶void printNumThreads();¶void recordThreadIndex(int index);¶void sum_parallel(double* array, int size) {¶	cout << "sum_parallel\n";¶¶	double start = omp_get_wtime();¶¶	double sum = 0;¶¶¶    #pragma omp critical¶	{¶	double sum = 0;¶	}¶    #pragma omp parallel¶	{¶		double local_sum = 0;¶¶		int rank = omp_get_thread_num();¶		int threads = omp_get_num_threads();¶¶		int start_index = (size/threads)*rank;¶		int end_index = (size/threads)*(rank+1);¶¶		if(rank==threads-1)¶			end_index=size;¶¶		for(int i = start_index; i < end_index; i++)¶			local_sum += array[i];¶¶		#pragma omp critical¶		sum += local_sum;¶	}¶¶	double end = omp_get_wtime();¶¶	printSumWithTimes(sum, start, end);¶¶¶}¶")]]]></diff>
  </Command>
  <Command __id="184573" _type="MoveCaretCommand" caretOffset="297" date="Mon Dec 30 10:06:59 EST 2019" docOffset="297" starttimestamp="1576666505112" timestamp="1051914005" />
  <Command __id="184574" _type="DiffBasedFileOpenCommand" date="Mon Dec 30 10:07:19 EST 2019" docASTNodeCount="1" docActiveCodeLength="532" docExpressionCount="0" docLength="575" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="1051933970">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\my_sum_parallel_for_reduction.cpp]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"#include <iostream>¶#include <omp.h>¶¶using namespace std;¶¶//const int SIZE = 1000;¶void printSumWithTimes(int sum, int start, int end);¶void printNumThreads();¶void recordThreadIndex(int index);¶void sum_parallel_for_reduction(double* array, int size) {¶	cout << "sum_parallel_for_reduction\n";¶¶	double start = omp_get_wtime();¶¶	double sum = 0;¶    #pragma omp  parallel for reduction ( + : sum )¶//	#pragma omp  for¶¶	for (int i = 0; i < size; i++) {¶		sum += array[i];¶		recordThreadIndex(i);¶	}¶¶	double end = omp_get_wtime();¶¶	printSumWithTimes(sum, start, end);¶¶}¶")]]]></diff>
  </Command>
  <Command __id="184575" _type="MoveCaretCommand" caretOffset="379" date="Mon Dec 30 10:07:19 EST 2019" docOffset="379" starttimestamp="1576666505112" timestamp="1051934139" />
  <Command __id="184577" _type="SelectTextCommand" caretOffset="493" date="Mon Dec 30 10:07:50 EST 2019" end="493" start="468" starttimestamp="1576666505112" timestamp="1051965111" />
  <DocumentChange __id="185648" _type="Replace" date="Mon Dec 30 10:17:50 EST 2019" docASTNodeCount="423" docActiveCodeLength="3162" docExpressionCount="328" docLength="5913" endLine="61" insertionLength="47" int_docASTNodeCount="423" int_docActiveCodeLength="3115" int_docExpressionCount="328" int_docLength="5866" length="38" offset="3215" startLine="61" starttimestamp="1576666505112" timestamp="1052565661">
    <deletedText><![CDATA[assignmentsToParallelSharedNonCritical]]></deletedText>
    <insertedText><![CDATA[assignmentsToParallelNonCriticalSharedVariables]]></insertedText>
  </DocumentChange>
  <Command __id="185710" _type="RunCommand" date="Mon Dec 30 10:18:41 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="1052616506" type="Debug" />
  <Command __id="185711" _type="RunCommand" date="Mon Dec 30 10:18:41 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="1052616506" type="Debug" />
  <Command __id="185712" _type="RunCommand" date="Mon Dec 30 10:18:41 EST 2019" kind="HitBreakPoint" projectName="PL_Java" starttimestamp="1576666505112" timestamp="1052616506" type="Run" />
  <Command __id="185713" _type="DiffBasedFileOpenCommand" date="Mon Dec 30 10:18:44 EST 2019" docASTNodeCount="1" docActiveCodeLength="532" docExpressionCount="0" docLength="575" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="1052619204">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\my_sum_parallel_for_reduction.cpp]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"#include <iostream>¶#include <omp.h>¶¶using namespace std;¶¶//const int SIZE = 1000;¶void printSumWithTimes(int sum, int start, int end);¶void printNumThreads();¶void recordThreadIndex(int index);¶void sum_parallel_for_reduction(double* array, int size) {¶	cout << "sum_parallel_for_reduction\n";¶¶	double start = omp_get_wtime();¶¶	double sum = 0;¶    #pragma omp  parallel for reduction ( + : sum )¶//	#pragma omp  for¶¶	for (int i = 0; i < size; i++) {¶		sum += array[i];¶		recordThreadIndex(i);¶	}¶¶	double end = omp_get_wtime();¶¶	printSumWithTimes(sum, start, end);¶¶}¶")]]]></diff>
  </Command>
  <Command __id="185714" _type="MoveCaretCommand" caretOffset="379" date="Mon Dec 30 10:18:44 EST 2019" docOffset="379" starttimestamp="1576666505112" timestamp="1052619366" />
  <Command __id="185715" _type="DiffBasedFileOpenCommand" date="Mon Dec 30 10:18:57 EST 2019" docASTNodeCount="1" docActiveCodeLength="659" docExpressionCount="0" docLength="747" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="1052632557">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\my_sum_parallel_for_local_var.cpp]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"#include <iostream>¶#include <omp.h>¶¶using namespace std;¶¶void printSumWithTimes (int sum, int start, int end);¶void printNumThreads();¶void recordThreadIndex(int index);¶void sum_parallel_for_local_var(double* array, int size)¶{¶	cout << "sum_parallel_for_local_var\n";¶¶	double start = omp_get_wtime();¶¶	double sum = 0;¶¶	int a, b;¶//¶//	for (int i = 0; i < size; i++) {¶//			sum += array[i];¶//			recordThreadIndex(i);¶//	}¶¶    #pragma omp parallel shared (sum, start) private (a, b)¶	{¶		double local_sum = 0;¶¶		#pragma omp for¶		for(int i = 0; i < size; i++) {¶			local_sum += array[i];¶			recordThreadIndex(i);¶		}¶¶		#pragma omp critical¶		sum += local_sum;¶	}¶¶	double end = omp_get_wtime();¶¶	printSumWithTimes(sum, start, end);¶	¶}¶")]]]></diff>
  </Command>
  <Command __id="185716" _type="MoveCaretCommand" caretOffset="621" date="Mon Dec 30 10:18:57 EST 2019" docOffset="621" starttimestamp="1576666505112" timestamp="1052632683" />
  <Command __id="185717" _type="DiffBasedFileOpenCommand" date="Mon Dec 30 10:19:12 EST 2019" docASTNodeCount="1" docActiveCodeLength="795" docExpressionCount="0" docLength="795" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="1052647749">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\my_sum_parallel.cpp]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"#include <iostream>¶#include <omp.h>¶¶using namespace std;¶¶void printSumWithTimes(int sum, int start, int end);¶void printNumThreads();¶void recordThreadIndex(int index);¶void sum_parallel(double* array, int size) {¶	cout << "sum_parallel\n";¶¶	double start = omp_get_wtime();¶¶	double sum = 0;¶¶¶    #pragma omp critical¶	{¶	double sum = 0;¶	}¶    #pragma omp parallel¶	{¶		double local_sum = 0;¶¶		int rank = omp_get_thread_num();¶		int threads = omp_get_num_threads();¶¶		int start_index = (size/threads)*rank;¶		int end_index = (size/threads)*(rank+1);¶¶		if(rank==threads-1)¶			end_index=size;¶¶		for(int i = start_index; i < end_index; i++)¶			local_sum += array[i];¶¶		#pragma omp critical¶		sum += local_sum;¶	}¶¶	double end = omp_get_wtime();¶¶	printSumWithTimes(sum, start, end);¶¶¶}¶")]]]></diff>
  </Command>
  <Command __id="185718" _type="MoveCaretCommand" caretOffset="297" date="Mon Dec 30 10:19:13 EST 2019" docOffset="297" starttimestamp="1576666505112" timestamp="1052647922" />
  <Command __id="185719" _type="DiffBasedFileOpenCommand" date="Mon Dec 30 10:19:59 EST 2019" docASTNodeCount="1" docActiveCodeLength="659" docExpressionCount="0" docLength="747" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="1052694677">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\my_sum_parallel_for_local_var.cpp]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"#include <iostream>¶#include <omp.h>¶¶using namespace std;¶¶void printSumWithTimes (int sum, int start, int end);¶void printNumThreads();¶void recordThreadIndex(int index);¶void sum_parallel_for_local_var(double* array, int size)¶{¶	cout << "sum_parallel_for_local_var\n";¶¶	double start = omp_get_wtime();¶¶	double sum = 0;¶¶	int a, b;¶//¶//	for (int i = 0; i < size; i++) {¶//			sum += array[i];¶//			recordThreadIndex(i);¶//	}¶¶    #pragma omp parallel shared (sum, start) private (a, b)¶	{¶		double local_sum = 0;¶¶		#pragma omp for¶		for(int i = 0; i < size; i++) {¶			local_sum += array[i];¶			recordThreadIndex(i);¶		}¶¶		#pragma omp critical¶		sum += local_sum;¶	}¶¶	double end = omp_get_wtime();¶¶	printSumWithTimes(sum, start, end);¶	¶}¶")]]]></diff>
  </Command>
  <Command __id="185720" _type="MoveCaretCommand" caretOffset="621" date="Mon Dec 30 10:19:59 EST 2019" docOffset="621" starttimestamp="1576666505112" timestamp="1052694794" />
  <Command __id="185723" _type="DiffBasedFileOpenCommand" date="Mon Dec 30 10:20:14 EST 2019" docASTNodeCount="4116" docActiveCodeLength="29362" docExpressionCount="2589" docLength="33548" projectName="GraderBasics" starttimestamp="1576666505112" timestamp="1052709391">
    <filePath><![CDATA[D:\dewan_backup\Java\GraderBasics\src\gradingTools\shared\testcases\openmp\scannedTree\OMPSNodeUtils.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package gradingTools.shared.testcases.openmp.scannedTree;¶¶import java.util.ArrayList;¶import java.util.Arrays;¶import java.util.HashMap;¶import java.util.HashSet;¶import java.util.List;¶import java.util.Map;¶import java.util.Set;¶import java.util.Stack;¶import java.util.regex.Matcher;¶import java.util.regex.Pattern;¶¶import org.apache.commons.lang.StringUtils;¶¶import grader.basics.project.source.ABasicTextManager;¶import gradingTools.shared.testcases.openmp.OpenMPKeywordEnum;¶import gradingTools.shared.testcases.openmp.OpenMPParallelPragma;¶import gradingTools.shared.testcases.openmp.OpenMPUtils;¶import gradingTools.shared.testcases.openmp.scannedTree.ADeclarationSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.ADeclaringAssignmentSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.AForSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.ATextSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.AnAssignmentSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.AnOMPCriticalSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.AnOMPForSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.AnOMPParallelSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.AnOMPSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.AnSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.AssignmentSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.DeclarationSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.DeclaringAssignmentSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.ForSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.OMPForSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.OMPSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.SNode;¶¶public class OMPSNodeUtils extends OpenMPUtils {¶¶	public static RootOfFileSNode getSNode(String aFileName, StringBuffer aFileBuffer) {¶		String[] aFileLines = aFileBuffer.toString().split("\n");¶		return getSNode(aFileName, aFileLines);¶	}¶¶	public static AssignmentSNode getAssignmentSNode(int aLineNumber, String aString) {¶		if (aString == null) {¶			return null;¶		}¶		String[] aTokens = aString.split("=");¶		if (aTokens.length == 1) {¶			return new AnAssignmentSNode(aLineNumber, aTokens[0], null);¶		} else {¶		return new AnAssignmentSNode(aLineNumber, aTokens[0], aTokens[1]);¶		}¶	}¶¶	public static DeclarationSNode getDeclarationSNode(int aLineNumber, String aString) {¶		String[] aTokens = aString.split(" ");¶		return new ADeclarationSNode(aLineNumber, aTokens[0], aTokens[1]);¶	}¶¶	public static DeclaringAssignmentSNode getDeclaringAssignmentSNode(int aLineNumber, String aString) {¶		String[] anLHSAndRHS = aString.split("=");¶		String[] aTypeAndVariable = anLHSAndRHS[0].split(" ");¶		return new ADeclaringAssignmentSNode(aLineNumber, aTypeAndVariable[0], aTypeAndVariable[1], anLHSAndRHS[1]);¶	}¶¶	public static boolean isDeclaringAssignment(String aFileLine) {¶		return startsWithTypeName(aFileLine) && aFileLine.contains("=");¶	}¶	public static boolean isMethodDeclaration(String aFileLine) {¶		return startsWithTypeName(aFileLine) && ¶				aFileLine.contains("(") &&¶				!aFileLine.contains("=");¶	}¶	public static boolean isExternalMethodDeclaration(String aFileLine) {¶		return isMethodDeclaration(aFileLine) && aFileLine.endsWith(";");¶	}¶¶¶	public static boolean isVariableDeclaration(String aFileLine) {¶¶		return startsWithTypeName(aFileLine) && !aFileLine.contains("(");¶	}¶¶	public static boolean isAssignment(String aFileLine) {¶		return aFileLine.contains("=");¶	}¶¶	public static boolean isForNode(String aFileLine) {¶		return aFileLine.startsWith("for");¶	}¶¶	public static ForSNode getForSNode(int aLineNumber, String aFileLine) {¶¶		int aLeftParenIndex = aFileLine.indexOf("(");¶		int aRightParenIndex = aFileLine.indexOf(")");¶		if (aLeftParenIndex < 0 || aRightParenIndex < 0) {¶			return null;¶		}¶		String aHeaderString = aFileLine.substring(aLeftParenIndex + 1, aRightParenIndex);¶		String[] aForComponents = aHeaderString.split(";");¶		AssignmentSNode anAssignmentSNode = null;¶		String aForInitializaton = aForComponents[0];¶		if (!aForInitializaton.isEmpty() && aForInitializaton.contains("=")) {¶			if (isDeclaringAssignment(aForInitializaton)) {¶				anAssignmentSNode = getDeclaringAssignmentSNode(aLineNumber, aForInitializaton);¶			} else {¶				anAssignmentSNode = getAssignmentSNode(aLineNumber, aForInitializaton);¶			}¶¶		}		¶		return new AForSNode(aLineNumber, anAssignmentSNode, aForComponents[1], getAssignmentSNode(aLineNumber, aForComponents[2]));¶	}¶	static String[] emptyArray = {};¶	public static MethodSNode getMethodSNode(int aLineNumber, String aFileLine, boolean isInternal) {¶¶		int aLeftParenIndex = aFileLine.indexOf("(");¶		int aRightParenIndex = aFileLine.indexOf(")");¶		if (aLeftParenIndex < 0 || aRightParenIndex < 0) {¶			return null;¶		}¶		String aMethodNameAndType = aFileLine.substring(0, aLeftParenIndex);¶		String[] aMethodNameAndTypeTokens = aMethodNameAndType.split("\\s+"); ¶		¶		String aMethodParameters = aFileLine.substring(aLeftParenIndex +1 , aRightParenIndex);¶		String[] aMethodParameterTokens = aMethodParameters.isEmpty()?emptyArray:¶		 aMethodParameters.split(",");¶		¶//		String[] aMethodParameterTypes = new String[aMethodParameterTokens.length];¶//		String[] aMethodParameterNames = new String[aMethodParameterTokens.length];¶		List<DeclarationSNode> aDeclarationSNodeList = new ArrayList();¶		for (int i = 0; i < aMethodParameterTokens.length; i++ ) {¶			String[] aTypeAndName = aMethodParameterTokens[i].trim().split("\\s+");¶			if (aTypeAndName.length < 2) {¶				continue;¶			}¶			aDeclarationSNodeList.add(new ADeclarationSNode(aLineNumber, aTypeAndName[0].trim(), aTypeAndName[1].trim()));¶//			aMethodParameterTypes[i] = aTypeAndName[0].trim();¶//			aMethodParameterNames[i] = aTypeAndName[1].trim();¶		}¶		if (isInternal)¶//		return new AMethodSNode(aLineNumber, aMethodNameAndTypeTokens[0], aMethodNameAndTypeTokens[1], aMethodParameterTypes,aMethodParameterNames );¶			return new AMethodSNode(aLineNumber, aMethodNameAndTypeTokens[0], aMethodNameAndTypeTokens[1], aDeclarationSNodeList );¶		else¶			return new AnExternalMethodSNode(aLineNumber, aMethodNameAndTypeTokens[0], aMethodNameAndTypeTokens[1], aDeclarationSNodeList );¶	}¶¶	public static void setReductionData(OMPForSNode lastChild, String aStoredToken, int aLeftParenIndex,¶			int aRightParenIndex) {¶		int aColonIndex = aStoredToken.indexOf(":");¶		if (aLeftParenIndex != -1 && aRightParenIndex != -1 && aColonIndex != -1) {¶			String anOperationString = aStoredToken.substring(aLeftParenIndex + 1, aColonIndex).trim();¶			String aVariableString = aStoredToken.substring(aColonIndex + 1, aRightParenIndex).trim();¶			((OMPForSNode) lastChild).setReductionVariable(aVariableString);¶			((OMPForSNode) lastChild).setReductionOperation(anOperationString);¶		}¶	}¶¶	public static void setSharedOrPrivateData(OMPSNode lastChild, String aStoredToken, int aLeftParenIndex,¶			int aRightParenIndex, boolean isShared) {¶//		int aColonIndex = aStoredToken.indexOf(":");¶		if (aLeftParenIndex != -1 && aRightParenIndex != -1) {¶			String aVariableDeclarations = aStoredToken.substring(aLeftParenIndex + 1, aRightParenIndex);¶			String[] aVariables = aVariableDeclarations.split(",");¶			if (isShared) {¶				lastChild.setSharedVariables(aVariables);¶			} else {¶				lastChild.setPrivateVariables(aVariables);¶			}¶		}¶	}¶¶	public static RootOfFileSNode getSNode(String aFileName, String[] aFileLines) {¶		Stack<SNode> anSNodes = new Stack();¶¶		RootOfFileSNode retVal = new ARootOfFileSNode(aFileName);¶		anSNodes.add(retVal);¶		SNode previousHeaderNode = null;¶		for (int i = 0; i < aFileLines.length; i++) {¶			String aFileLine = aFileLines[i].trim();¶			if (!isCodeLine(aFileLine)) {¶				continue;¶			}¶			if (isForNode(aFileLine)) {¶				ForSNode aForSNode = getForSNode(i, aFileLine);¶				aForSNode.setParent(anSNodes.peek());¶//				anSNodes.push(aForSNode);¶				previousHeaderNode = aForSNode;¶				if (aFileLine.endsWith(")")) {¶					continue;¶				}¶			}¶			if (isExternalMethodDeclaration(aFileLine)) {¶				MethodSNode aMethodSNode = getMethodSNode(i, aFileLine, false);¶				aMethodSNode.setParent(anSNodes.peek());¶//				anSNodes.push(aForSNode);¶				previousHeaderNode = aMethodSNode;¶				if (aFileLine.endsWith(")")) {¶					continue;¶				}¶			}¶			if (isMethodDeclaration(aFileLine)) {¶				MethodSNode aMethodSNode = getMethodSNode(i, aFileLine, true);¶				aMethodSNode.setParent(anSNodes.peek());¶//				anSNodes.push(aForSNode);¶				previousHeaderNode = aMethodSNode;¶				if (aFileLine.endsWith(")")) {¶					continue;¶				}¶			}¶			if (isPragmaStart(aFileLine)) {¶				OMPSNode anOMPSNode = getOMPSNode(i, anSNodes.peek(), aFileLine);¶//				anSNodes.push(anOMPSNode);¶				previousHeaderNode = anOMPSNode;¶				continue;¶			}¶			if (isBlockStart(aFileLine)) {¶				SNode aBlockSNode = new AnSNode(i);¶				if (previousHeaderNode != null) {¶					aBlockSNode.setParent(previousHeaderNode);¶				} else {¶					aBlockSNode.setParent(anSNodes.peek());¶				}¶				anSNodes.push(aBlockSNode);¶				previousHeaderNode = null;¶				continue;¶			}¶//			} else ¶			if (isBlockEnd(aFileLine)) {¶				anSNodes.pop();¶				continue;¶			}¶			SNode aNewLeafNode = null;¶			if (isDeclaringAssignment(aFileLine)) {¶				aNewLeafNode = getDeclaringAssignmentSNode(i, aFileLine);¶¶			} else if (isAssignment(aFileLine)) {¶				aNewLeafNode = getAssignmentSNode(i, aFileLine);¶			} else if (isVariableDeclaration(aFileLine)) {¶				aNewLeafNode = getDeclarationSNode(i, aFileLine);¶			} else {¶				List<MethodCall> aCalls = callsIn(i, aFileLine, null); // parent will be assigned below¶				if (aCalls != null && aCalls.size() == 1) {¶					aNewLeafNode = aCalls.get(0);¶				} else {¶					aNewLeafNode = new ATextSNode(i, aFileLine);¶				}¶			}¶//			else {¶//				aNewLeafNode = new ATextSNode(i, aFileLine);¶//			}¶			if (previousHeaderNode != null) {¶				aNewLeafNode.setParent(previousHeaderNode);¶			} else {¶				aNewLeafNode.setParent(anSNodes.peek());¶			}¶¶		}¶¶		return retVal;¶	}¶¶	public static OMPSNode getOMPSNode(int aLineIndex, SNode aParentNode, String aFileLine) {¶		String[] aTokens = aFileLine.split("\\s+");¶		if (aTokens.length <= 2) {¶			return null;¶		}¶		if (!aTokens[1].equals("omp")) {¶			return null;¶		}¶		if (aTokens.length < 3) {¶			return null;¶		}¶		String aFirstToken = aTokens[2];¶		OpenMPKeywordEnum anOpenMPKeyword = stringToOpenMPKeyword.get(aFirstToken);¶//		List<OpenMPPragma> retVal = new ArrayList();¶		OMPSNode lastChild = null;¶		int aStartIndex = 2;¶		OMPSNode aNewNode = null;¶		OMPForSNode aForChild = null;¶		switch (anOpenMPKeyword) {¶		case PARALLEL:¶			aNewNode = new AnOMPParallelSNode(aLineIndex);¶¶			if (aTokens.length > 3 && aTokens[3].equals("for")) {¶				aForChild = new AnOMPForSNode(aLineIndex);¶				aForChild.setParent(aNewNode);¶¶				aStartIndex++;¶			}¶			break;¶		case FOR:¶			aNewNode = new AnOMPForSNode(aLineIndex);¶			;¶			break;¶		case CRITICAL:¶			aNewNode = new AnOMPCriticalSNode(aLineIndex);¶//			retVal.add (lastChild);¶			break;¶		default:¶			aNewNode = new AnOMPSNode(aLineIndex);¶¶		}¶¶		if (lastChild != null) {¶			aNewNode.setParent(lastChild);¶		} else {¶			aNewNode.setParent(aParentNode);¶		}¶		lastChild = aForChild == null ? aNewNode : aForChild;¶¶		for (int i = aStartIndex; i < aTokens.length; i++) {¶			String aStoredToken = aTokens[i].trim();¶			if (aStoredToken.isEmpty()) {¶				continue;¶			}¶			if (aStoredToken.startsWith("reduction") || aStoredToken.startsWith("shared")¶					|| aStoredToken.startsWith("private")) {¶				// combine all tokens until ")" into one for normalization¶				while (!aStoredToken.endsWith(")")) {¶					i++;¶					if (i >= aTokens.length) {¶						break;¶					}¶					String aNewToken = aTokens[i].trim();¶					aStoredToken += aNewToken;¶				}¶				int aLeftParenIndex = aStoredToken.indexOf("(");¶				int aRightParenIndex = aStoredToken.indexOf(")");¶				if (aStoredToken.startsWith("reduction")) {¶					setReductionData((OMPForSNode) lastChild, aStoredToken, aLeftParenIndex, aRightParenIndex);¶				} else if (aStoredToken.startsWith("private")) {¶					setSharedOrPrivateData((OMPSNode) lastChild, aStoredToken, aLeftParenIndex, aRightParenIndex,¶							false);¶¶				} else if (aStoredToken.startsWith("shared")) {¶					setSharedOrPrivateData(lastChild, aStoredToken, aLeftParenIndex, aRightParenIndex, true);¶¶				}¶¶			}¶¶			lastChild.getOpenMPTokens().add(aStoredToken);¶		}¶¶		return lastChild;¶¶	}¶¶	public static boolean hasParallelAncestor(SNode anSNode) {¶		if (anSNode == null) {¶			return false;¶		}¶		if (anSNode instanceof OMPParallelSNode) {¶			return true;¶		}¶		return hasParallelAncestor(anSNode.getParent());¶	}¶	public static boolean hasCriticalAncestor(SNode anSNode) {¶		if (anSNode == null) {¶			return false;¶		}¶		if (anSNode instanceof OMPCriticalSNode) {¶			return true;¶		}¶		return hasCriticalAncestor(anSNode.getParent());¶	}¶¶¶	public static Boolean isDeclaredShared(OMPSNode anOMPSNode, String anLHS) {¶		if (Arrays.asList(anOMPSNode.getSharedVariables()).contains(anLHS)) {¶			return true;¶		}¶		if (Arrays.asList(anOMPSNode.getPrivateVariables()).contains(anLHS)) {¶			return false;¶		}¶		return null;¶¶	}¶¶	public static boolean isSharedVariable(SNode anSNode, String anLHS) {¶		if (anSNode == null) {¶			return false;¶		}¶		if (anSNode.getLocalVariables().contains(anLHS)) {¶			if (!(anSNode instanceof OMPSNode)) { // no shared and private declarations¶				return !hasParallelAncestor(anSNode); // shared if not inParallel¶			}¶			OMPSNode anOMPSNode = (OMPSNode) anSNode;¶			return (Arrays.asList(anOMPSNode.getSharedVariables()).contains(anLHS)); // private unless declared shared¶		}¶		if (anSNode instanceof OMPSNode) {¶			OMPSNode anOMPSNode = (OMPSNode) anSNode;¶			// the variable is global to this scope, check if it has have been made shared¶			// or private by this scope¶			Boolean isDeclaredShared = isDeclaredShared(anOMPSNode, anLHS);¶			if (isDeclaredShared != null) {¶				return isDeclaredShared;¶			}¶		}¶		// check the parent¶		return isSharedVariable(anSNode.getParent(), anLHS);¶	}¶¶	public static List<SNode> getAllLeafNodes(SNode aTopNode) {¶		List<SNode> retVal = new ArrayList();¶		addLeafNodes(aTopNode, retVal);¶		return retVal;¶	}¶¶	public static void addLeafNodes(SNode aTopNode, List<SNode> retVal) {¶		for (SNode aChild : aTopNode.getChildren()) {¶			if (aChild.isLeaf()) {¶				retVal.add(aChild);¶			} else {¶				addLeafNodes(aChild, retVal);¶			}¶		}¶	}¶¶	public static List<SNode> getNonParallelLeafNodes(SNode aTopNode) {¶		List<SNode> retVal = new ArrayList();¶		addNonParallelLeafNodes(aTopNode, retVal);¶		return retVal;¶	}¶¶	public static void addNonParallelLeafNodes(SNode aTopNode, List<SNode> retVal) {¶		if (aTopNode.isInParallel()) {¶			return;¶		}¶		for (SNode aChild : aTopNode.getChildren()) {¶			if (aChild.isLeaf()) {¶				retVal.add(aChild);¶			} else {¶				addLeafNodes(aChild, retVal);¶			}¶		}¶	}¶	static String callRegex = "([a-zA-Z_$][a-zA-Z_$0-9]*)\\(.*?\\)";¶	static Pattern callPattern = Pattern.compile(callRegex);¶¶	static String identifierRegex = "[a-zA-Z_$][a-zA-Z_$0-9]*";¶	static Pattern identifierPattern = Pattern.compile(identifierRegex);¶	public static List<String> identifiersIn(String aString) {¶		if (aString == null)¶			return null;¶//		Pattern mypattern = Pattern.compile("[a-zA-Z_$][a-zA-Z_$0-9]*");¶//		Matcher mymatcher = mypattern.matcher(aString);¶		Matcher mymatcher = identifierPattern.matcher(aString);¶		List<String> retVal = new ArrayList();¶		while (mymatcher.find()) {¶			String find = mymatcher.group(0);¶			retVal.add(find);¶		}¶		return retVal;¶	}¶	public static List<MethodCall> callsIn(int aLineNumber, String aString, SNode aParent) {¶		if (aString == null)¶			return null;¶//		Pattern mypattern = Pattern.compile("[a-zA-Z_$][a-zA-Z_$0-9]*");¶//		Matcher mymatcher = mypattern.matcher(aString);¶		Matcher mymatcher = callPattern.matcher(aString);¶		List<MethodCall> retVal = new ArrayList();¶		while (mymatcher.find()) {¶			String find = mymatcher.group(0);¶			int aLeftParenIndex = find.indexOf("(");¶			int aRightParenIndex = find.indexOf(")");¶			String aMethodName = find.substring(0, aLeftParenIndex).trim();¶			String aParameters = find.substring(aLeftParenIndex + 1, aRightParenIndex);¶			List<String> aParameterList = new ArrayList();¶			String[] aParameterTokens = aParameters.split(",");¶			for (String aParameter:aParameterTokens) {¶				String aParameterTrimmed = aParameter.trim();¶				if (!aParameterTrimmed.isEmpty())¶				aParameterList.add(aParameterTrimmed);¶			}¶			retVal.add(new AMethodCall(aLineNumber, aMethodName, aParameterList, aParent));¶¶//			aCallStrings.add(find);¶		}¶		return retVal;¶	}¶	static String numberRegex = "(\\d+\\.\\d+)|(\\d+)";¶	static Pattern numberPattern = Pattern.compile(numberRegex);¶	public static List<String> numbersIn(String aString) {¶		if (aString == null)¶			return null;¶//		String regex = "(\\d+\\.\\d+)|(\\d+)";¶//¶//		Matcher m = Pattern.compile(regex).matcher(aString);¶		Matcher m =numberPattern.matcher(aString);¶¶¶		List<String> retVal = new ArrayList();¶¶		while (m.find()) {¶			retVal.add(m.group());¶		}¶		return retVal;¶	}¶¶	public static String subscriptIn(String aString) {¶		if (aString == null)¶			return null;¶		return StringUtils.substringBetween(aString, "[", "]");¶	}¶	static String[] emptyStringArray = {};¶	public static String[] subscriptsIn(String aString) {¶		if (aString == null)¶			return emptyStringArray;¶		return StringUtils.substringsBetween(aString, "[", "]");¶	}¶	static  String operatorRegex = "([+-/*///^])|([/(/)])";¶	static Pattern operatorPattern = Pattern.compile(operatorRegex);¶¶	public static List<String> operatorsIn(String aString) {¶		if (aString == null)¶			return null;¶//		String operatorRegex = "([+-/*///^])|([/(/)])";¶//¶//		Matcher m = Pattern.compile(operatorRegex).matcher(aString);¶		¶		Matcher m = operatorPattern.matcher(aString);¶¶¶		List<String> retVal = new ArrayList();¶¶		while (m.find()) {¶			retVal.add(m.group());¶		}¶		return retVal;¶	}¶	¶	public static int numberOfNestingFors (SNode anSNode) {¶		if (anSNode == null) {¶			return 0;¶		}¶		int retVal = numberOfNestingFors (anSNode.getParent()) ;¶¶		if (anSNode instanceof ForSNode) {¶			retVal++;¶		} else if (anSNode instanceof MethodSNode) {¶			List<MethodCall> aMethodCalls = ((MethodSNode) anSNode).getCalls();¶			int aMaxNestingLevel = 0;¶			for (MethodCall aMethodCall:aMethodCalls) {¶				MethodSNode aCallerMethodSNode = getDeclarationOfCalledMethod(anSNode, aMethodCall);¶				int aCallerNumberOfNestingFors = numberOfNestingFors(aCallerMethodSNode);¶				aMaxNestingLevel = Math.max(aCallerNumberOfNestingFors, aMaxNestingLevel);				¶			}¶			return retVal + aMaxNestingLevel;¶		}¶		return retVal;¶	}¶	public static boolean hasOperator (SNode anSNode, String anOperator) {¶		boolean retVal = false;¶		if (anSNode instanceof AssignmentSNode) {¶			AssignmentSNode anAssignmentSNode = (AssignmentSNode) anSNode;¶			 retVal = (anAssignmentSNode.getLhsOperators().contains(anOperator) || ¶					anAssignmentSNode.getRhsOperators().contains(anOperator)) ;¶			if (retVal) {¶				return retVal;¶			} else {¶				List<MethodCall> aMethodCalls = anAssignmentSNode.getRhsCalls();¶				for (MethodCall aMethodCall:aMethodCalls) {¶					MethodSNode aMethodSNode = getDeclarationOfCalledMethod(anSNode, aMethodCall);¶					retVal = hasOperator(aMethodSNode, anOperator);¶					if (retVal) {¶						return retVal;¶					}¶					¶				}¶				return false;¶			}¶			¶		}¶		for (SNode aChild:anSNode.getChildren()) {¶			retVal = hasOperator(aChild, anOperator);¶			if (retVal) {¶				return retVal;¶			}¶		}¶		return false;¶	}¶	public static boolean hasMethodCall (SNode anSNode, String anOperator) {¶		boolean retVal = false;¶		if (anSNode instanceof AssignmentSNode) {¶			AssignmentSNode anAssignmentSNode = (AssignmentSNode) anSNode;¶			 retVal = (anAssignmentSNode.getLhsOperators().contains(anOperator) || ¶					anAssignmentSNode.getRhsOperators().contains(anOperator)) ;¶			if (retVal) {¶				return retVal;¶			} else {¶				List<MethodCall> aMethodCalls = anAssignmentSNode.getRhsCalls();¶				for (MethodCall aMethodCall:aMethodCalls) {¶					MethodSNode aMethodSNode = getDeclarationOfCalledMethod(anSNode, aMethodCall);¶					retVal = hasOperator(aMethodSNode, anOperator);¶					if (retVal) {¶						return retVal;¶					}¶					¶				}¶				return false;¶			}¶			¶		}¶		for (SNode aChild:anSNode.getChildren()) {¶			retVal = hasOperator(aChild, anOperator);¶			if (retVal) {¶				return retVal;¶			}¶		}¶		return false;¶	}¶	public static boolean dependsOn (AssignmentSNode anAssignmentSNode, String aVariable, String aCallIdentifier) {¶		// This assignment does not change aVariable¶		if (!aVariable.equals(anAssignmentSNode.getLhsVariable())) {¶			return false;¶		}¶		return dependsOn(anAssignmentSNode.getExpressionSNode(), aCallIdentifier);¶//		List<String> aCallIdentifiers = anAssignmentSNode.getRhsCallIdentifiers();¶//		boolean retVal = false;¶//		if (aCallIdentifiers != null && aCallIdentifiers.contains(aCallIdentifier)) {¶//			return true; // this assignment has aCallIdentifier in the rhs¶//		}¶//		// check if some referenced rhs variable depends on aCallIdentifier¶//		List<String> aReferencedVariableIdentifiers = anAssignmentSNode.getRhsVariableIdentifiers();¶//		SNode anAssignmentParent = anAssignmentSNode.getParent();¶//		if (anAssignmentParent == null) { // should never be trye¶//			return false;¶//		}¶//		int aLineNumber = anAssignmentSNode.getLineNumber();¶//		for (String aReferencedVariableIdentifier:aReferencedVariableIdentifiers ) {¶//			if (dependsOn (anAssignmentParent, aLineNumber, aReferencedVariableIdentifier, aCallIdentifier)) {¶//				return true;¶//			}¶//		}¶//		return false;¶	}¶	public static boolean dependsOn (ExpressionSNode anExpressionSNode, String aCallIdentifier) {¶		// This assignment does not change aVariable¶		¶		List<String> aCallIdentifiers = anExpressionSNode.getRhsCallIdentifiers();¶		boolean retVal = false;¶		if (aCallIdentifiers != null && aCallIdentifiers.contains(aCallIdentifier)) {¶			return true; // this assignment has aCallIdentifier in the rhs¶		}¶		// check if some referenced rhs variable depends on aCallIdentifier¶		List<String> aReferencedVariableIdentifiers = anExpressionSNode.getRhsVariableIdentifiers();¶		SNode anAssignmentParent = anExpressionSNode.getParent().getParent();¶		if (anAssignmentParent == null) { // should never be trye¶			return false;¶		}¶		int aLineNumber = anExpressionSNode.getLineNumber();¶		for (String aReferencedVariableIdentifier:aReferencedVariableIdentifiers ) {¶			if (dependsOn (anAssignmentParent, aLineNumber, aReferencedVariableIdentifier, aCallIdentifier)) {¶				return true;¶			}¶		}¶		return false;¶	}¶	public static Set<AssignmentSNode> assignmentsToSharedVariables(SNode anSNode) {¶		Set<AssignmentSNode> retVal =  new HashSet();¶		fillAssignmentsToShared(anSNode, retVal);¶		return retVal;¶		¶	}¶	public static Set<AssignmentSNode> assignmentsToSharedArrays(SNode anSNode) {¶		Set<AssignmentSNode> anAllSharedAssignments =  assignmentsToSharedVariables(anSNode);¶		Set<AssignmentSNode> aRetVal = new HashSet();¶		for (AssignmentSNode anAssignmentSNode:anAllSharedAssignments) {¶			if (anAssignmentSNode.getLhsSubscripts().length > 0) {¶				aRetVal.add(anAssignmentSNode);¶			}¶		}¶		return aRetVal;¶		¶	}¶	public static Set<AssignmentSNode> assignmentsToParallel"), Diff(DELETE,"Shared"), Diff(EQUAL,"Critical"), Diff(INSERT,"SharedVariables"), Diff(EQUAL,"(SNode anSNode) {¶		Set<AssignmentSNode> anAllSharedAssignments =  assignmentsToSharedVariables(anSNode);¶		Set<AssignmentSNode> aRetVal = new HashSet();¶		for (AssignmentSNode anAssignmentSNode:anAllSharedAssignments) {¶			if (anAssignmentSNode.isInParallel() &&¶					anAssignmentSNode.isInCritical()) {¶				aRetVal.add(anAssignmentSNode);¶			}¶		}¶		return aRetVal;¶		¶	}¶	public static Set<AssignmentSNode> assignmentsToNonParallel"), Diff(DELETE,"Shared"), Diff(EQUAL,"Critical"), Diff(INSERT,"SharedVariables"), Diff(EQUAL,"(SNode anSNode) {¶		Set<AssignmentSNode> anAllSharedAssignments =  assignmentsToSharedVariables(anSNode);¶		Set<AssignmentSNode> aRetVal = new HashSet();¶		for (AssignmentSNode anAssignmentSNode:anAllSharedAssignments) {¶			if (!anAssignmentSNode.isInParallel() &&¶"), Diff(DELETE,""), Diff(EQUAL,"					anAssignmentSNode.isInCritical()) {¶				aRetVal.add(anAssignmentSNode);¶			}¶		}¶		return aRetVal;¶		¶	}¶"), Diff(INSERT,"	public static Set<AssignmentSNode> assignmentsToParallelNonCriticalSharedVariables(SNode anSNode) {¶		Set<AssignmentSNode> anAllSharedAssignments =  assignmentsToSharedVariables(anSNode);¶		Set<AssignmentSNode> aRetVal = new HashSet();¶		for (AssignmentSNode anAssignmentSNode:anAllSharedAssignments) {¶			if (anAssignmentSNode.isInParallel() &&¶					!anAssignmentSNode.isInCritical()) {¶				aRetVal.add(anAssignmentSNode);¶			}¶		}¶		return aRetVal;¶		¶	}¶"), Diff(EQUAL,"    public static void fillAssignmentsToShared(SNode anSNode, Set<AssignmentSNode> retVal) {¶    	if (anSNode instanceof AssignmentSNode) {¶			AssignmentSNode anAssignmentSNode = (AssignmentSNode) anSNode;¶			String anLHS = anAssignmentSNode.getLhsVariable();¶			if (isSharedVariable(anSNode, anLHS)) {¶				retVal.add(anAssignmentSNode);¶				return;¶			}¶		}¶    	for (SNode aChild:anSNode.getChildren()) {¶    		fillAssignmentsToShared(aChild, retVal);¶    	}¶		¶	}¶	public static boolean dependsOn (SNode anSNode, int aVariableLineNumber, String aVariable, String aCallIdentifier) {¶		List<SNode> aListSNodes = anSNode.getChildren();¶		boolean retVal = false;¶		/*¶		 * Should probably ignore line number as it assumes straight line code¶		 */¶		for (int i = aVariableLineNumber; i >= 0; i--) {¶			SNode anSNodeChild = aListSNodes.get(i);¶			if (anSNodeChild instanceof AssignmentSNode) {¶				// does this statement in anSNode directly invoke aCallIdentifier ¶				if (dependsOn((AssignmentSNode) anSNodeChild, aVariable, aCallIdentifier))¶					return true;¶			} else if (!anSNode.isLeaf()) {¶					// child is overriding the variable so forget checking its assignment statements¶					if (anSNodeChild.getLocalVariables().contains(aVariable)) {¶						continue;¶					}¶					// some subblock of anSNode that has access to aVariable changes variable¶¶					if (dependsOn(anSNodeChild, anSNodeChild.getChildren().size() - 1, aVariable, aCallIdentifier)) {¶						return true;¶					}¶			}¶			¶		}¶		// none of the statements in anSNode or its descendents  have the required call¶		// is the variable a  method parameter ¶		if (anSNode instanceof MethodSNode) {¶			MethodSNode aMethodSNode = (MethodSNode) anSNode;¶			¶			int aParameterNumber = aMethodSNode.getLocalVariables().indexOf(aVariable);¶			if (aParameterNumber != -1) {¶				List <MethodCall> aCalls = aMethodSNode.getCalls();¶				for (MethodCall aCall:aCalls) {¶					MethodSNode aCallerSNode = getDeclarationOfCalledMethod(aMethodSNode, aCall);¶					boolean aCallerDepends = dependsOn(aMethodSNode, aCallerSNode.getLineNumber(), aVariable, aCallIdentifier);¶				    if (aCallerDepends) {¶				    	return true;¶				    }¶				}¶				return false;¶				// need to find all callers of method and see if any of the aliases for the variable in these¶				// calls depend on aCallIndentifier¶			}			¶			¶		} else if (anSNode.getLocalVariables().contains(aVariable)) {¶			// before going to the parent node, let us see if aVariable is declared here as a non  parameter ¶¶			return false; // no point going to parent¶		}¶		// not a local variable (parameter or declarated variable)¶		SNode anSNodeParent = anSNode.getParent() ;¶		if (anSNodeParent == null)  {¶			return false;¶		}¶		int anSNodeLineNumber = anSNodeParent.getChildren().indexOf(anSNode);¶		return dependsOn(anSNodeParent, anSNodeLineNumber, aVariable, aCallIdentifier);¶		¶	}¶	public static RootOfFileSNode getRootOfFileNode(SNode aCurrentSNode ) {¶		if (aCurrentSNode instanceof RootOfFileSNode) {¶			return (RootOfFileSNode) aCurrentSNode;¶		}¶		SNode aParentSNode = aCurrentSNode.getParent() ;¶		¶		if (aParentSNode == null) {¶			return null;¶		}¶		¶		return getRootOfFileNode(aParentSNode);¶		¶	}¶	public static boolean match (MethodSNode aMethodSNode, MethodCall aMethodCall) {¶		return aMethodSNode.getMethodName().equals(aMethodCall.getMethodName()) ¶				&& aMethodSNode.getLocalVariables().size() == aMethodCall.getMethodActuals().size();¶	}¶	¶	public static MethodSNode getDeclarationOfCalledMethod(SNode aCurrentSNode, MethodCall aMethodCall ) {¶		SNode aRootNode = getRootOfFileNode(aCurrentSNode);¶		for (SNode aChild:aRootNode.getChildren()) {¶			if (aChild instanceof MethodSNode) {¶				MethodSNode aMethodSNode = (MethodSNode) aChild;¶				if (match (aMethodSNode, aMethodCall)) {¶					return aMethodSNode;¶				}¶			}¶		}¶		return null; // this should never happen;¶	}¶	¶	public static RootOfProgramSNode getRootOfProgramSNode(String aSource) {¶		RootOfProgramSNode retVal = new ARootOfProgramSNode();¶		Map<String, StringBuffer> aFileNameToContents = ABasicTextManager.extractFileContents(aSource);¶		for (String aFileName:aFileNameToContents.keySet()) {¶			StringBuffer aFileContents = aFileNameToContents.get(aFileName);¶//			List<OpenMPPragma> anOpenMPPragmas = OpenMPUtils.getOpemMPPragmas(aFileContents);¶			RootOfFileSNode anSNode = OMPSNodeUtils.getSNode(aFileName, aFileContents);¶			retVal.getFileNameToSNode().put(aFileName, anSNode);¶			anSNode.setParent(retVal);¶//			System.out.println("file name:" + aFileName);¶//			System.out.println("pragmas:" + anSNode);¶		}¶		processExternalMethodSNodes(retVal);¶		return retVal;¶	}¶	public static void processExternalMethodSNodes (RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode) {¶		for (SNode anSNode:aRootOfFileSNode.getChildren()) {¶			if (anSNode instanceof ExternalMethodSNode) {¶				processExternalMethodSNode(aRootOfProgramSNode, aRootOfFileSNode, (ExternalMethodSNode) anSNode);¶			}¶		}¶	}¶	public static void processExternalMethodSNode (RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode, ExternalMethodSNode anExternalMethodSNode) {¶		MethodSNode aMethodSNode = aRootOfProgramSNode.getExternalToInternalMethod().get(anExternalMethodSNode.toString());¶		if (aMethodSNode == null) {¶			aMethodSNode = findMethodSNode(aRootOfProgramSNode, aRootOfFileSNode, anExternalMethodSNode);¶			if (aMethodSNode != null) {¶				aRootOfProgramSNode.getExternalToInternalMethod().put(anExternalMethodSNode.toString(),aMethodSNode );¶			}¶		}¶		if (aMethodSNode != null) {¶			anExternalMethodSNode.setActualMethodSNode(aMethodSNode);¶			aMethodSNode.getCalls().addAll(anExternalMethodSNode.getLocalCalls());¶		}¶	}¶	public static MethodSNode findMethodSNode (RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode, ExternalMethodSNode anExternalMethodSNode) {¶//		MethodSNode foundMethodSNode = null;¶		for (String aFileName:aRootOfProgramSNode.getFileNameToSNode().keySet()) {¶			if (aFileName.equals(aRootOfFileSNode.getFileName()))¶				continue;¶			¶			RootOfFileSNode aSearchedRootOfFileSNode = aRootOfProgramSNode.getFileNameToSNode().get(aFileName);¶			 for (SNode anSNode:aSearchedRootOfFileSNode.getChildren()) {¶				if (anSNode instanceof MethodSNode && !(anSNode instanceof ExternalMethodSNode)) {¶					if (anSNode.toString().equals(anExternalMethodSNode.toString())) {¶						return (MethodSNode) anSNode;¶						¶					}¶//					processExternalMethodSNode(aRootOfProgramSNode, aRootOfFileSNode, (ExternalMethodSNode) anSNode);¶				}¶			}¶		}¶		return null;¶	}¶	public static void processExternalMethodSNodes (RootOfProgramSNode aRootOfProgramSNode) {¶		for (String aFileName:aRootOfProgramSNode.getFileNameToSNode().keySet()) {¶			RootOfFileSNode aRootOfFileSNode = aRootOfProgramSNode.getFileNameToSNode().get(aFileName);¶			processExternalMethodSNodes(aRootOfProgramSNode, aRootOfFileSNode);¶			aRootOfFileSNode.getOmp_get_num_threads_SNode().¶				setActualMethodSNode(aRootOfProgramSNode.getOmp_get_num_threads_SNode());¶			aRootOfFileSNode.getOmp_get_thread_num_SNode().¶				setActualMethodSNode(aRootOfProgramSNode.getOmp_get_thread_num_SNode());¶			aRootOfFileSNode.getOmp_get_wtime_SNode().¶			setActualMethodSNode(aRootOfProgramSNode.getOmp_get_wtime_SNode());¶		}¶¶	}¶	¶¶//	public static void main(String[] args) {¶//		List<MethodCall> aTokens = callsIn("foo(bar, hgf)/foo2()*foo3(b, a c,)");¶//		System.out.println(aTokens);¶//		¶//		¶////		List<String> aTokens = identifiersIn("a[i] + b*2/3");¶////		System.out.println(aTokens);¶////		aTokens = numbersIn("a[i] + b*2/3");¶////		System.out.println(aTokens);¶////		aTokens = operatorsIn("a[i] + b*2/3");¶////		System.out.println(aTokens);¶////¶////		System.out.println(StringUtils.substringBetween("a", "[", "]"));¶//	}¶¶}¶")]]]></diff>
    <snapshot><![CDATA[package gradingTools.shared.testcases.openmp.scannedTree;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Stack;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.apache.commons.lang.StringUtils;

import grader.basics.project.source.ABasicTextManager;
import gradingTools.shared.testcases.openmp.OpenMPKeywordEnum;
import gradingTools.shared.testcases.openmp.OpenMPParallelPragma;
import gradingTools.shared.testcases.openmp.OpenMPUtils;
import gradingTools.shared.testcases.openmp.scannedTree.ADeclarationSNode;
import gradingTools.shared.testcases.openmp.scannedTree.ADeclaringAssignmentSNode;
import gradingTools.shared.testcases.openmp.scannedTree.AForSNode;
import gradingTools.shared.testcases.openmp.scannedTree.ATextSNode;
import gradingTools.shared.testcases.openmp.scannedTree.AnAssignmentSNode;
import gradingTools.shared.testcases.openmp.scannedTree.AnOMPCriticalSNode;
import gradingTools.shared.testcases.openmp.scannedTree.AnOMPForSNode;
import gradingTools.shared.testcases.openmp.scannedTree.AnOMPParallelSNode;
import gradingTools.shared.testcases.openmp.scannedTree.AnOMPSNode;
import gradingTools.shared.testcases.openmp.scannedTree.AnSNode;
import gradingTools.shared.testcases.openmp.scannedTree.AssignmentSNode;
import gradingTools.shared.testcases.openmp.scannedTree.DeclarationSNode;
import gradingTools.shared.testcases.openmp.scannedTree.DeclaringAssignmentSNode;
import gradingTools.shared.testcases.openmp.scannedTree.ForSNode;
import gradingTools.shared.testcases.openmp.scannedTree.OMPForSNode;
import gradingTools.shared.testcases.openmp.scannedTree.OMPSNode;
import gradingTools.shared.testcases.openmp.scannedTree.SNode;

public class OMPSNodeUtils extends OpenMPUtils {

	public static RootOfFileSNode getSNode(String aFileName, StringBuffer aFileBuffer) {
		String[] aFileLines = aFileBuffer.toString().split("\n");
		return getSNode(aFileName, aFileLines);
	}

	public static AssignmentSNode getAssignmentSNode(int aLineNumber, String aString) {
		if (aString == null) {
			return null;
		}
		String[] aTokens = aString.split("=");
		if (aTokens.length == 1) {
			return new AnAssignmentSNode(aLineNumber, aTokens[0], null);
		} else {
		return new AnAssignmentSNode(aLineNumber, aTokens[0], aTokens[1]);
		}
	}

	public static DeclarationSNode getDeclarationSNode(int aLineNumber, String aString) {
		String[] aTokens = aString.split(" ");
		return new ADeclarationSNode(aLineNumber, aTokens[0], aTokens[1]);
	}

	public static DeclaringAssignmentSNode getDeclaringAssignmentSNode(int aLineNumber, String aString) {
		String[] anLHSAndRHS = aString.split("=");
		String[] aTypeAndVariable = anLHSAndRHS[0].split(" ");
		return new ADeclaringAssignmentSNode(aLineNumber, aTypeAndVariable[0], aTypeAndVariable[1], anLHSAndRHS[1]);
	}

	public static boolean isDeclaringAssignment(String aFileLine) {
		return startsWithTypeName(aFileLine) && aFileLine.contains("=");
	}
	public static boolean isMethodDeclaration(String aFileLine) {
		return startsWithTypeName(aFileLine) && 
				aFileLine.contains("(") &&
				!aFileLine.contains("=");
	}
	public static boolean isExternalMethodDeclaration(String aFileLine) {
		return isMethodDeclaration(aFileLine) && aFileLine.endsWith(";");
	}


	public static boolean isVariableDeclaration(String aFileLine) {

		return startsWithTypeName(aFileLine) && !aFileLine.contains("(");
	}

	public static boolean isAssignment(String aFileLine) {
		return aFileLine.contains("=");
	}

	public static boolean isForNode(String aFileLine) {
		return aFileLine.startsWith("for");
	}

	public static ForSNode getForSNode(int aLineNumber, String aFileLine) {

		int aLeftParenIndex = aFileLine.indexOf("(");
		int aRightParenIndex = aFileLine.indexOf(")");
		if (aLeftParenIndex < 0 || aRightParenIndex < 0) {
			return null;
		}
		String aHeaderString = aFileLine.substring(aLeftParenIndex + 1, aRightParenIndex);
		String[] aForComponents = aHeaderString.split(";");
		AssignmentSNode anAssignmentSNode = null;
		String aForInitializaton = aForComponents[0];
		if (!aForInitializaton.isEmpty() && aForInitializaton.contains("=")) {
			if (isDeclaringAssignment(aForInitializaton)) {
				anAssignmentSNode = getDeclaringAssignmentSNode(aLineNumber, aForInitializaton);
			} else {
				anAssignmentSNode = getAssignmentSNode(aLineNumber, aForInitializaton);
			}

		}		
		return new AForSNode(aLineNumber, anAssignmentSNode, aForComponents[1], getAssignmentSNode(aLineNumber, aForComponents[2]));
	}
	static String[] emptyArray = {};
	public static MethodSNode getMethodSNode(int aLineNumber, String aFileLine, boolean isInternal) {

		int aLeftParenIndex = aFileLine.indexOf("(");
		int aRightParenIndex = aFileLine.indexOf(")");
		if (aLeftParenIndex < 0 || aRightParenIndex < 0) {
			return null;
		}
		String aMethodNameAndType = aFileLine.substring(0, aLeftParenIndex);
		String[] aMethodNameAndTypeTokens = aMethodNameAndType.split("\\s+"); 
		
		String aMethodParameters = aFileLine.substring(aLeftParenIndex +1 , aRightParenIndex);
		String[] aMethodParameterTokens = aMethodParameters.isEmpty()?emptyArray:
		 aMethodParameters.split(",");
		
//		String[] aMethodParameterTypes = new String[aMethodParameterTokens.length];
//		String[] aMethodParameterNames = new String[aMethodParameterTokens.length];
		List<DeclarationSNode> aDeclarationSNodeList = new ArrayList();
		for (int i = 0; i < aMethodParameterTokens.length; i++ ) {
			String[] aTypeAndName = aMethodParameterTokens[i].trim().split("\\s+");
			if (aTypeAndName.length < 2) {
				continue;
			}
			aDeclarationSNodeList.add(new ADeclarationSNode(aLineNumber, aTypeAndName[0].trim(), aTypeAndName[1].trim()));
//			aMethodParameterTypes[i] = aTypeAndName[0].trim();
//			aMethodParameterNames[i] = aTypeAndName[1].trim();
		}
		if (isInternal)
//		return new AMethodSNode(aLineNumber, aMethodNameAndTypeTokens[0], aMethodNameAndTypeTokens[1], aMethodParameterTypes,aMethodParameterNames );
			return new AMethodSNode(aLineNumber, aMethodNameAndTypeTokens[0], aMethodNameAndTypeTokens[1], aDeclarationSNodeList );
		else
			return new AnExternalMethodSNode(aLineNumber, aMethodNameAndTypeTokens[0], aMethodNameAndTypeTokens[1], aDeclarationSNodeList );
	}

	public static void setReductionData(OMPForSNode lastChild, String aStoredToken, int aLeftParenIndex,
			int aRightParenIndex) {
		int aColonIndex = aStoredToken.indexOf(":");
		if (aLeftParenIndex != -1 && aRightParenIndex != -1 && aColonIndex != -1) {
			String anOperationString = aStoredToken.substring(aLeftParenIndex + 1, aColonIndex).trim();
			String aVariableString = aStoredToken.substring(aColonIndex + 1, aRightParenIndex).trim();
			((OMPForSNode) lastChild).setReductionVariable(aVariableString);
			((OMPForSNode) lastChild).setReductionOperation(anOperationString);
		}
	}

	public static void setSharedOrPrivateData(OMPSNode lastChild, String aStoredToken, int aLeftParenIndex,
			int aRightParenIndex, boolean isShared) {
//		int aColonIndex = aStoredToken.indexOf(":");
		if (aLeftParenIndex != -1 && aRightParenIndex != -1) {
			String aVariableDeclarations = aStoredToken.substring(aLeftParenIndex + 1, aRightParenIndex);
			String[] aVariables = aVariableDeclarations.split(",");
			if (isShared) {
				lastChild.setSharedVariables(aVariables);
			} else {
				lastChild.setPrivateVariables(aVariables);
			}
		}
	}

	public static RootOfFileSNode getSNode(String aFileName, String[] aFileLines) {
		Stack<SNode> anSNodes = new Stack();

		RootOfFileSNode retVal = new ARootOfFileSNode(aFileName);
		anSNodes.add(retVal);
		SNode previousHeaderNode = null;
		for (int i = 0; i < aFileLines.length; i++) {
			String aFileLine = aFileLines[i].trim();
			if (!isCodeLine(aFileLine)) {
				continue;
			}
			if (isForNode(aFileLine)) {
				ForSNode aForSNode = getForSNode(i, aFileLine);
				aForSNode.setParent(anSNodes.peek());
//				anSNodes.push(aForSNode);
				previousHeaderNode = aForSNode;
				if (aFileLine.endsWith(")")) {
					continue;
				}
			}
			if (isExternalMethodDeclaration(aFileLine)) {
				MethodSNode aMethodSNode = getMethodSNode(i, aFileLine, false);
				aMethodSNode.setParent(anSNodes.peek());
//				anSNodes.push(aForSNode);
				previousHeaderNode = aMethodSNode;
				if (aFileLine.endsWith(")")) {
					continue;
				}
			}
			if (isMethodDeclaration(aFileLine)) {
				MethodSNode aMethodSNode = getMethodSNode(i, aFileLine, true);
				aMethodSNode.setParent(anSNodes.peek());
//				anSNodes.push(aForSNode);
				previousHeaderNode = aMethodSNode;
				if (aFileLine.endsWith(")")) {
					continue;
				}
			}
			if (isPragmaStart(aFileLine)) {
				OMPSNode anOMPSNode = getOMPSNode(i, anSNodes.peek(), aFileLine);
//				anSNodes.push(anOMPSNode);
				previousHeaderNode = anOMPSNode;
				continue;
			}
			if (isBlockStart(aFileLine)) {
				SNode aBlockSNode = new AnSNode(i);
				if (previousHeaderNode != null) {
					aBlockSNode.setParent(previousHeaderNode);
				} else {
					aBlockSNode.setParent(anSNodes.peek());
				}
				anSNodes.push(aBlockSNode);
				previousHeaderNode = null;
				continue;
			}
//			} else 
			if (isBlockEnd(aFileLine)) {
				anSNodes.pop();
				continue;
			}
			SNode aNewLeafNode = null;
			if (isDeclaringAssignment(aFileLine)) {
				aNewLeafNode = getDeclaringAssignmentSNode(i, aFileLine);

			} else if (isAssignment(aFileLine)) {
				aNewLeafNode = getAssignmentSNode(i, aFileLine);
			} else if (isVariableDeclaration(aFileLine)) {
				aNewLeafNode = getDeclarationSNode(i, aFileLine);
			} else {
				List<MethodCall> aCalls = callsIn(i, aFileLine, null); // parent will be assigned below
				if (aCalls != null && aCalls.size() == 1) {
					aNewLeafNode = aCalls.get(0);
				} else {
					aNewLeafNode = new ATextSNode(i, aFileLine);
				}
			}
//			else {
//				aNewLeafNode = new ATextSNode(i, aFileLine);
//			}
			if (previousHeaderNode != null) {
				aNewLeafNode.setParent(previousHeaderNode);
			} else {
				aNewLeafNode.setParent(anSNodes.peek());
			}

		}

		return retVal;
	}

	public static OMPSNode getOMPSNode(int aLineIndex, SNode aParentNode, String aFileLine) {
		String[] aTokens = aFileLine.split("\\s+");
		if (aTokens.length <= 2) {
			return null;
		}
		if (!aTokens[1].equals("omp")) {
			return null;
		}
		if (aTokens.length < 3) {
			return null;
		}
		String aFirstToken = aTokens[2];
		OpenMPKeywordEnum anOpenMPKeyword = stringToOpenMPKeyword.get(aFirstToken);
//		List<OpenMPPragma> retVal = new ArrayList();
		OMPSNode lastChild = null;
		int aStartIndex = 2;
		OMPSNode aNewNode = null;
		OMPForSNode aForChild = null;
		switch (anOpenMPKeyword) {
		case PARALLEL:
			aNewNode = new AnOMPParallelSNode(aLineIndex);

			if (aTokens.length > 3 && aTokens[3].equals("for")) {
				aForChild = new AnOMPForSNode(aLineIndex);
				aForChild.setParent(aNewNode);

				aStartIndex++;
			}
			break;
		case FOR:
			aNewNode = new AnOMPForSNode(aLineIndex);
			;
			break;
		case CRITICAL:
			aNewNode = new AnOMPCriticalSNode(aLineIndex);
//			retVal.add (lastChild);
			break;
		default:
			aNewNode = new AnOMPSNode(aLineIndex);

		}

		if (lastChild != null) {
			aNewNode.setParent(lastChild);
		} else {
			aNewNode.setParent(aParentNode);
		}
		lastChild = aForChild == null ? aNewNode : aForChild;

		for (int i = aStartIndex; i < aTokens.length; i++) {
			String aStoredToken = aTokens[i].trim();
			if (aStoredToken.isEmpty()) {
				continue;
			}
			if (aStoredToken.startsWith("reduction") || aStoredToken.startsWith("shared")
					|| aStoredToken.startsWith("private")) {
				// combine all tokens until ")" into one for normalization
				while (!aStoredToken.endsWith(")")) {
					i++;
					if (i >= aTokens.length) {
						break;
					}
					String aNewToken = aTokens[i].trim();
					aStoredToken += aNewToken;
				}
				int aLeftParenIndex = aStoredToken.indexOf("(");
				int aRightParenIndex = aStoredToken.indexOf(")");
				if (aStoredToken.startsWith("reduction")) {
					setReductionData((OMPForSNode) lastChild, aStoredToken, aLeftParenIndex, aRightParenIndex);
				} else if (aStoredToken.startsWith("private")) {
					setSharedOrPrivateData((OMPSNode) lastChild, aStoredToken, aLeftParenIndex, aRightParenIndex,
							false);

				} else if (aStoredToken.startsWith("shared")) {
					setSharedOrPrivateData(lastChild, aStoredToken, aLeftParenIndex, aRightParenIndex, true);

				}

			}

			lastChild.getOpenMPTokens().add(aStoredToken);
		}

		return lastChild;

	}

	public static boolean hasParallelAncestor(SNode anSNode) {
		if (anSNode == null) {
			return false;
		}
		if (anSNode instanceof OMPParallelSNode) {
			return true;
		}
		return hasParallelAncestor(anSNode.getParent());
	}
	public static boolean hasCriticalAncestor(SNode anSNode) {
		if (anSNode == null) {
			return false;
		}
		if (anSNode instanceof OMPCriticalSNode) {
			return true;
		}
		return hasCriticalAncestor(anSNode.getParent());
	}


	public static Boolean isDeclaredShared(OMPSNode anOMPSNode, String anLHS) {
		if (Arrays.asList(anOMPSNode.getSharedVariables()).contains(anLHS)) {
			return true;
		}
		if (Arrays.asList(anOMPSNode.getPrivateVariables()).contains(anLHS)) {
			return false;
		}
		return null;

	}

	public static boolean isSharedVariable(SNode anSNode, String anLHS) {
		if (anSNode == null) {
			return false;
		}
		if (anSNode.getLocalVariables().contains(anLHS)) {
			if (!(anSNode instanceof OMPSNode)) { // no shared and private declarations
				return !hasParallelAncestor(anSNode); // shared if not inParallel
			}
			OMPSNode anOMPSNode = (OMPSNode) anSNode;
			return (Arrays.asList(anOMPSNode.getSharedVariables()).contains(anLHS)); // private unless declared shared
		}
		if (anSNode instanceof OMPSNode) {
			OMPSNode anOMPSNode = (OMPSNode) anSNode;
			// the variable is global to this scope, check if it has have been made shared
			// or private by this scope
			Boolean isDeclaredShared = isDeclaredShared(anOMPSNode, anLHS);
			if (isDeclaredShared != null) {
				return isDeclaredShared;
			}
		}
		// check the parent
		return isSharedVariable(anSNode.getParent(), anLHS);
	}

	public static List<SNode> getAllLeafNodes(SNode aTopNode) {
		List<SNode> retVal = new ArrayList();
		addLeafNodes(aTopNode, retVal);
		return retVal;
	}

	public static void addLeafNodes(SNode aTopNode, List<SNode> retVal) {
		for (SNode aChild : aTopNode.getChildren()) {
			if (aChild.isLeaf()) {
				retVal.add(aChild);
			} else {
				addLeafNodes(aChild, retVal);
			}
		}
	}

	public static List<SNode> getNonParallelLeafNodes(SNode aTopNode) {
		List<SNode> retVal = new ArrayList();
		addNonParallelLeafNodes(aTopNode, retVal);
		return retVal;
	}

	public static void addNonParallelLeafNodes(SNode aTopNode, List<SNode> retVal) {
		if (aTopNode.isInParallel()) {
			return;
		}
		for (SNode aChild : aTopNode.getChildren()) {
			if (aChild.isLeaf()) {
				retVal.add(aChild);
			} else {
				addLeafNodes(aChild, retVal);
			}
		}
	}
	static String callRegex = "([a-zA-Z_$][a-zA-Z_$0-9]*)\\(.*?\\)";
	static Pattern callPattern = Pattern.compile(callRegex);

	static String identifierRegex = "[a-zA-Z_$][a-zA-Z_$0-9]*";
	static Pattern identifierPattern = Pattern.compile(identifierRegex);
	public static List<String> identifiersIn(String aString) {
		if (aString == null)
			return null;
//		Pattern mypattern = Pattern.compile("[a-zA-Z_$][a-zA-Z_$0-9]*");
//		Matcher mymatcher = mypattern.matcher(aString);
		Matcher mymatcher = identifierPattern.matcher(aString);
		List<String> retVal = new ArrayList();
		while (mymatcher.find()) {
			String find = mymatcher.group(0);
			retVal.add(find);
		}
		return retVal;
	}
	public static List<MethodCall> callsIn(int aLineNumber, String aString, SNode aParent) {
		if (aString == null)
			return null;
//		Pattern mypattern = Pattern.compile("[a-zA-Z_$][a-zA-Z_$0-9]*");
//		Matcher mymatcher = mypattern.matcher(aString);
		Matcher mymatcher = callPattern.matcher(aString);
		List<MethodCall> retVal = new ArrayList();
		while (mymatcher.find()) {
			String find = mymatcher.group(0);
			int aLeftParenIndex = find.indexOf("(");
			int aRightParenIndex = find.indexOf(")");
			String aMethodName = find.substring(0, aLeftParenIndex).trim();
			String aParameters = find.substring(aLeftParenIndex + 1, aRightParenIndex);
			List<String> aParameterList = new ArrayList();
			String[] aParameterTokens = aParameters.split(",");
			for (String aParameter:aParameterTokens) {
				String aParameterTrimmed = aParameter.trim();
				if (!aParameterTrimmed.isEmpty())
				aParameterList.add(aParameterTrimmed);
			}
			retVal.add(new AMethodCall(aLineNumber, aMethodName, aParameterList, aParent));

//			aCallStrings.add(find);
		}
		return retVal;
	}
	static String numberRegex = "(\\d+\\.\\d+)|(\\d+)";
	static Pattern numberPattern = Pattern.compile(numberRegex);
	public static List<String> numbersIn(String aString) {
		if (aString == null)
			return null;
//		String regex = "(\\d+\\.\\d+)|(\\d+)";
//
//		Matcher m = Pattern.compile(regex).matcher(aString);
		Matcher m =numberPattern.matcher(aString);


		List<String> retVal = new ArrayList();

		while (m.find()) {
			retVal.add(m.group());
		}
		return retVal;
	}

	public static String subscriptIn(String aString) {
		if (aString == null)
			return null;
		return StringUtils.substringBetween(aString, "[", "]");
	}
	static String[] emptyStringArray = {};
	public static String[] subscriptsIn(String aString) {
		if (aString == null)
			return emptyStringArray;
		return StringUtils.substringsBetween(aString, "[", "]");
	}
	static  String operatorRegex = "([+-/*///^])|([/(/)])";
	static Pattern operatorPattern = Pattern.compile(operatorRegex);

	public static List<String> operatorsIn(String aString) {
		if (aString == null)
			return null;
//		String operatorRegex = "([+-/*///^])|([/(/)])";
//
//		Matcher m = Pattern.compile(operatorRegex).matcher(aString);
		
		Matcher m = operatorPattern.matcher(aString);


		List<String> retVal = new ArrayList();

		while (m.find()) {
			retVal.add(m.group());
		}
		return retVal;
	}
	
	public static int numberOfNestingFors (SNode anSNode) {
		if (anSNode == null) {
			return 0;
		}
		int retVal = numberOfNestingFors (anSNode.getParent()) ;

		if (anSNode instanceof ForSNode) {
			retVal++;
		} else if (anSNode instanceof MethodSNode) {
			List<MethodCall> aMethodCalls = ((MethodSNode) anSNode).getCalls();
			int aMaxNestingLevel = 0;
			for (MethodCall aMethodCall:aMethodCalls) {
				MethodSNode aCallerMethodSNode = getDeclarationOfCalledMethod(anSNode, aMethodCall);
				int aCallerNumberOfNestingFors = numberOfNestingFors(aCallerMethodSNode);
				aMaxNestingLevel = Math.max(aCallerNumberOfNestingFors, aMaxNestingLevel);				
			}
			return retVal + aMaxNestingLevel;
		}
		return retVal;
	}
	public static boolean hasOperator (SNode anSNode, String anOperator) {
		boolean retVal = false;
		if (anSNode instanceof AssignmentSNode) {
			AssignmentSNode anAssignmentSNode = (AssignmentSNode) anSNode;
			 retVal = (anAssignmentSNode.getLhsOperators().contains(anOperator) || 
					anAssignmentSNode.getRhsOperators().contains(anOperator)) ;
			if (retVal) {
				return retVal;
			} else {
				List<MethodCall> aMethodCalls = anAssignmentSNode.getRhsCalls();
				for (MethodCall aMethodCall:aMethodCalls) {
					MethodSNode aMethodSNode = getDeclarationOfCalledMethod(anSNode, aMethodCall);
					retVal = hasOperator(aMethodSNode, anOperator);
					if (retVal) {
						return retVal;
					}
					
				}
				return false;
			}
			
		}
		for (SNode aChild:anSNode.getChildren()) {
			retVal = hasOperator(aChild, anOperator);
			if (retVal) {
				return retVal;
			}
		}
		return false;
	}
	public static boolean hasMethodCall (SNode anSNode, String anOperator) {
		boolean retVal = false;
		if (anSNode instanceof AssignmentSNode) {
			AssignmentSNode anAssignmentSNode = (AssignmentSNode) anSNode;
			 retVal = (anAssignmentSNode.getLhsOperators().contains(anOperator) || 
					anAssignmentSNode.getRhsOperators().contains(anOperator)) ;
			if (retVal) {
				return retVal;
			} else {
				List<MethodCall> aMethodCalls = anAssignmentSNode.getRhsCalls();
				for (MethodCall aMethodCall:aMethodCalls) {
					MethodSNode aMethodSNode = getDeclarationOfCalledMethod(anSNode, aMethodCall);
					retVal = hasOperator(aMethodSNode, anOperator);
					if (retVal) {
						return retVal;
					}
					
				}
				return false;
			}
			
		}
		for (SNode aChild:anSNode.getChildren()) {
			retVal = hasOperator(aChild, anOperator);
			if (retVal) {
				return retVal;
			}
		}
		return false;
	}
	public static boolean dependsOn (AssignmentSNode anAssignmentSNode, String aVariable, String aCallIdentifier) {
		// This assignment does not change aVariable
		if (!aVariable.equals(anAssignmentSNode.getLhsVariable())) {
			return false;
		}
		return dependsOn(anAssignmentSNode.getExpressionSNode(), aCallIdentifier);
//		List<String> aCallIdentifiers = anAssignmentSNode.getRhsCallIdentifiers();
//		boolean retVal = false;
//		if (aCallIdentifiers != null && aCallIdentifiers.contains(aCallIdentifier)) {
//			return true; // this assignment has aCallIdentifier in the rhs
//		}
//		// check if some referenced rhs variable depends on aCallIdentifier
//		List<String> aReferencedVariableIdentifiers = anAssignmentSNode.getRhsVariableIdentifiers();
//		SNode anAssignmentParent = anAssignmentSNode.getParent();
//		if (anAssignmentParent == null) { // should never be trye
//			return false;
//		}
//		int aLineNumber = anAssignmentSNode.getLineNumber();
//		for (String aReferencedVariableIdentifier:aReferencedVariableIdentifiers ) {
//			if (dependsOn (anAssignmentParent, aLineNumber, aReferencedVariableIdentifier, aCallIdentifier)) {
//				return true;
//			}
//		}
//		return false;
	}
	public static boolean dependsOn (ExpressionSNode anExpressionSNode, String aCallIdentifier) {
		// This assignment does not change aVariable
		
		List<String> aCallIdentifiers = anExpressionSNode.getRhsCallIdentifiers();
		boolean retVal = false;
		if (aCallIdentifiers != null && aCallIdentifiers.contains(aCallIdentifier)) {
			return true; // this assignment has aCallIdentifier in the rhs
		}
		// check if some referenced rhs variable depends on aCallIdentifier
		List<String> aReferencedVariableIdentifiers = anExpressionSNode.getRhsVariableIdentifiers();
		SNode anAssignmentParent = anExpressionSNode.getParent().getParent();
		if (anAssignmentParent == null) { // should never be trye
			return false;
		}
		int aLineNumber = anExpressionSNode.getLineNumber();
		for (String aReferencedVariableIdentifier:aReferencedVariableIdentifiers ) {
			if (dependsOn (anAssignmentParent, aLineNumber, aReferencedVariableIdentifier, aCallIdentifier)) {
				return true;
			}
		}
		return false;
	}
	public static Set<AssignmentSNode> assignmentsToSharedVariables(SNode anSNode) {
		Set<AssignmentSNode> retVal =  new HashSet();
		fillAssignmentsToShared(anSNode, retVal);
		return retVal;
		
	}
	public static Set<AssignmentSNode> assignmentsToSharedArrays(SNode anSNode) {
		Set<AssignmentSNode> anAllSharedAssignments =  assignmentsToSharedVariables(anSNode);
		Set<AssignmentSNode> aRetVal = new HashSet();
		for (AssignmentSNode anAssignmentSNode:anAllSharedAssignments) {
			if (anAssignmentSNode.getLhsSubscripts().length > 0) {
				aRetVal.add(anAssignmentSNode);
			}
		}
		return aRetVal;
		
	}
	public static Set<AssignmentSNode> assignmentsToParallelCriticalSharedVariables(SNode anSNode) {
		Set<AssignmentSNode> anAllSharedAssignments =  assignmentsToSharedVariables(anSNode);
		Set<AssignmentSNode> aRetVal = new HashSet();
		for (AssignmentSNode anAssignmentSNode:anAllSharedAssignments) {
			if (anAssignmentSNode.isInParallel() &&
					anAssignmentSNode.isInCritical()) {
				aRetVal.add(anAssignmentSNode);
			}
		}
		return aRetVal;
		
	}
	public static Set<AssignmentSNode> assignmentsToNonParallelCriticalSharedVariables(SNode anSNode) {
		Set<AssignmentSNode> anAllSharedAssignments =  assignmentsToSharedVariables(anSNode);
		Set<AssignmentSNode> aRetVal = new HashSet();
		for (AssignmentSNode anAssignmentSNode:anAllSharedAssignments) {
			if (!anAssignmentSNode.isInParallel() &&
					anAssignmentSNode.isInCritical()) {
				aRetVal.add(anAssignmentSNode);
			}
		}
		return aRetVal;
		
	}
	public static Set<AssignmentSNode> assignmentsToParallelNonCriticalSharedVariables(SNode anSNode) {
		Set<AssignmentSNode> anAllSharedAssignments =  assignmentsToSharedVariables(anSNode);
		Set<AssignmentSNode> aRetVal = new HashSet();
		for (AssignmentSNode anAssignmentSNode:anAllSharedAssignments) {
			if (anAssignmentSNode.isInParallel() &&
					!anAssignmentSNode.isInCritical()) {
				aRetVal.add(anAssignmentSNode);
			}
		}
		return aRetVal;
		
	}
    public static void fillAssignmentsToShared(SNode anSNode, Set<AssignmentSNode> retVal) {
    	if (anSNode instanceof AssignmentSNode) {
			AssignmentSNode anAssignmentSNode = (AssignmentSNode) anSNode;
			String anLHS = anAssignmentSNode.getLhsVariable();
			if (isSharedVariable(anSNode, anLHS)) {
				retVal.add(anAssignmentSNode);
				return;
			}
		}
    	for (SNode aChild:anSNode.getChildren()) {
    		fillAssignmentsToShared(aChild, retVal);
    	}
		
	}
	public static boolean dependsOn (SNode anSNode, int aVariableLineNumber, String aVariable, String aCallIdentifier) {
		List<SNode> aListSNodes = anSNode.getChildren();
		boolean retVal = false;
		/*
		 * Should probably ignore line number as it assumes straight line code
		 */
		for (int i = aVariableLineNumber; i >= 0; i--) {
			SNode anSNodeChild = aListSNodes.get(i);
			if (anSNodeChild instanceof AssignmentSNode) {
				// does this statement in anSNode directly invoke aCallIdentifier 
				if (dependsOn((AssignmentSNode) anSNodeChild, aVariable, aCallIdentifier))
					return true;
			} else if (!anSNode.isLeaf()) {
					// child is overriding the variable so forget checking its assignment statements
					if (anSNodeChild.getLocalVariables().contains(aVariable)) {
						continue;
					}
					// some subblock of anSNode that has access to aVariable changes variable

					if (dependsOn(anSNodeChild, anSNodeChild.getChildren().size() - 1, aVariable, aCallIdentifier)) {
						return true;
					}
			}
			
		}
		// none of the statements in anSNode or its descendents  have the required call
		// is the variable a  method parameter 
		if (anSNode instanceof MethodSNode) {
			MethodSNode aMethodSNode = (MethodSNode) anSNode;
			
			int aParameterNumber = aMethodSNode.getLocalVariables().indexOf(aVariable);
			if (aParameterNumber != -1) {
				List <MethodCall> aCalls = aMethodSNode.getCalls();
				for (MethodCall aCall:aCalls) {
					MethodSNode aCallerSNode = getDeclarationOfCalledMethod(aMethodSNode, aCall);
					boolean aCallerDepends = dependsOn(aMethodSNode, aCallerSNode.getLineNumber(), aVariable, aCallIdentifier);
				    if (aCallerDepends) {
				    	return true;
				    }
				}
				return false;
				// need to find all callers of method and see if any of the aliases for the variable in these
				// calls depend on aCallIndentifier
			}			
			
		} else if (anSNode.getLocalVariables().contains(aVariable)) {
			// before going to the parent node, let us see if aVariable is declared here as a non  parameter 

			return false; // no point going to parent
		}
		// not a local variable (parameter or declarated variable)
		SNode anSNodeParent = anSNode.getParent() ;
		if (anSNodeParent == null)  {
			return false;
		}
		int anSNodeLineNumber = anSNodeParent.getChildren().indexOf(anSNode);
		return dependsOn(anSNodeParent, anSNodeLineNumber, aVariable, aCallIdentifier);
		
	}
	public static RootOfFileSNode getRootOfFileNode(SNode aCurrentSNode ) {
		if (aCurrentSNode instanceof RootOfFileSNode) {
			return (RootOfFileSNode) aCurrentSNode;
		}
		SNode aParentSNode = aCurrentSNode.getParent() ;
		
		if (aParentSNode == null) {
			return null;
		}
		
		return getRootOfFileNode(aParentSNode);
		
	}
	public static boolean match (MethodSNode aMethodSNode, MethodCall aMethodCall) {
		return aMethodSNode.getMethodName().equals(aMethodCall.getMethodName()) 
				&& aMethodSNode.getLocalVariables().size() == aMethodCall.getMethodActuals().size();
	}
	
	public static MethodSNode getDeclarationOfCalledMethod(SNode aCurrentSNode, MethodCall aMethodCall ) {
		SNode aRootNode = getRootOfFileNode(aCurrentSNode);
		for (SNode aChild:aRootNode.getChildren()) {
			if (aChild instanceof MethodSNode) {
				MethodSNode aMethodSNode = (MethodSNode) aChild;
				if (match (aMethodSNode, aMethodCall)) {
					return aMethodSNode;
				}
			}
		}
		return null; // this should never happen;
	}
	
	public static RootOfProgramSNode getRootOfProgramSNode(String aSource) {
		RootOfProgramSNode retVal = new ARootOfProgramSNode();
		Map<String, StringBuffer> aFileNameToContents = ABasicTextManager.extractFileContents(aSource);
		for (String aFileName:aFileNameToContents.keySet()) {
			StringBuffer aFileContents = aFileNameToContents.get(aFileName);
//			List<OpenMPPragma> anOpenMPPragmas = OpenMPUtils.getOpemMPPragmas(aFileContents);
			RootOfFileSNode anSNode = OMPSNodeUtils.getSNode(aFileName, aFileContents);
			retVal.getFileNameToSNode().put(aFileName, anSNode);
			anSNode.setParent(retVal);
//			System.out.println("file name:" + aFileName);
//			System.out.println("pragmas:" + anSNode);
		}
		processExternalMethodSNodes(retVal);
		return retVal;
	}
	public static void processExternalMethodSNodes (RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode) {
		for (SNode anSNode:aRootOfFileSNode.getChildren()) {
			if (anSNode instanceof ExternalMethodSNode) {
				processExternalMethodSNode(aRootOfProgramSNode, aRootOfFileSNode, (ExternalMethodSNode) anSNode);
			}
		}
	}
	public static void processExternalMethodSNode (RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode, ExternalMethodSNode anExternalMethodSNode) {
		MethodSNode aMethodSNode = aRootOfProgramSNode.getExternalToInternalMethod().get(anExternalMethodSNode.toString());
		if (aMethodSNode == null) {
			aMethodSNode = findMethodSNode(aRootOfProgramSNode, aRootOfFileSNode, anExternalMethodSNode);
			if (aMethodSNode != null) {
				aRootOfProgramSNode.getExternalToInternalMethod().put(anExternalMethodSNode.toString(),aMethodSNode );
			}
		}
		if (aMethodSNode != null) {
			anExternalMethodSNode.setActualMethodSNode(aMethodSNode);
			aMethodSNode.getCalls().addAll(anExternalMethodSNode.getLocalCalls());
		}
	}
	public static MethodSNode findMethodSNode (RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode, ExternalMethodSNode anExternalMethodSNode) {
//		MethodSNode foundMethodSNode = null;
		for (String aFileName:aRootOfProgramSNode.getFileNameToSNode().keySet()) {
			if (aFileName.equals(aRootOfFileSNode.getFileName()))
				continue;
			
			RootOfFileSNode aSearchedRootOfFileSNode = aRootOfProgramSNode.getFileNameToSNode().get(aFileName);
			 for (SNode anSNode:aSearchedRootOfFileSNode.getChildren()) {
				if (anSNode instanceof MethodSNode && !(anSNode instanceof ExternalMethodSNode)) {
					if (anSNode.toString().equals(anExternalMethodSNode.toString())) {
						return (MethodSNode) anSNode;
						
					}
//					processExternalMethodSNode(aRootOfProgramSNode, aRootOfFileSNode, (ExternalMethodSNode) anSNode);
				}
			}
		}
		return null;
	}
	public static void processExternalMethodSNodes (RootOfProgramSNode aRootOfProgramSNode) {
		for (String aFileName:aRootOfProgramSNode.getFileNameToSNode().keySet()) {
			RootOfFileSNode aRootOfFileSNode = aRootOfProgramSNode.getFileNameToSNode().get(aFileName);
			processExternalMethodSNodes(aRootOfProgramSNode, aRootOfFileSNode);
			aRootOfFileSNode.getOmp_get_num_threads_SNode().
				setActualMethodSNode(aRootOfProgramSNode.getOmp_get_num_threads_SNode());
			aRootOfFileSNode.getOmp_get_thread_num_SNode().
				setActualMethodSNode(aRootOfProgramSNode.getOmp_get_thread_num_SNode());
			aRootOfFileSNode.getOmp_get_wtime_SNode().
			setActualMethodSNode(aRootOfProgramSNode.getOmp_get_wtime_SNode());
		}

	}
	

//	public static void main(String[] args) {
//		List<MethodCall> aTokens = callsIn("foo(bar, hgf)/foo2()*foo3(b, a c,)");
//		System.out.println(aTokens);
//		
//		
////		List<String> aTokens = identifiersIn("a[i] + b*2/3");
////		System.out.println(aTokens);
////		aTokens = numbersIn("a[i] + b*2/3");
////		System.out.println(aTokens);
////		aTokens = operatorsIn("a[i] + b*2/3");
////		System.out.println(aTokens);
////
////		System.out.println(StringUtils.substringBetween("a", "[", "]"));
//	}

}
]]></snapshot>
  </Command>
  <Command __id="185749" _type="RunCommand" date="Mon Dec 30 10:20:36 EST 2019" kind="StepInto" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="1052731860" type="Run" />
  <Command __id="185750" _type="DiffBasedFileOpenCommand" date="Mon Dec 30 10:20:51 EST 2019" docASTNodeCount="1" docActiveCodeLength="532" docExpressionCount="0" docLength="575" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="1052745953">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\my_sum_parallel_for_reduction.cpp]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"#include <iostream>¶#include <omp.h>¶¶using namespace std;¶¶//const int SIZE = 1000;¶void printSumWithTimes(int sum, int start, int end);¶void printNumThreads();¶void recordThreadIndex(int index);¶void sum_parallel_for_reduction(double* array, int size) {¶	cout << "sum_parallel_for_reduction\n";¶¶	double start = omp_get_wtime();¶¶	double sum = 0;¶    #pragma omp  parallel for reduction ( + : sum )¶//	#pragma omp  for¶¶	for (int i = 0; i < size; i++) {¶		sum += array[i];¶		recordThreadIndex(i);¶	}¶¶	double end = omp_get_wtime();¶¶	printSumWithTimes(sum, start, end);¶¶}¶")]]]></diff>
  </Command>
  <Command __id="185751" _type="MoveCaretCommand" caretOffset="379" date="Mon Dec 30 10:20:51 EST 2019" docOffset="379" starttimestamp="1576666505112" timestamp="1052746101" />
  <Command __id="185752" _type="DiffBasedFileOpenCommand" date="Mon Dec 30 10:20:55 EST 2019" docASTNodeCount="1" docActiveCodeLength="659" docExpressionCount="0" docLength="747" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="1052750814">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\my_sum_parallel_for_local_var.cpp]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"#include <iostream>¶#include <omp.h>¶¶using namespace std;¶¶void printSumWithTimes (int sum, int start, int end);¶void printNumThreads();¶void recordThreadIndex(int index);¶void sum_parallel_for_local_var(double* array, int size)¶{¶	cout << "sum_parallel_for_local_var\n";¶¶	double start = omp_get_wtime();¶¶	double sum = 0;¶¶	int a, b;¶//¶//	for (int i = 0; i < size; i++) {¶//			sum += array[i];¶//			recordThreadIndex(i);¶//	}¶¶    #pragma omp parallel shared (sum, start) private (a, b)¶	{¶		double local_sum = 0;¶¶		#pragma omp for¶		for(int i = 0; i < size; i++) {¶			local_sum += array[i];¶			recordThreadIndex(i);¶		}¶¶		#pragma omp critical¶		sum += local_sum;¶	}¶¶	double end = omp_get_wtime();¶¶	printSumWithTimes(sum, start, end);¶	¶}¶")]]]></diff>
  </Command>
  <Command __id="185753" _type="MoveCaretCommand" caretOffset="621" date="Mon Dec 30 10:20:56 EST 2019" docOffset="621" starttimestamp="1576666505112" timestamp="1052750941" />
  <Command __id="185754" _type="DiffBasedFileOpenCommand" date="Mon Dec 30 10:20:59 EST 2019" docASTNodeCount="1" docActiveCodeLength="532" docExpressionCount="0" docLength="575" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="1052753897">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\my_sum_parallel_for_reduction.cpp]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"#include <iostream>¶#include <omp.h>¶¶using namespace std;¶¶//const int SIZE = 1000;¶void printSumWithTimes(int sum, int start, int end);¶void printNumThreads();¶void recordThreadIndex(int index);¶void sum_parallel_for_reduction(double* array, int size) {¶	cout << "sum_parallel_for_reduction\n";¶¶	double start = omp_get_wtime();¶¶	double sum = 0;¶    #pragma omp  parallel for reduction ( + : sum )¶//	#pragma omp  for¶¶	for (int i = 0; i < size; i++) {¶		sum += array[i];¶		recordThreadIndex(i);¶	}¶¶	double end = omp_get_wtime();¶¶	printSumWithTimes(sum, start, end);¶¶}¶")]]]></diff>
  </Command>
  <Command __id="185755" _type="MoveCaretCommand" caretOffset="379" date="Mon Dec 30 10:20:59 EST 2019" docOffset="379" starttimestamp="1576666505112" timestamp="1052754035" />
  <Command __id="185925" _type="DiffBasedFileOpenCommand" date="Mon Dec 30 10:27:41 EST 2019" docASTNodeCount="4116" docActiveCodeLength="29362" docExpressionCount="2589" docLength="33548" projectName="GraderBasics" starttimestamp="1576666505112" timestamp="1053156132">
    <filePath><![CDATA[D:\dewan_backup\Java\GraderBasics\src\gradingTools\shared\testcases\openmp\scannedTree\OMPSNodeUtils.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package gradingTools.shared.testcases.openmp.scannedTree;¶¶import java.util.ArrayList;¶import java.util.Arrays;¶import java.util.HashMap;¶import java.util.HashSet;¶import java.util.List;¶import java.util.Map;¶import java.util.Set;¶import java.util.Stack;¶import java.util.regex.Matcher;¶import java.util.regex.Pattern;¶¶import org.apache.commons.lang.StringUtils;¶¶import grader.basics.project.source.ABasicTextManager;¶import gradingTools.shared.testcases.openmp.OpenMPKeywordEnum;¶import gradingTools.shared.testcases.openmp.OpenMPParallelPragma;¶import gradingTools.shared.testcases.openmp.OpenMPUtils;¶import gradingTools.shared.testcases.openmp.scannedTree.ADeclarationSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.ADeclaringAssignmentSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.AForSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.ATextSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.AnAssignmentSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.AnOMPCriticalSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.AnOMPForSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.AnOMPParallelSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.AnOMPSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.AnSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.AssignmentSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.DeclarationSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.DeclaringAssignmentSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.ForSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.OMPForSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.OMPSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.SNode;¶¶public class OMPSNodeUtils extends OpenMPUtils {¶¶	public static RootOfFileSNode getSNode(String aFileName, StringBuffer aFileBuffer) {¶		String[] aFileLines = aFileBuffer.toString().split("\n");¶		return getSNode(aFileName, aFileLines);¶	}¶¶	public static AssignmentSNode getAssignmentSNode(int aLineNumber, String aString) {¶		if (aString == null) {¶			return null;¶		}¶		String[] aTokens = aString.split("=");¶		if (aTokens.length == 1) {¶			return new AnAssignmentSNode(aLineNumber, aTokens[0], null);¶		} else {¶		return new AnAssignmentSNode(aLineNumber, aTokens[0], aTokens[1]);¶		}¶	}¶¶	public static DeclarationSNode getDeclarationSNode(int aLineNumber, String aString) {¶		String[] aTokens = aString.split(" ");¶		return new ADeclarationSNode(aLineNumber, aTokens[0], aTokens[1]);¶	}¶¶	public static DeclaringAssignmentSNode getDeclaringAssignmentSNode(int aLineNumber, String aString) {¶		String[] anLHSAndRHS = aString.split("=");¶		String[] aTypeAndVariable = anLHSAndRHS[0].split(" ");¶		return new ADeclaringAssignmentSNode(aLineNumber, aTypeAndVariable[0], aTypeAndVariable[1], anLHSAndRHS[1]);¶	}¶¶	public static boolean isDeclaringAssignment(String aFileLine) {¶		return startsWithTypeName(aFileLine) && aFileLine.contains("=");¶	}¶	public static boolean isMethodDeclaration(String aFileLine) {¶		return startsWithTypeName(aFileLine) && ¶				aFileLine.contains("(") &&¶				!aFileLine.contains("=");¶	}¶	public static boolean isExternalMethodDeclaration(String aFileLine) {¶		return isMethodDeclaration(aFileLine) && aFileLine.endsWith(";");¶	}¶¶¶	public static boolean isVariableDeclaration(String aFileLine) {¶¶		return startsWithTypeName(aFileLine) && !aFileLine.contains("(");¶	}¶¶	public static boolean isAssignment(String aFileLine) {¶		return aFileLine.contains("=");¶	}¶¶	public static boolean isForNode(String aFileLine) {¶		return aFileLine.startsWith("for");¶	}¶¶	public static ForSNode getForSNode(int aLineNumber, String aFileLine) {¶¶		int aLeftParenIndex = aFileLine.indexOf("(");¶		int aRightParenIndex = aFileLine.indexOf(")");¶		if (aLeftParenIndex < 0 || aRightParenIndex < 0) {¶			return null;¶		}¶		String aHeaderString = aFileLine.substring(aLeftParenIndex + 1, aRightParenIndex);¶		String[] aForComponents = aHeaderString.split(";");¶		AssignmentSNode anAssignmentSNode = null;¶		String aForInitializaton = aForComponents[0];¶		if (!aForInitializaton.isEmpty() && aForInitializaton.contains("=")) {¶			if (isDeclaringAssignment(aForInitializaton)) {¶				anAssignmentSNode = getDeclaringAssignmentSNode(aLineNumber, aForInitializaton);¶			} else {¶				anAssignmentSNode = getAssignmentSNode(aLineNumber, aForInitializaton);¶			}¶¶		}		¶		return new AForSNode(aLineNumber, anAssignmentSNode, aForComponents[1], getAssignmentSNode(aLineNumber, aForComponents[2]));¶	}¶	static String[] emptyArray = {};¶	public static MethodSNode getMethodSNode(int aLineNumber, String aFileLine, boolean isInternal) {¶¶		int aLeftParenIndex = aFileLine.indexOf("(");¶		int aRightParenIndex = aFileLine.indexOf(")");¶		if (aLeftParenIndex < 0 || aRightParenIndex < 0) {¶			return null;¶		}¶		String aMethodNameAndType = aFileLine.substring(0, aLeftParenIndex);¶		String[] aMethodNameAndTypeTokens = aMethodNameAndType.split("\\s+"); ¶		¶		String aMethodParameters = aFileLine.substring(aLeftParenIndex +1 , aRightParenIndex);¶		String[] aMethodParameterTokens = aMethodParameters.isEmpty()?emptyArray:¶		 aMethodParameters.split(",");¶		¶//		String[] aMethodParameterTypes = new String[aMethodParameterTokens.length];¶//		String[] aMethodParameterNames = new String[aMethodParameterTokens.length];¶		List<DeclarationSNode> aDeclarationSNodeList = new ArrayList();¶		for (int i = 0; i < aMethodParameterTokens.length; i++ ) {¶			String[] aTypeAndName = aMethodParameterTokens[i].trim().split("\\s+");¶			if (aTypeAndName.length < 2) {¶				continue;¶			}¶			aDeclarationSNodeList.add(new ADeclarationSNode(aLineNumber, aTypeAndName[0].trim(), aTypeAndName[1].trim()));¶//			aMethodParameterTypes[i] = aTypeAndName[0].trim();¶//			aMethodParameterNames[i] = aTypeAndName[1].trim();¶		}¶		if (isInternal)¶//		return new AMethodSNode(aLineNumber, aMethodNameAndTypeTokens[0], aMethodNameAndTypeTokens[1], aMethodParameterTypes,aMethodParameterNames );¶			return new AMethodSNode(aLineNumber, aMethodNameAndTypeTokens[0], aMethodNameAndTypeTokens[1], aDeclarationSNodeList );¶		else¶			return new AnExternalMethodSNode(aLineNumber, aMethodNameAndTypeTokens[0], aMethodNameAndTypeTokens[1], aDeclarationSNodeList );¶	}¶¶	public static void setReductionData(OMPForSNode lastChild, String aStoredToken, int aLeftParenIndex,¶			int aRightParenIndex) {¶		int aColonIndex = aStoredToken.indexOf(":");¶		if (aLeftParenIndex != -1 && aRightParenIndex != -1 && aColonIndex != -1) {¶			String anOperationString = aStoredToken.substring(aLeftParenIndex + 1, aColonIndex).trim();¶			String aVariableString = aStoredToken.substring(aColonIndex + 1, aRightParenIndex).trim();¶			((OMPForSNode) lastChild).setReductionVariable(aVariableString);¶			((OMPForSNode) lastChild).setReductionOperation(anOperationString);¶		}¶	}¶¶	public static void setSharedOrPrivateData(OMPSNode lastChild, String aStoredToken, int aLeftParenIndex,¶			int aRightParenIndex, boolean isShared) {¶//		int aColonIndex = aStoredToken.indexOf(":");¶		if (aLeftParenIndex != -1 && aRightParenIndex != -1) {¶			String aVariableDeclarations = aStoredToken.substring(aLeftParenIndex + 1, aRightParenIndex);¶			String[] aVariables = aVariableDeclarations.split(",");¶			if (isShared) {¶				lastChild.setSharedVariables(aVariables);¶			} else {¶				lastChild.setPrivateVariables(aVariables);¶			}¶		}¶	}¶¶	public static RootOfFileSNode getSNode(String aFileName, String[] aFileLines) {¶		Stack<SNode> anSNodes = new Stack();¶¶		RootOfFileSNode retVal = new ARootOfFileSNode(aFileName);¶		anSNodes.add(retVal);¶		SNode previousHeaderNode = null;¶		for (int i = 0; i < aFileLines.length; i++) {¶			String aFileLine = aFileLines[i].trim();¶			if (!isCodeLine(aFileLine)) {¶				continue;¶			}¶			if (isForNode(aFileLine)) {¶				ForSNode aForSNode = getForSNode(i, aFileLine);¶				aForSNode.setParent(anSNodes.peek());¶//				anSNodes.push(aForSNode);¶				previousHeaderNode = aForSNode;¶				if (aFileLine.endsWith(")")) {¶					continue;¶				}¶			}¶			if (isExternalMethodDeclaration(aFileLine)) {¶				MethodSNode aMethodSNode = getMethodSNode(i, aFileLine, false);¶				aMethodSNode.setParent(anSNodes.peek());¶//				anSNodes.push(aForSNode);¶				previousHeaderNode = aMethodSNode;¶				if (aFileLine.endsWith(")")) {¶					continue;¶				}¶			}¶			if (isMethodDeclaration(aFileLine)) {¶				MethodSNode aMethodSNode = getMethodSNode(i, aFileLine, true);¶				aMethodSNode.setParent(anSNodes.peek());¶//				anSNodes.push(aForSNode);¶				previousHeaderNode = aMethodSNode;¶				if (aFileLine.endsWith(")")) {¶					continue;¶				}¶			}¶			if (isPragmaStart(aFileLine)) {¶				OMPSNode anOMPSNode = getOMPSNode(i, anSNodes.peek(), aFileLine);¶//				anSNodes.push(anOMPSNode);¶				previousHeaderNode = anOMPSNode;¶				continue;¶			}¶			if (isBlockStart(aFileLine)) {¶				SNode aBlockSNode = new AnSNode(i);¶				if (previousHeaderNode != null) {¶					aBlockSNode.setParent(previousHeaderNode);¶				} else {¶					aBlockSNode.setParent(anSNodes.peek());¶				}¶				anSNodes.push(aBlockSNode);¶				previousHeaderNode = null;¶				continue;¶			}¶//			} else ¶			if (isBlockEnd(aFileLine)) {¶				anSNodes.pop();¶				continue;¶			}¶			SNode aNewLeafNode = null;¶			if (isDeclaringAssignment(aFileLine)) {¶				aNewLeafNode = getDeclaringAssignmentSNode(i, aFileLine);¶¶			} else if (isAssignment(aFileLine)) {¶				aNewLeafNode = getAssignmentSNode(i, aFileLine);¶			} else if (isVariableDeclaration(aFileLine)) {¶				aNewLeafNode = getDeclarationSNode(i, aFileLine);¶			} else {¶				List<MethodCall> aCalls = callsIn(i, aFileLine, null); // parent will be assigned below¶				if (aCalls != null && aCalls.size() == 1) {¶					aNewLeafNode = aCalls.get(0);¶				} else {¶					aNewLeafNode = new ATextSNode(i, aFileLine);¶				}¶			}¶//			else {¶//				aNewLeafNode = new ATextSNode(i, aFileLine);¶//			}¶			if (previousHeaderNode != null) {¶				aNewLeafNode.setParent(previousHeaderNode);¶			} else {¶				aNewLeafNode.setParent(anSNodes.peek());¶			}¶¶		}¶¶		return retVal;¶	}¶¶	public static OMPSNode getOMPSNode(int aLineIndex, SNode aParentNode, String aFileLine) {¶		String[] aTokens = aFileLine.split("\\s+");¶		if (aTokens.length <= 2) {¶			return null;¶		}¶		if (!aTokens[1].equals("omp")) {¶			return null;¶		}¶		if (aTokens.length < 3) {¶			return null;¶		}¶		String aFirstToken = aTokens[2];¶		OpenMPKeywordEnum anOpenMPKeyword = stringToOpenMPKeyword.get(aFirstToken);¶//		List<OpenMPPragma> retVal = new ArrayList();¶		OMPSNode lastChild = null;¶		int aStartIndex = 2;¶		OMPSNode aNewNode = null;¶		OMPForSNode aForChild = null;¶		switch (anOpenMPKeyword) {¶		case PARALLEL:¶			aNewNode = new AnOMPParallelSNode(aLineIndex);¶¶			if (aTokens.length > 3 && aTokens[3].equals("for")) {¶				aForChild = new AnOMPForSNode(aLineIndex);¶				aForChild.setParent(aNewNode);¶¶				aStartIndex++;¶			}¶			break;¶		case FOR:¶			aNewNode = new AnOMPForSNode(aLineIndex);¶			;¶			break;¶		case CRITICAL:¶			aNewNode = new AnOMPCriticalSNode(aLineIndex);¶//			retVal.add (lastChild);¶			break;¶		default:¶			aNewNode = new AnOMPSNode(aLineIndex);¶¶		}¶¶		if (lastChild != null) {¶			aNewNode.setParent(lastChild);¶		} else {¶			aNewNode.setParent(aParentNode);¶		}¶		lastChild = aForChild == null ? aNewNode : aForChild;¶¶		for (int i = aStartIndex; i < aTokens.length; i++) {¶			String aStoredToken = aTokens[i].trim();¶			if (aStoredToken.isEmpty()) {¶				continue;¶			}¶			if (aStoredToken.startsWith("reduction") || aStoredToken.startsWith("shared")¶					|| aStoredToken.startsWith("private")) {¶				// combine all tokens until ")" into one for normalization¶				while (!aStoredToken.endsWith(")")) {¶					i++;¶					if (i >= aTokens.length) {¶						break;¶					}¶					String aNewToken = aTokens[i].trim();¶					aStoredToken += aNewToken;¶				}¶				int aLeftParenIndex = aStoredToken.indexOf("(");¶				int aRightParenIndex = aStoredToken.indexOf(")");¶				if (aStoredToken.startsWith("reduction")) {¶					setReductionData((OMPForSNode) lastChild, aStoredToken, aLeftParenIndex, aRightParenIndex);¶				} else if (aStoredToken.startsWith("private")) {¶					setSharedOrPrivateData((OMPSNode) lastChild, aStoredToken, aLeftParenIndex, aRightParenIndex,¶							false);¶¶				} else if (aStoredToken.startsWith("shared")) {¶					setSharedOrPrivateData(lastChild, aStoredToken, aLeftParenIndex, aRightParenIndex, true);¶¶				}¶¶			}¶¶			lastChild.getOpenMPTokens().add(aStoredToken);¶		}¶¶		return lastChild;¶¶	}¶¶	public static boolean hasParallelAncestor(SNode anSNode) {¶		if (anSNode == null) {¶			return false;¶		}¶		if (anSNode instanceof OMPParallelSNode) {¶			return true;¶		}¶		return hasParallelAncestor(anSNode.getParent());¶	}¶	public static boolean hasCriticalAncestor(SNode anSNode) {¶		if (anSNode == null) {¶			return false;¶		}¶		if (anSNode instanceof OMPCriticalSNode) {¶			return true;¶		}¶		return hasCriticalAncestor(anSNode.getParent());¶	}¶¶¶	public static Boolean isDeclaredShared(OMPSNode anOMPSNode, String anLHS) {¶		if (Arrays.asList(anOMPSNode.getSharedVariables()).contains(anLHS)) {¶			return true;¶		}¶		if (Arrays.asList(anOMPSNode.getPrivateVariables()).contains(anLHS)) {¶			return false;¶		}¶		return null;¶¶	}¶¶	public static boolean isSharedVariable(SNode anSNode, String anLHS) {¶		if (anSNode == null) {¶			return false;¶		}¶		if (anSNode.getLocalVariables().contains(anLHS)) {¶			if (!(anSNode instanceof OMPSNode)) { // no shared and private declarations¶				return !hasParallelAncestor(anSNode); // shared if not inParallel¶			}¶			OMPSNode anOMPSNode = (OMPSNode) anSNode;¶			return (Arrays.asList(anOMPSNode.getSharedVariables()).contains(anLHS)); // private unless declared shared¶		}¶		if (anSNode instanceof OMPSNode) {¶			OMPSNode anOMPSNode = (OMPSNode) anSNode;¶			// the variable is global to this scope, check if it has have been made shared¶			// or private by this scope¶			Boolean isDeclaredShared = isDeclaredShared(anOMPSNode, anLHS);¶			if (isDeclaredShared != null) {¶				return isDeclaredShared;¶			}¶		}¶		// check the parent¶		return isSharedVariable(anSNode.getParent(), anLHS);¶	}¶¶	public static List<SNode> getAllLeafNodes(SNode aTopNode) {¶		List<SNode> retVal = new ArrayList();¶		addLeafNodes(aTopNode, retVal);¶		return retVal;¶	}¶¶	public static void addLeafNodes(SNode aTopNode, List<SNode> retVal) {¶		for (SNode aChild : aTopNode.getChildren()) {¶			if (aChild.isLeaf()) {¶				retVal.add(aChild);¶			} else {¶				addLeafNodes(aChild, retVal);¶			}¶		}¶	}¶¶	public static List<SNode> getNonParallelLeafNodes(SNode aTopNode) {¶		List<SNode> retVal = new ArrayList();¶		addNonParallelLeafNodes(aTopNode, retVal);¶		return retVal;¶	}¶¶	public static void addNonParallelLeafNodes(SNode aTopNode, List<SNode> retVal) {¶		if (aTopNode.isInParallel()) {¶			return;¶		}¶		for (SNode aChild : aTopNode.getChildren()) {¶			if (aChild.isLeaf()) {¶				retVal.add(aChild);¶			} else {¶				addLeafNodes(aChild, retVal);¶			}¶		}¶	}¶	static String callRegex = "([a-zA-Z_$][a-zA-Z_$0-9]*)\\(.*?\\)";¶	static Pattern callPattern = Pattern.compile(callRegex);¶¶	static String identifierRegex = "[a-zA-Z_$][a-zA-Z_$0-9]*";¶	static Pattern identifierPattern = Pattern.compile(identifierRegex);¶	public static List<String> identifiersIn(String aString) {¶		if (aString == null)¶			return null;¶//		Pattern mypattern = Pattern.compile("[a-zA-Z_$][a-zA-Z_$0-9]*");¶//		Matcher mymatcher = mypattern.matcher(aString);¶		Matcher mymatcher = identifierPattern.matcher(aString);¶		List<String> retVal = new ArrayList();¶		while (mymatcher.find()) {¶			String find = mymatcher.group(0);¶			retVal.add(find);¶		}¶		return retVal;¶	}¶	public static List<MethodCall> callsIn(int aLineNumber, String aString, SNode aParent) {¶		if (aString == null)¶			return null;¶//		Pattern mypattern = Pattern.compile("[a-zA-Z_$][a-zA-Z_$0-9]*");¶//		Matcher mymatcher = mypattern.matcher(aString);¶		Matcher mymatcher = callPattern.matcher(aString);¶		List<MethodCall> retVal = new ArrayList();¶		while (mymatcher.find()) {¶			String find = mymatcher.group(0);¶			int aLeftParenIndex = find.indexOf("(");¶			int aRightParenIndex = find.indexOf(")");¶			String aMethodName = find.substring(0, aLeftParenIndex).trim();¶			String aParameters = find.substring(aLeftParenIndex + 1, aRightParenIndex);¶			List<String> aParameterList = new ArrayList();¶			String[] aParameterTokens = aParameters.split(",");¶			for (String aParameter:aParameterTokens) {¶				String aParameterTrimmed = aParameter.trim();¶				if (!aParameterTrimmed.isEmpty())¶				aParameterList.add(aParameterTrimmed);¶			}¶			retVal.add(new AMethodCall(aLineNumber, aMethodName, aParameterList, aParent));¶¶//			aCallStrings.add(find);¶		}¶		return retVal;¶	}¶	static String numberRegex = "(\\d+\\.\\d+)|(\\d+)";¶	static Pattern numberPattern = Pattern.compile(numberRegex);¶	public static List<String> numbersIn(String aString) {¶		if (aString == null)¶			return null;¶//		String regex = "(\\d+\\.\\d+)|(\\d+)";¶//¶//		Matcher m = Pattern.compile(regex).matcher(aString);¶		Matcher m =numberPattern.matcher(aString);¶¶¶		List<String> retVal = new ArrayList();¶¶		while (m.find()) {¶			retVal.add(m.group());¶		}¶		return retVal;¶	}¶¶	public static String subscriptIn(String aString) {¶		if (aString == null)¶			return null;¶		return StringUtils.substringBetween(aString, "[", "]");¶	}¶	static String[] emptyStringArray = {};¶	public static String[] subscriptsIn(String aString) {¶		if (aString == null)¶			return emptyStringArray;¶		return StringUtils.substringsBetween(aString, "[", "]");¶	}¶	static  String operatorRegex = "([+-/*///^])|([/(/)])";¶	static Pattern operatorPattern = Pattern.compile(operatorRegex);¶¶	public static List<String> operatorsIn(String aString) {¶		if (aString == null)¶			return null;¶//		String operatorRegex = "([+-/*///^])|([/(/)])";¶//¶//		Matcher m = Pattern.compile(operatorRegex).matcher(aString);¶		¶		Matcher m = operatorPattern.matcher(aString);¶¶¶		List<String> retVal = new ArrayList();¶¶		while (m.find()) {¶			retVal.add(m.group());¶		}¶		return retVal;¶	}¶	¶	public static int numberOfNestingFors (SNode anSNode) {¶		if (anSNode == null) {¶			return 0;¶		}¶		int retVal = numberOfNestingFors (anSNode.getParent()) ;¶¶		if (anSNode instanceof ForSNode) {¶			retVal++;¶		} else if (anSNode instanceof MethodSNode) {¶			List<MethodCall> aMethodCalls = ((MethodSNode) anSNode).getCalls();¶			int aMaxNestingLevel = 0;¶			for (MethodCall aMethodCall:aMethodCalls) {¶				MethodSNode aCallerMethodSNode = getDeclarationOfCalledMethod(anSNode, aMethodCall);¶				int aCallerNumberOfNestingFors = numberOfNestingFors(aCallerMethodSNode);¶				aMaxNestingLevel = Math.max(aCallerNumberOfNestingFors, aMaxNestingLevel);				¶			}¶			return retVal + aMaxNestingLevel;¶		}¶		return retVal;¶	}¶	public static boolean hasOperator (SNode anSNode, String anOperator) {¶		boolean retVal = false;¶		if (anSNode instanceof AssignmentSNode) {¶			AssignmentSNode anAssignmentSNode = (AssignmentSNode) anSNode;¶			 retVal = (anAssignmentSNode.getLhsOperators().contains(anOperator) || ¶					anAssignmentSNode.getRhsOperators().contains(anOperator)) ;¶			if (retVal) {¶				return retVal;¶			} else {¶				List<MethodCall> aMethodCalls = anAssignmentSNode.getRhsCalls();¶				for (MethodCall aMethodCall:aMethodCalls) {¶					MethodSNode aMethodSNode = getDeclarationOfCalledMethod(anSNode, aMethodCall);¶					retVal = hasOperator(aMethodSNode, anOperator);¶					if (retVal) {¶						return retVal;¶					}¶					¶				}¶				return false;¶			}¶			¶		}¶		for (SNode aChild:anSNode.getChildren()) {¶			retVal = hasOperator(aChild, anOperator);¶			if (retVal) {¶				return retVal;¶			}¶		}¶		return false;¶	}¶	public static boolean hasMethodCall (SNode anSNode, String anOperator) {¶		boolean retVal = false;¶		if (anSNode instanceof AssignmentSNode) {¶			AssignmentSNode anAssignmentSNode = (AssignmentSNode) anSNode;¶			 retVal = (anAssignmentSNode.getLhsOperators().contains(anOperator) || ¶					anAssignmentSNode.getRhsOperators().contains(anOperator)) ;¶			if (retVal) {¶				return retVal;¶			} else {¶				List<MethodCall> aMethodCalls = anAssignmentSNode.getRhsCalls();¶				for (MethodCall aMethodCall:aMethodCalls) {¶					MethodSNode aMethodSNode = getDeclarationOfCalledMethod(anSNode, aMethodCall);¶					retVal = hasOperator(aMethodSNode, anOperator);¶					if (retVal) {¶						return retVal;¶					}¶					¶				}¶				return false;¶			}¶			¶		}¶		for (SNode aChild:anSNode.getChildren()) {¶			retVal = hasOperator(aChild, anOperator);¶			if (retVal) {¶				return retVal;¶			}¶		}¶		return false;¶	}¶	public static boolean dependsOn (AssignmentSNode anAssignmentSNode, String aVariable, String aCallIdentifier) {¶		// This assignment does not change aVariable¶		if (!aVariable.equals(anAssignmentSNode.getLhsVariable())) {¶			return false;¶		}¶		return dependsOn(anAssignmentSNode.getExpressionSNode(), aCallIdentifier);¶//		List<String> aCallIdentifiers = anAssignmentSNode.getRhsCallIdentifiers();¶//		boolean retVal = false;¶//		if (aCallIdentifiers != null && aCallIdentifiers.contains(aCallIdentifier)) {¶//			return true; // this assignment has aCallIdentifier in the rhs¶//		}¶//		// check if some referenced rhs variable depends on aCallIdentifier¶//		List<String> aReferencedVariableIdentifiers = anAssignmentSNode.getRhsVariableIdentifiers();¶//		SNode anAssignmentParent = anAssignmentSNode.getParent();¶//		if (anAssignmentParent == null) { // should never be trye¶//			return false;¶//		}¶//		int aLineNumber = anAssignmentSNode.getLineNumber();¶//		for (String aReferencedVariableIdentifier:aReferencedVariableIdentifiers ) {¶//			if (dependsOn (anAssignmentParent, aLineNumber, aReferencedVariableIdentifier, aCallIdentifier)) {¶//				return true;¶//			}¶//		}¶//		return false;¶	}¶	public static boolean dependsOn (ExpressionSNode anExpressionSNode, String aCallIdentifier) {¶		// This assignment does not change aVariable¶		¶		List<String> aCallIdentifiers = anExpressionSNode.getRhsCallIdentifiers();¶		boolean retVal = false;¶		if (aCallIdentifiers != null && aCallIdentifiers.contains(aCallIdentifier)) {¶			return true; // this assignment has aCallIdentifier in the rhs¶		}¶		// check if some referenced rhs variable depends on aCallIdentifier¶		List<String> aReferencedVariableIdentifiers = anExpressionSNode.getRhsVariableIdentifiers();¶		SNode anAssignmentParent = anExpressionSNode.getParent().getParent();¶		if (anAssignmentParent == null) { // should never be trye¶			return false;¶		}¶		int aLineNumber = anExpressionSNode.getLineNumber();¶		for (String aReferencedVariableIdentifier:aReferencedVariableIdentifiers ) {¶			if (dependsOn (anAssignmentParent, aLineNumber, aReferencedVariableIdentifier, aCallIdentifier)) {¶				return true;¶			}¶		}¶		return false;¶	}¶	public static Set<AssignmentSNode> assignmentsToSharedVariables(SNode anSNode) {¶		Set<AssignmentSNode> retVal =  new HashSet();¶		fillAssignmentsToShared(anSNode, retVal);¶		return retVal;¶		¶	}¶	public static Set<AssignmentSNode> assignmentsToSharedArrays(SNode anSNode) {¶		Set<AssignmentSNode> anAllSharedAssignments =  assignmentsToSharedVariables(anSNode);¶		Set<AssignmentSNode> aRetVal = new HashSet();¶		for (AssignmentSNode anAssignmentSNode:anAllSharedAssignments) {¶			if (anAssignmentSNode.getLhsSubscripts().length > 0) {¶				aRetVal.add(anAssignmentSNode);¶			}¶		}¶		return aRetVal;¶		¶	}¶	public static Set<AssignmentSNode> assignmentsToParallelCriticalSharedVariables(SNode anSNode) {¶		Set<AssignmentSNode> anAllSharedAssignments =  assignmentsToSharedVariables(anSNode);¶		Set<AssignmentSNode> aRetVal = new HashSet();¶		for (AssignmentSNode anAssignmentSNode:anAllSharedAssignments) {¶			if (anAssignmentSNode.isInParallel() &&¶					anAssignmentSNode.isInCritical()) {¶				aRetVal.add(anAssignmentSNode);¶			}¶		}¶		return aRetVal;¶		¶	}¶	public static Set<AssignmentSNode> assignmentsToNonParallelCriticalSharedVariables(SNode anSNode) {¶		Set<AssignmentSNode> anAllSharedAssignments =  assignmentsToSharedVariables(anSNode);¶		Set<AssignmentSNode> aRetVal = new HashSet();¶		for (AssignmentSNode anAssignmentSNode:anAllSharedAssignments) {¶			if (!anAssignmentSNode.isInParallel() &&¶					anAssignmentSNode.isInCritical()) {¶				aRetVal.add(anAssignmentSNode);¶			}¶		}¶		return aRetVal;¶		¶	}¶	public static Set<AssignmentSNode> assignmentsToParallelNonCriticalSharedVariables(SNode anSNode) {¶		Set<AssignmentSNode> anAllSharedAssignments =  assignmentsToSharedVariables(anSNode);¶		Set<AssignmentSNode> aRetVal = new HashSet();¶		for (AssignmentSNode anAssignmentSNode:anAllSharedAssignments) {¶			if (anAssignmentSNode.isInParallel() &&¶					!anAssignmentSNode.isInCritical()) {¶				aRetVal.add(anAssignmentSNode);¶			}¶		}¶		return aRetVal;¶		¶	}¶    public static void fillAssignmentsToShared(SNode anSNode, Set<AssignmentSNode> retVal) {¶    	if (anSNode instanceof AssignmentSNode) {¶			AssignmentSNode anAssignmentSNode = (AssignmentSNode) anSNode;¶			String anLHS = anAssignmentSNode.getLhsVariable();¶			if (isSharedVariable(anSNode, anLHS)) {¶				retVal.add(anAssignmentSNode);¶				return;¶			}¶		}¶    	for (SNode aChild:anSNode.getChildren()) {¶    		fillAssignmentsToShared(aChild, retVal);¶    	}¶		¶	}¶	public static boolean dependsOn (SNode anSNode, int aVariableLineNumber, String aVariable, String aCallIdentifier) {¶		List<SNode> aListSNodes = anSNode.getChildren();¶		boolean retVal = false;¶		/*¶		 * Should probably ignore line number as it assumes straight line code¶		 */¶		for (int i = aVariableLineNumber; i >= 0; i--) {¶			SNode anSNodeChild = aListSNodes.get(i);¶			if (anSNodeChild instanceof AssignmentSNode) {¶				// does this statement in anSNode directly invoke aCallIdentifier ¶				if (dependsOn((AssignmentSNode) anSNodeChild, aVariable, aCallIdentifier))¶					return true;¶			} else if (!anSNode.isLeaf()) {¶					// child is overriding the variable so forget checking its assignment statements¶					if (anSNodeChild.getLocalVariables().contains(aVariable)) {¶						continue;¶					}¶					// some subblock of anSNode that has access to aVariable changes variable¶¶					if (dependsOn(anSNodeChild, anSNodeChild.getChildren().size() - 1, aVariable, aCallIdentifier)) {¶						return true;¶					}¶			}¶			¶		}¶		// none of the statements in anSNode or its descendents  have the required call¶		// is the variable a  method parameter ¶		if (anSNode instanceof MethodSNode) {¶			MethodSNode aMethodSNode = (MethodSNode) anSNode;¶			¶			int aParameterNumber = aMethodSNode.getLocalVariables().indexOf(aVariable);¶			if (aParameterNumber != -1) {¶				List <MethodCall> aCalls = aMethodSNode.getCalls();¶				for (MethodCall aCall:aCalls) {¶					MethodSNode aCallerSNode = getDeclarationOfCalledMethod(aMethodSNode, aCall);¶					boolean aCallerDepends = dependsOn(aMethodSNode, aCallerSNode.getLineNumber(), aVariable, aCallIdentifier);¶				    if (aCallerDepends) {¶				    	return true;¶				    }¶				}¶				return false;¶				// need to find all callers of method and see if any of the aliases for the variable in these¶				// calls depend on aCallIndentifier¶			}			¶			¶		} else if (anSNode.getLocalVariables().contains(aVariable)) {¶			// before going to the parent node, let us see if aVariable is declared here as a non  parameter ¶¶			return false; // no point going to parent¶		}¶		// not a local variable (parameter or declarated variable)¶		SNode anSNodeParent = anSNode.getParent() ;¶		if (anSNodeParent == null)  {¶			return false;¶		}¶		int anSNodeLineNumber = anSNodeParent.getChildren().indexOf(anSNode);¶		return dependsOn(anSNodeParent, anSNodeLineNumber, aVariable, aCallIdentifier);¶		¶	}¶	public static RootOfFileSNode getRootOfFileNode(SNode aCurrentSNode ) {¶		if (aCurrentSNode instanceof RootOfFileSNode) {¶			return (RootOfFileSNode) aCurrentSNode;¶		}¶		SNode aParentSNode = aCurrentSNode.getParent() ;¶		¶		if (aParentSNode == null) {¶			return null;¶		}¶		¶		return getRootOfFileNode(aParentSNode);¶		¶	}¶	public static boolean match (MethodSNode aMethodSNode, MethodCall aMethodCall) {¶		return aMethodSNode.getMethodName().equals(aMethodCall.getMethodName()) ¶				&& aMethodSNode.getLocalVariables().size() == aMethodCall.getMethodActuals().size();¶	}¶	¶	public static MethodSNode getDeclarationOfCalledMethod(SNode aCurrentSNode, MethodCall aMethodCall ) {¶		SNode aRootNode = getRootOfFileNode(aCurrentSNode);¶		for (SNode aChild:aRootNode.getChildren()) {¶			if (aChild instanceof MethodSNode) {¶				MethodSNode aMethodSNode = (MethodSNode) aChild;¶				if (match (aMethodSNode, aMethodCall)) {¶					return aMethodSNode;¶				}¶			}¶		}¶		return null; // this should never happen;¶	}¶	¶	public static RootOfProgramSNode getRootOfProgramSNode(String aSource) {¶		RootOfProgramSNode retVal = new ARootOfProgramSNode();¶		Map<String, StringBuffer> aFileNameToContents = ABasicTextManager.extractFileContents(aSource);¶		for (String aFileName:aFileNameToContents.keySet()) {¶			StringBuffer aFileContents = aFileNameToContents.get(aFileName);¶//			List<OpenMPPragma> anOpenMPPragmas = OpenMPUtils.getOpemMPPragmas(aFileContents);¶			RootOfFileSNode anSNode = OMPSNodeUtils.getSNode(aFileName, aFileContents);¶			retVal.getFileNameToSNode().put(aFileName, anSNode);¶			anSNode.setParent(retVal);¶//			System.out.println("file name:" + aFileName);¶//			System.out.println("pragmas:" + anSNode);¶		}¶		processExternalMethodSNodes(retVal);¶		return retVal;¶	}¶	public static void processExternalMethodSNodes (RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode) {¶		for (SNode anSNode:aRootOfFileSNode.getChildren()) {¶			if (anSNode instanceof ExternalMethodSNode) {¶				processExternalMethodSNode(aRootOfProgramSNode, aRootOfFileSNode, (ExternalMethodSNode) anSNode);¶			}¶		}¶	}¶	public static void processExternalMethodSNode (RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode, ExternalMethodSNode anExternalMethodSNode) {¶		MethodSNode aMethodSNode = aRootOfProgramSNode.getExternalToInternalMethod().get(anExternalMethodSNode.toString());¶		if (aMethodSNode == null) {¶			aMethodSNode = findMethodSNode(aRootOfProgramSNode, aRootOfFileSNode, anExternalMethodSNode);¶			if (aMethodSNode != null) {¶				aRootOfProgramSNode.getExternalToInternalMethod().put(anExternalMethodSNode.toString(),aMethodSNode );¶			}¶		}¶		if (aMethodSNode != null) {¶			anExternalMethodSNode.setActualMethodSNode(aMethodSNode);¶			aMethodSNode.getCalls().addAll(anExternalMethodSNode.getLocalCalls());¶		}¶	}¶	public static MethodSNode findMethodSNode (RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode, ExternalMethodSNode anExternalMethodSNode) {¶//		MethodSNode foundMethodSNode = null;¶		for (String aFileName:aRootOfProgramSNode.getFileNameToSNode().keySet()) {¶			if (aFileName.equals(aRootOfFileSNode.getFileName()))¶				continue;¶			¶			RootOfFileSNode aSearchedRootOfFileSNode = aRootOfProgramSNode.getFileNameToSNode().get(aFileName);¶			 for (SNode anSNode:aSearchedRootOfFileSNode.getChildren()) {¶				if (anSNode instanceof MethodSNode && !(anSNode instanceof ExternalMethodSNode)) {¶					if (anSNode.toString().equals(anExternalMethodSNode.toString())) {¶						return (MethodSNode) anSNode;¶						¶					}¶//					processExternalMethodSNode(aRootOfProgramSNode, aRootOfFileSNode, (ExternalMethodSNode) anSNode);¶				}¶			}¶		}¶		return null;¶	}¶	public static void processExternalMethodSNodes (RootOfProgramSNode aRootOfProgramSNode) {¶		for (String aFileName:aRootOfProgramSNode.getFileNameToSNode().keySet()) {¶			RootOfFileSNode aRootOfFileSNode = aRootOfProgramSNode.getFileNameToSNode().get(aFileName);¶			processExternalMethodSNodes(aRootOfProgramSNode, aRootOfFileSNode);¶			aRootOfFileSNode.getOmp_get_num_threads_SNode().¶				setActualMethodSNode(aRootOfProgramSNode.getOmp_get_num_threads_SNode());¶			aRootOfFileSNode.getOmp_get_thread_num_SNode().¶				setActualMethodSNode(aRootOfProgramSNode.getOmp_get_thread_num_SNode());¶			aRootOfFileSNode.getOmp_get_wtime_SNode().¶			setActualMethodSNode(aRootOfProgramSNode.getOmp_get_wtime_SNode());¶		}¶¶	}¶	¶¶//	public static void main(String[] args) {¶//		List<MethodCall> aTokens = callsIn("foo(bar, hgf)/foo2()*foo3(b, a c,)");¶//		System.out.println(aTokens);¶//		¶//		¶////		List<String> aTokens = identifiersIn("a[i] + b*2/3");¶////		System.out.println(aTokens);¶////		aTokens = numbersIn("a[i] + b*2/3");¶////		System.out.println(aTokens);¶////		aTokens = operatorsIn("a[i] + b*2/3");¶////		System.out.println(aTokens);¶////¶////		System.out.println(StringUtils.substringBetween("a", "[", "]"));¶//	}¶¶}¶")]]]></diff>
  </Command>
  <Command __id="186069" _type="DiffBasedFileOpenCommand" date="Mon Dec 30 10:46:57 EST 2019" docASTNodeCount="423" docActiveCodeLength="3162" docExpressionCount="328" docLength="5913" projectName="DemoCourseLocalBasicChecks" starttimestamp="1576666505112" timestamp="1054312808">
    <filePath><![CDATA[D:\dewan_backup\Java\DemoCourseLocalBasicChecks\src\gradingTools\comp123\assignment1\openmp\testcases\SequentialSumTestCase.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package gradingTools.comp123.assignment1.openmp.testcases;¶¶import java.util.Arrays;¶import java.util.List;¶import java.util.Map;¶import java.util.Set;¶import java.util.regex.Pattern;¶¶import grader.basics.execution.NotRunnableException;¶import grader.basics.execution.RunningProject;¶import grader.basics.junit.NotAutomatableException;¶import grader.basics.junit.TestCaseResult;¶import grader.basics.project.NotGradableException;¶import grader.basics.project.Project;¶import grader.basics.project.source.ABasicTextManager;¶import grader.basics.testcase.PassFailJUnitTestCase;¶import gradingTools.shared.testcases.SubstringSequenceChecker;¶import gradingTools.shared.testcases.openmp.OpenMPPragma;¶import gradingTools.shared.testcases.openmp.OpenMPUtils;¶import gradingTools.shared.testcases.openmp.scannedTree.AssignmentSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.ExternalMethodSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.MethodSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.OMPSNodeUtils;¶import gradingTools.shared.testcases.openmp.scannedTree.RootOfFileSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.RootOfProgramSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.SNode;¶import gradingTools.shared.testcases.utils.LinesMatchKind;¶import gradingTools.shared.testcases.utils.LinesMatcher;¶import gradingTools.utils.RunningProjectUtils;¶¶public class SequentialSumTestCase extends PassFailJUnitTestCase {¶	public static final int TIME_OUT_SECS = 1; // secs¶	protected SubstringSequenceChecker checker = new ASequentialSumChecker();	¶¶	public SequentialSumTestCase() {¶	}¶¶	¶¶	@Override¶	public TestCaseResult test(Project project, boolean autoGrade) throws NotAutomatableException,¶			NotGradableException {¶		try {¶			RunningProject aRunningProject = RunningProjectUtils.runProject(project, TIME_OUT_SECS);¶			String anOutput = aRunningProject.await();¶			LinesMatcher aLinesMatcher = aRunningProject.getLinesMatcher();¶			boolean aRetval = checker.check(aLinesMatcher, LinesMatchKind.ONE_TIME_LINE, Pattern.DOTALL);¶			String aSource = project.getSource();¶//			Map<String, StringBuffer> aFileNameToContents = ABasicTextManager.extractFileContents(aSource);¶//			for (String aFileName:aFileNameToContents.keySet()) {¶//				StringBuffer aFileContents = aFileNameToContents.get(aFileName);¶////				List<OpenMPPragma> anOpenMPPragmas = OpenMPUtils.getOpemMPPragmas(aFileContents);¶//				SNode anSNode = OMPSNodeUtils.getSNode(aFileName, aFileContents);¶//				System.out.println("file name:" + aFileName);¶//				System.out.println("pragmas:" + anSNode);¶//			}¶			RootOfProgramSNode aRootOfProgramSNode = OMPSNodeUtils.getRootOfProgramSNode(aSource);¶			Set<AssignmentSNode> anAssignments = OMPSNodeUtils.assignmentsToSharedVariables(aRootOfProgramSNode);¶			anAssignments = OMPSNodeUtils.assignmentsToSharedArrays(aRootOfProgramSNode);¶			anAssignments = OMPSNodeUtils.assignmentsToParallelCriticalSharedVariables(aRootOfProgramSNode);¶			anAssignments = OMPSNodeUtils.assignmentsToNonParallelCriticalSharedVariables(aRootOfProgramSNode);¶			anAssignments = OMPSNodeUtils.assignmentsToParallelNonCriticalSharedVariables(aRootOfProgramSNode);¶¶¶¶			String anExpectedLines = Arrays.toString(checker.getSubstrings());¶¶			if (!aRetval) {¶				return fail("Output  did not match:" + anExpectedLines);¶¶			}¶			return pass();¶			¶¶		} catch (NotRunnableException e) {¶			throw new NotGradableException();¶		}¶	}¶//	public static void processExternalMethodSNodes (RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode) {¶//		for (SNode anSNode:aRootOfFileSNode.getChildren()) {¶//			if (anSNode instanceof ExternalMethodSNode) {¶//				processExternalMethodSNode(aRootOfProgramSNode, aRootOfFileSNode, (ExternalMethodSNode) anSNode);¶//			}¶//		}¶//	}¶//	public static void processExternalMethodSNode (RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode, ExternalMethodSNode anExternalMethodSNode) {¶//		MethodSNode aMethodSNode = aRootOfProgramSNode.getExternalToInternalMethod().get(anExternalMethodSNode.toString());¶//		if (aMethodSNode == null) {¶//			aMethodSNode = findMethodSNode(aRootOfProgramSNode, aRootOfFileSNode, anExternalMethodSNode);¶//			if (aMethodSNode != null) {¶//				aRootOfProgramSNode.getExternalToInternalMethod().put(anExternalMethodSNode.toString(),aMethodSNode );¶//			}¶//		}¶//		if (aMethodSNode != null) {¶//			anExternalMethodSNode.setActualMethodSNode(aMethodSNode);¶//		}¶//	}¶//	public static MethodSNode findMethodSNode (RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode, ExternalMethodSNode anExternalMethodSNode) {¶////		MethodSNode foundMethodSNode = null;¶//		for (String aFileName:aRootOfProgramSNode.getFileNameToSNode().keySet()) {¶//			if (aFileName.equals(aRootOfFileSNode.getFileName()))¶//				continue;¶//			¶//			RootOfFileSNode aSearchedRootOfFileSNode = aRootOfProgramSNode.getFileNameToSNode().get(aFileName);¶//			 for (SNode anSNode:aSearchedRootOfFileSNode.getChildren()) {¶//				if (anSNode instanceof MethodSNode && !(anSNode instanceof ExternalMethodSNode)) {¶//					if (anSNode.toString().equals(anExternalMethodSNode)) {¶//						return (MethodSNode) anSNode;¶//						¶//					}¶////					processExternalMethodSNode(aRootOfProgramSNode, aRootOfFileSNode, (ExternalMethodSNode) anSNode);¶//				}¶//			}¶//		}¶//		return null;¶//	}¶//	public static void processExternalMethodSNodes (RootOfProgramSNode aRootOfProgramSNode) {¶//		for (String aFileName:aRootOfProgramSNode.getFileNameToSNode().keySet()) {¶//			RootOfFileSNode aRootOfFileSNode = aRootOfProgramSNode.getFileNameToSNode().get(aFileName);¶//			processExternalMethodSNodes(aRootOfProgramSNode, aRootOfFileSNode);¶//			¶//		}¶//¶//	}¶}¶")]]]></diff>
  </Command>
  <Command __id="186133" _type="ShellCommand" date="Wed Jan 01 00:02:15 EST 2020" starttimestamp="1576666505112" timestamp="1188430095" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="186134" _type="DiffBasedFileOpenCommand" date="Wed Jan 01 00:02:22 EST 2020" docASTNodeCount="1" docActiveCodeLength="659" docExpressionCount="0" docLength="747" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="1188437556">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\my_sum_parallel_for_local_var.cpp]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"#include <iostream>¶#include <omp.h>¶¶using namespace std;¶¶void printSumWithTimes (int sum, int start, int end);¶void printNumThreads();¶void recordThreadIndex(int index);¶void sum_parallel_for_local_var(double* array, int size)¶{¶	cout << "sum_parallel_for_local_var\n";¶¶	double start = omp_get_wtime();¶¶	double sum = 0;¶¶	int a, b;¶//¶//	for (int i = 0; i < size; i++) {¶//			sum += array[i];¶//			recordThreadIndex(i);¶//	}¶¶    #pragma omp parallel shared (sum, start) private (a, b)¶	{¶		double local_sum = 0;¶¶		#pragma omp for¶		for(int i = 0; i < size; i++) {¶			local_sum += array[i];¶			recordThreadIndex(i);¶		}¶¶		#pragma omp critical¶		sum += local_sum;¶	}¶¶	double end = omp_get_wtime();¶¶	printSumWithTimes(sum, start, end);¶	¶}¶")]]]></diff>
  </Command>
  <Command __id="186135" _type="MoveCaretCommand" caretOffset="621" date="Wed Jan 01 00:02:23 EST 2020" docOffset="621" starttimestamp="1576666505112" timestamp="1188438012" />
  <Command __id="186136" _type="DiffBasedFileOpenCommand" date="Wed Jan 01 00:02:44 EST 2020" docASTNodeCount="1" docActiveCodeLength="453" docExpressionCount="0" docLength="453" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="1188458938">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\my_sum_sequential.cpp]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"#include <iostream>¶#include <omp.h>¶¶using namespace std;¶void printSumWithTimes(int sum, int start, int end);¶void printNumThreads();¶void recordThreadIndex(int index);¶void sum_sequential(double* array, int size) {¶¶	cout << "sum_sequential\n";¶¶	double start = omp_get_wtime();¶¶	double sum = 0;¶¶	for (int i = 0; i < size; i++) {¶		sum += array[i];¶		recordThreadIndex(i);¶	}¶¶	double end = omp_get_wtime();¶¶	printSumWithTimes(sum, start, end);¶}¶")]]]></diff>
  </Command>
  <Command __id="186137" _type="SelectTextCommand" caretOffset="280" date="Wed Jan 01 00:02:44 EST 2020" end="280" start="265" starttimestamp="1576666505112" timestamp="1188459199" />
  <Command __id="186139" _type="MoveCaretCommand" caretOffset="379" date="Wed Jan 01 00:02:58 EST 2020" docOffset="379" starttimestamp="1576666505112" timestamp="1188473563" />
  <Command __id="186138" _type="DiffBasedFileOpenCommand" date="Wed Jan 01 00:02:58 EST 2020" docASTNodeCount="1" docActiveCodeLength="532" docExpressionCount="0" docLength="575" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="1188473301">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\my_sum_parallel_for_reduction.cpp]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"#include <iostream>¶#include <omp.h>¶¶using namespace std;¶¶//const int SIZE = 1000;¶void printSumWithTimes(int sum, int start, int end);¶void printNumThreads();¶void recordThreadIndex(int index);¶void sum_parallel_for_reduction(double* array, int size) {¶	cout << "sum_parallel_for_reduction\n";¶¶	double start = omp_get_wtime();¶¶	double sum = 0;¶    #pragma omp  parallel for reduction ( + : sum )¶//	#pragma omp  for¶¶	for (int i = 0; i < size; i++) {¶		sum += array[i];¶		recordThreadIndex(i);¶	}¶¶	double end = omp_get_wtime();¶¶	printSumWithTimes(sum, start, end);¶¶}¶")]]]></diff>
  </Command>
  <Command __id="186140" _type="MoveCaretCommand" caretOffset="458" date="Wed Jan 01 00:03:34 EST 2020" docOffset="458" starttimestamp="1576666505112" timestamp="1188509052" />
  <DocumentChange __id="186141" _type="Insert" date="Wed Jan 01 00:03:35 EST 2020" docASTNodeCount="1" docActiveCodeLength="533" docExpressionCount="0" docLength="576" length="1" offset="458" starttimestamp="1576666505112" timestamp="1188510086">
    <text><![CDATA[i]]></text>
  </DocumentChange>
  <Command __id="186142" _type="InsertStringCommand" date="Wed Jan 01 00:03:35 EST 2020" starttimestamp="1576666505112" timestamp="1188510103" timestamp2="1188510103">
    <data><![CDATA[i]]></data>
  </Command>
  <DocumentChange __id="186143" _type="Insert" date="Wed Jan 01 00:03:35 EST 2020" docASTNodeCount="1" docActiveCodeLength="534" docExpressionCount="0" docLength="577" length="1" offset="459" starttimestamp="1576666505112" timestamp="1188510205">
    <text><![CDATA[n]]></text>
  </DocumentChange>
  <Command __id="186144" _type="InsertStringCommand" date="Wed Jan 01 00:03:35 EST 2020" starttimestamp="1576666505112" timestamp="1188510208" timestamp2="1188510208">
    <data><![CDATA[n]]></data>
  </Command>
  <DocumentChange __id="186145" _type="Insert" date="Wed Jan 01 00:03:35 EST 2020" docASTNodeCount="1" docActiveCodeLength="535" docExpressionCount="0" docLength="578" length="1" offset="460" starttimestamp="1576666505112" timestamp="1188510317">
    <text><![CDATA[t]]></text>
  </DocumentChange>
  <Command __id="186146" _type="InsertStringCommand" date="Wed Jan 01 00:03:35 EST 2020" starttimestamp="1576666505112" timestamp="1188510323" timestamp2="1188510323">
    <data><![CDATA[t]]></data>
  </Command>
  <DocumentChange __id="186147" _type="Insert" date="Wed Jan 01 00:03:36 EST 2020" docASTNodeCount="1" docActiveCodeLength="536" docExpressionCount="0" docLength="579" length="1" offset="461" starttimestamp="1576666505112" timestamp="1188511240">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <Command __id="186148" _type="InsertStringCommand" date="Wed Jan 01 00:03:36 EST 2020" starttimestamp="1576666505112" timestamp="1188511246" timestamp2="1188511246">
    <data><![CDATA[ ]]></data>
  </Command>
  <DocumentChange __id="186149" _type="Delete" date="Wed Jan 01 00:03:37 EST 2020" docASTNodeCount="1" docActiveCodeLength="532" docExpressionCount="0" docLength="575" endLine="19" length="4" offset="458" startLine="19" starttimestamp="1576666505112" timestamp="1188512760">
    <text><![CDATA[int ]]></text>
  </DocumentChange>
  <Command __id="186150" _type="UndoCommand" date="Wed Jan 01 00:03:39 EST 2020" starttimestamp="1576666505112" timestamp="1188513971" />
  <DocumentChange __id="186151" _type="Insert" date="Wed Jan 01 00:03:39 EST 2020" docASTNodeCount="1" docActiveCodeLength="533" docExpressionCount="0" docLength="576" length="1" offset="379" starttimestamp="1576666505112" timestamp="1188514580">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <Command __id="186152" _type="UndoCommand" date="Wed Jan 01 00:03:39 EST 2020" starttimestamp="1576666505112" timestamp="1188514602" />
  <Command __id="186154" _type="RedoCommand" date="Wed Jan 01 00:03:42 EST 2020" starttimestamp="1576666505112" timestamp="1188517148" />
  <Command __id="186155" _type="MoveCaretCommand" caretOffset="463" date="Wed Jan 01 00:03:44 EST 2020" docOffset="463" starttimestamp="1576666505112" timestamp="1188518944" />
  <Command __id="186156" _type="MoveCaretCommand" caretOffset="463" date="Wed Jan 01 00:03:44 EST 2020" docOffset="463" starttimestamp="1576666505112" timestamp="1188519122" />
  <Command __id="186157" _type="SelectTextCommand" caretOffset="475" date="Wed Jan 01 00:03:44 EST 2020" end="475" start="456" starttimestamp="1576666505112" timestamp="1188519384" />
  <Command __id="186158" _type="CopyCommand" date="Wed Jan 01 00:03:45 EST 2020" starttimestamp="1576666505112" timestamp="1188520817" />
  <DocumentChange __id="186153" _type="Delete" date="Wed Jan 01 00:03:42 EST 2020" docASTNodeCount="1" docActiveCodeLength="532" docExpressionCount="0" docLength="575" endLine="15" length="1" offset="379" startLine="15" starttimestamp="1576666505112" timestamp="1188517108">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="186160" _type="Insert" date="Wed Jan 01 00:03:47 EST 2020" docASTNodeCount="1" docActiveCodeLength="535" docExpressionCount="0" docLength="578" length="3" offset="474" starttimestamp="1576666505112" timestamp="1188522539">
    <text><![CDATA[
		]]></text>
  </DocumentChange>
  <Command __id="186159" _type="MoveCaretCommand" caretOffset="474" date="Wed Jan 01 00:03:47 EST 2020" docOffset="474" starttimestamp="1576666505112" timestamp="1188522066" />
  <Command __id="186161" _type="InsertStringCommand" date="Wed Jan 01 00:03:47 EST 2020" starttimestamp="1576666505112" timestamp="1188522549" timestamp2="1188522549">
    <data><![CDATA[]]></data>
  </Command>
  <Command __id="186163" _type="PasteCommand" date="Wed Jan 01 00:03:49 EST 2020" starttimestamp="1576666505112" timestamp="1188524245" />
  <Command __id="186164" _type="MoveCaretCommand" caretOffset="457" date="Wed Jan 01 00:03:50 EST 2020" docOffset="457" starttimestamp="1576666505112" timestamp="1188525628" />
  <Command __id="186166" _type="EclipseCommand" commandID="org.eclipse.cdt.ui.edit.text.c.toggle.comment" date="Wed Jan 01 00:03:51 EST 2020" starttimestamp="1576666505112" timestamp="1188526696" />
  <Command __id="186167" _type="MoveCaretCommand" caretOffset="479" date="Wed Jan 01 00:03:53 EST 2020" docOffset="479" starttimestamp="1576666505112" timestamp="1188528407" />
  <Command __id="186169" _type="InsertStringCommand" date="Wed Jan 01 00:03:53 EST 2020" starttimestamp="1576666505112" timestamp="1188528738" timestamp2="1188528738">
    <data><![CDATA[i]]></data>
  </Command>
  <Command __id="186171" _type="InsertStringCommand" date="Wed Jan 01 00:03:54 EST 2020" starttimestamp="1576666505112" timestamp="1188528998" timestamp2="1188528998">
    <data><![CDATA[n]]></data>
  </Command>
  <Command __id="186173" _type="InsertStringCommand" date="Wed Jan 01 00:03:54 EST 2020" starttimestamp="1576666505112" timestamp="1188529123" timestamp2="1188529123">
    <data><![CDATA[t]]></data>
  </Command>
  <Command __id="186175" _type="InsertStringCommand" date="Wed Jan 01 00:03:54 EST 2020" starttimestamp="1576666505112" timestamp="1188529363" timestamp2="1188529363">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="186176" _type="EclipseCommand" commandID="org.eclipse.ui.file.save" date="Wed Jan 01 00:03:55 EST 2020" starttimestamp="1576666505112" timestamp="1188530498" />
  <DocumentChange __id="186162" _type="Replace" date="Wed Jan 01 00:03:49 EST 2020" docASTNodeCount="1" docActiveCodeLength="552" docExpressionCount="0" docLength="595" endLine="20" insertionLength="19" int_docASTNodeCount="1" int_docActiveCodeLength="533" int_docExpressionCount="0" int_docLength="576" length="2" offset="475" startLine="20" starttimestamp="1576666505112" timestamp="1188524171">
    <deletedText><![CDATA[		]]></deletedText>
    <insertedText><![CDATA[		sum += array[i];
]]></insertedText>
  </DocumentChange>
  <DocumentChange __id="186165" _type="Insert" date="Wed Jan 01 00:03:51 EST 2020" docASTNodeCount="1" docActiveCodeLength="534" docExpressionCount="0" docLength="597" length="2" offset="456" starttimestamp="1576666505112" timestamp="1188526620">
    <text><![CDATA[//]]></text>
  </DocumentChange>
  <DocumentChange __id="186168" _type="Insert" date="Wed Jan 01 00:03:53 EST 2020" docASTNodeCount="1" docActiveCodeLength="535" docExpressionCount="0" docLength="598" length="1" offset="479" starttimestamp="1576666505112" timestamp="1188528727">
    <text><![CDATA[i]]></text>
  </DocumentChange>
  <DocumentChange __id="186170" _type="Insert" date="Wed Jan 01 00:03:54 EST 2020" docASTNodeCount="1" docActiveCodeLength="536" docExpressionCount="0" docLength="599" length="1" offset="480" starttimestamp="1576666505112" timestamp="1188528990">
    <text><![CDATA[n]]></text>
  </DocumentChange>
  <DocumentChange __id="186172" _type="Insert" date="Wed Jan 01 00:03:54 EST 2020" docASTNodeCount="1" docActiveCodeLength="537" docExpressionCount="0" docLength="600" length="1" offset="481" starttimestamp="1576666505112" timestamp="1188529113">
    <text><![CDATA[t]]></text>
  </DocumentChange>
  <DocumentChange __id="186174" _type="Insert" date="Wed Jan 01 00:03:54 EST 2020" docASTNodeCount="1" docActiveCodeLength="538" docExpressionCount="0" docLength="601" length="1" offset="482" starttimestamp="1576666505112" timestamp="1188529358">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <Command __id="186177" _type="MoveCaretCommand" caretOffset="481" date="Wed Jan 01 00:04:11 EST 2020" docOffset="481" starttimestamp="1576666505112" timestamp="1188546580" />
  <Command __id="186178" _type="SelectTextCommand" caretOffset="482" date="Wed Jan 01 00:04:11 EST 2020" end="482" start="479" starttimestamp="1576666505112" timestamp="1188546861" />
  <Command __id="186180" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Wed Jan 01 00:04:13 EST 2020" starttimestamp="1576666505112" timestamp="1188548584" />
  <Command __id="186181" _type="MoveCaretCommand" caretOffset="481" date="Wed Jan 01 00:04:18 EST 2020" docOffset="481" starttimestamp="1576666505112" timestamp="1188553423" />
  <Command __id="186182" _type="SelectTextCommand" caretOffset="483" date="Wed Jan 01 00:04:18 EST 2020" end="483" start="480" starttimestamp="1576666505112" timestamp="1188553607" />
  <Command __id="186183" _type="SelectTextCommand" caretOffset="497" date="Wed Jan 01 00:04:18 EST 2020" end="497" start="477" starttimestamp="1576666505112" timestamp="1188553876" />
  <Command __id="186185" _type="EclipseCommand" commandID="org.eclipse.ui.edit.delete" date="Wed Jan 01 00:04:19 EST 2020" starttimestamp="1576666505112" timestamp="1188554876" />
  <Command __id="186197" _type="RunCommand" date="Wed Jan 01 00:04:56 EST 2020" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="1188591370" type="Run" />
  <Command __id="186198" _type="RunCommand" date="Wed Jan 01 00:04:56 EST 2020" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="1188591370" type="Run" />
  <Command __id="186199" _type="RunCommand" date="Wed Jan 01 00:04:56 EST 2020" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="1188591785" type="Run" />
  <Command __id="186200" _type="EclipseCommand" commandID="org.eclipse.cdt.make.ui.targetBuildLastCommand" date="Wed Jan 01 00:05:03 EST 2020" starttimestamp="1576666505112" timestamp="1188598585" />
  <DocumentChange __id="186179" _type="Delete" date="Wed Jan 01 00:04:13 EST 2020" docASTNodeCount="1" docActiveCodeLength="535" docExpressionCount="0" docLength="598" endLine="20" length="3" offset="479" startLine="20" starttimestamp="1576666505112" timestamp="1188548557">
    <text><![CDATA[int]]></text>
  </DocumentChange>
  <DocumentChange __id="186184" _type="Delete" date="Wed Jan 01 00:04:19 EST 2020" docASTNodeCount="1" docActiveCodeLength="515" docExpressionCount="0" docLength="578" endLine="21" length="20" offset="477" startLine="20" starttimestamp="1576666505112" timestamp="1188554851">
    <text><![CDATA[		 sum += array[i];
]]></text>
  </DocumentChange>
  <Command __id="186201" _type="EclipseCommand" commandID="org.eclipse.debug.ui.commands.Resume" date="Wed Jan 01 00:05:05 EST 2020" starttimestamp="1576666505112" timestamp="1188600688" />
  <Command __id="186202" _type="RunCommand" date="Wed Jan 01 00:05:05 EST 2020" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="1188600709" type="Debug" />
  <Command __id="186203" _type="RunCommand" date="Wed Jan 01 00:05:05 EST 2020" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="1188600709" type="Run" />
  <Command __id="186204" _type="RunCommand" date="Wed Jan 01 00:05:05 EST 2020" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="1188600709" type="Debug" />
  <Command __id="186205" _type="RunCommand" date="Wed Jan 01 00:05:05 EST 2020" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="1188600709" type="Run" />
  <Command __id="186206" _type="EHExceptionCommand" date="Wed Jan 01 00:05:05 EST 2020" starttimestamp="1576666505112" timestamp="1188600803" type="Exception">
    <outputString><![CDATA[sum_sequential
Sum: 499500
Took: 0
thread:0 lastIndex:999
_____________________________
sum_parallel_for_reduction
Sum: 499500
Took: 0
thread:0 lastIndex:124
thread:1 lastIndex:249
thread:2 lastIndex:374
thread:3 lastIndex:499
thread:4 lastIndex:624
thread:5 lastIndex:749
thread:6 lastIndex:874
thread:7 lastIndex:999
_____________________________
sum_parallel_for_local_var
Sum: 499500
Took: 0
thread:0 lastIndex:124
thread:1 lastIndex:249
thread:2 lastIndex:374
thread:3 lastIndex:499
thread:4 lastIndex:624
thread:5 lastIndex:749
thread:6 lastIndex:874
thread:7 lastIndex:999
_____________________________
sum_parallel
Sum: 499500
Took: 0
_____________________________
]]></outputString>
  </Command>
  <Command __id="186207" _type="RunCommand" date="Wed Jan 01 00:05:06 EST 2020" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="1188601239" type="Debug" />
  <Command __id="186208" _type="RunCommand" date="Wed Jan 01 00:05:06 EST 2020" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="1188601239" type="Run" />
  <Command __id="186209" _type="RunCommand" date="Wed Jan 01 00:05:06 EST 2020" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="1188601239" type="Debug" />
  <Command __id="186210" _type="RunCommand" date="Wed Jan 01 00:05:06 EST 2020" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="1188601239" type="Run" />
  <Command __id="186211" _type="DiffBasedFileOpenCommand" date="Wed Jan 01 00:05:20 EST 2020" docASTNodeCount="1" docActiveCodeLength="1642" docExpressionCount="0" docLength="1924" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="1188615210">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\my_sum_main.cpp]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"#include <iostream>¶#include <omp.h>¶¶using namespace std;¶//need to declare headers of external functions called¶void sum_sequential(double* array, int size);¶void sum_parallel_for_reduction(double* array, int size);¶void sum_parallel(double* array, int size);¶void sum_parallel_for_local_var(double* array, int size);¶¶// if this main is used to call functions to do other computations¶// then those headers should also be declared here¶¶const int SIZE = 1000;¶void initArray (double* array, int size ) {¶	for(int i = 0; i < size; i++)¶			array[i]=i;¶}¶/**¶ * Called by each of the summing alternatives¶ */¶void printSumWithTimes (int sum, int start, int end) {¶	cout << "Sum: " << sum << endl;¶	cout << "Took: " << end - start << endl;¶}¶void printNumThreads() {¶	cout << "threads:" << omp_get_num_threads() << endl;¶}¶/**¶ * an array to learn how much concurrency occcurred¶ */¶int MAX_THREADS = 100;¶double* threadsLastIndex = new double[MAX_THREADS];¶int numThreads;¶¶¶void recordThreadIndex(int index) {¶	int thread =  omp_get_thread_num();¶	if (thread >= MAX_THREADS) {¶		return;¶	}¶	threadsLastIndex[thread] = index;¶	numThreads = omp_get_num_threads();¶}¶void initThreadRecording() {¶	numThreads = 0;¶	for (int i = 0; i < MAX_THREADS; i++) {¶		threadsLastIndex[i] = -1;¶	}¶}¶¶void printThreadLastIndex() {¶	for (int i = 0; i < numThreads; i++) {¶		cout << "thread:" << i << " lastIndex:" << threadsLastIndex[i] << endl;¶	}¶	cout << "_____________________________" << endl;¶}¶¶¶int main()¶{¶	double* array = new double[SIZE];¶	initArray(array, SIZE);¶	initThreadRecording();¶	sum_sequential(array, SIZE);¶	printThreadLastIndex();¶	initThreadRecording();¶	sum_parallel_for_reduction(array, SIZE);¶	printThreadLastIndex();¶	initThreadRecording();¶	sum_parallel_for_local_var(array, SIZE);¶	printThreadLastIndex();¶	initThreadRecording();¶	sum_parallel(array, SIZE);¶	printThreadLastIndex();¶	initThreadRecording();¶}¶")]]]></diff>
  </Command>
  <Command __id="186212" _type="MoveCaretCommand" caretOffset="1500" date="Wed Jan 01 00:05:20 EST 2020" docOffset="1500" starttimestamp="1576666505112" timestamp="1188615333" />
  <Command __id="186213" _type="DiffBasedFileOpenCommand" date="Wed Jan 01 00:05:32 EST 2020" docASTNodeCount="1" docActiveCodeLength="659" docExpressionCount="0" docLength="747" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="1188627637">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\my_sum_parallel_for_local_var.cpp]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"#include <iostream>¶#include <omp.h>¶¶using namespace std;¶¶void printSumWithTimes (int sum, int start, int end);¶void printNumThreads();¶void recordThreadIndex(int index);¶void sum_parallel_for_local_var(double* array, int size)¶{¶	cout << "sum_parallel_for_local_var\n";¶¶	double start = omp_get_wtime();¶¶	double sum = 0;¶¶	int a, b;¶//¶//	for (int i = 0; i < size; i++) {¶//			sum += array[i];¶//			recordThreadIndex(i);¶//	}¶¶    #pragma omp parallel shared (sum, start) private (a, b)¶	{¶		double local_sum = 0;¶¶		#pragma omp for¶		for(int i = 0; i < size; i++) {¶			local_sum += array[i];¶			recordThreadIndex(i);¶		}¶¶		#pragma omp critical¶		sum += local_sum;¶	}¶¶	double end = omp_get_wtime();¶¶	printSumWithTimes(sum, start, end);¶	¶}¶")]]]></diff>
  </Command>
  <Command __id="186215" _type="RunCommand" date="Wed Jan 01 00:05:46 EST 2020" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="1188641824" type="Run" />
  <Command __id="186216" _type="RunCommand" date="Wed Jan 01 00:05:46 EST 2020" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="1188641824" type="Run" />
  <Command __id="186217" _type="RunCommand" date="Wed Jan 01 00:05:46 EST 2020" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="1188641841" type="Debug" />
  <Command __id="186218" _type="RunCommand" date="Wed Jan 01 00:05:46 EST 2020" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="1188641841" type="Run" />
  <Command __id="186219" _type="RunCommand" date="Wed Jan 01 00:05:46 EST 2020" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="1188641841" type="Debug" />
  <Command __id="186220" _type="RunCommand" date="Wed Jan 01 00:05:46 EST 2020" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="1188641841" type="Run" />
  <Command __id="186221" _type="EHExceptionCommand" date="Wed Jan 01 00:05:47 EST 2020" starttimestamp="1576666505112" timestamp="1188642043" type="Exception">
    <outputString><![CDATA[sum_sequential
Sum: 499500
Took: 0
thread:0 lastIndex:999
_____________________________
sum_parallel_for_reduction
Sum: 499500
Took: 0
thread:0 lastIndex:124
thread:1 lastIndex:249
thread:2 lastIndex:374
thread:3 lastIndex:499
thread:4 lastIndex:624
thread:5 lastIndex:749
thread:6 lastIndex:874
thread:7 lastIndex:999
_____________________________
sum_parallel_for_local_var
Sum: 499500
Took: 0
thread:0 lastIndex:124
thread:1 lastIndex:249
thread:2 lastIndex:374
thread:3 lastIndex:499
thread:4 lastIndex:624
thread:5 lastIndex:749
thread:6 lastIndex:874
thread:7 lastIndex:999
_____________________________
sum_parallel
Sum: 499500
Took: 0
_____________________________
]]></outputString>
  </Command>
  <Command __id="186222" _type="DiffBasedFileOpenCommand" date="Wed Jan 01 00:05:52 EST 2020" docASTNodeCount="1" docActiveCodeLength="515" docExpressionCount="0" docLength="578" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="1188647437">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\my_sum_parallel_for_reduction.cpp]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"#include <iostream>¶#include <omp.h>¶¶using namespace std;¶¶//const int SIZE = 1000;¶void printSumWithTimes(int sum, int start, int end);¶void printNumThreads();¶void recordThreadIndex(int index);¶void sum_parallel_for_reduction(double* array, int size) {¶	cout << "sum_parallel_for_reduction\n";¶¶	double start = omp_get_wtime();¶¶	double sum = 0;¶    #pragma omp  parallel for reduction ( + : sum )¶//	#pragma omp  for¶¶	for (int i = 0; i < size; i++) {¶"), Diff(INSERT,"//"), Diff(EQUAL,"		sum += array[i];¶"), Diff(INSERT,"¶"), Diff(EQUAL,"		recordThreadIndex(i);¶	}¶¶	double end = omp_get_wtime();¶¶	printSumWithTimes(sum, start, end);¶¶}¶")]]]></diff>
    <snapshot><![CDATA[#include <iostream>
#include <omp.h>

using namespace std;

//const int SIZE = 1000;
void printSumWithTimes(int sum, int start, int end);
void printNumThreads();
void recordThreadIndex(int index);
void sum_parallel_for_reduction(double* array, int size) {
	cout << "sum_parallel_for_reduction\n";

	double start = omp_get_wtime();

	double sum = 0;
    #pragma omp  parallel for reduction ( + : sum )
//	#pragma omp  for

	for (int i = 0; i < size; i++) {
//		sum += array[i];

		recordThreadIndex(i);
	}

	double end = omp_get_wtime();

	printSumWithTimes(sum, start, end);

}
]]></snapshot>
  </Command>
  <Command __id="186223" _type="MoveCaretCommand" caretOffset="477" date="Wed Jan 01 00:05:52 EST 2020" docOffset="477" starttimestamp="1576666505112" timestamp="1188647720" />
  <Command __id="186224" _type="DiffBasedFileOpenCommand" date="Wed Jan 01 00:05:57 EST 2020" docASTNodeCount="1" docActiveCodeLength="453" docExpressionCount="0" docLength="453" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="1188652134">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\my_sum_sequential.cpp]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"#include <iostream>¶#include <omp.h>¶¶using namespace std;¶void printSumWithTimes(int sum, int start, int end);¶void printNumThreads();¶void recordThreadIndex(int index);¶void sum_sequential(double* array, int size) {¶¶	cout << "sum_sequential\n";¶¶	double start = omp_get_wtime();¶¶	double sum = 0;¶¶	for (int i = 0; i < size; i++) {¶		sum += array[i];¶		recordThreadIndex(i);¶	}¶¶	double end = omp_get_wtime();¶¶	printSumWithTimes(sum, start, end);¶}¶")]]]></diff>
  </Command>
  <Command __id="186225" _type="SelectTextCommand" caretOffset="280" date="Wed Jan 01 00:05:57 EST 2020" end="280" start="265" starttimestamp="1576666505112" timestamp="1188652302" />
  <Command __id="186226" _type="DiffBasedFileOpenCommand" date="Wed Jan 01 00:06:01 EST 2020" docASTNodeCount="1" docActiveCodeLength="515" docExpressionCount="0" docLength="578" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="1188656877">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\my_sum_parallel_for_reduction.cpp]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"#include <iostream>¶#include <omp.h>¶¶using namespace std;¶¶//const int SIZE = 1000;¶void printSumWithTimes(int sum, int start, int end);¶void printNumThreads();¶void recordThreadIndex(int index);¶void sum_parallel_for_reduction(double* array, int size) {¶	cout << "sum_parallel_for_reduction\n";¶¶	double start = omp_get_wtime();¶¶	double sum = 0;¶    #pragma omp  parallel for reduction ( + : sum )¶//	#pragma omp  for¶¶	for (int i = 0; i < size; i++) {¶//		sum += array[i];¶¶		recordThreadIndex(i);¶	}¶¶	double end = omp_get_wtime();¶¶	printSumWithTimes(sum, start, end);¶¶}¶")]]]></diff>
  </Command>
  <Command __id="186227" _type="MoveCaretCommand" caretOffset="477" date="Wed Jan 01 00:06:02 EST 2020" docOffset="477" starttimestamp="1576666505112" timestamp="1188657051" />
  <Command __id="186228" _type="DiffBasedFileOpenCommand" date="Wed Jan 01 00:06:06 EST 2020" docASTNodeCount="1" docActiveCodeLength="659" docExpressionCount="0" docLength="747" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="1188660905">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\my_sum_parallel_for_local_var.cpp]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"#include <iostream>¶#include <omp.h>¶¶using namespace std;¶¶void printSumWithTimes (int sum, int start, int end);¶void printNumThreads();¶void recordThreadIndex(int index);¶void sum_parallel_for_local_var(double* array, int size)¶{¶	cout << "sum_parallel_for_local_var\n";¶¶	double start = omp_get_wtime();¶¶	double sum = 0;¶¶	int a, b;¶//¶//	for (int i = 0; i < size; i++) {¶//			sum += array[i];¶//			recordThreadIndex(i);¶//	}¶¶    #pragma omp parallel shared (sum, start) private (a, b)¶	{¶		double local_sum = 0;¶¶		#pragma omp for¶		for(int i = 0; i < size; i++) {¶			local_sum += array[i];¶			recordThreadIndex(i);¶		}¶¶		#pragma omp critical¶		sum += local_sum;¶	}¶¶	double end = omp_get_wtime();¶¶	printSumWithTimes(sum, start, end);¶	¶}¶")]]]></diff>
  </Command>
  <Command __id="186229" _type="MoveCaretCommand" caretOffset="621" date="Wed Jan 01 00:06:06 EST 2020" docOffset="621" starttimestamp="1576666505112" timestamp="1188661069" />
  <Command __id="186231" _type="MoveCaretCommand" caretOffset="477" date="Wed Jan 01 00:06:14 EST 2020" docOffset="477" starttimestamp="1576666505112" timestamp="1188669508" />
  <Command __id="186230" _type="DiffBasedFileOpenCommand" date="Wed Jan 01 00:06:14 EST 2020" docASTNodeCount="1" docActiveCodeLength="515" docExpressionCount="0" docLength="578" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="1188669313">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\my_sum_parallel_for_reduction.cpp]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"#include <iostream>¶#include <omp.h>¶¶using namespace std;¶¶//const int SIZE = 1000;¶void printSumWithTimes(int sum, int start, int end);¶void printNumThreads();¶void recordThreadIndex(int index);¶void sum_parallel_for_reduction(double* array, int size) {¶	cout << "sum_parallel_for_reduction\n";¶¶	double start = omp_get_wtime();¶¶	double sum = 0;¶    #pragma omp  parallel for reduction ( + : sum )¶//	#pragma omp  for¶¶	for (int i = 0; i < size; i++) {¶//		sum += array[i];¶¶		recordThreadIndex(i);¶	}¶¶	double end = omp_get_wtime();¶¶	printSumWithTimes(sum, start, end);¶¶}¶")]]]></diff>
  </Command>
  <Command __id="186232" _type="MoveCaretCommand" caretOffset="456" date="Wed Jan 01 00:06:19 EST 2020" docOffset="456" starttimestamp="1576666505112" timestamp="1188673984" />
  <Command __id="186234" _type="EclipseCommand" commandID="org.eclipse.cdt.ui.edit.text.c.toggle.comment" date="Wed Jan 01 00:06:21 EST 2020" starttimestamp="1576666505112" timestamp="1188676278" />
  <Command __id="186235" _type="EclipseCommand" commandID="org.eclipse.ui.file.save" date="Wed Jan 01 00:06:22 EST 2020" starttimestamp="1576666505112" timestamp="1188676933" />
  <DocumentChange __id="186233" _type="Delete" date="Wed Jan 01 00:06:21 EST 2020" docASTNodeCount="1" docActiveCodeLength="533" docExpressionCount="0" docLength="576" endLine="19" length="2" offset="456" startLine="19" starttimestamp="1576666505112" timestamp="1188676237">
    <text><![CDATA[//]]></text>
  </DocumentChange>
  <Command __id="186236" _type="MoveCaretCommand" caretOffset="457" date="Wed Jan 01 00:06:52 EST 2020" docOffset="457" starttimestamp="1576666505112" timestamp="1188707347" />
  <Command __id="186238" _type="EclipseCommand" commandID="org.eclipse.cdt.ui.edit.text.c.toggle.comment" date="Wed Jan 01 00:06:53 EST 2020" starttimestamp="1576666505112" timestamp="1188708555" />
  <Command __id="186239" _type="EclipseCommand" commandID="org.eclipse.ui.file.save" date="Wed Jan 01 00:06:54 EST 2020" starttimestamp="1576666505112" timestamp="1188709611" />
  <DocumentChange __id="186237" _type="Insert" date="Wed Jan 01 00:06:53 EST 2020" docASTNodeCount="1" docActiveCodeLength="515" docExpressionCount="0" docLength="578" length="2" offset="456" starttimestamp="1576666505112" timestamp="1188708488">
    <text><![CDATA[//]]></text>
  </DocumentChange>
  <Command __id="186240" _type="MoveCaretCommand" caretOffset="504" date="Wed Jan 01 00:07:08 EST 2020" docOffset="504" starttimestamp="1576666505112" timestamp="1188722979" />
  <DocumentChange __id="186241" _type="Insert" date="Wed Jan 01 00:07:33 EST 2020" docASTNodeCount="1" docActiveCodeLength="517" docExpressionCount="0" docLength="580" length="2" offset="477" starttimestamp="1576666505112" timestamp="1188748531">
    <text><![CDATA[		]]></text>
  </DocumentChange>
  <Command __id="186242" _type="InsertStringCommand" date="Wed Jan 01 00:07:33 EST 2020" starttimestamp="1576666505112" timestamp="1188748538" timestamp2="1188748538">
    <data><![CDATA[	]]></data>
  </Command>
  <Command __id="186245" _type="RunCommand" date="Wed Jan 01 00:07:56 EST 2020" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="1188771585" type="Run" />
  <Command __id="186246" _type="RunCommand" date="Wed Jan 01 00:07:56 EST 2020" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="1188771585" type="Run" />
  <Command __id="186247" _type="RunCommand" date="Wed Jan 01 00:07:56 EST 2020" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="1188771610" type="Debug" />
  <Command __id="186248" _type="RunCommand" date="Wed Jan 01 00:07:56 EST 2020" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="1188771611" type="Run" />
  <Command __id="186249" _type="RunCommand" date="Wed Jan 01 00:07:56 EST 2020" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="1188771611" type="Debug" />
  <Command __id="186250" _type="RunCommand" date="Wed Jan 01 00:07:56 EST 2020" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="1188771611" type="Run" />
  <Command __id="186251" _type="EHExceptionCommand" date="Wed Jan 01 00:07:57 EST 2020" starttimestamp="1576666505112" timestamp="1188771948" type="Exception">
    <outputString><![CDATA[sum_sequential
Sum: 499500
Took: 0
thread:0 lastIndex:999
_____________________________
sum_parallel_for_reduction
Sum: 0
Took: 0
thread:0 lastIndex:124
thread:1 lastIndex:249
thread:2 lastIndex:374
thread:3 lastIndex:499
thread:4 lastIndex:624
thread:5 lastIndex:749
thread:6 lastIndex:874
thread:7 lastIndex:999
_____________________________
sum_parallel_for_local_var
Sum: 499500
Took: 0
thread:0 lastIndex:124
thread:1 lastIndex:249
thread:2 lastIndex:374
thread:3 lastIndex:499
thread:4 lastIndex:624
thread:5 lastIndex:749
thread:6 lastIndex:874
thread:7 lastIndex:999
_____________________________
sum_parallel
Sum: 499500
Took: 0
_____________________________
]]></outputString>
  </Command>
  <Command __id="186252" _type="MoveCaretCommand" caretOffset="367" date="Wed Jan 01 00:09:45 EST 2020" docOffset="367" starttimestamp="1576666505112" timestamp="1188880787" />
  <Command __id="186253" _type="SelectTextCommand" caretOffset="374" date="Wed Jan 01 00:09:46 EST 2020" end="374" start="366" starttimestamp="1576666505112" timestamp="1188881026" />
  <Command __id="186254" _type="SelectTextCommand" caretOffset="349" date="Wed Jan 01 00:09:46 EST 2020" end="401" start="349" starttimestamp="1576666505112" timestamp="1188881336" />
  <Command __id="186255" _type="CopyCommand" date="Wed Jan 01 00:09:49 EST 2020" starttimestamp="1576666505112" timestamp="1188884545" />
  <DocumentChange __id="186243" _type="Delete" date="Wed Jan 01 00:07:42 EST 2020" docASTNodeCount="1" docActiveCodeLength="515" docExpressionCount="0" docLength="578" endLine="20" length="2" offset="477" startLine="20" starttimestamp="1576666505112" timestamp="1188757654">
    <text><![CDATA[		]]></text>
  </DocumentChange>
  <Command __id="186256" _type="MoveCaretCommand" caretOffset="349" date="Wed Jan 01 00:09:53 EST 2020" docOffset="349" starttimestamp="1576666505112" timestamp="1188888194" />
  <Command __id="186258" _type="EclipseCommand" commandID="org.eclipse.cdt.ui.edit.text.c.toggle.comment" date="Wed Jan 01 00:09:55 EST 2020" starttimestamp="1576666505112" timestamp="1188890308" />
  <Command __id="186259" _type="MoveCaretCommand" caretOffset="364" date="Wed Jan 01 00:09:57 EST 2020" docOffset="364" starttimestamp="1576666505112" timestamp="1188892328" />
  <Command __id="186260" _type="SelectTextCommand" caretOffset="366" date="Wed Jan 01 00:09:57 EST 2020" end="366" start="363" starttimestamp="1576666505112" timestamp="1188892562" />
  <Command __id="186261" _type="SelectTextCommand" caretOffset="403" date="Wed Jan 01 00:09:57 EST 2020" end="403" start="349" starttimestamp="1576666505112" timestamp="1188892851" />
  <Command __id="186262" _type="CopyCommand" date="Wed Jan 01 00:09:58 EST 2020" starttimestamp="1576666505112" timestamp="1188893600" />
  <DocumentChange __id="186257" _type="Insert" date="Wed Jan 01 00:09:55 EST 2020" docASTNodeCount="1" docActiveCodeLength="464" docExpressionCount="0" docLength="580" length="2" offset="349" starttimestamp="1576666505112" timestamp="1188890250">
    <text><![CDATA[//]]></text>
  </DocumentChange>
  <DocumentChange __id="186264" _type="Insert" date="Wed Jan 01 00:10:01 EST 2020" docASTNodeCount="1" docActiveCodeLength="466" docExpressionCount="0" docLength="582" length="2" offset="402" starttimestamp="1576666505112" timestamp="1188896331">
    <text><![CDATA[
	]]></text>
  </DocumentChange>
  <Command __id="186263" _type="MoveCaretCommand" caretOffset="402" date="Wed Jan 01 00:10:00 EST 2020" docOffset="402" starttimestamp="1576666505112" timestamp="1188895674" />
  <Command __id="186265" _type="InsertStringCommand" date="Wed Jan 01 00:10:01 EST 2020" starttimestamp="1576666505112" timestamp="1188896336" timestamp2="1188896336">
    <data><![CDATA[]]></data>
  </Command>
  <Command __id="186267" _type="PasteCommand" date="Wed Jan 01 00:10:02 EST 2020" starttimestamp="1576666505112" timestamp="1188897364" />
  <DocumentChange __id="186266" _type="Replace" date="Wed Jan 01 00:10:02 EST 2020" docASTNodeCount="1" docActiveCodeLength="467" docExpressionCount="0" docLength="636" endLine="16" insertionLength="55" int_docASTNodeCount="1" int_docActiveCodeLength="465" int_docExpressionCount="0" int_docLength="581" length="1" offset="403" startLine="16" starttimestamp="1576666505112" timestamp="1188897343">
    <deletedText><![CDATA[	]]></deletedText>
    <insertedText><![CDATA[	//    #pragma omp  parallel for reduction ( + : sum )
]]></insertedText>
  </DocumentChange>
  <DocumentChange __id="186269" _type="Delete" date="Wed Jan 01 00:10:04 EST 2020" docASTNodeCount="1" docActiveCodeLength="467" docExpressionCount="0" docLength="635" endLine="16" length="1" offset="406" startLine="16" starttimestamp="1576666505112" timestamp="1188899856">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="186271" _type="Delete" date="Wed Jan 01 00:10:05 EST 2020" docASTNodeCount="1" docActiveCodeLength="518" docExpressionCount="0" docLength="634" endLine="16" length="1" offset="405" startLine="16" starttimestamp="1576666505112" timestamp="1188900015">
    <text><![CDATA[/]]></text>
  </DocumentChange>
  <DocumentChange __id="186273" _type="Delete" date="Wed Jan 01 00:10:05 EST 2020" docASTNodeCount="1" docActiveCodeLength="517" docExpressionCount="0" docLength="633" endLine="16" length="1" offset="404" startLine="16" starttimestamp="1576666505112" timestamp="1188900166">
    <text><![CDATA[/]]></text>
  </DocumentChange>
  <DocumentChange __id="186275" _type="Delete" date="Wed Jan 01 00:10:07 EST 2020" docASTNodeCount="1" docActiveCodeLength="516" docExpressionCount="0" docLength="632" endLine="16" length="1" offset="403" startLine="16" starttimestamp="1576666505112" timestamp="1188902344">
    <text><![CDATA[	]]></text>
  </DocumentChange>
  <Command __id="186268" _type="MoveCaretCommand" caretOffset="407" date="Wed Jan 01 00:10:04 EST 2020" docOffset="407" starttimestamp="1576666505112" timestamp="1188899487" />
  <Command __id="186270" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Wed Jan 01 00:10:04 EST 2020" starttimestamp="1576666505112" timestamp="1188899861" />
  <Command __id="186272" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Wed Jan 01 00:10:05 EST 2020" starttimestamp="1576666505112" timestamp="1188900020" />
  <Command __id="186274" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Wed Jan 01 00:10:05 EST 2020" starttimestamp="1576666505112" timestamp="1188900177" />
  <Command __id="186276" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Wed Jan 01 00:10:07 EST 2020" starttimestamp="1576666505112" timestamp="1188902346" />
  <Command __id="186278" _type="InsertStringCommand" date="Wed Jan 01 00:10:08 EST 2020" starttimestamp="1576666505112" timestamp="1188903555" timestamp2="1188903555">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="186279" _type="MoveCaretCommand" caretOffset="421" date="Wed Jan 01 00:10:13 EST 2020" docOffset="421" starttimestamp="1576666505112" timestamp="1188907974" />
  <Command __id="186280" _type="SelectTextCommand" caretOffset="428" date="Wed Jan 01 00:10:13 EST 2020" end="428" start="420" starttimestamp="1576666505112" timestamp="1188908251" />
  <Command __id="186282" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Wed Jan 01 00:10:13 EST 2020" starttimestamp="1576666505112" timestamp="1188908779" />
  <Command __id="186284" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Wed Jan 01 00:10:14 EST 2020" starttimestamp="1576666505112" timestamp="1188909166" />
  <Command __id="186285" _type="EclipseCommand" commandID="org.eclipse.ui.file.save" date="Wed Jan 01 00:10:16 EST 2020" starttimestamp="1576666505112" timestamp="1188911107" />
  <Command __id="186286" _type="ShellCommand" date="Wed Jan 01 00:10:25 EST 2020" starttimestamp="1576666505112" timestamp="1188919951" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="186287" _type="ShellCommand" date="Wed Jan 01 00:10:26 EST 2020" starttimestamp="1576666505112" timestamp="1188921836" type="ECLIPSE_GAINED_FOCUS" />
  <DocumentChange __id="186277" _type="Insert" date="Wed Jan 01 00:10:08 EST 2020" docASTNodeCount="1" docActiveCodeLength="517" docExpressionCount="0" docLength="633" length="1" offset="403" starttimestamp="1576666505112" timestamp="1188903549">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="186281" _type="Delete" date="Wed Jan 01 00:10:13 EST 2020" docASTNodeCount="1" docActiveCodeLength="509" docExpressionCount="0" docLength="625" endLine="16" length="8" offset="420" startLine="16" starttimestamp="1576666505112" timestamp="1188908776">
    <text><![CDATA[parallel]]></text>
  </DocumentChange>
  <DocumentChange __id="186283" _type="Delete" date="Wed Jan 01 00:10:14 EST 2020" docASTNodeCount="1" docActiveCodeLength="508" docExpressionCount="0" docLength="624" endLine="16" length="1" offset="419" startLine="16" starttimestamp="1576666505112" timestamp="1188909158">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <Command __id="186288" _type="MoveCaretCommand" caretOffset="403" date="Wed Jan 01 00:10:35 EST 2020" docOffset="403" starttimestamp="1576666505112" timestamp="1188930394" />
  <Command __id="186290" _type="EclipseCommand" commandID="org.eclipse.cdt.ui.edit.text.c.toggle.comment" date="Wed Jan 01 00:10:36 EST 2020" starttimestamp="1576666505112" timestamp="1188931631" />
  <Command __id="186291" _type="MoveCaretCommand" caretOffset="349" date="Wed Jan 01 00:10:39 EST 2020" docOffset="349" starttimestamp="1576666505112" timestamp="1188934556" />
  <Command __id="186293" _type="EclipseCommand" commandID="org.eclipse.cdt.ui.edit.text.c.toggle.comment" date="Wed Jan 01 00:10:40 EST 2020" starttimestamp="1576666505112" timestamp="1188935604" />
  <Command __id="186294" _type="EclipseCommand" commandID="org.eclipse.ui.file.save" date="Wed Jan 01 00:10:41 EST 2020" starttimestamp="1576666505112" timestamp="1188936648" />
  <Command __id="186295" _type="MoveCaretCommand" caretOffset="502" date="Wed Jan 01 00:10:51 EST 2020" docOffset="502" starttimestamp="1576666505112" timestamp="1188946149" />
  <Command __id="186297" _type="EclipseCommand" commandID="org.eclipse.cdt.ui.edit.text.c.toggle.comment" date="Wed Jan 01 00:10:52 EST 2020" starttimestamp="1576666505112" timestamp="1188947146" />
  <Command __id="186298" _type="EclipseCommand" commandID="org.eclipse.ui.file.save" date="Wed Jan 01 00:10:53 EST 2020" starttimestamp="1576666505112" timestamp="1188948235" />
  <Command __id="186299" _type="ShellCommand" date="Wed Jan 01 00:11:13 EST 2020" starttimestamp="1576666505112" timestamp="1188968158" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="186300" _type="ShellCommand" date="Wed Jan 01 00:11:16 EST 2020" starttimestamp="1576666505112" timestamp="1188971577" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="186301" _type="ShellCommand" date="Wed Jan 01 00:11:20 EST 2020" starttimestamp="1576666505112" timestamp="1188974990" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="187858" _type="DiffBasedFileOpenCommand" date="Wed Jan 01 00:45:06 EST 2020" docASTNodeCount="447" docActiveCodeLength="3342" docExpressionCount="346" docLength="6093" projectName="DemoCourseLocalBasicChecks" starttimestamp="1576666505112" timestamp="1191001432">
    <filePath><![CDATA[D:\dewan_backup\Java\DemoCourseLocalBasicChecks\src\gradingTools\comp123\assignment1\openmp\testcases\SequentialSumTestCase.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package gradingTools.comp123.assignment1.openmp.testcases;¶¶import java.util.Arrays;¶import java.util.List;¶import java.util.Map;¶import java.util.Set;¶import java.util.regex.Pattern;¶¶import grader.basics.execution.NotRunnableException;¶import grader.basics.execution.RunningProject;¶import grader.basics.junit.NotAutomatableException;¶import grader.basics.junit.TestCaseResult;¶import grader.basics.project.NotGradableException;¶import grader.basics.project.Project;¶import grader.basics.project.source.ABasicTextManager;¶import grader.basics.testcase.PassFailJUnitTestCase;¶import gradingTools.shared.testcases.SubstringSequenceChecker;¶import gradingTools.shared.testcases.openmp.OpenMPPragma;¶import gradingTools.shared.testcases.openmp.OpenMPUtils;¶import gradingTools.shared.testcases.openmp.scannedTree.AssignmentSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.ExternalMethodSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.MethodSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.OMPParallelSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.OMPSNodeUtils;¶import gradingTools.shared.testcases.openmp.scannedTree.RootOfFileSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.RootOfProgramSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.SNode;¶import gradingTools.shared.testcases.utils.LinesMatchKind;¶import gradingTools.shared.testcases.utils.LinesMatcher;¶import gradingTools.utils.RunningProjectUtils;¶¶public class SequentialSumTestCase extends PassFailJUnitTestCase {¶	public static final int TIME_OUT_SECS = 1; // secs¶	protected SubstringSequenceChecker checker = new ASequentialSumChecker();	¶¶	public SequentialSumTestCase() {¶	}¶¶	¶¶	@Override¶	public TestCaseResult test(Project project, boolean autoGrade) throws NotAutomatableException,¶			NotGradableException {¶		try {¶			RunningProject aRunningProject = RunningProjectUtils.runProject(project, TIME_OUT_SECS);¶			String anOutput = aRunningProject.await();¶			LinesMatcher aLinesMatcher = aRunningProject.getLinesMatcher();¶			boolean aRetval = checker.check(aLinesMatcher, LinesMatchKind.ONE_TIME_LINE, Pattern.DOTALL);¶			String aSource = project.getSource();¶//			Map<String, StringBuffer> aFileNameToContents = ABasicTextManager.extractFileContents(aSource);¶//			for (String aFileName:aFileNameToContents.keySet()) {¶//				StringBuffer aFileContents = aFileNameToContents.get(aFileName);¶////				List<OpenMPPragma> anOpenMPPragmas = OpenMPUtils.getOpemMPPragmas(aFileContents);¶//				SNode anSNode = OMPSNodeUtils.getSNode(aFileName, aFileContents);¶//				System.out.println("file name:" + aFileName);¶//				System.out.println("pragmas:" + anSNode);¶//			}¶			RootOfProgramSNode aRootOfProgramSNode = OMPSNodeUtils.getRootOfProgramSNode(aSource);¶			Set<AssignmentSNode> anAssignments = OMPSNodeUtils.assignmentsToSharedVariables(aRootOfProgramSNode);¶			anAssignments = OMPSNodeUtils.assignmentsToSharedArrays(aRootOfProgramSNode);¶			anAssignments = OMPSNodeUtils.assignmentsToParallelCriticalSharedVariables(aRootOfProgramSNode);¶			anAssignments = OMPSNodeUtils.assignmentsToNonParallelCriticalSharedVariables(aRootOfProgramSNode);¶			anAssignments = OMPSNodeUtils.assignmentsToParallelNonCriticalSharedVariables(aRootOfProgramSNode);¶			Set<OMPParallelSNode> anOMPParallelSNodes = OMPSNodeUtils.ompParallelSNodes(aRootOfProgramSNode);¶			¶¶¶			String anExpectedLines = Arrays.toString(checker.getSubstrings());¶¶			if (!aRetval) {¶				return fail("Output  did not match:" + anExpectedLines);¶¶			}¶			return pass();¶			¶¶		} catch (NotRunnableException e) {¶			throw new NotGradableException();¶		}¶	}¶//	public static void processExternalMethodSNodes (RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode) {¶//		for (SNode anSNode:aRootOfFileSNode.getChildren()) {¶//			if (anSNode instanceof ExternalMethodSNode) {¶//				processExternalMethodSNode(aRootOfProgramSNode, aRootOfFileSNode, (ExternalMethodSNode) anSNode);¶//			}¶//		}¶//	}¶//	public static void processExternalMethodSNode (RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode, ExternalMethodSNode anExternalMethodSNode) {¶//		MethodSNode aMethodSNode = aRootOfProgramSNode.getExternalToInternalMethod().get(anExternalMethodSNode.toString());¶//		if (aMethodSNode == null) {¶//			aMethodSNode = findMethodSNode(aRootOfProgramSNode, aRootOfFileSNode, anExternalMethodSNode);¶//			if (aMethodSNode != null) {¶//				aRootOfProgramSNode.getExternalToInternalMethod().put(anExternalMethodSNode.toString(),aMethodSNode );¶//			}¶//		}¶//		if (aMethodSNode != null) {¶//			anExternalMethodSNode.setActualMethodSNode(aMethodSNode);¶//		}¶//	}¶//	public static MethodSNode findMethodSNode (RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode, ExternalMethodSNode anExternalMethodSNode) {¶////		MethodSNode foundMethodSNode = null;¶//		for (String aFileName:aRootOfProgramSNode.getFileNameToSNode().keySet()) {¶//			if (aFileName.equals(aRootOfFileSNode.getFileName()))¶//				continue;¶//			¶//			RootOfFileSNode aSearchedRootOfFileSNode = aRootOfProgramSNode.getFileNameToSNode().get(aFileName);¶//			 for (SNode anSNode:aSearchedRootOfFileSNode.getChildren()) {¶//				if (anSNode instanceof MethodSNode && !(anSNode instanceof ExternalMethodSNode)) {¶//					if (anSNode.toString().equals(anExternalMethodSNode)) {¶//						return (MethodSNode) anSNode;¶//						¶//					}¶////					processExternalMethodSNode(aRootOfProgramSNode, aRootOfFileSNode, (ExternalMethodSNode) anSNode);¶//				}¶//			}¶//		}¶//		return null;¶//	}¶//	public static void processExternalMethodSNodes (RootOfProgramSNode aRootOfProgramSNode) {¶//		for (String aFileName:aRootOfProgramSNode.getFileNameToSNode().keySet()) {¶//			RootOfFileSNode aRootOfFileSNode = aRootOfProgramSNode.getFileNameToSNode().get(aFileName);¶//			processExternalMethodSNodes(aRootOfProgramSNode, aRootOfFileSNode);¶//			¶//		}¶//¶//	}¶}¶")]]]></diff>
  </Command>
  <Command __id="187859" _type="MoveCaretCommand" caretOffset="3472" date="Wed Jan 01 00:45:06 EST 2020" docOffset="3472" starttimestamp="1576666505112" timestamp="1191001506" />
  <Command __id="187860" _type="DiffBasedFileOpenCommand" date="Wed Jan 01 00:45:27 EST 2020" docASTNodeCount="1" docActiveCodeLength="453" docExpressionCount="0" docLength="453" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="1191022515">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\my_sum_sequential.cpp]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"#include <iostream>¶#include <omp.h>¶¶using namespace std;¶void printSumWithTimes(int sum, int start, int end);¶void printNumThreads();¶void recordThreadIndex(int index);¶void sum_sequential(double* array, int size) {¶¶	cout << "sum_sequential\n";¶¶	double start = omp_get_wtime();¶¶	double sum = 0;¶¶	for (int i = 0; i < size; i++) {¶		sum += array[i];¶		recordThreadIndex(i);¶	}¶¶	double end = omp_get_wtime();¶¶	printSumWithTimes(sum, start, end);¶}¶")]]]></diff>
  </Command>
  <Command __id="187861" _type="SelectTextCommand" caretOffset="280" date="Wed Jan 01 00:45:27 EST 2020" end="280" start="265" starttimestamp="1576666505112" timestamp="1191022727" />
  <Command __id="187862" _type="DiffBasedFileOpenCommand" date="Wed Jan 01 00:45:29 EST 2020" docASTNodeCount="1" docActiveCodeLength="535" docExpressionCount="0" docLength="622" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="1191024677">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\my_sum_parallel_for_reduction.cpp]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"#include <iostream>¶#include <omp.h>¶¶using namespace std;¶¶//const int SIZE = 1000;¶void printSumWithTimes(int sum, int start, int end);¶void printNumThreads();¶void recordThreadIndex(int index);¶void sum_parallel_for_reduction(double* array, int size) {¶	cout << "sum_parallel_for_reduction\n";¶¶	double start = omp_get_wtime();¶¶	double sum = 0;¶    #pragma omp  parallel for reduction ( + : sum )¶"), Diff(INSERT,"//    #pragma omp  for reduction ( + : sum )¶¶"), Diff(EQUAL,"//	#pragma omp  for¶¶	for (int i = 0; i < size; i++) {¶"), Diff(DELETE,"//"), Diff(EQUAL,"		sum += array[i];¶¶		recordThreadIndex(i);¶	}¶¶	double end = omp_get_wtime();¶¶	printSumWithTimes(sum, start, end);¶¶}¶")]]]></diff>
    <snapshot><![CDATA[#include <iostream>
#include <omp.h>

using namespace std;

//const int SIZE = 1000;
void printSumWithTimes(int sum, int start, int end);
void printNumThreads();
void recordThreadIndex(int index);
void sum_parallel_for_reduction(double* array, int size) {
	cout << "sum_parallel_for_reduction\n";

	double start = omp_get_wtime();

	double sum = 0;
    #pragma omp  parallel for reduction ( + : sum )
//    #pragma omp  for reduction ( + : sum )

//	#pragma omp  for

	for (int i = 0; i < size; i++) {
		sum += array[i];

		recordThreadIndex(i);
	}

	double end = omp_get_wtime();

	printSumWithTimes(sum, start, end);

}
]]></snapshot>
  </Command>
  <Command __id="187863" _type="MoveCaretCommand" caretOffset="502" date="Wed Jan 01 00:45:29 EST 2020" docOffset="502" starttimestamp="1576666505112" timestamp="1191024886" />
  <Command __id="188046" _type="ShellCommand" date="Wed Jan 01 00:50:52 EST 2020" starttimestamp="1576666505112" timestamp="1191347124" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="188048" _type="MoveCaretCommand" caretOffset="502" date="Wed Jan 01 00:50:52 EST 2020" docOffset="502" starttimestamp="1576666505112" timestamp="1191347610" />
  <Command __id="188049" _type="EclipseCommand" commandID="" date="Wed Jan 01 00:50:53 EST 2020" starttimestamp="1576666505112" timestamp="1191348342" />
  <Command __id="188050" _type="EclipseCommand" commandID="" date="Wed Jan 01 00:50:53 EST 2020" starttimestamp="1576666505112" timestamp="1191348552" />
  <DocumentChange __id="188028" _type="Insert" date="Wed Jan 01 00:48:42 EST 2020" docASTNodeCount="4270" docActiveCodeLength="30320" docExpressionCount="2667" docLength="34506" length="1" offset="26563" starttimestamp="1576666505112" timestamp="1191217397">
    <text><![CDATA[o]]></text>
  </DocumentChange>
  <DocumentChange __id="188035" _type="Replace" date="Wed Jan 01 00:48:47 EST 2020" docASTNodeCount="4270" docActiveCodeLength="30312" docExpressionCount="2667" docLength="34498" endLine="743" insertionLength="18" int_docASTNodeCount="4268" int_docActiveCodeLength="30294" int_docExpressionCount="2665" int_docLength="34480" length="26" offset="26639" startLine="743" starttimestamp="1576666505112" timestamp="1191222561">
    <deletedText><![CDATA[    	fillOMPParallelSNodes]]></deletedText>
    <insertedText><![CDATA[    	fillForSNodes]]></insertedText>
  </DocumentChange>
  <Command __id="188047" _type="DiffBasedFileOpenCommand" date="Wed Jan 01 00:50:52 EST 2020" docASTNodeCount="1" docActiveCodeLength="535" docExpressionCount="0" docLength="622" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="1191347404">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\my_sum_parallel_for_reduction.cpp]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"#include <iostream>¶#include <omp.h>¶¶using namespace std;¶¶//const int SIZE = 1000;¶void printSumWithTimes(int sum, int start, int end);¶void printNumThreads();¶void recordThreadIndex(int index);¶void sum_parallel_for_reduction(double* array, int size) {¶	cout << "sum_parallel_for_reduction\n";¶¶	double start = omp_get_wtime();¶¶	double sum = 0;¶    #pragma omp  parallel for reduction ( + : sum )¶//    #pragma omp  for reduction ( + : sum )¶¶//	#pragma omp  for¶¶	for (int i = 0; i < size; i++) {¶		sum += array[i];¶¶		recordThreadIndex(i);¶	}¶¶	double end = omp_get_wtime();¶¶	printSumWithTimes(sum, start, end);¶¶}¶")]]]></diff>
  </Command>
  <Command __id="188051" _type="MoveCaretCommand" caretOffset="349" date="Wed Jan 01 00:50:56 EST 2020" docOffset="349" starttimestamp="1576666505112" timestamp="1191351613" />
  <Command __id="188053" _type="EclipseCommand" commandID="org.eclipse.cdt.ui.edit.text.c.toggle.comment" date="Wed Jan 01 00:50:58 EST 2020" starttimestamp="1576666505112" timestamp="1191352932" />
  <Command __id="188054" _type="MoveCaretCommand" caretOffset="449" date="Wed Jan 01 00:51:01 EST 2020" docOffset="449" starttimestamp="1576666505112" timestamp="1191356139" />
  <Command __id="188056" _type="EclipseCommand" commandID="org.eclipse.cdt.ui.edit.text.c.toggle.comment" date="Wed Jan 01 00:51:02 EST 2020" starttimestamp="1576666505112" timestamp="1191357162" />
  <Command __id="188058" _type="RunCommand" date="Wed Jan 01 00:51:17 EST 2020" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="1191372380" type="Run" />
  <Command __id="188059" _type="RunCommand" date="Wed Jan 01 00:51:17 EST 2020" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="1191372380" type="Run" />
  <Command __id="188060" _type="RunCommand" date="Wed Jan 01 00:51:17 EST 2020" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="1191372402" type="Debug" />
  <Command __id="188061" _type="RunCommand" date="Wed Jan 01 00:51:17 EST 2020" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="1191372402" type="Run" />
  <Command __id="188062" _type="RunCommand" date="Wed Jan 01 00:51:17 EST 2020" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="1191372402" type="Debug" />
  <Command __id="188063" _type="RunCommand" date="Wed Jan 01 00:51:17 EST 2020" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="1191372403" type="Run" />
  <Command __id="188064" _type="EHExceptionCommand" date="Wed Jan 01 00:51:17 EST 2020" starttimestamp="1576666505112" timestamp="1191372704" type="Exception">
    <outputString><![CDATA[sum_sequential
Sum: 499500
Took: 0
thread:0 lastIndex:999
_____________________________
sum_parallel_for_reduction
Sum: 499500
Took: 0
thread:0 lastIndex:999
_____________________________
sum_parallel_for_local_var
Sum: 499500
Took: 0
thread:0 lastIndex:124
thread:1 lastIndex:249
thread:2 lastIndex:374
thread:3 lastIndex:499
thread:4 lastIndex:624
thread:5 lastIndex:749
thread:6 lastIndex:874
thread:7 lastIndex:999
_____________________________
sum_parallel
Sum: 499500
Took: 0
_____________________________
]]></outputString>
  </Command>
  <Command __id="188065" _type="ShellCommand" date="Wed Jan 01 00:51:30 EST 2020" starttimestamp="1576666505112" timestamp="1191385175" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="188066" _type="ShellCommand" date="Wed Jan 01 00:51:30 EST 2020" starttimestamp="1576666505112" timestamp="1191385341" type="ECLIPSE_GAINED_FOCUS" />
  <DocumentChange __id="188052" _type="Insert" date="Wed Jan 01 00:50:57 EST 2020" docASTNodeCount="1" docActiveCodeLength="484" docExpressionCount="0" docLength="624" length="2" offset="349" starttimestamp="1576666505112" timestamp="1191352887">
    <text><![CDATA[//]]></text>
  </DocumentChange>
  <DocumentChange __id="188055" _type="Delete" date="Wed Jan 01 00:51:02 EST 2020" docASTNodeCount="1" docActiveCodeLength="501" docExpressionCount="0" docLength="622" endLine="18" length="2" offset="449" startLine="18" starttimestamp="1576666505112" timestamp="1191357115">
    <text><![CDATA[//]]></text>
  </DocumentChange>
  <Command __id="188067" _type="MoveCaretCommand" caretOffset="449" date="Wed Jan 01 00:51:44 EST 2020" docOffset="449" starttimestamp="1576666505112" timestamp="1191399718" />
  <Command __id="188069" _type="EclipseCommand" commandID="org.eclipse.cdt.ui.edit.text.c.toggle.comment" date="Wed Jan 01 00:51:47 EST 2020" starttimestamp="1576666505112" timestamp="1191401963" />
  <DocumentChange __id="188564" _type="Insert" date="Wed Jan 01 01:04:33 EST 2020" docASTNodeCount="483" docActiveCodeLength="3577" docExpressionCount="371" docLength="6328" length="1" offset="3661" starttimestamp="1576666505112" timestamp="1192168408">
    <text><![CDATA[F]]></text>
  </DocumentChange>
  <DocumentChange __id="188578" _type="Insert" date="Wed Jan 01 01:04:42 EST 2020" docASTNodeCount="495" docActiveCodeLength="3645" docExpressionCount="382" docLength="6396" length="68" offset="1061" starttimestamp="1576666505112" timestamp="1192177659">
    <text><![CDATA[import gradingTools.shared.testcases.openmp.scannedTree.OMPForSNode;]]></text>
  </DocumentChange>
  <DocumentChange __id="188579" _type="Insert" date="Wed Jan 01 01:04:42 EST 2020" docASTNodeCount="495" docActiveCodeLength="3647" docExpressionCount="382" docLength="6398" length="2" offset="1061" starttimestamp="1576666505112" timestamp="1192177659">
    <text><![CDATA[
]]></text>
  </DocumentChange>
  <Command __id="188589" _type="RunCommand" date="Wed Jan 01 01:04:59 EST 2020" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="1192194477" type="Run" />
  <Command __id="188590" _type="RunCommand" date="Wed Jan 01 01:04:59 EST 2020" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="1192194478" type="Run" />
  <Command __id="188591" _type="RunCommand" date="Wed Jan 01 01:04:59 EST 2020" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="1192194869" type="Run" />
  <Command __id="188614" _type="RunCommand" date="Wed Jan 01 01:05:26 EST 2020" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="1192221375" type="Run" />
  <Command __id="188615" _type="EHExceptionCommand" date="Wed Jan 01 01:05:26 EST 2020" starttimestamp="1576666505112" timestamp="1192221412" type="Exception">
    <outputString><![CDATA[I***(TestCaseResult) ### SequentialSumTestCase: 1.0
Returning first of multiple entry points:[MyOpenMPTraining.exe, OpenMPTraining.exe]
I***(BasicProcessRunner) Running command:D:\dewan_backup\C\MyOpenMPTraining\Debug\MyOpenMPTraining.exe
I***(BasicProcessRunner) Running in folder: D:\dewan_backup\C\MyOpenMPTraining\Debug
I***(BasicProcessRunner)  Process started: D:\dewan_backup\C\MyOpenMPTraining\Debug\MyOpenMPTraining.exe folder: D:\dewan_backup\C\MyOpenMPTraining\Debug entry point: null class path: D:\dewan_backup\Java\PLTeaching\PL_Java\bin;D:\dewan_backup\Java\lib\oeall22.jar;C:\Users\dewan\.p2\pool\plugins\org.junit_4.12.0.v201504281640\junit.jar;C:\Users\dewan\.p2\pool\plugins\org.hamcrest.core_1.3.0.v20180420-1519.jar;D:\dewan_backup\Java\GraderBasics\lib\commons-configuration-1.9.jar;D:\dewan_backup\Java\GraderBasics\lib\commons-lang-2.6.jar;D:\dewan_backup\Java\GraderBasics\lib\commons-logging-1.1.1.jar;G:\My Drive\Java\lib\Herrmes\lib\weka3_6.jar;D:\dewan_backup\Java\GraderBasics\target\classes;D:\dewan_backup\Java\DemoCourseLocalBasicChecks\bin
]]></outputString>
  </Command>
  <Command __id="188616" _type="RunCommand" date="Wed Jan 01 01:05:26 EST 2020" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="1192221415" type="Run" />
  <Command __id="188617" _type="RunCommand" date="Wed Jan 01 01:05:26 EST 2020" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="1192221418" type="Run" />
  <Command __id="188618" _type="EHExceptionCommand" date="Wed Jan 01 01:05:26 EST 2020" starttimestamp="1576666505112" timestamp="1192221473" type="Exception">
    <outputString><![CDATA[I***(ARunnerInputStreamProcessor) Provided Input:
I***(BasicRunningProject) 1577858726534:Received output from main: sum_sequential
I***(BasicRunningProject) 1577858726535:Processing line from main: sum_sequential
I***(BasicRunningProject) 1577858726535:Received output from main: Sum: 499500
I***(BasicRunningProject) 1577858726535:Processing line from main: Sum: 499500
I***(BasicRunningProject) 1577858726535:Received output from main: Took: 0
I***(BasicRunningProject) 1577858726535:Processing line from main: Took: 0
I***(BasicRunningProject) 1577858726536:Received output from main: thread:0 lastIndex:999
I***(BasicRunningProject) 1577858726536:Processing line from main: thread:0 lastIndex:999
I***(BasicRunningProject) 1577858726536:Received output from main: _____________________________
I***(BasicRunningProject) 1577858726536:Processing line from main: _____________________________
I***(BasicRunningProject) 1577858726536:Received output from main: sum_parallel_for_reduction
I***(BasicRunningProject) 1577858726536:Processing line from main: sum_parallel_for_reduction
I***(BasicRunningProject) 1577858726536:Received output from main: Sum: 499500
I***(BasicRunningProject) 1577858726536:Processing line from main: Sum: 499500
I***(BasicRunningProject) 1577858726537:Received output from main: Took: 0
I***(BasicRunningProject) 1577858726537:Processing line from main: Took: 0
I***(BasicRunningProject) 1577858726537:Received output from main: thread:0 lastIndex:999
I***(BasicRunningProject) 1577858726537:Processing line from main: thread:0 lastIndex:999
I***(BasicRunningProject) 1577858726537:Received output from main: _____________________________
I***(BasicRunningProject) 1577858726537:Processing line from main: _____________________________
I***(BasicRunningProject) 1577858726538:Received output from main: sum_parallel_for_local_var
I***(BasicRunningProject) 1577858726538:Processing line from main: sum_parallel_for_local_var
I***(BasicRunningProject) 1577858726538:Received output from main: Sum: 499500
I***(BasicRunningProject) 1577858726538:Processing line from main: Sum: 499500
I***(BasicRunningProject) 1577858726538:Received output from main: Took: 0
I***(BasicRunningProject) 1577858726538:Processing line from main: Took: 0
I***(BasicRunningProject) 1577858726538:Received output from main: thread:0 lastIndex:124
I***(BasicRunningProject) 1577858726538:Processing line from main: thread:0 lastIndex:124
I***(BasicRunningProject) 1577858726538:Received output from main: thread:1 lastIndex:249
I***(BasicRunningProject) 1577858726538:Processing line from main: thread:1 lastIndex:249
I***(BasicRunningProject) 1577858726539:Received output from main: thread:2 lastIndex:374
I***(BasicRunningProject) 1577858726539:Processing line from main: thread:2 lastIndex:374
I***(BasicRunningProject) 1577858726539:Received output from main: thread:3 lastIndex:499
I***(BasicRunningProject) 1577858726539:Processing line from main: thread:3 lastIndex:499
I***(BasicRunningProject) 1577858726539:Received output from main: thread:4 lastIndex:624
I***(BasicRunningProject) 1577858726539:Processing line from main: thread:4 lastIndex:624
I***(BasicRunningProject) 1577858726539:Received output from main: thread:5 lastIndex:749
I***(BasicRunningProject) 1577858726539:Processing line from main: thread:5 lastIndex:749
I***(BasicProcessRunner)  Process finished; folder: D:\dewan_backup\C\MyOpenMPTraining\Debug entry point: null class path: D:\dewan_backup\Java\PLTeaching\PL_Java\bin;D:\dewan_backup\Java\lib\oeall22.jar;C:\Users\dewan\.p2\pool\plugins\org.junit_4.12.0.v201504281640\junit.jar;C:\Users\dewan\.p2\pool\plugins\org.hamcrest.core_1.3.0.v20180420-1519.jar;D:\dewan_backup\Java\GraderBasics\lib\commons-configuration-1.9.jar;D:\dewan_backup\Java\GraderBasics\lib\commons-lang-2.6.jar;D:\dewan_backup\Java\GraderBasics\lib\commons-logging-1.1.1.jar;G:\My Drive\Java\lib\Herrmes\lib\weka3_6.jar;D:\dewan_backup\Java\GraderBasics\target\classes;D:\dewan_backup\Java\DemoCourseLocalBasicChecks\bin
I***(BasicRunningProject) 1577858726539:Received output from main: thread:6 lastIndex:874
I***(BasicRunningProject) 1577858726540:Processing line from main: thread:6 lastIndex:874
I***(BasicRunningProject) 1577858726540:Received output from main: thread:7 lastIndex:999
I***(BasicRunningProject) 1577858726540:Processing line from main: thread:7 lastIndex:999
I***(BasicRunningProject) 1577858726540:Received output from main: _____________________________
I***(BasicRunningProject) 1577858726540:Processing line from main: _____________________________
I***(BasicRunningProject) 1577858726540:Received output from main: sum_parallel
I***(BasicRunningProject) 1577858726540:Processing line from main: sum_parallel
I***(BasicRunningProject) 1577858726540:Received output from main: Sum: 499500
I***(BasicRunningProject) 1577858726541:Processing line from main: Sum: 499500
I***(BasicRunningProject) 1577858726541:Received output from main: Took: 0
I***(BasicRunningProject) 1577858726541:Processing line from main: Took: 0
I***(BasicRunningProject) 1577858726541:Received output from main: _____________________________
I***(BasicRunningProject) 1577858726541:Processing line from main: _____________________________
I***(BasicRunningProject) Thread[AWT-EventQueue-0,6,main] sleeping for ms:2000 waiting for pending output from threads 
]]></outputString>
  </Command>
  <Command __id="188685" _type="DiffBasedFileOpenCommand" date="Wed Jan 01 01:07:20 EST 2020" docASTNodeCount="495" docActiveCodeLength="3647" docExpressionCount="382" docLength="6398" projectName="DemoCourseLocalBasicChecks" starttimestamp="1576666505112" timestamp="1192335674">
    <filePath><![CDATA[D:\dewan_backup\Java\DemoCourseLocalBasicChecks\src\gradingTools\comp123\assignment1\openmp\testcases\SequentialSumTestCase.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package gradingTools.comp123.assignment1.openmp.testcases;¶¶import java.util.Arrays;¶import java.util.List;¶import java.util.Map;¶import java.util.Set;¶import java.util.regex.Pattern;¶¶import grader.basics.execution.NotRunnableException;¶import grader.basics.execution.RunningProject;¶import grader.basics.junit.NotAutomatableException;¶import grader.basics.junit.TestCaseResult;¶import grader.basics.project.NotGradableException;¶import grader.basics.project.Project;¶import grader.basics.project.source.ABasicTextManager;¶import grader.basics.testcase.PassFailJUnitTestCase;¶import gradingTools.shared.testcases.SubstringSequenceChecker;¶import gradingTools.shared.testcases.openmp.OpenMPPragma;¶import gradingTools.shared.testcases.openmp.OpenMPUtils;¶import gradingTools.shared.testcases.openmp.scannedTree.AssignmentSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.ExternalMethodSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.ForSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.MethodSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.OMPForSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.OMPParallelSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.OMPSNodeUtils;¶import gradingTools.shared.testcases.openmp.scannedTree.RootOfFileSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.RootOfProgramSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.SNode;¶import gradingTools.shared.testcases.utils.LinesMatchKind;¶import gradingTools.shared.testcases.utils.LinesMatcher;¶import gradingTools.utils.RunningProjectUtils;¶¶public class SequentialSumTestCase extends PassFailJUnitTestCase {¶	public static final int TIME_OUT_SECS = 1; // secs¶	protected SubstringSequenceChecker checker = new ASequentialSumChecker();	¶¶	public SequentialSumTestCase() {¶	}¶¶	¶¶	@Override¶	public TestCaseResult test(Project project, boolean autoGrade) throws NotAutomatableException,¶			NotGradableException {¶		try {¶			RunningProject aRunningProject = RunningProjectUtils.runProject(project, TIME_OUT_SECS);¶			String anOutput = aRunningProject.await();¶			LinesMatcher aLinesMatcher = aRunningProject.getLinesMatcher();¶			boolean aRetval = checker.check(aLinesMatcher, LinesMatchKind.ONE_TIME_LINE, Pattern.DOTALL);¶			String aSource = project.getSource();¶//			Map<String, StringBuffer> aFileNameToContents = ABasicTextManager.extractFileContents(aSource);¶//			for (String aFileName:aFileNameToContents.keySet()) {¶//				StringBuffer aFileContents = aFileNameToContents.get(aFileName);¶////				List<OpenMPPragma> anOpenMPPragmas = OpenMPUtils.getOpemMPPragmas(aFileContents);¶//				SNode anSNode = OMPSNodeUtils.getSNode(aFileName, aFileContents);¶//				System.out.println("file name:" + aFileName);¶//				System.out.println("pragmas:" + anSNode);¶//			}¶			RootOfProgramSNode aRootOfProgramSNode = OMPSNodeUtils.getRootOfProgramSNode(aSource);¶			Set<AssignmentSNode> anAssignments = OMPSNodeUtils.assignmentsToSharedVariables(aRootOfProgramSNode);¶			anAssignments = OMPSNodeUtils.assignmentsToSharedArrays(aRootOfProgramSNode);¶			anAssignments = OMPSNodeUtils.assignmentsToParallelCriticalSharedVariables(aRootOfProgramSNode);¶			anAssignments = OMPSNodeUtils.assignmentsToNonParallelCriticalSharedVariables(aRootOfProgramSNode);¶			anAssignments = OMPSNodeUtils.assignmentsToParallelNonCriticalSharedVariables(aRootOfProgramSNode);¶			Set<OMPParallelSNode> anOMPParallelSNodes = OMPSNodeUtils.ompParallelSNodes(aRootOfProgramSNode);¶			Set<ForSNode> aForSNodes = OMPSNodeUtils.forSNodes(aRootOfProgramSNode);¶			Set<OMPForSNode> anOMPForSNodes = OMPSNodeUtils.ompForSNodes(aRootOfProgramSNode);¶¶¶			¶¶¶			String anExpectedLines = Arrays.toString(checker.getSubstrings());¶¶			if (!aRetval) {¶				return fail("Output  did not match:" + anExpectedLines);¶¶			}¶			return pass();¶			¶¶		} catch (NotRunnableException e) {¶			throw new NotGradableException();¶		}¶	}¶//	public static void processExternalMethodSNodes (RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode) {¶//		for (SNode anSNode:aRootOfFileSNode.getChildren()) {¶//			if (anSNode instanceof ExternalMethodSNode) {¶//				processExternalMethodSNode(aRootOfProgramSNode, aRootOfFileSNode, (ExternalMethodSNode) anSNode);¶//			}¶//		}¶//	}¶//	public static void processExternalMethodSNode (RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode, ExternalMethodSNode anExternalMethodSNode) {¶//		MethodSNode aMethodSNode = aRootOfProgramSNode.getExternalToInternalMethod().get(anExternalMethodSNode.toString());¶//		if (aMethodSNode == null) {¶//			aMethodSNode = findMethodSNode(aRootOfProgramSNode, aRootOfFileSNode, anExternalMethodSNode);¶//			if (aMethodSNode != null) {¶//				aRootOfProgramSNode.getExternalToInternalMethod().put(anExternalMethodSNode.toString(),aMethodSNode );¶//			}¶//		}¶//		if (aMethodSNode != null) {¶//			anExternalMethodSNode.setActualMethodSNode(aMethodSNode);¶//		}¶//	}¶//	public static MethodSNode findMethodSNode (RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode, ExternalMethodSNode anExternalMethodSNode) {¶////		MethodSNode foundMethodSNode = null;¶//		for (String aFileName:aRootOfProgramSNode.getFileNameToSNode().keySet()) {¶//			if (aFileName.equals(aRootOfFileSNode.getFileName()))¶//				continue;¶//			¶//			RootOfFileSNode aSearchedRootOfFileSNode = aRootOfProgramSNode.getFileNameToSNode().get(aFileName);¶//			 for (SNode anSNode:aSearchedRootOfFileSNode.getChildren()) {¶//				if (anSNode instanceof MethodSNode && !(anSNode instanceof ExternalMethodSNode)) {¶//					if (anSNode.toString().equals(anExternalMethodSNode)) {¶//						return (MethodSNode) anSNode;¶//						¶//					}¶////					processExternalMethodSNode(aRootOfProgramSNode, aRootOfFileSNode, (ExternalMethodSNode) anSNode);¶//				}¶//			}¶//		}¶//		return null;¶//	}¶//	public static void processExternalMethodSNodes (RootOfProgramSNode aRootOfProgramSNode) {¶//		for (String aFileName:aRootOfProgramSNode.getFileNameToSNode().keySet()) {¶//			RootOfFileSNode aRootOfFileSNode = aRootOfProgramSNode.getFileNameToSNode().get(aFileName);¶//			processExternalMethodSNodes(aRootOfProgramSNode, aRootOfFileSNode);¶//			¶//		}¶//¶//	}¶}¶")]]]></diff>
  </Command>
  <Command __id="188704" _type="EclipseCommand" commandID="org.eclipse.debug.ui.commands.Resume" date="Wed Jan 01 01:08:17 EST 2020" starttimestamp="1576666505112" timestamp="1192392705" />
  <Command __id="188705" _type="RunCommand" date="Wed Jan 01 01:08:17 EST 2020" kind="StepInto" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="1192392705" type="Run" />
  <Command __id="188706" _type="EHExceptionCommand" date="Wed Jan 01 01:08:17 EST 2020" starttimestamp="1576666505112" timestamp="1192392822" type="Exception">
    <outputString><![CDATA[I***(TestCaseResult) ### anonymous: 1.0
]]></outputString>
  </Command>
  <Command __id="188707" _type="DiffBasedFileOpenCommand" date="Wed Jan 01 01:09:41 EST 2020" docASTNodeCount="1" docActiveCodeLength="659" docExpressionCount="0" docLength="747" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="1192475918">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\my_sum_parallel_for_local_var.cpp]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"#include <iostream>¶#include <omp.h>¶¶using namespace std;¶¶void printSumWithTimes (int sum, int start, int end);¶void printNumThreads();¶void recordThreadIndex(int index);¶void sum_parallel_for_local_var(double* array, int size)¶{¶	cout << "sum_parallel_for_local_var\n";¶¶	double start = omp_get_wtime();¶¶	double sum = 0;¶¶	int a, b;¶//¶//	for (int i = 0; i < size; i++) {¶//			sum += array[i];¶//			recordThreadIndex(i);¶//	}¶¶    #pragma omp parallel shared (sum, start) private (a, b)¶	{¶		double local_sum = 0;¶¶		#pragma omp for¶		for(int i = 0; i < size; i++) {¶			local_sum += array[i];¶			recordThreadIndex(i);¶		}¶¶		#pragma omp critical¶		sum += local_sum;¶	}¶¶	double end = omp_get_wtime();¶¶	printSumWithTimes(sum, start, end);¶	¶}¶")]]]></diff>
  </Command>
  <Command __id="188708" _type="MoveCaretCommand" caretOffset="621" date="Wed Jan 01 01:09:41 EST 2020" docOffset="621" starttimestamp="1576666505112" timestamp="1192476242" />
  <Command __id="188710" _type="SelectTextCommand" caretOffset="449" date="Wed Jan 01 01:09:53 EST 2020" end="451" start="449" starttimestamp="1576666505112" timestamp="1192488248" />
  <Command __id="188709" _type="DiffBasedFileOpenCommand" date="Wed Jan 01 01:09:53 EST 2020" docASTNodeCount="1" docActiveCodeLength="484" docExpressionCount="0" docLength="624" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="1192488024">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\my_sum_parallel_for_reduction.cpp]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"#include <iostream>¶#include <omp.h>¶¶using namespace std;¶¶//const int SIZE = 1000;¶void printSumWithTimes(int sum, int start, int end);¶void printNumThreads();¶void recordThreadIndex(int index);¶void sum_parallel_for_reduction(double* array, int size) {¶	cout << "sum_parallel_for_reduction\n";¶¶	double start = omp_get_wtime();¶¶	double sum = 0;¶"), Diff(INSERT,"//"), Diff(EQUAL,"    #pragma omp  parallel for reduction ( + : sum )¶//    #pragma omp  for reduction ( + : sum )¶¶//	#pragma omp  for¶¶	for (int i = 0; i < size; i++) {¶		sum += array[i];¶¶		recordThreadIndex(i);¶	}¶¶	double end = omp_get_wtime();¶¶	printSumWithTimes(sum, start, end);¶¶}¶")]]]></diff>
    <snapshot><![CDATA[#include <iostream>
#include <omp.h>

using namespace std;

//const int SIZE = 1000;
void printSumWithTimes(int sum, int start, int end);
void printNumThreads();
void recordThreadIndex(int index);
void sum_parallel_for_reduction(double* array, int size) {
	cout << "sum_parallel_for_reduction\n";

	double start = omp_get_wtime();

	double sum = 0;
//    #pragma omp  parallel for reduction ( + : sum )
//    #pragma omp  for reduction ( + : sum )

//	#pragma omp  for

	for (int i = 0; i < size; i++) {
		sum += array[i];

		recordThreadIndex(i);
	}

	double end = omp_get_wtime();

	printSumWithTimes(sum, start, end);

}
]]></snapshot>
  </Command>
  <Command __id="188711" _type="MoveCaretCommand" caretOffset="349" date="Wed Jan 01 01:09:58 EST 2020" docOffset="349" starttimestamp="1576666505112" timestamp="1192493523" />
  <Command __id="188713" _type="EclipseCommand" commandID="org.eclipse.cdt.ui.edit.text.c.toggle.comment" date="Wed Jan 01 01:10:01 EST 2020" starttimestamp="1576666505112" timestamp="1192495954" />
  <Command __id="188714" _type="EclipseCommand" commandID="org.eclipse.ui.file.save" date="Wed Jan 01 01:10:02 EST 2020" starttimestamp="1576666505112" timestamp="1192497101" />
  <Command __id="188716" _type="RunCommand" date="Wed Jan 01 01:10:11 EST 2020" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="1192506471" type="Run" />
  <Command __id="188717" _type="RunCommand" date="Wed Jan 01 01:10:11 EST 2020" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="1192506477" type="Run" />
  <Command __id="188718" _type="RunCommand" date="Wed Jan 01 01:10:11 EST 2020" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="1192506478" type="Run" />
  <Command __id="188719" _type="EHExceptionCommand" date="Wed Jan 01 01:10:11 EST 2020" starttimestamp="1576666505112" timestamp="1192506522" type="Exception">
    <outputString><![CDATA[I***(TestCaseResult) ### SequentialSumTestCase: 1.0
Returning first of multiple entry points:[MyOpenMPTraining.exe, OpenMPTraining.exe]
I***(BasicProcessRunner) Running command:D:\dewan_backup\C\MyOpenMPTraining\Debug\MyOpenMPTraining.exe
I***(BasicProcessRunner) Running in folder: D:\dewan_backup\C\MyOpenMPTraining\Debug
I***(BasicProcessRunner)  Process started: D:\dewan_backup\C\MyOpenMPTraining\Debug\MyOpenMPTraining.exe folder: D:\dewan_backup\C\MyOpenMPTraining\Debug entry point: null class path: D:\dewan_backup\Java\PLTeaching\PL_Java\bin;D:\dewan_backup\Java\lib\oeall22.jar;C:\Users\dewan\.p2\pool\plugins\org.junit_4.12.0.v201504281640\junit.jar;C:\Users\dewan\.p2\pool\plugins\org.hamcrest.core_1.3.0.v20180420-1519.jar;D:\dewan_backup\Java\GraderBasics\lib\commons-configuration-1.9.jar;D:\dewan_backup\Java\GraderBasics\lib\commons-lang-2.6.jar;D:\dewan_backup\Java\GraderBasics\lib\commons-logging-1.1.1.jar;G:\My Drive\Java\lib\Herrmes\lib\weka3_6.jar;D:\dewan_backup\Java\GraderBasics\target\classes;D:\dewan_backup\Java\DemoCourseLocalBasicChecks\bin
I***(ARunnerInputStreamProcessor) Provided Input:
]]></outputString>
  </Command>
  <Command __id="188720" _type="EHExceptionCommand" date="Wed Jan 01 01:10:11 EST 2020" starttimestamp="1576666505112" timestamp="1192506592" type="Exception">
    <outputString><![CDATA[I***(BasicRunningProject) 1577859011636:Received output from main: sum_sequential
I***(BasicRunningProject) 1577859011636:Processing line from main: sum_sequential
I***(BasicRunningProject) 1577859011637:Received output from main: Sum: 499500
I***(BasicRunningProject) 1577859011637:Processing line from main: Sum: 499500
I***(BasicRunningProject) 1577859011637:Received output from main: Took: 0
I***(BasicRunningProject) 1577859011637:Processing line from main: Took: 0
I***(BasicRunningProject) 1577859011637:Received output from main: thread:0 lastIndex:999
I***(BasicRunningProject) 1577859011637:Processing line from main: thread:0 lastIndex:999
I***(BasicRunningProject) 1577859011637:Received output from main: _____________________________
I***(BasicRunningProject) 1577859011638:Processing line from main: _____________________________
I***(BasicRunningProject) 1577859011638:Received output from main: sum_parallel_for_reduction
I***(BasicRunningProject) 1577859011638:Processing line from main: sum_parallel_for_reduction
I***(BasicRunningProject) 1577859011639:Received output from main: Sum: 499500
I***(BasicRunningProject) 1577859011639:Processing line from main: Sum: 499500
I***(BasicRunningProject) 1577859011639:Received output from main: Took: 0
I***(BasicRunningProject) 1577859011639:Processing line from main: Took: 0
I***(BasicRunningProject) 1577859011639:Received output from main: thread:0 lastIndex:999
I***(BasicRunningProject) 1577859011639:Processing line from main: thread:0 lastIndex:999
I***(BasicRunningProject) 1577859011639:Received output from main: _____________________________
I***(BasicRunningProject) 1577859011639:Processing line from main: _____________________________
I***(BasicRunningProject) 1577859011639:Received output from main: sum_parallel_for_local_var
I***(BasicRunningProject) 1577859011640:Processing line from main: sum_parallel_for_local_var
I***(BasicRunningProject) 1577859011640:Received output from main: Sum: 499500
I***(BasicRunningProject) 1577859011640:Processing line from main: Sum: 499500
I***(BasicRunningProject) 1577859011640:Received output from main: Took: 0
I***(BasicRunningProject) 1577859011640:Processing line from main: Took: 0
I***(BasicRunningProject) 1577859011640:Received output from main: thread:0 lastIndex:124
I***(BasicRunningProject) 1577859011640:Processing line from main: thread:0 lastIndex:124
I***(BasicRunningProject) 1577859011640:Received output from main: thread:1 lastIndex:249
I***(BasicRunningProject) 1577859011640:Processing line from main: thread:1 lastIndex:249
I***(BasicRunningProject) 1577859011640:Received output from main: thread:2 lastIndex:374
I***(BasicRunningProject) 1577859011640:Processing line from main: thread:2 lastIndex:374
I***(BasicRunningProject) 1577859011640:Received output from main: thread:3 lastIndex:499
I***(BasicRunningProject) 1577859011641:Processing line from main: thread:3 lastIndex:499
I***(BasicRunningProject) 1577859011641:Received output from main: thread:4 lastIndex:624
I***(BasicRunningProject) 1577859011642:Processing line from main: thread:4 lastIndex:624
I***(BasicRunningProject) 1577859011642:Received output from main: thread:5 lastIndex:749
I***(BasicRunningProject) 1577859011642:Processing line from main: thread:5 lastIndex:749
I***(BasicRunningProject) 1577859011642:Received output from main: thread:6 lastIndex:874
I***(BasicRunningProject) 1577859011642:Processing line from main: thread:6 lastIndex:874
I***(BasicRunningProject) 1577859011642:Received output from main: thread:7 lastIndex:999
I***(BasicRunningProject) 1577859011642:Processing line from main: thread:7 lastIndex:999
I***(BasicRunningProject) 1577859011642:Received output from main: _____________________________
I***(BasicRunningProject) 1577859011642:Processing line from main: _____________________________
I***(BasicRunningProject) 1577859011643:Received output from main: sum_parallel
I***(BasicRunningProject) 1577859011643:Processing line from main: sum_parallel
I***(BasicRunningProject) 1577859011643:Received output from main: Sum: 499500
I***(BasicRunningProject) 1577859011643:Processing line from main: Sum: 499500
I***(BasicRunningProject) 1577859011643:Received output from main: Took: 0
I***(BasicRunningProject) 1577859011643:Processing line from main: Took: 0
I***(BasicProcessRunner)  Process finished; folder: D:\dewan_backup\C\MyOpenMPTraining\Debug entry point: null class path: D:\dewan_backup\Java\PLTeaching\PL_Java\bin;D:\dewan_backup\Java\lib\oeall22.jar;C:\Users\dewan\.p2\pool\plugins\org.junit_4.12.0.v201504281640\junit.jar;C:\Users\dewan\.p2\pool\plugins\org.hamcrest.core_1.3.0.v20180420-1519.jar;D:\dewan_backup\Java\GraderBasics\lib\commons-configuration-1.9.jar;D:\dewan_backup\Java\GraderBasics\lib\commons-lang-2.6.jar;D:\dewan_backup\Java\GraderBasics\lib\commons-logging-1.1.1.jar;G:\My Drive\Java\lib\Herrmes\lib\weka3_6.jar;D:\dewan_backup\Java\GraderBasics\target\classes;D:\dewan_backup\Java\DemoCourseLocalBasicChecks\bin
I***(BasicRunningProject) 1577859011643:Received output from main: _____________________________
I***(BasicRunningProject) 1577859011643:Processing line from main: _____________________________
I***(BasicRunningProject) Thread[AWT-EventQueue-0,6,main] sleeping for ms:2000 waiting for pending output from threads 
]]></outputString>
  </Command>
  <Command __id="188723" _type="DiffBasedFileOpenCommand" date="Wed Jan 01 01:10:16 EST 2020" docASTNodeCount="495" docActiveCodeLength="3647" docExpressionCount="382" docLength="6398" projectName="DemoCourseLocalBasicChecks" starttimestamp="1576666505112" timestamp="1192511675">
    <filePath><![CDATA[D:\dewan_backup\Java\DemoCourseLocalBasicChecks\src\gradingTools\comp123\assignment1\openmp\testcases\SequentialSumTestCase.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package gradingTools.comp123.assignment1.openmp.testcases;¶¶import java.util.Arrays;¶import java.util.List;¶import java.util.Map;¶import java.util.Set;¶import java.util.regex.Pattern;¶¶import grader.basics.execution.NotRunnableException;¶import grader.basics.execution.RunningProject;¶import grader.basics.junit.NotAutomatableException;¶import grader.basics.junit.TestCaseResult;¶import grader.basics.project.NotGradableException;¶import grader.basics.project.Project;¶import grader.basics.project.source.ABasicTextManager;¶import grader.basics.testcase.PassFailJUnitTestCase;¶import gradingTools.shared.testcases.SubstringSequenceChecker;¶import gradingTools.shared.testcases.openmp.OpenMPPragma;¶import gradingTools.shared.testcases.openmp.OpenMPUtils;¶import gradingTools.shared.testcases.openmp.scannedTree.AssignmentSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.ExternalMethodSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.ForSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.MethodSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.OMPForSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.OMPParallelSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.OMPSNodeUtils;¶import gradingTools.shared.testcases.openmp.scannedTree.RootOfFileSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.RootOfProgramSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.SNode;¶import gradingTools.shared.testcases.utils.LinesMatchKind;¶import gradingTools.shared.testcases.utils.LinesMatcher;¶import gradingTools.utils.RunningProjectUtils;¶¶public class SequentialSumTestCase extends PassFailJUnitTestCase {¶	public static final int TIME_OUT_SECS = 1; // secs¶	protected SubstringSequenceChecker checker = new ASequentialSumChecker();	¶¶	public SequentialSumTestCase() {¶	}¶¶	¶¶	@Override¶	public TestCaseResult test(Project project, boolean autoGrade) throws NotAutomatableException,¶			NotGradableException {¶		try {¶			RunningProject aRunningProject = RunningProjectUtils.runProject(project, TIME_OUT_SECS);¶			String anOutput = aRunningProject.await();¶			LinesMatcher aLinesMatcher = aRunningProject.getLinesMatcher();¶			boolean aRetval = checker.check(aLinesMatcher, LinesMatchKind.ONE_TIME_LINE, Pattern.DOTALL);¶			String aSource = project.getSource();¶//			Map<String, StringBuffer> aFileNameToContents = ABasicTextManager.extractFileContents(aSource);¶//			for (String aFileName:aFileNameToContents.keySet()) {¶//				StringBuffer aFileContents = aFileNameToContents.get(aFileName);¶////				List<OpenMPPragma> anOpenMPPragmas = OpenMPUtils.getOpemMPPragmas(aFileContents);¶//				SNode anSNode = OMPSNodeUtils.getSNode(aFileName, aFileContents);¶//				System.out.println("file name:" + aFileName);¶//				System.out.println("pragmas:" + anSNode);¶//			}¶			RootOfProgramSNode aRootOfProgramSNode = OMPSNodeUtils.getRootOfProgramSNode(aSource);¶			Set<AssignmentSNode> anAssignments = OMPSNodeUtils.assignmentsToSharedVariables(aRootOfProgramSNode);¶			anAssignments = OMPSNodeUtils.assignmentsToSharedArrays(aRootOfProgramSNode);¶			anAssignments = OMPSNodeUtils.assignmentsToParallelCriticalSharedVariables(aRootOfProgramSNode);¶			anAssignments = OMPSNodeUtils.assignmentsToNonParallelCriticalSharedVariables(aRootOfProgramSNode);¶			anAssignments = OMPSNodeUtils.assignmentsToParallelNonCriticalSharedVariables(aRootOfProgramSNode);¶			Set<OMPParallelSNode> anOMPParallelSNodes = OMPSNodeUtils.ompParallelSNodes(aRootOfProgramSNode);¶			Set<ForSNode> aForSNodes = OMPSNodeUtils.forSNodes(aRootOfProgramSNode);¶			Set<OMPForSNode> anOMPForSNodes = OMPSNodeUtils.ompForSNodes(aRootOfProgramSNode);¶¶¶			¶¶¶			String anExpectedLines = Arrays.toString(checker.getSubstrings());¶¶			if (!aRetval) {¶				return fail("Output  did not match:" + anExpectedLines);¶¶			}¶			return pass();¶			¶¶		} catch (NotRunnableException e) {¶			throw new NotGradableException();¶		}¶	}¶//	public static void processExternalMethodSNodes (RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode) {¶//		for (SNode anSNode:aRootOfFileSNode.getChildren()) {¶//			if (anSNode instanceof ExternalMethodSNode) {¶//				processExternalMethodSNode(aRootOfProgramSNode, aRootOfFileSNode, (ExternalMethodSNode) anSNode);¶//			}¶//		}¶//	}¶//	public static void processExternalMethodSNode (RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode, ExternalMethodSNode anExternalMethodSNode) {¶//		MethodSNode aMethodSNode = aRootOfProgramSNode.getExternalToInternalMethod().get(anExternalMethodSNode.toString());¶//		if (aMethodSNode == null) {¶//			aMethodSNode = findMethodSNode(aRootOfProgramSNode, aRootOfFileSNode, anExternalMethodSNode);¶//			if (aMethodSNode != null) {¶//				aRootOfProgramSNode.getExternalToInternalMethod().put(anExternalMethodSNode.toString(),aMethodSNode );¶//			}¶//		}¶//		if (aMethodSNode != null) {¶//			anExternalMethodSNode.setActualMethodSNode(aMethodSNode);¶//		}¶//	}¶//	public static MethodSNode findMethodSNode (RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode, ExternalMethodSNode anExternalMethodSNode) {¶////		MethodSNode foundMethodSNode = null;¶//		for (String aFileName:aRootOfProgramSNode.getFileNameToSNode().keySet()) {¶//			if (aFileName.equals(aRootOfFileSNode.getFileName()))¶//				continue;¶//			¶//			RootOfFileSNode aSearchedRootOfFileSNode = aRootOfProgramSNode.getFileNameToSNode().get(aFileName);¶//			 for (SNode anSNode:aSearchedRootOfFileSNode.getChildren()) {¶//				if (anSNode instanceof MethodSNode && !(anSNode instanceof ExternalMethodSNode)) {¶//					if (anSNode.toString().equals(anExternalMethodSNode)) {¶//						return (MethodSNode) anSNode;¶//						¶//					}¶////					processExternalMethodSNode(aRootOfProgramSNode, aRootOfFileSNode, (ExternalMethodSNode) anSNode);¶//				}¶//			}¶//		}¶//		return null;¶//	}¶//	public static void processExternalMethodSNodes (RootOfProgramSNode aRootOfProgramSNode) {¶//		for (String aFileName:aRootOfProgramSNode.getFileNameToSNode().keySet()) {¶//			RootOfFileSNode aRootOfFileSNode = aRootOfProgramSNode.getFileNameToSNode().get(aFileName);¶//			processExternalMethodSNodes(aRootOfProgramSNode, aRootOfFileSNode);¶//			¶//		}¶//¶//	}¶}¶")]]]></diff>
  </Command>
  <Command __id="188750" _type="MoveCaretCommand" caretOffset="3483" date="Wed Jan 01 01:11:06 EST 2020" docOffset="3483" starttimestamp="1576666505112" timestamp="1192561154" />
  <Command __id="188751" _type="DiffBasedFileOpenCommand" date="Wed Jan 01 01:11:09 EST 2020" docASTNodeCount="1" docActiveCodeLength="659" docExpressionCount="0" docLength="747" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="1192563969">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\my_sum_parallel_for_local_var.cpp]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"#include <iostream>¶#include <omp.h>¶¶using namespace std;¶¶void printSumWithTimes (int sum, int start, int end);¶void printNumThreads();¶void recordThreadIndex(int index);¶void sum_parallel_for_local_var(double* array, int size)¶{¶	cout << "sum_parallel_for_local_var\n";¶¶	double start = omp_get_wtime();¶¶	double sum = 0;¶¶	int a, b;¶//¶//	for (int i = 0; i < size; i++) {¶//			sum += array[i];¶//			recordThreadIndex(i);¶//	}¶¶    #pragma omp parallel shared (sum, start) private (a, b)¶	{¶		double local_sum = 0;¶¶		#pragma omp for¶		for(int i = 0; i < size; i++) {¶			local_sum += array[i];¶			recordThreadIndex(i);¶		}¶¶		#pragma omp critical¶		sum += local_sum;¶	}¶¶	double end = omp_get_wtime();¶¶	printSumWithTimes(sum, start, end);¶	¶}¶")]]]></diff>
  </Command>
  <Command __id="188752" _type="MoveCaretCommand" caretOffset="621" date="Wed Jan 01 01:11:09 EST 2020" docOffset="621" starttimestamp="1576666505112" timestamp="1192564228" />
  <Command __id="188754" _type="MoveCaretCommand" caretOffset="349" date="Wed Jan 01 01:11:13 EST 2020" docOffset="349" starttimestamp="1576666505112" timestamp="1192568253" />
  <Command __id="188755" _type="SelectTextCommand" caretOffset="401" date="Wed Jan 01 01:11:23 EST 2020" end="466" start="401" starttimestamp="1576666505112" timestamp="1192578584" />
  <Command __id="188756" _type="MoveCaretCommand" caretOffset="466" date="Wed Jan 01 01:11:31 EST 2020" docOffset="466" starttimestamp="1576666505112" timestamp="1192586787" />
  <DocumentChange __id="190018" _type="Insert" date="Wed Jan 01 01:40:42 EST 2020" docASTNodeCount="4422" docActiveCodeLength="31256" docExpressionCount="2749" docLength="35442" length="1" offset="8306" starttimestamp="1576666505112" timestamp="1194337879">
    <text><![CDATA[)]]></text>
  </DocumentChange>
  <Command __id="190088" _type="DiffBasedFileOpenCommand" date="Wed Jan 01 01:41:50 EST 2020" docASTNodeCount="236" docActiveCodeLength="1780" docExpressionCount="130" docLength="2279" projectName="GraderBasics" starttimestamp="1576666505112" timestamp="1194405478">
    <filePath><![CDATA[D:\dewan_backup\Java\GraderBasics\src\gradingTools\shared\testcases\openmp\scannedTree\AnOMPForSNode.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package gradingTools.shared.testcases.openmp.scannedTree;¶¶import java.util.ArrayList;¶import java.util.List;¶¶public class AnOMPForSNode extends AnOMPSNode implements OMPForSNode  {¶	protected String reductionVariable;¶	protected String reductionOperation;¶	protected List<AssignmentSNode> reductionVariableAssignments = new ArrayList();¶	protected List<String> reductionOperationUses = new ArrayList();¶	protected Boolean indexVariableNotShared;¶//	protected boolean inParallel;¶	¶	public AnOMPForSNode(int lineNumber) {¶		super(lineNumber);¶	}¶	@Override¶	public void addChild(SNode aChild) {¶		super.addChild(aChild);¶		if (aChild instanceof ForSNode) {¶			ForSNode aForSNode = (ForSNode) aChild;¶			AssignmentSNode anAssignmentSNode = aForSNode.getInitalization();¶			if (anAssignmentSNode != null) {¶				 indexVariableNotShared = ¶						 (anAssignmentSNode instanceof DeclaringAssignmentSNode) ?¶								true:¶								OMPSNodeUtils.isSharedVariable(this, anAssignmentSNode.getLHS());¶			}¶			¶		}¶		¶		¶//		if (reductionVariable != null) {¶//			if (aChild instanceof AssignmentSNode) {¶//				AssignmentSNode anAssignmentSNode = (AssignmentSNode) aChild;¶//				getReductionVariableAssignments().add(anAssignmentSNode);¶//				if (reductionOperation != null) { // can it ever be not null¶//					if (anAssignmentSNode.getOperationAndRHS().contains(reductionOperation)) {¶//						getReductionOperationUses().add(anAssignmentSNode.getOperationAndRHS());¶//					}¶//				}¶//			}			¶//		}¶	}¶	@Override¶	public String getReductionOperation() {¶		return reductionOperation;¶	}¶	@Override¶	public void setReductionOperation(String reductionOperation) {¶		this.reductionOperation = reductionOperation;¶	}¶	@Override¶	public List<AssignmentSNode> getReductionVariableAssignments() {¶		return reductionVariableAssignments;¶	}¶	@Override¶	public List<String> getReductionOperationUses() {¶		return reductionOperationUses;¶	}¶	@Override¶	public String getReductionVariable() {¶		return reductionVariable;¶	}¶	@Override¶	public void setReductionVariable(String reductionVariable) {¶		this.reductionVariable = reductionVariable;¶	}¶	@Override¶	public void setParent (SNode aParent) {¶		super.setParent(aParent);¶	}¶}¶")]]]></diff>
  </Command>
  <Command __id="190095" _type="DiffBasedFileOpenCommand" date="Wed Jan 01 01:41:56 EST 2020" docASTNodeCount="527" docActiveCodeLength="3955" docExpressionCount="393" docLength="6706" projectName="DemoCourseLocalBasicChecks" starttimestamp="1576666505112" timestamp="1194411215">
    <filePath><![CDATA[D:\dewan_backup\Java\DemoCourseLocalBasicChecks\src\gradingTools\comp123\assignment1\openmp\testcases\SequentialSumTestCase.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package gradingTools.comp123.assignment1.openmp.testcases;¶¶import java.util.Arrays;¶import java.util.List;¶import java.util.Map;¶import java.util.Set;¶import java.util.regex.Pattern;¶¶import grader.basics.execution.NotRunnableException;¶import grader.basics.execution.RunningProject;¶import grader.basics.junit.NotAutomatableException;¶import grader.basics.junit.TestCaseResult;¶import grader.basics.project.NotGradableException;¶import grader.basics.project.Project;¶import grader.basics.project.source.ABasicTextManager;¶import grader.basics.testcase.PassFailJUnitTestCase;¶import gradingTools.shared.testcases.SubstringSequenceChecker;¶import gradingTools.shared.testcases.openmp.OpenMPPragma;¶import gradingTools.shared.testcases.openmp.OpenMPUtils;¶import gradingTools.shared.testcases.openmp.scannedTree.AssignmentSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.ExternalMethodSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.ForSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.MethodSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.OMPForSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.OMPParallelSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.OMPSNodeUtils;¶import gradingTools.shared.testcases.openmp.scannedTree.RootOfFileSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.RootOfProgramSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.SNode;¶import gradingTools.shared.testcases.utils.LinesMatchKind;¶import gradingTools.shared.testcases.utils.LinesMatcher;¶import gradingTools.utils.RunningProjectUtils;¶¶public class SequentialSumTestCase extends PassFailJUnitTestCase {¶	public static final int TIME_OUT_SECS = 1; // secs¶	protected SubstringSequenceChecker checker = new ASequentialSumChecker();	¶¶	public SequentialSumTestCase() {¶	}¶¶	¶¶	@Override¶	public TestCaseResult test(Project project, boolean autoGrade) throws NotAutomatableException,¶			NotGradableException {¶		try {¶			RunningProject aRunningProject = RunningProjectUtils.runProject(project, TIME_OUT_SECS);¶			String anOutput = aRunningProject.await();¶			LinesMatcher aLinesMatcher = aRunningProject.getLinesMatcher();¶			boolean aRetval = checker.check(aLinesMatcher, LinesMatchKind.ONE_TIME_LINE, Pattern.DOTALL);¶			String aSource = project.getSource();¶//			Map<String, StringBuffer> aFileNameToContents = ABasicTextManager.extractFileContents(aSource);¶//			for (String aFileName:aFileNameToContents.keySet()) {¶//				StringBuffer aFileContents = aFileNameToContents.get(aFileName);¶////				List<OpenMPPragma> anOpenMPPragmas = OpenMPUtils.getOpemMPPragmas(aFileContents);¶//				SNode anSNode = OMPSNodeUtils.getSNode(aFileName, aFileContents);¶//				System.out.println("file name:" + aFileName);¶//				System.out.println("pragmas:" + anSNode);¶//			}¶			RootOfProgramSNode aRootOfProgramSNode = OMPSNodeUtils.getRootOfProgramSNode(aSource);¶			Set<AssignmentSNode> anAssignments = OMPSNodeUtils.assignmentsToSharedVariables(aRootOfProgramSNode);¶			Set<AssignmentSNode> anAssignmentsToSharedArrays = OMPSNodeUtils.assignmentsToSharedArrays(aRootOfProgramSNode);¶			Set<AssignmentSNode> anAssignmentsToParallelCriticalSharedVariables = OMPSNodeUtils.assignmentsToParallelCriticalSharedVariables(aRootOfProgramSNode);¶			Set<AssignmentSNode> anAssignmentsToNonParallelCriticalSharedVariables  = OMPSNodeUtils.assignmentsToNonParallelCriticalSharedVariables(aRootOfProgramSNode);¶			Set<AssignmentSNode> anAssignmentsToParallelNonCriticalSharedVariables = OMPSNodeUtils.assignmentsToParallelNonCriticalSharedVariables(aRootOfProgramSNode);¶			Set<OMPParallelSNode> anOMPParallelSNodes = OMPSNodeUtils.ompParallelSNodes(aRootOfProgramSNode);¶			Set<ForSNode> aForSNodes = OMPSNodeUtils.forSNodes(aRootOfProgramSNode);¶			Set<OMPForSNode> anOMPForSNodes = OMPSNodeUtils.ompForSNodes(aRootOfProgramSNode);¶			Set<OMPForSNode> anOMPReducingForSNodes = OMPSNodeUtils.ompReducingForNodes(aRootOfProgramSNode);¶¶¶¶			¶¶¶			String anExpectedLines = Arrays.toString(checker.getSubstrings());¶¶			if (!aRetval) {¶				return fail("Output  did not match:" + anExpectedLines);¶¶			}¶			return pass();¶			¶¶		} catch (NotRunnableException e) {¶			throw new NotGradableException();¶		}¶	}¶//	public static void processExternalMethodSNodes (RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode) {¶//		for (SNode anSNode:aRootOfFileSNode.getChildren()) {¶//			if (anSNode instanceof ExternalMethodSNode) {¶//				processExternalMethodSNode(aRootOfProgramSNode, aRootOfFileSNode, (ExternalMethodSNode) anSNode);¶//			}¶//		}¶//	}¶//	public static void processExternalMethodSNode (RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode, ExternalMethodSNode anExternalMethodSNode) {¶//		MethodSNode aMethodSNode = aRootOfProgramSNode.getExternalToInternalMethod().get(anExternalMethodSNode.toString());¶//		if (aMethodSNode == null) {¶//			aMethodSNode = findMethodSNode(aRootOfProgramSNode, aRootOfFileSNode, anExternalMethodSNode);¶//			if (aMethodSNode != null) {¶//				aRootOfProgramSNode.getExternalToInternalMethod().put(anExternalMethodSNode.toString(),aMethodSNode );¶//			}¶//		}¶//		if (aMethodSNode != null) {¶//			anExternalMethodSNode.setActualMethodSNode(aMethodSNode);¶//		}¶//	}¶//	public static MethodSNode findMethodSNode (RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode, ExternalMethodSNode anExternalMethodSNode) {¶////		MethodSNode foundMethodSNode = null;¶//		for (String aFileName:aRootOfProgramSNode.getFileNameToSNode().keySet()) {¶//			if (aFileName.equals(aRootOfFileSNode.getFileName()))¶//				continue;¶//			¶//			RootOfFileSNode aSearchedRootOfFileSNode = aRootOfProgramSNode.getFileNameToSNode().get(aFileName);¶//			 for (SNode anSNode:aSearchedRootOfFileSNode.getChildren()) {¶//				if (anSNode instanceof MethodSNode && !(anSNode instanceof ExternalMethodSNode)) {¶//					if (anSNode.toString().equals(anExternalMethodSNode)) {¶//						return (MethodSNode) anSNode;¶//						¶//					}¶////					processExternalMethodSNode(aRootOfProgramSNode, aRootOfFileSNode, (ExternalMethodSNode) anSNode);¶//				}¶//			}¶//		}¶//		return null;¶//	}¶//	public static void processExternalMethodSNodes (RootOfProgramSNode aRootOfProgramSNode) {¶//		for (String aFileName:aRootOfProgramSNode.getFileNameToSNode().keySet()) {¶//			RootOfFileSNode aRootOfFileSNode = aRootOfProgramSNode.getFileNameToSNode().get(aFileName);¶//			processExternalMethodSNodes(aRootOfProgramSNode, aRootOfFileSNode);¶//			¶//		}¶//¶//	}¶}¶")]]]></diff>
  </Command>
  <Command __id="190172" _type="ShellCommand" date="Wed Jan 01 05:02:25 EST 2020" starttimestamp="1576666505112" timestamp="1206440601" type="ECLIPSE_MAXIMIZED" />
  <Command __id="190173" _type="ShellCommand" date="Wed Jan 01 05:02:25 EST 2020" starttimestamp="1576666505112" timestamp="1206440753" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="190174" _type="DiffBasedFileOpenCommand" date="Wed Jan 01 05:02:38 EST 2020" docASTNodeCount="1" docActiveCodeLength="659" docExpressionCount="0" docLength="747" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="1206453349">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\my_sum_parallel_for_local_var.cpp]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"#include <iostream>¶#include <omp.h>¶¶using namespace std;¶¶void printSumWithTimes (int sum, int start, int end);¶void printNumThreads();¶void recordThreadIndex(int index);¶void sum_parallel_for_local_var(double* array, int size)¶{¶	cout << "sum_parallel_for_local_var\n";¶¶	double start = omp_get_wtime();¶¶	double sum = 0;¶¶	int a, b;¶//¶//	for (int i = 0; i < size; i++) {¶//			sum += array[i];¶//			recordThreadIndex(i);¶//	}¶¶    #pragma omp parallel shared (sum, start) private (a, b)¶	{¶		double local_sum = 0;¶¶		#pragma omp for¶		for(int i = 0; i < size; i++) {¶			local_sum += array[i];¶			recordThreadIndex(i);¶		}¶¶		#pragma omp critical¶		sum += local_sum;¶	}¶¶	double end = omp_get_wtime();¶¶	printSumWithTimes(sum, start, end);¶	¶}¶")]]]></diff>
  </Command>
  <Command __id="190175" _type="MoveCaretCommand" caretOffset="621" date="Wed Jan 01 05:02:38 EST 2020" docOffset="621" starttimestamp="1576666505112" timestamp="1206453621" />
  <DocumentChange __id="197052" _type="Insert" date="Wed Jan 01 10:12:12 EST 2020" docASTNodeCount="4568" docActiveCodeLength="32563" docExpressionCount="2837" docLength="37762" length="1" offset="32185" starttimestamp="1576666505112" timestamp="1225027283">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <Command __id="197118" _type="DiffBasedFileOpenCommand" date="Wed Jan 01 10:12:49 EST 2020" docASTNodeCount="563" docActiveCodeLength="4315" docExpressionCount="417" docLength="7066" projectName="DemoCourseLocalBasicChecks" starttimestamp="1576666505112" timestamp="1225064396">
    <filePath><![CDATA[D:\dewan_backup\Java\DemoCourseLocalBasicChecks\src\gradingTools\comp123\assignment1\openmp\testcases\SequentialSumTestCase.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package gradingTools.comp123.assignment1.openmp.testcases;¶¶import java.util.Arrays;¶import java.util.List;¶import java.util.Map;¶import java.util.Set;¶import java.util.regex.Pattern;¶¶import grader.basics.execution.NotRunnableException;¶import grader.basics.execution.RunningProject;¶import grader.basics.junit.NotAutomatableException;¶import grader.basics.junit.TestCaseResult;¶import grader.basics.project.NotGradableException;¶import grader.basics.project.Project;¶import grader.basics.project.source.ABasicTextManager;¶import grader.basics.testcase.PassFailJUnitTestCase;¶import gradingTools.shared.testcases.SubstringSequenceChecker;¶import gradingTools.shared.testcases.openmp.OpenMPPragma;¶import gradingTools.shared.testcases.openmp.OpenMPUtils;¶import gradingTools.shared.testcases.openmp.scannedTree.AssignmentSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.ExternalMethodSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.ForSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.MethodSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.OMPForSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.OMPParallelSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.OMPSNodeUtils;¶import gradingTools.shared.testcases.openmp.scannedTree.RootOfFileSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.RootOfProgramSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.SNode;¶import gradingTools.shared.testcases.utils.LinesMatchKind;¶import gradingTools.shared.testcases.utils.LinesMatcher;¶import gradingTools.utils.RunningProjectUtils;¶¶public class SequentialSumTestCase extends PassFailJUnitTestCase {¶	public static final int TIME_OUT_SECS = 1; // secs¶	protected SubstringSequenceChecker checker = new ASequentialSumChecker();	¶¶	public SequentialSumTestCase() {¶	}¶¶	¶¶	@Override¶	public TestCaseResult test(Project project, boolean autoGrade) throws NotAutomatableException,¶			NotGradableException {¶		try {¶			RunningProject aRunningProject = RunningProjectUtils.runProject(project, TIME_OUT_SECS);¶			String anOutput = aRunningProject.await();¶			LinesMatcher aLinesMatcher = aRunningProject.getLinesMatcher();¶			boolean aRetval = checker.check(aLinesMatcher, LinesMatchKind.ONE_TIME_LINE, Pattern.DOTALL);¶			String aSource = project.getSource();¶//			Map<String, StringBuffer> aFileNameToContents = ABasicTextManager.extractFileContents(aSource);¶//			for (String aFileName:aFileNameToContents.keySet()) {¶//				StringBuffer aFileContents = aFileNameToContents.get(aFileName);¶////				List<OpenMPPragma> anOpenMPPragmas = OpenMPUtils.getOpemMPPragmas(aFileContents);¶//				SNode anSNode = OMPSNodeUtils.getSNode(aFileName, aFileContents);¶//				System.out.println("file name:" + aFileName);¶//				System.out.println("pragmas:" + anSNode);¶//			}¶			RootOfProgramSNode aRootOfProgramSNode = OMPSNodeUtils.getRootOfProgramSNode(aSource);¶			Set<AssignmentSNode> anAssignments = OMPSNodeUtils.assignmentsToSharedVariables(aRootOfProgramSNode);¶			Set<AssignmentSNode> anAssignmentsToSharedArrays = OMPSNodeUtils.assignmentsToSharedArrays(aRootOfProgramSNode);¶			Set<AssignmentSNode> anAssignmentsToParallelCriticalSharedVariables = OMPSNodeUtils.assignmentsToParallelCriticalSharedVariables(aRootOfProgramSNode);¶			Set<AssignmentSNode> anAssignmentsToNonParallelCriticalSharedVariables  = OMPSNodeUtils.assignmentsToNonParallelCriticalSharedVariables(aRootOfProgramSNode);¶			Set<AssignmentSNode> anAssignmentsToParallelNonCriticalSharedVariables = OMPSNodeUtils.assignmentsToParallelNonCriticalSharedVariables(aRootOfProgramSNode);¶			Set<OMPParallelSNode> anOMPParallelSNodes = OMPSNodeUtils.ompParallelSNodes(aRootOfProgramSNode);¶			Set<ForSNode> aForSNodes = OMPSNodeUtils.forSNodes(aRootOfProgramSNode);¶			Set<OMPForSNode> anOMPForSNodes = OMPSNodeUtils.ompForSNodes(aRootOfProgramSNode);¶			Set<OMPForSNode> anOMPReducingForSNodes = OMPSNodeUtils.ompReducingForNodes(aRootOfProgramSNode);¶			for (OMPForSNode anOMPForSNode:anOMPReducingForSNodes) {¶				Set<AssignmentSNode> anAssignmentsToReducingForNode = OMPSNodeUtils.assignmentsToOMPReducingForNode(anOMPForSNode);¶				if (anAssignmentsToReducingForNode.isEmpty()) {¶					System.err.println(anOMPForSNode + " does not have assignment to:" + anOMPForSNode.getReductionVariable());¶				}¶			}¶¶¶			¶¶¶			String anExpectedLines = Arrays.toString(checker.getSubstrings());¶¶			if (!aRetval) {¶				return fail("Output  did not match:" + anExpectedLines);¶¶			}¶			return pass();¶			¶¶		} catch (NotRunnableException e) {¶			throw new NotGradableException();¶		}¶	}¶//	public static void processExternalMethodSNodes (RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode) {¶//		for (SNode anSNode:aRootOfFileSNode.getChildren()) {¶//			if (anSNode instanceof ExternalMethodSNode) {¶//				processExternalMethodSNode(aRootOfProgramSNode, aRootOfFileSNode, (ExternalMethodSNode) anSNode);¶//			}¶//		}¶//	}¶//	public static void processExternalMethodSNode (RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode, ExternalMethodSNode anExternalMethodSNode) {¶//		MethodSNode aMethodSNode = aRootOfProgramSNode.getExternalToInternalMethod().get(anExternalMethodSNode.toString());¶//		if (aMethodSNode == null) {¶//			aMethodSNode = findMethodSNode(aRootOfProgramSNode, aRootOfFileSNode, anExternalMethodSNode);¶//			if (aMethodSNode != null) {¶//				aRootOfProgramSNode.getExternalToInternalMethod().put(anExternalMethodSNode.toString(),aMethodSNode );¶//			}¶//		}¶//		if (aMethodSNode != null) {¶//			anExternalMethodSNode.setActualMethodSNode(aMethodSNode);¶//		}¶//	}¶//	public static MethodSNode findMethodSNode (RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode, ExternalMethodSNode anExternalMethodSNode) {¶////		MethodSNode foundMethodSNode = null;¶//		for (String aFileName:aRootOfProgramSNode.getFileNameToSNode().keySet()) {¶//			if (aFileName.equals(aRootOfFileSNode.getFileName()))¶//				continue;¶//			¶//			RootOfFileSNode aSearchedRootOfFileSNode = aRootOfProgramSNode.getFileNameToSNode().get(aFileName);¶//			 for (SNode anSNode:aSearchedRootOfFileSNode.getChildren()) {¶//				if (anSNode instanceof MethodSNode && !(anSNode instanceof ExternalMethodSNode)) {¶//					if (anSNode.toString().equals(anExternalMethodSNode)) {¶//						return (MethodSNode) anSNode;¶//						¶//					}¶////					processExternalMethodSNode(aRootOfProgramSNode, aRootOfFileSNode, (ExternalMethodSNode) anSNode);¶//				}¶//			}¶//		}¶//		return null;¶//	}¶//	public static void processExternalMethodSNodes (RootOfProgramSNode aRootOfProgramSNode) {¶//		for (String aFileName:aRootOfProgramSNode.getFileNameToSNode().keySet()) {¶//			RootOfFileSNode aRootOfFileSNode = aRootOfProgramSNode.getFileNameToSNode().get(aFileName);¶//			processExternalMethodSNodes(aRootOfProgramSNode, aRootOfFileSNode);¶//			¶//		}¶//¶//	}¶}¶")]]]></diff>
  </Command>
  <Command __id="197133" _type="ShellCommand" date="Wed Jan 01 10:13:38 EST 2020" starttimestamp="1576666505112" timestamp="1225113066" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="197134" _type="RunCommand" date="Wed Jan 01 10:13:38 EST 2020" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="1225113187" type="Debug" />
  <Command __id="197135" _type="RunCommand" date="Wed Jan 01 10:13:38 EST 2020" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="1225113187" type="Debug" />
  <Command __id="197136" _type="RunCommand" date="Wed Jan 01 10:13:38 EST 2020" kind="HitBreakPoint" projectName="PL_Java" starttimestamp="1576666505112" timestamp="1225113187" type="Run" />
  <Command __id="197138" _type="MoveCaretCommand" caretOffset="348" date="Wed Jan 01 10:13:42 EST 2020" docOffset="348" starttimestamp="1576666505112" timestamp="1225117590" />
  <Command __id="197137" _type="DiffBasedFileOpenCommand" date="Wed Jan 01 10:13:42 EST 2020" docASTNodeCount="1" docActiveCodeLength="535" docExpressionCount="0" docLength="622" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="1225117404">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\my_sum_parallel_for_reduction.cpp]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"#include <iostream>¶#include <omp.h>¶¶using namespace std;¶¶//const int SIZE = 1000;¶void printSumWithTimes(int sum, int start, int end);¶void printNumThreads();¶void recordThreadIndex(int index);¶void sum_parallel_for_reduction(double* array, int size) {¶	cout << "sum_parallel_for_reduction\n";¶¶	double start = omp_get_wtime();¶¶	double sum = 0;¶    #pragma omp  parallel for reduction ( + : sum )¶//    #pragma omp  for reduction ( + : sum )¶¶//	#pragma omp  for¶¶	for (int i = 0; i < size; i++) {¶		sum += array[i];¶¶		recordThreadIndex(i);¶	}¶¶	double end = omp_get_wtime();¶¶	printSumWithTimes(sum, start, end);¶¶}¶")]]]></diff>
  </Command>
  <DocumentChange __id="197140" _type="Insert" date="Wed Jan 01 10:13:58 EST 2020" docASTNodeCount="1" docActiveCodeLength="536" docExpressionCount="0" docLength="623" length="1" offset="196" starttimestamp="1576666505112" timestamp="1225133246">
    <text><![CDATA[
]]></text>
  </DocumentChange>
  <DocumentChange __id="197142" _type="Insert" date="Wed Jan 01 10:13:58 EST 2020" docASTNodeCount="1" docActiveCodeLength="537" docExpressionCount="0" docLength="624" length="1" offset="197" starttimestamp="1576666505112" timestamp="1225133760">
    <text><![CDATA[v]]></text>
  </DocumentChange>
  <Command __id="197139" _type="MoveCaretCommand" caretOffset="196" date="Wed Jan 01 10:13:57 EST 2020" docOffset="196" starttimestamp="1576666505112" timestamp="1225132493" />
  <Command __id="197141" _type="InsertStringCommand" date="Wed Jan 01 10:13:58 EST 2020" starttimestamp="1576666505112" timestamp="1225133250" timestamp2="1225133250">
    <data><![CDATA[]]></data>
  </Command>
  <Command __id="197143" _type="InsertStringCommand" date="Wed Jan 01 10:13:58 EST 2020" starttimestamp="1576666505112" timestamp="1225133765" timestamp2="1225133765">
    <data><![CDATA[v]]></data>
  </Command>
  <Command __id="197145" _type="InsertStringCommand" date="Wed Jan 01 10:14:00 EST 2020" starttimestamp="1576666505112" timestamp="1225135194" timestamp2="1225135194">
    <data><![CDATA[o]]></data>
  </Command>
  <Command __id="197147" _type="InsertStringCommand" date="Wed Jan 01 10:14:00 EST 2020" starttimestamp="1576666505112" timestamp="1225135429" timestamp2="1225135429">
    <data><![CDATA[i]]></data>
  </Command>
  <Command __id="197149" _type="InsertStringCommand" date="Wed Jan 01 10:14:01 EST 2020" starttimestamp="1576666505112" timestamp="1225136413" timestamp2="1225136413">
    <data><![CDATA[d]]></data>
  </Command>
  <Command __id="197151" _type="InsertStringCommand" date="Wed Jan 01 10:14:01 EST 2020" starttimestamp="1576666505112" timestamp="1225136740" timestamp2="1225136740">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="197153" _type="InsertStringCommand" date="Wed Jan 01 10:14:02 EST 2020" starttimestamp="1576666505112" timestamp="1225136896" timestamp2="1225136896">
    <data><![CDATA[i]]></data>
  </Command>
  <Command __id="197155" _type="InsertStringCommand" date="Wed Jan 01 10:14:02 EST 2020" starttimestamp="1576666505112" timestamp="1225137195" timestamp2="1225137195">
    <data><![CDATA[n]]></data>
  </Command>
  <Command __id="197157" _type="InsertStringCommand" date="Wed Jan 01 10:14:02 EST 2020" starttimestamp="1576666505112" timestamp="1225137418" timestamp2="1225137418">
    <data><![CDATA[c]]></data>
  </Command>
  <Command __id="197159" _type="InsertStringCommand" date="Wed Jan 01 10:14:03 EST 2020" starttimestamp="1576666505112" timestamp="1225138004" timestamp2="1225138004">
    <data><![CDATA[r]]></data>
  </Command>
  <Command __id="197161" _type="InsertStringCommand" date="Wed Jan 01 10:14:03 EST 2020" starttimestamp="1576666505112" timestamp="1225138122" timestamp2="1225138122">
    <data><![CDATA[e]]></data>
  </Command>
  <Command __id="197163" _type="InsertStringCommand" date="Wed Jan 01 10:14:03 EST 2020" starttimestamp="1576666505112" timestamp="1225138416" timestamp2="1225138416">
    <data><![CDATA[e]]></data>
  </Command>
  <Command __id="197165" _type="InsertStringCommand" date="Wed Jan 01 10:14:03 EST 2020" starttimestamp="1576666505112" timestamp="1225138570" timestamp2="1225138570">
    <data><![CDATA[n]]></data>
  </Command>
  <Command __id="197167" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Wed Jan 01 10:14:04 EST 2020" starttimestamp="1576666505112" timestamp="1225139121" />
  <Command __id="197169" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Wed Jan 01 10:14:04 EST 2020" starttimestamp="1576666505112" timestamp="1225139296" />
  <Command __id="197171" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Wed Jan 01 10:14:04 EST 2020" starttimestamp="1576666505112" timestamp="1225139444" />
  <Command __id="197173" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Wed Jan 01 10:14:04 EST 2020" starttimestamp="1576666505112" timestamp="1225139621" />
  <Command __id="197175" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Wed Jan 01 10:14:04 EST 2020" starttimestamp="1576666505112" timestamp="1225139797" />
  <Command __id="197177" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Wed Jan 01 10:14:05 EST 2020" starttimestamp="1576666505112" timestamp="1225139959" />
  <Command __id="197179" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Wed Jan 01 10:14:05 EST 2020" starttimestamp="1576666505112" timestamp="1225140118" />
  <Command __id="197181" _type="InsertStringCommand" date="Wed Jan 01 10:14:05 EST 2020" starttimestamp="1576666505112" timestamp="1225140340" timestamp2="1225140340">
    <data><![CDATA[a]]></data>
  </Command>
  <Command __id="197183" _type="InsertStringCommand" date="Wed Jan 01 10:14:05 EST 2020" starttimestamp="1576666505112" timestamp="1225140636" timestamp2="1225140636">
    <data><![CDATA[d]]></data>
  </Command>
  <Command __id="197185" _type="InsertStringCommand" date="Wed Jan 01 10:14:05 EST 2020" starttimestamp="1576666505112" timestamp="1225140792" timestamp2="1225140792">
    <data><![CDATA[d]]></data>
  </Command>
  <DocumentChange __id="197144" _type="Insert" date="Wed Jan 01 10:14:00 EST 2020" docASTNodeCount="1" docActiveCodeLength="538" docExpressionCount="0" docLength="625" length="1" offset="198" starttimestamp="1576666505112" timestamp="1225135190">
    <text><![CDATA[o]]></text>
  </DocumentChange>
  <DocumentChange __id="197146" _type="Insert" date="Wed Jan 01 10:14:00 EST 2020" docASTNodeCount="1" docActiveCodeLength="539" docExpressionCount="0" docLength="626" length="1" offset="199" starttimestamp="1576666505112" timestamp="1225135426">
    <text><![CDATA[i]]></text>
  </DocumentChange>
  <DocumentChange __id="197148" _type="Insert" date="Wed Jan 01 10:14:01 EST 2020" docASTNodeCount="1" docActiveCodeLength="540" docExpressionCount="0" docLength="627" length="1" offset="200" starttimestamp="1576666505112" timestamp="1225136409">
    <text><![CDATA[d]]></text>
  </DocumentChange>
  <DocumentChange __id="197150" _type="Insert" date="Wed Jan 01 10:14:01 EST 2020" docASTNodeCount="1" docActiveCodeLength="541" docExpressionCount="0" docLength="628" length="1" offset="201" starttimestamp="1576666505112" timestamp="1225136736">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="197152" _type="Insert" date="Wed Jan 01 10:14:01 EST 2020" docASTNodeCount="1" docActiveCodeLength="542" docExpressionCount="0" docLength="629" length="1" offset="202" starttimestamp="1576666505112" timestamp="1225136885">
    <text><![CDATA[i]]></text>
  </DocumentChange>
  <DocumentChange __id="197154" _type="Insert" date="Wed Jan 01 10:14:02 EST 2020" docASTNodeCount="1" docActiveCodeLength="543" docExpressionCount="0" docLength="630" length="1" offset="203" starttimestamp="1576666505112" timestamp="1225137192">
    <text><![CDATA[n]]></text>
  </DocumentChange>
  <DocumentChange __id="197156" _type="Insert" date="Wed Jan 01 10:14:02 EST 2020" docASTNodeCount="1" docActiveCodeLength="544" docExpressionCount="0" docLength="631" length="1" offset="204" starttimestamp="1576666505112" timestamp="1225137415">
    <text><![CDATA[c]]></text>
  </DocumentChange>
  <DocumentChange __id="197158" _type="Insert" date="Wed Jan 01 10:14:03 EST 2020" docASTNodeCount="1" docActiveCodeLength="545" docExpressionCount="0" docLength="632" length="1" offset="205" starttimestamp="1576666505112" timestamp="1225138000">
    <text><![CDATA[r]]></text>
  </DocumentChange>
  <DocumentChange __id="197160" _type="Insert" date="Wed Jan 01 10:14:03 EST 2020" docASTNodeCount="1" docActiveCodeLength="546" docExpressionCount="0" docLength="633" length="1" offset="206" starttimestamp="1576666505112" timestamp="1225138118">
    <text><![CDATA[e]]></text>
  </DocumentChange>
  <DocumentChange __id="197162" _type="Insert" date="Wed Jan 01 10:14:03 EST 2020" docASTNodeCount="1" docActiveCodeLength="547" docExpressionCount="0" docLength="634" length="1" offset="207" starttimestamp="1576666505112" timestamp="1225138412">
    <text><![CDATA[e]]></text>
  </DocumentChange>
  <DocumentChange __id="197164" _type="Insert" date="Wed Jan 01 10:14:03 EST 2020" docASTNodeCount="1" docActiveCodeLength="548" docExpressionCount="0" docLength="635" length="1" offset="208" starttimestamp="1576666505112" timestamp="1225138565">
    <text><![CDATA[n]]></text>
  </DocumentChange>
  <DocumentChange __id="197166" _type="Delete" date="Wed Jan 01 10:14:04 EST 2020" docASTNodeCount="1" docActiveCodeLength="547" docExpressionCount="0" docLength="634" endLine="9" length="1" offset="208" startLine="9" starttimestamp="1576666505112" timestamp="1225139119">
    <text><![CDATA[n]]></text>
  </DocumentChange>
  <DocumentChange __id="197168" _type="Delete" date="Wed Jan 01 10:14:04 EST 2020" docASTNodeCount="1" docActiveCodeLength="546" docExpressionCount="0" docLength="633" endLine="9" length="1" offset="207" startLine="9" starttimestamp="1576666505112" timestamp="1225139290">
    <text><![CDATA[e]]></text>
  </DocumentChange>
  <DocumentChange __id="197170" _type="Delete" date="Wed Jan 01 10:14:04 EST 2020" docASTNodeCount="1" docActiveCodeLength="545" docExpressionCount="0" docLength="632" endLine="9" length="1" offset="206" startLine="9" starttimestamp="1576666505112" timestamp="1225139441">
    <text><![CDATA[e]]></text>
  </DocumentChange>
  <DocumentChange __id="197172" _type="Delete" date="Wed Jan 01 10:14:04 EST 2020" docASTNodeCount="1" docActiveCodeLength="544" docExpressionCount="0" docLength="631" endLine="9" length="1" offset="205" startLine="9" starttimestamp="1576666505112" timestamp="1225139619">
    <text><![CDATA[r]]></text>
  </DocumentChange>
  <DocumentChange __id="197174" _type="Delete" date="Wed Jan 01 10:14:04 EST 2020" docASTNodeCount="1" docActiveCodeLength="543" docExpressionCount="0" docLength="630" endLine="9" length="1" offset="204" startLine="9" starttimestamp="1576666505112" timestamp="1225139791">
    <text><![CDATA[c]]></text>
  </DocumentChange>
  <DocumentChange __id="197176" _type="Delete" date="Wed Jan 01 10:14:05 EST 2020" docASTNodeCount="1" docActiveCodeLength="542" docExpressionCount="0" docLength="629" endLine="9" length="1" offset="203" startLine="9" starttimestamp="1576666505112" timestamp="1225139954">
    <text><![CDATA[n]]></text>
  </DocumentChange>
  <DocumentChange __id="197178" _type="Delete" date="Wed Jan 01 10:14:05 EST 2020" docASTNodeCount="1" docActiveCodeLength="541" docExpressionCount="0" docLength="628" endLine="9" length="1" offset="202" startLine="9" starttimestamp="1576666505112" timestamp="1225140116">
    <text><![CDATA[i]]></text>
  </DocumentChange>
  <DocumentChange __id="197180" _type="Insert" date="Wed Jan 01 10:14:05 EST 2020" docASTNodeCount="1" docActiveCodeLength="542" docExpressionCount="0" docLength="629" length="1" offset="202" starttimestamp="1576666505112" timestamp="1225140337">
    <text><![CDATA[a]]></text>
  </DocumentChange>
  <DocumentChange __id="197182" _type="Insert" date="Wed Jan 01 10:14:05 EST 2020" docASTNodeCount="1" docActiveCodeLength="543" docExpressionCount="0" docLength="630" length="1" offset="203" starttimestamp="1576666505112" timestamp="1225140633">
    <text><![CDATA[d]]></text>
  </DocumentChange>
  <DocumentChange __id="197184" _type="Insert" date="Wed Jan 01 10:14:05 EST 2020" docASTNodeCount="1" docActiveCodeLength="544" docExpressionCount="0" docLength="631" length="1" offset="204" starttimestamp="1576666505112" timestamp="1225140788">
    <text><![CDATA[d]]></text>
  </DocumentChange>
  <DocumentChange __id="197186" _type="Insert" date="Wed Jan 01 10:14:06 EST 2020" docASTNodeCount="1" docActiveCodeLength="545" docExpressionCount="0" docLength="632" length="1" offset="205" starttimestamp="1576666505112" timestamp="1225141687">
    <text><![CDATA[T]]></text>
  </DocumentChange>
  <DocumentChange __id="197188" _type="Insert" date="Wed Jan 01 10:14:07 EST 2020" docASTNodeCount="1" docActiveCodeLength="546" docExpressionCount="0" docLength="633" length="1" offset="206" starttimestamp="1576666505112" timestamp="1225141966">
    <text><![CDATA[o]]></text>
  </DocumentChange>
  <DocumentChange __id="197190" _type="Insert" date="Wed Jan 01 10:14:07 EST 2020" docASTNodeCount="1" docActiveCodeLength="547" docExpressionCount="0" docLength="634" length="1" offset="207" starttimestamp="1576666505112" timestamp="1225142414">
    <text><![CDATA[S]]></text>
  </DocumentChange>
  <Command __id="197187" _type="InsertStringCommand" date="Wed Jan 01 10:14:06 EST 2020" starttimestamp="1576666505112" timestamp="1225141693" timestamp2="1225141693">
    <data><![CDATA[T]]></data>
  </Command>
  <Command __id="197189" _type="InsertStringCommand" date="Wed Jan 01 10:14:07 EST 2020" starttimestamp="1576666505112" timestamp="1225141974" timestamp2="1225141974">
    <data><![CDATA[o]]></data>
  </Command>
  <Command __id="197191" _type="InsertStringCommand" date="Wed Jan 01 10:14:07 EST 2020" starttimestamp="1576666505112" timestamp="1225142418" timestamp2="1225142418">
    <data><![CDATA[S]]></data>
  </Command>
  <Command __id="197193" _type="InsertStringCommand" date="Wed Jan 01 10:14:07 EST 2020" starttimestamp="1576666505112" timestamp="1225142650" timestamp2="1225142650">
    <data><![CDATA[u]]></data>
  </Command>
  <Command __id="197195" _type="InsertStringCommand" date="Wed Jan 01 10:14:08 EST 2020" starttimestamp="1576666505112" timestamp="1225142904" timestamp2="1225142904">
    <data><![CDATA[m]]></data>
  </Command>
  <Command __id="197197" _type="InsertStringCommand" date="Wed Jan 01 10:14:08 EST 2020" starttimestamp="1576666505112" timestamp="1225143843" timestamp2="1225143843">
    <data><![CDATA[(]]></data>
  </Command>
  <Command __id="197198" _type="ShellCommand" date="Wed Jan 01 10:14:09 EST 2020" starttimestamp="1576666505112" timestamp="1225144646" type="ECLIPSE_LOST_FOCUS" />
  <DocumentChange __id="197192" _type="Insert" date="Wed Jan 01 10:14:07 EST 2020" docASTNodeCount="1" docActiveCodeLength="548" docExpressionCount="0" docLength="635" length="1" offset="208" starttimestamp="1576666505112" timestamp="1225142642">
    <text><![CDATA[u]]></text>
  </DocumentChange>
  <DocumentChange __id="197194" _type="Insert" date="Wed Jan 01 10:14:08 EST 2020" docASTNodeCount="1" docActiveCodeLength="549" docExpressionCount="0" docLength="636" length="1" offset="209" starttimestamp="1576666505112" timestamp="1225142900">
    <text><![CDATA[m]]></text>
  </DocumentChange>
  <DocumentChange __id="197196" _type="Insert" date="Wed Jan 01 10:14:08 EST 2020" docASTNodeCount="1" docActiveCodeLength="551" docExpressionCount="0" docLength="638" length="2" offset="210" starttimestamp="1576666505112" timestamp="1225143837">
    <text><![CDATA[()]]></text>
  </DocumentChange>
  <DocumentChange __id="197200" _type="Insert" date="Wed Jan 01 10:14:13 EST 2020" docASTNodeCount="1" docActiveCodeLength="552" docExpressionCount="0" docLength="639" length="1" offset="211" starttimestamp="1576666505112" timestamp="1225148089">
    <text><![CDATA[i]]></text>
  </DocumentChange>
  <DocumentChange __id="197202" _type="Insert" date="Wed Jan 01 10:14:13 EST 2020" docASTNodeCount="1" docActiveCodeLength="553" docExpressionCount="0" docLength="640" length="1" offset="212" starttimestamp="1576666505112" timestamp="1225148347">
    <text><![CDATA[n]]></text>
  </DocumentChange>
  <DocumentChange __id="197204" _type="Insert" date="Wed Jan 01 10:14:13 EST 2020" docASTNodeCount="1" docActiveCodeLength="554" docExpressionCount="0" docLength="641" length="1" offset="213" starttimestamp="1576666505112" timestamp="1225148425">
    <text><![CDATA[t]]></text>
  </DocumentChange>
  <DocumentChange __id="197206" _type="Insert" date="Wed Jan 01 10:14:14 EST 2020" docASTNodeCount="1" docActiveCodeLength="555" docExpressionCount="0" docLength="642" length="1" offset="214" starttimestamp="1576666505112" timestamp="1225149174">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="197208" _type="Insert" date="Wed Jan 01 10:14:15 EST 2020" docASTNodeCount="1" docActiveCodeLength="556" docExpressionCount="0" docLength="643" length="1" offset="215" starttimestamp="1576666505112" timestamp="1225150801">
    <text><![CDATA[*]]></text>
  </DocumentChange>
  <Command __id="197199" _type="ShellCommand" date="Wed Jan 01 10:14:12 EST 2020" starttimestamp="1576666505112" timestamp="1225147119" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="197201" _type="InsertStringCommand" date="Wed Jan 01 10:14:13 EST 2020" starttimestamp="1576666505112" timestamp="1225148096" timestamp2="1225148096">
    <data><![CDATA[i]]></data>
  </Command>
  <Command __id="197203" _type="InsertStringCommand" date="Wed Jan 01 10:14:13 EST 2020" starttimestamp="1576666505112" timestamp="1225148351" timestamp2="1225148351">
    <data><![CDATA[n]]></data>
  </Command>
  <Command __id="197205" _type="InsertStringCommand" date="Wed Jan 01 10:14:13 EST 2020" starttimestamp="1576666505112" timestamp="1225148428" timestamp2="1225148428">
    <data><![CDATA[t]]></data>
  </Command>
  <Command __id="197207" _type="InsertStringCommand" date="Wed Jan 01 10:14:14 EST 2020" starttimestamp="1576666505112" timestamp="1225149176" timestamp2="1225149176">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="197209" _type="InsertStringCommand" date="Wed Jan 01 10:14:15 EST 2020" starttimestamp="1576666505112" timestamp="1225150805" timestamp2="1225150805">
    <data><![CDATA[*]]></data>
  </Command>
  <Command __id="197211" _type="InsertStringCommand" date="Wed Jan 01 10:14:19 EST 2020" starttimestamp="1576666505112" timestamp="1225153919" timestamp2="1225153919">
    <data><![CDATA[a]]></data>
  </Command>
  <Command __id="197212" _type="MoveCaretCommand" caretOffset="210" date="Wed Jan 01 10:14:21 EST 2020" docOffset="210" starttimestamp="1576666505112" timestamp="1225156251" />
  <Command __id="197214" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Wed Jan 01 10:14:21 EST 2020" starttimestamp="1576666505112" timestamp="1225156751" />
  <Command __id="197216" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Wed Jan 01 10:14:22 EST 2020" starttimestamp="1576666505112" timestamp="1225156938" />
  <Command __id="197218" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Wed Jan 01 10:14:22 EST 2020" starttimestamp="1576666505112" timestamp="1225157131" />
  <Command __id="197220" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Wed Jan 01 10:14:22 EST 2020" starttimestamp="1576666505112" timestamp="1225157299" />
  <Command __id="197222" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Wed Jan 01 10:14:22 EST 2020" starttimestamp="1576666505112" timestamp="1225157520" />
  <DocumentChange __id="197210" _type="Insert" date="Wed Jan 01 10:14:19 EST 2020" docASTNodeCount="1" docActiveCodeLength="557" docExpressionCount="0" docLength="644" length="1" offset="216" starttimestamp="1576666505112" timestamp="1225153916">
    <text><![CDATA[a]]></text>
  </DocumentChange>
  <DocumentChange __id="197213" _type="Delete" date="Wed Jan 01 10:14:21 EST 2020" docASTNodeCount="1" docActiveCodeLength="556" docExpressionCount="0" docLength="643" endLine="9" length="1" offset="209" startLine="9" starttimestamp="1576666505112" timestamp="1225156748">
    <text><![CDATA[m]]></text>
  </DocumentChange>
  <DocumentChange __id="197215" _type="Delete" date="Wed Jan 01 10:14:22 EST 2020" docASTNodeCount="1" docActiveCodeLength="555" docExpressionCount="0" docLength="642" endLine="9" length="1" offset="208" startLine="9" starttimestamp="1576666505112" timestamp="1225156934">
    <text><![CDATA[u]]></text>
  </DocumentChange>
  <DocumentChange __id="197217" _type="Delete" date="Wed Jan 01 10:14:22 EST 2020" docASTNodeCount="1" docActiveCodeLength="554" docExpressionCount="0" docLength="641" endLine="9" length="1" offset="207" startLine="9" starttimestamp="1576666505112" timestamp="1225157126">
    <text><![CDATA[S]]></text>
  </DocumentChange>
  <DocumentChange __id="197219" _type="Delete" date="Wed Jan 01 10:14:22 EST 2020" docASTNodeCount="1" docActiveCodeLength="553" docExpressionCount="0" docLength="640" endLine="9" length="1" offset="206" startLine="9" starttimestamp="1576666505112" timestamp="1225157297">
    <text><![CDATA[o]]></text>
  </DocumentChange>
  <DocumentChange __id="197221" _type="Delete" date="Wed Jan 01 10:14:22 EST 2020" docASTNodeCount="1" docActiveCodeLength="552" docExpressionCount="0" docLength="639" endLine="9" length="1" offset="205" startLine="9" starttimestamp="1576666505112" timestamp="1225157518">
    <text><![CDATA[T]]></text>
  </DocumentChange>
  <DocumentChange __id="197224" _type="Delete" date="Wed Jan 01 10:14:26 EST 2020" docASTNodeCount="1" docActiveCodeLength="551" docExpressionCount="0" docLength="638" endLine="9" length="1" offset="211" startLine="9" starttimestamp="1576666505112" timestamp="1225161134">
    <text><![CDATA[a]]></text>
  </DocumentChange>
  <DocumentChange __id="197226" _type="Insert" date="Wed Jan 01 10:14:26 EST 2020" docASTNodeCount="1" docActiveCodeLength="552" docExpressionCount="0" docLength="639" length="1" offset="211" starttimestamp="1576666505112" timestamp="1225161506">
    <text><![CDATA[f]]></text>
  </DocumentChange>
  <DocumentChange __id="197228" _type="Insert" date="Wed Jan 01 10:14:26 EST 2020" docASTNodeCount="1" docActiveCodeLength="553" docExpressionCount="0" docLength="640" length="1" offset="212" starttimestamp="1576666505112" timestamp="1225161657">
    <text><![CDATA[i]]></text>
  </DocumentChange>
  <DocumentChange __id="197230" _type="Insert" date="Wed Jan 01 10:14:26 EST 2020" docASTNodeCount="1" docActiveCodeLength="554" docExpressionCount="0" docLength="641" length="1" offset="213" starttimestamp="1576666505112" timestamp="1225161775">
    <text><![CDATA[r]]></text>
  </DocumentChange>
  <DocumentChange __id="197232" _type="Insert" date="Wed Jan 01 10:14:27 EST 2020" docASTNodeCount="1" docActiveCodeLength="555" docExpressionCount="0" docLength="642" length="1" offset="214" starttimestamp="1576666505112" timestamp="1225162023">
    <text><![CDATA[s]]></text>
  </DocumentChange>
  <DocumentChange __id="197234" _type="Insert" date="Wed Jan 01 10:14:27 EST 2020" docASTNodeCount="1" docActiveCodeLength="556" docExpressionCount="0" docLength="643" length="1" offset="215" starttimestamp="1576666505112" timestamp="1225162169">
    <text><![CDATA[t]]></text>
  </DocumentChange>
  <DocumentChange __id="197236" _type="Delete" date="Wed Jan 01 10:14:28 EST 2020" docASTNodeCount="1" docActiveCodeLength="555" docExpressionCount="0" docLength="642" endLine="9" length="1" offset="215" startLine="9" starttimestamp="1576666505112" timestamp="1225163163">
    <text><![CDATA[t]]></text>
  </DocumentChange>
  <DocumentChange __id="197238" _type="Delete" date="Wed Jan 01 10:14:28 EST 2020" docASTNodeCount="1" docActiveCodeLength="554" docExpressionCount="0" docLength="641" endLine="9" length="1" offset="214" startLine="9" starttimestamp="1576666505112" timestamp="1225163330">
    <text><![CDATA[s]]></text>
  </DocumentChange>
  <DocumentChange __id="197240" _type="Delete" date="Wed Jan 01 10:14:28 EST 2020" docASTNodeCount="1" docActiveCodeLength="553" docExpressionCount="0" docLength="640" endLine="9" length="1" offset="213" startLine="9" starttimestamp="1576666505112" timestamp="1225163501">
    <text><![CDATA[r]]></text>
  </DocumentChange>
  <DocumentChange __id="197242" _type="Delete" date="Wed Jan 01 10:14:28 EST 2020" docASTNodeCount="1" docActiveCodeLength="552" docExpressionCount="0" docLength="639" endLine="9" length="1" offset="212" startLine="9" starttimestamp="1576666505112" timestamp="1225163664">
    <text><![CDATA[i]]></text>
  </DocumentChange>
  <DocumentChange __id="197244" _type="Delete" date="Wed Jan 01 10:14:28 EST 2020" docASTNodeCount="1" docActiveCodeLength="551" docExpressionCount="0" docLength="638" endLine="9" length="1" offset="211" startLine="9" starttimestamp="1576666505112" timestamp="1225163859">
    <text><![CDATA[f]]></text>
  </DocumentChange>
  <DocumentChange __id="197246" _type="Insert" date="Wed Jan 01 10:14:29 EST 2020" docASTNodeCount="1" docActiveCodeLength="552" docExpressionCount="0" docLength="639" length="1" offset="211" starttimestamp="1576666505112" timestamp="1225164214">
    <text><![CDATA[a]]></text>
  </DocumentChange>
  <Command __id="197223" _type="MoveCaretCommand" caretOffset="212" date="Wed Jan 01 10:14:25 EST 2020" docOffset="212" starttimestamp="1576666505112" timestamp="1225160665" />
  <Command __id="197225" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Wed Jan 01 10:14:26 EST 2020" starttimestamp="1576666505112" timestamp="1225161137" />
  <Command __id="197227" _type="InsertStringCommand" date="Wed Jan 01 10:14:26 EST 2020" starttimestamp="1576666505112" timestamp="1225161509" timestamp2="1225161509">
    <data><![CDATA[f]]></data>
  </Command>
  <Command __id="197229" _type="InsertStringCommand" date="Wed Jan 01 10:14:26 EST 2020" starttimestamp="1576666505112" timestamp="1225161661" timestamp2="1225161661">
    <data><![CDATA[i]]></data>
  </Command>
  <Command __id="197231" _type="InsertStringCommand" date="Wed Jan 01 10:14:26 EST 2020" starttimestamp="1576666505112" timestamp="1225161779" timestamp2="1225161779">
    <data><![CDATA[r]]></data>
  </Command>
  <Command __id="197233" _type="InsertStringCommand" date="Wed Jan 01 10:14:27 EST 2020" starttimestamp="1576666505112" timestamp="1225162027" timestamp2="1225162027">
    <data><![CDATA[s]]></data>
  </Command>
  <Command __id="197235" _type="InsertStringCommand" date="Wed Jan 01 10:14:27 EST 2020" starttimestamp="1576666505112" timestamp="1225162174" timestamp2="1225162174">
    <data><![CDATA[t]]></data>
  </Command>
  <Command __id="197237" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Wed Jan 01 10:14:28 EST 2020" starttimestamp="1576666505112" timestamp="1225163165" />
  <Command __id="197239" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Wed Jan 01 10:14:28 EST 2020" starttimestamp="1576666505112" timestamp="1225163332" />
  <Command __id="197241" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Wed Jan 01 10:14:28 EST 2020" starttimestamp="1576666505112" timestamp="1225163508" />
  <Command __id="197243" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Wed Jan 01 10:14:28 EST 2020" starttimestamp="1576666505112" timestamp="1225163666" />
  <Command __id="197245" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Wed Jan 01 10:14:28 EST 2020" starttimestamp="1576666505112" timestamp="1225163862" />
  <Command __id="197247" _type="InsertStringCommand" date="Wed Jan 01 10:14:29 EST 2020" starttimestamp="1576666505112" timestamp="1225164218" timestamp2="1225164218">
    <data><![CDATA[a]]></data>
  </Command>
  <Command __id="197249" _type="InsertStringCommand" date="Wed Jan 01 10:14:30 EST 2020" starttimestamp="1576666505112" timestamp="1225165311" timestamp2="1225165311">
    <data><![CDATA[1]]></data>
  </Command>
  <Command __id="197251" _type="InsertStringCommand" date="Wed Jan 01 10:14:30 EST 2020" starttimestamp="1576666505112" timestamp="1225165617" timestamp2="1225165617">
    <data><![CDATA[,]]></data>
  </Command>
  <Command __id="197253" _type="InsertStringCommand" date="Wed Jan 01 10:14:30 EST 2020" starttimestamp="1576666505112" timestamp="1225165763" timestamp2="1225165763">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="197255" _type="InsertStringCommand" date="Wed Jan 01 10:14:31 EST 2020" starttimestamp="1576666505112" timestamp="1225165913" timestamp2="1225165913">
    <data><![CDATA[i]]></data>
  </Command>
  <Command __id="197257" _type="InsertStringCommand" date="Wed Jan 01 10:14:31 EST 2020" starttimestamp="1576666505112" timestamp="1225166167" timestamp2="1225166167">
    <data><![CDATA[n]]></data>
  </Command>
  <Command __id="197259" _type="InsertStringCommand" date="Wed Jan 01 10:14:31 EST 2020" starttimestamp="1576666505112" timestamp="1225166280" timestamp2="1225166280">
    <data><![CDATA[t]]></data>
  </Command>
  <Command __id="197261" _type="InsertStringCommand" date="Wed Jan 01 10:14:31 EST 2020" starttimestamp="1576666505112" timestamp="1225166841" timestamp2="1225166841">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="197263" _type="InsertStringCommand" date="Wed Jan 01 10:14:32 EST 2020" starttimestamp="1576666505112" timestamp="1225167194" timestamp2="1225167194">
    <data><![CDATA[i]]></data>
  </Command>
  <Command __id="197265" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Wed Jan 01 10:14:32 EST 2020" starttimestamp="1576666505112" timestamp="1225167731" />
  <Command __id="197267" _type="InsertStringCommand" date="Wed Jan 01 10:14:32 EST 2020" starttimestamp="1576666505112" timestamp="1225167853" timestamp2="1225167853">
    <data><![CDATA[a]]></data>
  </Command>
  <Command __id="197269" _type="InsertStringCommand" date="Wed Jan 01 10:14:33 EST 2020" starttimestamp="1576666505112" timestamp="1225168086" timestamp2="1225168086">
    <data><![CDATA[n]]></data>
  </Command>
  <DocumentChange __id="197248" _type="Insert" date="Wed Jan 01 10:14:30 EST 2020" docASTNodeCount="1" docActiveCodeLength="553" docExpressionCount="0" docLength="640" length="1" offset="212" starttimestamp="1576666505112" timestamp="1225165305">
    <text><![CDATA[1]]></text>
  </DocumentChange>
  <DocumentChange __id="197250" _type="Insert" date="Wed Jan 01 10:14:30 EST 2020" docASTNodeCount="1" docActiveCodeLength="554" docExpressionCount="0" docLength="641" length="1" offset="213" starttimestamp="1576666505112" timestamp="1225165614">
    <text><![CDATA[,]]></text>
  </DocumentChange>
  <DocumentChange __id="197252" _type="Insert" date="Wed Jan 01 10:14:30 EST 2020" docASTNodeCount="1" docActiveCodeLength="555" docExpressionCount="0" docLength="642" length="1" offset="214" starttimestamp="1576666505112" timestamp="1225165759">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="197254" _type="Insert" date="Wed Jan 01 10:14:31 EST 2020" docASTNodeCount="1" docActiveCodeLength="556" docExpressionCount="0" docLength="643" length="1" offset="215" starttimestamp="1576666505112" timestamp="1225165909">
    <text><![CDATA[i]]></text>
  </DocumentChange>
  <DocumentChange __id="197256" _type="Insert" date="Wed Jan 01 10:14:31 EST 2020" docASTNodeCount="1" docActiveCodeLength="557" docExpressionCount="0" docLength="644" length="1" offset="216" starttimestamp="1576666505112" timestamp="1225166161">
    <text><![CDATA[n]]></text>
  </DocumentChange>
  <DocumentChange __id="197258" _type="Insert" date="Wed Jan 01 10:14:31 EST 2020" docASTNodeCount="1" docActiveCodeLength="558" docExpressionCount="0" docLength="645" length="1" offset="217" starttimestamp="1576666505112" timestamp="1225166276">
    <text><![CDATA[t]]></text>
  </DocumentChange>
  <DocumentChange __id="197260" _type="Insert" date="Wed Jan 01 10:14:31 EST 2020" docASTNodeCount="1" docActiveCodeLength="559" docExpressionCount="0" docLength="646" length="1" offset="218" starttimestamp="1576666505112" timestamp="1225166839">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="197262" _type="Insert" date="Wed Jan 01 10:14:32 EST 2020" docASTNodeCount="1" docActiveCodeLength="560" docExpressionCount="0" docLength="647" length="1" offset="219" starttimestamp="1576666505112" timestamp="1225167189">
    <text><![CDATA[i]]></text>
  </DocumentChange>
  <DocumentChange __id="197264" _type="Delete" date="Wed Jan 01 10:14:32 EST 2020" docASTNodeCount="1" docActiveCodeLength="559" docExpressionCount="0" docLength="646" endLine="9" length="1" offset="219" startLine="9" starttimestamp="1576666505112" timestamp="1225167728">
    <text><![CDATA[i]]></text>
  </DocumentChange>
  <DocumentChange __id="197266" _type="Insert" date="Wed Jan 01 10:14:32 EST 2020" docASTNodeCount="1" docActiveCodeLength="560" docExpressionCount="0" docLength="647" length="1" offset="219" starttimestamp="1576666505112" timestamp="1225167850">
    <text><![CDATA[a]]></text>
  </DocumentChange>
  <DocumentChange __id="197268" _type="Insert" date="Wed Jan 01 10:14:33 EST 2020" docASTNodeCount="1" docActiveCodeLength="561" docExpressionCount="0" docLength="648" length="1" offset="220" starttimestamp="1576666505112" timestamp="1225168081">
    <text><![CDATA[n]]></text>
  </DocumentChange>
  <DocumentChange __id="197270" _type="Insert" date="Wed Jan 01 10:14:33 EST 2020" docASTNodeCount="1" docActiveCodeLength="562" docExpressionCount="0" docLength="649" length="1" offset="221" starttimestamp="1576666505112" timestamp="1225168442">
    <text><![CDATA[I]]></text>
  </DocumentChange>
  <DocumentChange __id="197272" _type="Insert" date="Wed Jan 01 10:14:33 EST 2020" docASTNodeCount="1" docActiveCodeLength="563" docExpressionCount="0" docLength="650" length="1" offset="222" starttimestamp="1576666505112" timestamp="1225168716">
    <text><![CDATA[n]]></text>
  </DocumentChange>
  <DocumentChange __id="197274" _type="Insert" date="Wed Jan 01 10:14:33 EST 2020" docASTNodeCount="1" docActiveCodeLength="564" docExpressionCount="0" docLength="651" length="1" offset="223" starttimestamp="1576666505112" timestamp="1225168752">
    <text><![CDATA[b]]></text>
  </DocumentChange>
  <DocumentChange __id="197276" _type="Insert" date="Wed Jan 01 10:14:34 EST 2020" docASTNodeCount="1" docActiveCodeLength="565" docExpressionCount="0" docLength="652" length="1" offset="224" starttimestamp="1576666505112" timestamp="1225168985">
    <text><![CDATA[c]]></text>
  </DocumentChange>
  <DocumentChange __id="197278" _type="Insert" date="Wed Jan 01 10:14:34 EST 2020" docASTNodeCount="1" docActiveCodeLength="566" docExpressionCount="0" docLength="653" length="1" offset="225" starttimestamp="1576666505112" timestamp="1225169224">
    <text><![CDATA[r]]></text>
  </DocumentChange>
  <DocumentChange __id="197280" _type="Insert" date="Wed Jan 01 10:14:34 EST 2020" docASTNodeCount="1" docActiveCodeLength="567" docExpressionCount="0" docLength="654" length="1" offset="226" starttimestamp="1576666505112" timestamp="1225169351">
    <text><![CDATA[e]]></text>
  </DocumentChange>
  <DocumentChange __id="197282" _type="Delete" date="Wed Jan 01 10:14:34 EST 2020" docASTNodeCount="1" docActiveCodeLength="566" docExpressionCount="0" docLength="653" endLine="9" length="1" offset="226" startLine="9" starttimestamp="1576666505112" timestamp="1225169654">
    <text><![CDATA[e]]></text>
  </DocumentChange>
  <DocumentChange __id="197284" _type="Delete" date="Wed Jan 01 10:14:34 EST 2020" docASTNodeCount="1" docActiveCodeLength="565" docExpressionCount="0" docLength="652" endLine="9" length="1" offset="225" startLine="9" starttimestamp="1576666505112" timestamp="1225169800">
    <text><![CDATA[r]]></text>
  </DocumentChange>
  <DocumentChange __id="197286" _type="Delete" date="Wed Jan 01 10:14:35 EST 2020" docASTNodeCount="1" docActiveCodeLength="564" docExpressionCount="0" docLength="651" endLine="9" length="1" offset="224" startLine="9" starttimestamp="1576666505112" timestamp="1225169962">
    <text><![CDATA[c]]></text>
  </DocumentChange>
  <DocumentChange __id="197288" _type="Delete" date="Wed Jan 01 10:14:35 EST 2020" docASTNodeCount="1" docActiveCodeLength="563" docExpressionCount="0" docLength="650" endLine="9" length="1" offset="223" startLine="9" starttimestamp="1576666505112" timestamp="1225170126">
    <text><![CDATA[b]]></text>
  </DocumentChange>
  <DocumentChange __id="197290" _type="Insert" date="Wed Jan 01 10:14:36 EST 2020" docASTNodeCount="1" docActiveCodeLength="564" docExpressionCount="0" docLength="651" length="1" offset="223" starttimestamp="1576666505112" timestamp="1225170916">
    <text><![CDATA[c]]></text>
  </DocumentChange>
  <DocumentChange __id="197292" _type="Insert" date="Wed Jan 01 10:14:36 EST 2020" docASTNodeCount="1" docActiveCodeLength="565" docExpressionCount="0" docLength="652" length="1" offset="224" starttimestamp="1576666505112" timestamp="1225171169">
    <text><![CDATA[r]]></text>
  </DocumentChange>
  <DocumentChange __id="197294" _type="Insert" date="Wed Jan 01 10:14:36 EST 2020" docASTNodeCount="1" docActiveCodeLength="566" docExpressionCount="0" docLength="653" length="1" offset="225" starttimestamp="1576666505112" timestamp="1225171344">
    <text><![CDATA[e]]></text>
  </DocumentChange>
  <Command __id="197271" _type="InsertStringCommand" date="Wed Jan 01 10:14:33 EST 2020" starttimestamp="1576666505112" timestamp="1225168445" timestamp2="1225168445">
    <data><![CDATA[I]]></data>
  </Command>
  <Command __id="197273" _type="InsertStringCommand" date="Wed Jan 01 10:14:33 EST 2020" starttimestamp="1576666505112" timestamp="1225168725" timestamp2="1225168725">
    <data><![CDATA[n]]></data>
  </Command>
  <Command __id="197275" _type="InsertStringCommand" date="Wed Jan 01 10:14:33 EST 2020" starttimestamp="1576666505112" timestamp="1225168757" timestamp2="1225168757">
    <data><![CDATA[b]]></data>
  </Command>
  <Command __id="197277" _type="InsertStringCommand" date="Wed Jan 01 10:14:34 EST 2020" starttimestamp="1576666505112" timestamp="1225168990" timestamp2="1225168990">
    <data><![CDATA[c]]></data>
  </Command>
  <Command __id="197279" _type="InsertStringCommand" date="Wed Jan 01 10:14:34 EST 2020" starttimestamp="1576666505112" timestamp="1225169228" timestamp2="1225169228">
    <data><![CDATA[r]]></data>
  </Command>
  <Command __id="197281" _type="InsertStringCommand" date="Wed Jan 01 10:14:34 EST 2020" starttimestamp="1576666505112" timestamp="1225169354" timestamp2="1225169354">
    <data><![CDATA[e]]></data>
  </Command>
  <Command __id="197283" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Wed Jan 01 10:14:34 EST 2020" starttimestamp="1576666505112" timestamp="1225169656" />
  <Command __id="197285" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Wed Jan 01 10:14:34 EST 2020" starttimestamp="1576666505112" timestamp="1225169802" />
  <Command __id="197287" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Wed Jan 01 10:14:35 EST 2020" starttimestamp="1576666505112" timestamp="1225169965" />
  <Command __id="197289" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Wed Jan 01 10:14:35 EST 2020" starttimestamp="1576666505112" timestamp="1225170128" />
  <Command __id="197291" _type="InsertStringCommand" date="Wed Jan 01 10:14:36 EST 2020" starttimestamp="1576666505112" timestamp="1225170919" timestamp2="1225170919">
    <data><![CDATA[c]]></data>
  </Command>
  <Command __id="197293" _type="InsertStringCommand" date="Wed Jan 01 10:14:36 EST 2020" starttimestamp="1576666505112" timestamp="1225171180" timestamp2="1225171180">
    <data><![CDATA[r]]></data>
  </Command>
  <Command __id="197295" _type="InsertStringCommand" date="Wed Jan 01 10:14:36 EST 2020" starttimestamp="1576666505112" timestamp="1225171350" timestamp2="1225171350">
    <data><![CDATA[e]]></data>
  </Command>
  <Command __id="197297" _type="InsertStringCommand" date="Wed Jan 01 10:14:36 EST 2020" starttimestamp="1576666505112" timestamp="1225171511" timestamp2="1225171511">
    <data><![CDATA[m]]></data>
  </Command>
  <Command __id="197299" _type="InsertStringCommand" date="Wed Jan 01 10:14:36 EST 2020" starttimestamp="1576666505112" timestamp="1225171606" timestamp2="1225171606">
    <data><![CDATA[e]]></data>
  </Command>
  <Command __id="197301" _type="InsertStringCommand" date="Wed Jan 01 10:14:36 EST 2020" starttimestamp="1576666505112" timestamp="1225171717" timestamp2="1225171717">
    <data><![CDATA[n]]></data>
  </Command>
  <Command __id="197303" _type="InsertStringCommand" date="Wed Jan 01 10:14:37 EST 2020" starttimestamp="1576666505112" timestamp="1225171984" timestamp2="1225171984">
    <data><![CDATA[t]]></data>
  </Command>
  <Command __id="197304" _type="MoveCaretCommand" caretOffset="213" date="Wed Jan 01 10:14:38 EST 2020" docOffset="213" starttimestamp="1576666505112" timestamp="1225173296" />
  <Command __id="197306" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Wed Jan 01 10:14:38 EST 2020" starttimestamp="1576666505112" timestamp="1225173770" />
  <Command __id="197308" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Wed Jan 01 10:14:39 EST 2020" starttimestamp="1576666505112" timestamp="1225173923" />
  <Command __id="197310" _type="InsertStringCommand" date="Wed Jan 01 10:14:39 EST 2020" starttimestamp="1576666505112" timestamp="1225174796" timestamp2="1225174796">
    <data><![CDATA[p]]></data>
  </Command>
  <Command __id="197311" _type="MoveCaretCommand" caretOffset="230" date="Wed Jan 01 10:14:41 EST 2020" docOffset="230" starttimestamp="1576666505112" timestamp="1225176637" />
  <Command __id="197312" _type="MoveCaretCommand" caretOffset="203" date="Wed Jan 01 10:14:43 EST 2020" docOffset="203" starttimestamp="1576666505112" timestamp="1225178840" />
  <Command __id="197313" _type="SelectTextCommand" caretOffset="205" date="Wed Jan 01 10:14:44 EST 2020" end="205" start="202" starttimestamp="1576666505112" timestamp="1225179090" />
  <DocumentChange __id="197296" _type="Insert" date="Wed Jan 01 10:14:36 EST 2020" docASTNodeCount="1" docActiveCodeLength="567" docExpressionCount="0" docLength="654" length="1" offset="226" starttimestamp="1576666505112" timestamp="1225171502">
    <text><![CDATA[m]]></text>
  </DocumentChange>
  <DocumentChange __id="197298" _type="Insert" date="Wed Jan 01 10:14:36 EST 2020" docASTNodeCount="1" docActiveCodeLength="568" docExpressionCount="0" docLength="655" length="1" offset="227" starttimestamp="1576666505112" timestamp="1225171602">
    <text><![CDATA[e]]></text>
  </DocumentChange>
  <DocumentChange __id="197300" _type="Insert" date="Wed Jan 01 10:14:36 EST 2020" docASTNodeCount="1" docActiveCodeLength="569" docExpressionCount="0" docLength="656" length="1" offset="228" starttimestamp="1576666505112" timestamp="1225171714">
    <text><![CDATA[n]]></text>
  </DocumentChange>
  <DocumentChange __id="197302" _type="Insert" date="Wed Jan 01 10:14:37 EST 2020" docASTNodeCount="1" docActiveCodeLength="570" docExpressionCount="0" docLength="657" length="1" offset="229" starttimestamp="1576666505112" timestamp="1225171979">
    <text><![CDATA[t]]></text>
  </DocumentChange>
  <DocumentChange __id="197305" _type="Delete" date="Wed Jan 01 10:14:38 EST 2020" docASTNodeCount="1" docActiveCodeLength="569" docExpressionCount="0" docLength="656" endLine="9" length="1" offset="212" startLine="9" starttimestamp="1576666505112" timestamp="1225173766">
    <text><![CDATA[1]]></text>
  </DocumentChange>
  <DocumentChange __id="197307" _type="Delete" date="Wed Jan 01 10:14:39 EST 2020" docASTNodeCount="1" docActiveCodeLength="568" docExpressionCount="0" docLength="655" endLine="9" length="1" offset="211" startLine="9" starttimestamp="1576666505112" timestamp="1225173916">
    <text><![CDATA[a]]></text>
  </DocumentChange>
  <DocumentChange __id="197309" _type="Insert" date="Wed Jan 01 10:14:39 EST 2020" docASTNodeCount="1" docActiveCodeLength="569" docExpressionCount="0" docLength="656" length="1" offset="211" starttimestamp="1576666505112" timestamp="1225174792">
    <text><![CDATA[p]]></text>
  </DocumentChange>
  <DocumentChange __id="197315" _type="Insert" date="Wed Jan 01 10:14:45 EST 2020" docASTNodeCount="1" docActiveCodeLength="570" docExpressionCount="0" docLength="657" length="1" offset="230" starttimestamp="1576666505112" timestamp="1225180834">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="197317" _type="Insert" date="Wed Jan 01 10:14:46 EST 2020" docASTNodeCount="1" docActiveCodeLength="571" docExpressionCount="0" docLength="658" length="1" offset="231" starttimestamp="1576666505112" timestamp="1225181548">
    <text><![CDATA[{]]></text>
  </DocumentChange>
  <DocumentChange __id="197319" _type="Insert" date="Wed Jan 01 10:14:46 EST 2020" docASTNodeCount="1" docActiveCodeLength="575" docExpressionCount="0" docLength="662" length="4" offset="232" starttimestamp="1576666505112" timestamp="1225181824">
    <text><![CDATA[
	
}]]></text>
  </DocumentChange>
  <DocumentChange __id="197321" _type="Insert" date="Wed Jan 01 10:14:51 EST 2020" docASTNodeCount="1" docActiveCodeLength="576" docExpressionCount="0" docLength="663" length="1" offset="234" starttimestamp="1576666505112" timestamp="1225186081">
    <text><![CDATA[*]]></text>
  </DocumentChange>
  <DocumentChange __id="197323" _type="Insert" date="Wed Jan 01 10:14:52 EST 2020" docASTNodeCount="1" docActiveCodeLength="577" docExpressionCount="0" docLength="664" length="1" offset="235" starttimestamp="1576666505112" timestamp="1225187372">
    <text><![CDATA[p]]></text>
  </DocumentChange>
  <DocumentChange __id="197325" _type="Insert" date="Wed Jan 01 10:14:52 EST 2020" docASTNodeCount="1" docActiveCodeLength="578" docExpressionCount="0" docLength="665" length="1" offset="236" starttimestamp="1576666505112" timestamp="1225187787">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="197327" _type="Insert" date="Wed Jan 01 10:14:53 EST 2020" docASTNodeCount="1" docActiveCodeLength="579" docExpressionCount="0" docLength="666" length="1" offset="237" starttimestamp="1576666505112" timestamp="1225188841">
    <text><![CDATA[=]]></text>
  </DocumentChange>
  <DocumentChange __id="197329" _type="Insert" date="Wed Jan 01 10:14:54 EST 2020" docASTNodeCount="1" docActiveCodeLength="580" docExpressionCount="0" docLength="667" length="1" offset="238" starttimestamp="1576666505112" timestamp="1225189343">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="197331" _type="Insert" date="Wed Jan 01 10:14:55 EST 2020" docASTNodeCount="1" docActiveCodeLength="581" docExpressionCount="0" docLength="668" length="1" offset="239" starttimestamp="1576666505112" timestamp="1225190674">
    <text><![CDATA[*]]></text>
  </DocumentChange>
  <DocumentChange __id="197333" _type="Insert" date="Wed Jan 01 10:14:56 EST 2020" docASTNodeCount="1" docActiveCodeLength="582" docExpressionCount="0" docLength="669" length="1" offset="240" starttimestamp="1576666505112" timestamp="1225191261">
    <text><![CDATA[p]]></text>
  </DocumentChange>
  <DocumentChange __id="197335" _type="Insert" date="Wed Jan 01 10:14:56 EST 2020" docASTNodeCount="1" docActiveCodeLength="583" docExpressionCount="0" docLength="670" length="1" offset="241" starttimestamp="1576666505112" timestamp="1225191619">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <Command __id="197314" _type="MoveCaretCommand" caretOffset="230" date="Wed Jan 01 10:14:45 EST 2020" docOffset="230" starttimestamp="1576666505112" timestamp="1225180563" />
  <Command __id="197316" _type="InsertStringCommand" date="Wed Jan 01 10:14:45 EST 2020" starttimestamp="1576666505112" timestamp="1225180838" timestamp2="1225180838">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="197318" _type="InsertStringCommand" date="Wed Jan 01 10:14:46 EST 2020" starttimestamp="1576666505112" timestamp="1225181550" timestamp2="1225181550">
    <data><![CDATA[{]]></data>
  </Command>
  <Command __id="197320" _type="InsertStringCommand" date="Wed Jan 01 10:14:46 EST 2020" starttimestamp="1576666505112" timestamp="1225181828" timestamp2="1225181828">
    <data><![CDATA[]]></data>
  </Command>
  <Command __id="197322" _type="InsertStringCommand" date="Wed Jan 01 10:14:51 EST 2020" starttimestamp="1576666505112" timestamp="1225186084" timestamp2="1225186084">
    <data><![CDATA[*]]></data>
  </Command>
  <Command __id="197324" _type="InsertStringCommand" date="Wed Jan 01 10:14:52 EST 2020" starttimestamp="1576666505112" timestamp="1225187375" timestamp2="1225187375">
    <data><![CDATA[p]]></data>
  </Command>
  <Command __id="197326" _type="InsertStringCommand" date="Wed Jan 01 10:14:52 EST 2020" starttimestamp="1576666505112" timestamp="1225187790" timestamp2="1225187790">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="197328" _type="InsertStringCommand" date="Wed Jan 01 10:14:53 EST 2020" starttimestamp="1576666505112" timestamp="1225188846" timestamp2="1225188846">
    <data><![CDATA[=]]></data>
  </Command>
  <Command __id="197330" _type="InsertStringCommand" date="Wed Jan 01 10:14:54 EST 2020" starttimestamp="1576666505112" timestamp="1225189347" timestamp2="1225189347">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="197332" _type="InsertStringCommand" date="Wed Jan 01 10:14:55 EST 2020" starttimestamp="1576666505112" timestamp="1225190677" timestamp2="1225190677">
    <data><![CDATA[*]]></data>
  </Command>
  <Command __id="197334" _type="InsertStringCommand" date="Wed Jan 01 10:14:56 EST 2020" starttimestamp="1576666505112" timestamp="1225191266" timestamp2="1225191266">
    <data><![CDATA[p]]></data>
  </Command>
  <Command __id="197336" _type="InsertStringCommand" date="Wed Jan 01 10:14:56 EST 2020" starttimestamp="1576666505112" timestamp="1225191623" timestamp2="1225191623">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="197338" _type="InsertStringCommand" date="Wed Jan 01 10:14:58 EST 2020" starttimestamp="1576666505112" timestamp="1225193162" timestamp2="1225193162">
    <data><![CDATA[+]]></data>
  </Command>
  <Command __id="197340" _type="InsertStringCommand" date="Wed Jan 01 10:14:58 EST 2020" starttimestamp="1576666505112" timestamp="1225193410" timestamp2="1225193410">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="197342" _type="InsertStringCommand" date="Wed Jan 01 10:14:58 EST 2020" starttimestamp="1576666505112" timestamp="1225193571" timestamp2="1225193571">
    <data><![CDATA[a]]></data>
  </Command>
  <Command __id="197344" _type="InsertStringCommand" date="Wed Jan 01 10:14:58 EST 2020" starttimestamp="1576666505112" timestamp="1225193724" timestamp2="1225193724">
    <data><![CDATA[n]]></data>
  </Command>
  <Command __id="197346" _type="InsertStringCommand" date="Wed Jan 01 10:14:59 EST 2020" starttimestamp="1576666505112" timestamp="1225194050" timestamp2="1225194050">
    <data><![CDATA[I]]></data>
  </Command>
  <Command __id="197348" _type="InsertStringCommand" date="Wed Jan 01 10:14:59 EST 2020" starttimestamp="1576666505112" timestamp="1225194283" timestamp2="1225194283">
    <data><![CDATA[n]]></data>
  </Command>
  <Command __id="197350" _type="InsertStringCommand" date="Wed Jan 01 10:14:59 EST 2020" starttimestamp="1576666505112" timestamp="1225194573" timestamp2="1225194573">
    <data><![CDATA[c]]></data>
  </Command>
  <Command __id="197352" _type="InsertStringCommand" date="Wed Jan 01 10:14:59 EST 2020" starttimestamp="1576666505112" timestamp="1225194805" timestamp2="1225194805">
    <data><![CDATA[r]]></data>
  </Command>
  <Command __id="197354" _type="InsertStringCommand" date="Wed Jan 01 10:14:59 EST 2020" starttimestamp="1576666505112" timestamp="1225194884" timestamp2="1225194884">
    <data><![CDATA[e]]></data>
  </Command>
  <Command __id="197356" _type="InsertStringCommand" date="Wed Jan 01 10:15:00 EST 2020" starttimestamp="1576666505112" timestamp="1225195143" timestamp2="1225195143">
    <data><![CDATA[m]]></data>
  </Command>
  <Command __id="197358" _type="InsertStringCommand" date="Wed Jan 01 10:15:00 EST 2020" starttimestamp="1576666505112" timestamp="1225195255" timestamp2="1225195255">
    <data><![CDATA[e]]></data>
  </Command>
  <Command __id="197360" _type="InsertStringCommand" date="Wed Jan 01 10:15:00 EST 2020" starttimestamp="1576666505112" timestamp="1225195400" timestamp2="1225195400">
    <data><![CDATA[n]]></data>
  </Command>
  <Command __id="197362" _type="InsertStringCommand" date="Wed Jan 01 10:15:00 EST 2020" starttimestamp="1576666505112" timestamp="1225195700" timestamp2="1225195700">
    <data><![CDATA[t]]></data>
  </Command>
  <Command __id="197364" _type="InsertStringCommand" date="Wed Jan 01 10:15:01 EST 2020" starttimestamp="1576666505112" timestamp="1225196668" timestamp2="1225196668">
    <data><![CDATA[;]]></data>
  </Command>
  <DocumentChange __id="197337" _type="Insert" date="Wed Jan 01 10:14:58 EST 2020" docASTNodeCount="1" docActiveCodeLength="584" docExpressionCount="0" docLength="671" length="1" offset="242" starttimestamp="1576666505112" timestamp="1225193159">
    <text><![CDATA[+]]></text>
  </DocumentChange>
  <DocumentChange __id="197339" _type="Insert" date="Wed Jan 01 10:14:58 EST 2020" docASTNodeCount="1" docActiveCodeLength="585" docExpressionCount="0" docLength="672" length="1" offset="243" starttimestamp="1576666505112" timestamp="1225193407">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="197341" _type="Insert" date="Wed Jan 01 10:14:58 EST 2020" docASTNodeCount="1" docActiveCodeLength="586" docExpressionCount="0" docLength="673" length="1" offset="244" starttimestamp="1576666505112" timestamp="1225193562">
    <text><![CDATA[a]]></text>
  </DocumentChange>
  <DocumentChange __id="197343" _type="Insert" date="Wed Jan 01 10:14:58 EST 2020" docASTNodeCount="1" docActiveCodeLength="587" docExpressionCount="0" docLength="674" length="1" offset="245" starttimestamp="1576666505112" timestamp="1225193715">
    <text><![CDATA[n]]></text>
  </DocumentChange>
  <DocumentChange __id="197345" _type="Insert" date="Wed Jan 01 10:14:59 EST 2020" docASTNodeCount="1" docActiveCodeLength="588" docExpressionCount="0" docLength="675" length="1" offset="246" starttimestamp="1576666505112" timestamp="1225194046">
    <text><![CDATA[I]]></text>
  </DocumentChange>
  <DocumentChange __id="197347" _type="Insert" date="Wed Jan 01 10:14:59 EST 2020" docASTNodeCount="1" docActiveCodeLength="589" docExpressionCount="0" docLength="676" length="1" offset="247" starttimestamp="1576666505112" timestamp="1225194279">
    <text><![CDATA[n]]></text>
  </DocumentChange>
  <DocumentChange __id="197349" _type="Insert" date="Wed Jan 01 10:14:59 EST 2020" docASTNodeCount="1" docActiveCodeLength="590" docExpressionCount="0" docLength="677" length="1" offset="248" starttimestamp="1576666505112" timestamp="1225194570">
    <text><![CDATA[c]]></text>
  </DocumentChange>
  <DocumentChange __id="197351" _type="Insert" date="Wed Jan 01 10:14:59 EST 2020" docASTNodeCount="1" docActiveCodeLength="591" docExpressionCount="0" docLength="678" length="1" offset="249" starttimestamp="1576666505112" timestamp="1225194802">
    <text><![CDATA[r]]></text>
  </DocumentChange>
  <DocumentChange __id="197353" _type="Insert" date="Wed Jan 01 10:14:59 EST 2020" docASTNodeCount="1" docActiveCodeLength="592" docExpressionCount="0" docLength="679" length="1" offset="250" starttimestamp="1576666505112" timestamp="1225194881">
    <text><![CDATA[e]]></text>
  </DocumentChange>
  <DocumentChange __id="197355" _type="Insert" date="Wed Jan 01 10:15:00 EST 2020" docASTNodeCount="1" docActiveCodeLength="593" docExpressionCount="0" docLength="680" length="1" offset="251" starttimestamp="1576666505112" timestamp="1225195138">
    <text><![CDATA[m]]></text>
  </DocumentChange>
  <DocumentChange __id="197357" _type="Insert" date="Wed Jan 01 10:15:00 EST 2020" docASTNodeCount="1" docActiveCodeLength="594" docExpressionCount="0" docLength="681" length="1" offset="252" starttimestamp="1576666505112" timestamp="1225195251">
    <text><![CDATA[e]]></text>
  </DocumentChange>
  <DocumentChange __id="197359" _type="Insert" date="Wed Jan 01 10:15:00 EST 2020" docASTNodeCount="1" docActiveCodeLength="595" docExpressionCount="0" docLength="682" length="1" offset="253" starttimestamp="1576666505112" timestamp="1225195397">
    <text><![CDATA[n]]></text>
  </DocumentChange>
  <DocumentChange __id="197361" _type="Insert" date="Wed Jan 01 10:15:00 EST 2020" docASTNodeCount="1" docActiveCodeLength="596" docExpressionCount="0" docLength="683" length="1" offset="254" starttimestamp="1576666505112" timestamp="1225195696">
    <text><![CDATA[t]]></text>
  </DocumentChange>
  <DocumentChange __id="197363" _type="Insert" date="Wed Jan 01 10:15:01 EST 2020" docASTNodeCount="1" docActiveCodeLength="597" docExpressionCount="0" docLength="684" length="1" offset="255" starttimestamp="1576666505112" timestamp="1225196666">
    <text><![CDATA[;]]></text>
  </DocumentChange>
  <Command __id="197365" _type="MoveCaretCommand" caretOffset="566" date="Wed Jan 01 10:15:08 EST 2020" docOffset="566" starttimestamp="1576666505112" timestamp="1225203065" />
  <Command __id="197367" _type="EclipseCommand" commandID="org.eclipse.cdt.ui.edit.text.c.toggle.comment" date="Wed Jan 01 10:15:09 EST 2020" starttimestamp="1576666505112" timestamp="1225204139" />
  <DocumentChange __id="197366" _type="Insert" date="Wed Jan 01 10:15:09 EST 2020" docASTNodeCount="1" docActiveCodeLength="579" docExpressionCount="0" docLength="686" length="2" offset="564" starttimestamp="1576666505112" timestamp="1225204117">
    <text><![CDATA[//]]></text>
  </DocumentChange>
  <Command __id="197368" _type="MoveCaretCommand" caretOffset="585" date="Wed Jan 01 10:15:16 EST 2020" docOffset="585" starttimestamp="1576666505112" timestamp="1225211033" />
  <DocumentChange __id="197369" _type="Insert" date="Wed Jan 01 10:15:17 EST 2020" docASTNodeCount="1" docActiveCodeLength="581" docExpressionCount="0" docLength="688" length="2" offset="585" starttimestamp="1576666505112" timestamp="1225212136">
    <text><![CDATA[		]]></text>
  </DocumentChange>
  <Command __id="197370" _type="InsertStringCommand" date="Wed Jan 01 10:15:17 EST 2020" starttimestamp="1576666505112" timestamp="1225212140" timestamp2="1225212140">
    <data><![CDATA[	]]></data>
  </Command>
  <DocumentChange __id="197371" _type="Insert" date="Wed Jan 01 10:15:17 EST 2020" docASTNodeCount="1" docActiveCodeLength="582" docExpressionCount="0" docLength="689" length="1" offset="587" starttimestamp="1576666505112" timestamp="1225212628">
    <text><![CDATA[a]]></text>
  </DocumentChange>
  <Command __id="197372" _type="InsertStringCommand" date="Wed Jan 01 10:15:17 EST 2020" starttimestamp="1576666505112" timestamp="1225212638" timestamp2="1225212638">
    <data><![CDATA[a]]></data>
  </Command>
  <DocumentChange __id="197373" _type="Insert" date="Wed Jan 01 10:15:18 EST 2020" docASTNodeCount="1" docActiveCodeLength="583" docExpressionCount="0" docLength="690" length="1" offset="588" starttimestamp="1576666505112" timestamp="1225213008">
    <text><![CDATA[d]]></text>
  </DocumentChange>
  <Command __id="197374" _type="InsertStringCommand" date="Wed Jan 01 10:15:18 EST 2020" starttimestamp="1576666505112" timestamp="1225213011" timestamp2="1225213011">
    <data><![CDATA[d]]></data>
  </Command>
  <DocumentChange __id="197375" _type="Insert" date="Wed Jan 01 10:15:18 EST 2020" docASTNodeCount="1" docActiveCodeLength="584" docExpressionCount="0" docLength="691" length="1" offset="589" starttimestamp="1576666505112" timestamp="1225213144">
    <text><![CDATA[d]]></text>
  </DocumentChange>
  <Command __id="197376" _type="InsertStringCommand" date="Wed Jan 01 10:15:18 EST 2020" starttimestamp="1576666505112" timestamp="1225213154" timestamp2="1225213154">
    <data><![CDATA[d]]></data>
  </Command>
  <DocumentChange __id="197377" _type="Insert" date="Wed Jan 01 10:15:19 EST 2020" docASTNodeCount="1" docActiveCodeLength="586" docExpressionCount="0" docLength="693" length="2" offset="590" starttimestamp="1576666505112" timestamp="1225213911">
    <text><![CDATA[()]]></text>
  </DocumentChange>
  <Command __id="197378" _type="InsertStringCommand" date="Wed Jan 01 10:15:19 EST 2020" starttimestamp="1576666505112" timestamp="1225213916" timestamp2="1225213916">
    <data><![CDATA[(]]></data>
  </Command>
  <DocumentChange __id="197379" _type="Insert" date="Wed Jan 01 10:15:20 EST 2020" docASTNodeCount="1" docActiveCodeLength="587" docExpressionCount="0" docLength="694" length="1" offset="591" starttimestamp="1576666505112" timestamp="1225215407">
    <text><![CDATA[&]]></text>
  </DocumentChange>
  <Command __id="197380" _type="InsertStringCommand" date="Wed Jan 01 10:15:20 EST 2020" starttimestamp="1576666505112" timestamp="1225215412" timestamp2="1225215412">
    <data><![CDATA[&]]></data>
  </Command>
  <DocumentChange __id="197381" _type="Insert" date="Wed Jan 01 10:15:21 EST 2020" docASTNodeCount="1" docActiveCodeLength="588" docExpressionCount="0" docLength="695" length="1" offset="592" starttimestamp="1576666505112" timestamp="1225216806">
    <text><![CDATA[s]]></text>
  </DocumentChange>
  <Command __id="197382" _type="InsertStringCommand" date="Wed Jan 01 10:15:21 EST 2020" starttimestamp="1576666505112" timestamp="1225216808" timestamp2="1225216808">
    <data><![CDATA[s]]></data>
  </Command>
  <DocumentChange __id="197383" _type="Insert" date="Wed Jan 01 10:15:22 EST 2020" docASTNodeCount="1" docActiveCodeLength="589" docExpressionCount="0" docLength="696" length="1" offset="593" starttimestamp="1576666505112" timestamp="1225217165">
    <text><![CDATA[u]]></text>
  </DocumentChange>
  <Command __id="197384" _type="InsertStringCommand" date="Wed Jan 01 10:15:22 EST 2020" starttimestamp="1576666505112" timestamp="1225217166" timestamp2="1225217166">
    <data><![CDATA[u]]></data>
  </Command>
  <DocumentChange __id="197385" _type="Insert" date="Wed Jan 01 10:15:22 EST 2020" docASTNodeCount="1" docActiveCodeLength="590" docExpressionCount="0" docLength="697" length="1" offset="594" starttimestamp="1576666505112" timestamp="1225217430">
    <text><![CDATA[n]]></text>
  </DocumentChange>
  <Command __id="197386" _type="InsertStringCommand" date="Wed Jan 01 10:15:22 EST 2020" starttimestamp="1576666505112" timestamp="1225217435" timestamp2="1225217435">
    <data><![CDATA[n]]></data>
  </Command>
  <DocumentChange __id="197387" _type="Delete" date="Wed Jan 01 10:15:23 EST 2020" docASTNodeCount="1" docActiveCodeLength="589" docExpressionCount="0" docLength="696" endLine="25" length="1" offset="594" startLine="25" starttimestamp="1576666505112" timestamp="1225218239">
    <text><![CDATA[n]]></text>
  </DocumentChange>
  <Command __id="197388" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Wed Jan 01 10:15:23 EST 2020" starttimestamp="1576666505112" timestamp="1225218240" />
  <DocumentChange __id="197389" _type="Insert" date="Wed Jan 01 10:15:23 EST 2020" docASTNodeCount="1" docActiveCodeLength="590" docExpressionCount="0" docLength="697" length="1" offset="594" starttimestamp="1576666505112" timestamp="1225218564">
    <text><![CDATA[m]]></text>
  </DocumentChange>
  <Command __id="197390" _type="InsertStringCommand" date="Wed Jan 01 10:15:23 EST 2020" starttimestamp="1576666505112" timestamp="1225218567" timestamp2="1225218567">
    <data><![CDATA[m]]></data>
  </Command>
  <DocumentChange __id="197391" _type="Insert" date="Wed Jan 01 10:15:23 EST 2020" docASTNodeCount="1" docActiveCodeLength="591" docExpressionCount="0" docLength="698" length="1" offset="595" starttimestamp="1576666505112" timestamp="1225218833">
    <text><![CDATA[,]]></text>
  </DocumentChange>
  <Command __id="197392" _type="InsertStringCommand" date="Wed Jan 01 10:15:23 EST 2020" starttimestamp="1576666505112" timestamp="1225218835" timestamp2="1225218835">
    <data><![CDATA[,]]></data>
  </Command>
  <Command __id="197394" _type="InsertStringCommand" date="Wed Jan 01 10:15:24 EST 2020" starttimestamp="1576666505112" timestamp="1225219111" timestamp2="1225219111">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="197395" _type="SelectTextCommand" caretOffset="583" date="Wed Jan 01 10:15:30 EST 2020" end="583" start="575" starttimestamp="1576666505112" timestamp="1225225613" />
  <Command __id="197396" _type="CopyCommand" date="Wed Jan 01 10:15:31 EST 2020" starttimestamp="1576666505112" timestamp="1225226136" />
  <DocumentChange __id="197393" _type="Insert" date="Wed Jan 01 10:15:24 EST 2020" docASTNodeCount="1" docActiveCodeLength="592" docExpressionCount="0" docLength="699" length="1" offset="596" starttimestamp="1576666505112" timestamp="1225219109">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <Command __id="197397" _type="MoveCaretCommand" caretOffset="596" date="Wed Jan 01 10:15:33 EST 2020" docOffset="596" starttimestamp="1576666505112" timestamp="1225227908" />
  <DocumentChange __id="197398" _type="Insert" date="Wed Jan 01 10:15:37 EST 2020" docASTNodeCount="1" docActiveCodeLength="593" docExpressionCount="0" docLength="700" length="1" offset="596" starttimestamp="1576666505112" timestamp="1225232081">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <Command __id="197399" _type="InsertStringCommand" date="Wed Jan 01 10:15:37 EST 2020" starttimestamp="1576666505112" timestamp="1225232087" timestamp2="1225232087">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="197401" _type="PasteCommand" date="Wed Jan 01 10:15:37 EST 2020" starttimestamp="1576666505112" timestamp="1225232735" />
  <Command __id="197402" _type="MoveCaretCommand" caretOffset="607" date="Wed Jan 01 10:15:39 EST 2020" docOffset="607" starttimestamp="1576666505112" timestamp="1225234448" />
  <Command __id="197404" _type="InsertStringCommand" date="Wed Jan 01 10:15:40 EST 2020" starttimestamp="1576666505112" timestamp="1225235332" timestamp2="1225235332">
    <data><![CDATA[;]]></data>
  </Command>
  <DocumentChange __id="197400" _type="Insert" date="Wed Jan 01 10:15:37 EST 2020" docASTNodeCount="1" docActiveCodeLength="601" docExpressionCount="0" docLength="708" length="8" offset="597" starttimestamp="1576666505112" timestamp="1225232719">
    <text><![CDATA[array[i]]]></text>
  </DocumentChange>
  <DocumentChange __id="197403" _type="Insert" date="Wed Jan 01 10:15:40 EST 2020" docASTNodeCount="1" docActiveCodeLength="602" docExpressionCount="0" docLength="709" length="1" offset="607" starttimestamp="1576666505112" timestamp="1225235328">
    <text><![CDATA[;]]></text>
  </DocumentChange>
  <Command __id="197405" _type="MoveCaretCommand" caretOffset="237" date="Wed Jan 01 10:15:43 EST 2020" docOffset="237" starttimestamp="1576666505112" timestamp="1225238085" />
  <Command __id="197407" _type="InsertStringCommand" date="Wed Jan 01 10:15:45 EST 2020" starttimestamp="1576666505112" timestamp="1225240600" timestamp2="1225240600">
    <data><![CDATA[+]]></data>
  </Command>
  <Command __id="197408" _type="MoveCaretCommand" caretOffset="245" date="Wed Jan 01 10:15:47 EST 2020" docOffset="245" starttimestamp="1576666505112" timestamp="1225242459" />
  <Command __id="197410" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Wed Jan 01 10:15:47 EST 2020" starttimestamp="1576666505112" timestamp="1225242847" />
  <Command __id="197412" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Wed Jan 01 10:15:48 EST 2020" starttimestamp="1576666505112" timestamp="1225243020" />
  <Command __id="197414" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Wed Jan 01 10:15:48 EST 2020" starttimestamp="1576666505112" timestamp="1225243208" />
  <Command __id="197416" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Wed Jan 01 10:15:48 EST 2020" starttimestamp="1576666505112" timestamp="1225243376" />
  <Command __id="197418" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Wed Jan 01 10:15:48 EST 2020" starttimestamp="1576666505112" timestamp="1225243541" />
  <Command __id="197419" _type="MoveCaretCommand" caretOffset="588" date="Wed Jan 01 10:16:19 EST 2020" docOffset="588" starttimestamp="1576666505112" timestamp="1225274729" />
  <Command __id="197421" _type="InsertStringCommand" date="Wed Jan 01 10:16:20 EST 2020" starttimestamp="1576666505112" timestamp="1225275160" timestamp2="1225275160">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="197422" _type="MoveCaretCommand" caretOffset="609" date="Wed Jan 01 10:16:21 EST 2020" docOffset="609" starttimestamp="1576666505112" timestamp="1225276792" />
  <Command __id="197423" _type="EclipseCommand" commandID="org.eclipse.ui.file.save" date="Wed Jan 01 10:16:25 EST 2020" starttimestamp="1576666505112" timestamp="1225280229" />
  <Command __id="197439" _type="RunCommand" date="Wed Jan 01 10:16:56 EST 2020" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="1225311658" type="Run" />
  <Command __id="197440" _type="RunCommand" date="Wed Jan 01 10:16:56 EST 2020" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="1225311658" type="Run" />
  <Command __id="197441" _type="RunCommand" date="Wed Jan 01 10:16:56 EST 2020" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="1225311672" type="Debug" />
  <Command __id="197442" _type="RunCommand" date="Wed Jan 01 10:16:56 EST 2020" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="1225311673" type="Run" />
  <Command __id="197443" _type="RunCommand" date="Wed Jan 01 10:16:56 EST 2020" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="1225311673" type="Debug" />
  <Command __id="197444" _type="RunCommand" date="Wed Jan 01 10:16:56 EST 2020" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="1225311673" type="Run" />
  <Command __id="197445" _type="EHExceptionCommand" date="Wed Jan 01 10:16:56 EST 2020" starttimestamp="1576666505112" timestamp="1225311829" type="Exception">
    <outputString><![CDATA[sum_sequential
Sum: 499500
Took: 0
thread:0 lastIndex:999
_____________________________
sum_parallel_for_reduction
Sum: 499500
Took: 0
thread:0 lastIndex:124
thread:1 lastIndex:249
thread:2 lastIndex:374
thread:3 lastIndex:499
thread:4 lastIndex:624
thread:5 lastIndex:749
thread:6 lastIndex:874
thread:7 lastIndex:999
_____________________________
sum_parallel_for_local_var
Sum: 499500
Took: 0
thread:0 lastIndex:124
thread:1 lastIndex:249
thread:2 lastIndex:374
thread:3 lastIndex:499
thread:4 lastIndex:624
thread:5 lastIndex:749
thread:6 lastIndex:874
thread:7 lastIndex:999
_____________________________
sum_parallel
Sum: 499500
Took: 0
_____________________________
]]></outputString>
  </Command>
  <DocumentChange __id="197406" _type="Insert" date="Wed Jan 01 10:15:45 EST 2020" docASTNodeCount="1" docActiveCodeLength="603" docExpressionCount="0" docLength="710" length="1" offset="237" starttimestamp="1576666505112" timestamp="1225240597">
    <text><![CDATA[+]]></text>
  </DocumentChange>
  <DocumentChange __id="197409" _type="Delete" date="Wed Jan 01 10:15:47 EST 2020" docASTNodeCount="1" docActiveCodeLength="602" docExpressionCount="0" docLength="709" endLine="10" length="1" offset="244" startLine="10" starttimestamp="1576666505112" timestamp="1225242844">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="197411" _type="Delete" date="Wed Jan 01 10:15:48 EST 2020" docASTNodeCount="1" docActiveCodeLength="601" docExpressionCount="0" docLength="708" endLine="10" length="1" offset="243" startLine="10" starttimestamp="1576666505112" timestamp="1225243017">
    <text><![CDATA[+]]></text>
  </DocumentChange>
  <DocumentChange __id="197413" _type="Delete" date="Wed Jan 01 10:15:48 EST 2020" docASTNodeCount="1" docActiveCodeLength="600" docExpressionCount="0" docLength="707" endLine="10" length="1" offset="242" startLine="10" starttimestamp="1576666505112" timestamp="1225243206">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="197415" _type="Delete" date="Wed Jan 01 10:15:48 EST 2020" docASTNodeCount="1" docActiveCodeLength="599" docExpressionCount="0" docLength="706" endLine="10" length="1" offset="241" startLine="10" starttimestamp="1576666505112" timestamp="1225243370">
    <text><![CDATA[p]]></text>
  </DocumentChange>
  <DocumentChange __id="197417" _type="Delete" date="Wed Jan 01 10:15:48 EST 2020" docASTNodeCount="1" docActiveCodeLength="598" docExpressionCount="0" docLength="705" endLine="10" length="1" offset="240" startLine="10" starttimestamp="1576666505112" timestamp="1225243539">
    <text><![CDATA[*]]></text>
  </DocumentChange>
  <DocumentChange __id="197420" _type="Insert" date="Wed Jan 01 10:16:20 EST 2020" docASTNodeCount="1" docActiveCodeLength="599" docExpressionCount="0" docLength="706" length="1" offset="588" starttimestamp="1576666505112" timestamp="1225275157">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="197426" _type="Replace" date="Wed Jan 01 10:16:43 EST 2020" docASTNodeCount="1" docActiveCodeLength="597" docExpressionCount="0" docLength="704" endLine="9" insertionLength="1" int_docASTNodeCount="1" int_docActiveCodeLength="596" int_docExpressionCount="0" int_docLength="703" length="3" offset="206" startLine="9" starttimestamp="1576666505112" timestamp="1225298565">
    <deletedText><![CDATA[int]]></deletedText>
    <insertedText><![CDATA[d]]></insertedText>
  </DocumentChange>
  <DocumentChange __id="197428" _type="Insert" date="Wed Jan 01 10:16:43 EST 2020" docASTNodeCount="1" docActiveCodeLength="598" docExpressionCount="0" docLength="705" length="1" offset="207" starttimestamp="1576666505112" timestamp="1225298724">
    <text><![CDATA[o]]></text>
  </DocumentChange>
  <DocumentChange __id="197430" _type="Insert" date="Wed Jan 01 10:16:44 EST 2020" docASTNodeCount="1" docActiveCodeLength="599" docExpressionCount="0" docLength="706" length="1" offset="208" starttimestamp="1576666505112" timestamp="1225298977">
    <text><![CDATA[u]]></text>
  </DocumentChange>
  <DocumentChange __id="197432" _type="Insert" date="Wed Jan 01 10:16:44 EST 2020" docASTNodeCount="1" docActiveCodeLength="600" docExpressionCount="0" docLength="707" length="1" offset="209" starttimestamp="1576666505112" timestamp="1225299208">
    <text><![CDATA[b]]></text>
  </DocumentChange>
  <DocumentChange __id="197434" _type="Insert" date="Wed Jan 01 10:16:44 EST 2020" docASTNodeCount="1" docActiveCodeLength="601" docExpressionCount="0" docLength="708" length="1" offset="210" starttimestamp="1576666505112" timestamp="1225299501">
    <text><![CDATA[l]]></text>
  </DocumentChange>
  <DocumentChange __id="197436" _type="Insert" date="Wed Jan 01 10:16:44 EST 2020" docASTNodeCount="1" docActiveCodeLength="602" docExpressionCount="0" docLength="709" length="1" offset="211" starttimestamp="1576666505112" timestamp="1225299611">
    <text><![CDATA[e]]></text>
  </DocumentChange>
  <Command __id="197446" _type="ShellCommand" date="Wed Jan 01 10:17:07 EST 2020" starttimestamp="1576666505112" timestamp="1225322078" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="197447" _type="ShellCommand" date="Wed Jan 01 10:17:07 EST 2020" starttimestamp="1576666505112" timestamp="1225322566" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="197448" _type="MoveCaretCommand" caretOffset="585" date="Wed Jan 01 10:17:07 EST 2020" docOffset="585" starttimestamp="1576666505112" timestamp="1225322688" />
  <Command __id="197449" _type="ShellCommand" date="Wed Jan 01 10:17:08 EST 2020" starttimestamp="1576666505112" timestamp="1225323562" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="197450" _type="ShellCommand" date="Wed Jan 01 10:17:09 EST 2020" starttimestamp="1576666505112" timestamp="1225324014" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="197454" _type="RunCommand" date="Wed Jan 01 10:17:17 EST 2020" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="1225332781" type="Run" />
  <Command __id="197455" _type="RunCommand" date="Wed Jan 01 10:17:17 EST 2020" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="1225332781" type="Run" />
  <Command __id="197456" _type="RunCommand" date="Wed Jan 01 10:17:17 EST 2020" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="1225332822" type="Debug" />
  <Command __id="197457" _type="RunCommand" date="Wed Jan 01 10:17:17 EST 2020" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="1225332822" type="Run" />
  <Command __id="197458" _type="RunCommand" date="Wed Jan 01 10:17:17 EST 2020" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="1225332822" type="Debug" />
  <Command __id="197459" _type="RunCommand" date="Wed Jan 01 10:17:17 EST 2020" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="1225332822" type="Run" />
  <Command __id="197460" _type="EHExceptionCommand" date="Wed Jan 01 10:17:18 EST 2020" starttimestamp="1576666505112" timestamp="1225332975" type="Exception">
    <outputString><![CDATA[sum_sequential
Sum: 499500
Took: 0
thread:0 lastIndex:999
_____________________________
sum_parallel_for_reduction
Sum: 0
Took: 0
thread:0 lastIndex:124
thread:1 lastIndex:249
thread:2 lastIndex:374
thread:3 lastIndex:499
thread:4 lastIndex:624
thread:5 lastIndex:749
thread:6 lastIndex:874
thread:7 lastIndex:999
_____________________________
sum_parallel_for_local_var
Sum: 499500
Took: 0
thread:0 lastIndex:124
thread:1 lastIndex:249
thread:2 lastIndex:374
thread:3 lastIndex:499
thread:4 lastIndex:624
thread:5 lastIndex:749
thread:6 lastIndex:874
thread:7 lastIndex:999
_____________________________
sum_parallel
Sum: 499500
Took: 0
_____________________________
]]></outputString>
  </Command>
  <Command __id="197461" _type="MoveCaretCommand" caretOffset="584" date="Wed Jan 01 10:17:30 EST 2020" docOffset="584" starttimestamp="1576666505112" timestamp="1225345488" />
  <Command __id="197463" _type="EclipseCommand" commandID="org.eclipse.cdt.ui.edit.text.c.toggle.comment" date="Wed Jan 01 10:17:31 EST 2020" starttimestamp="1576666505112" timestamp="1225346429" />
  <Command __id="197464" _type="EclipseCommand" commandID="org.eclipse.ui.file.save" date="Wed Jan 01 10:17:32 EST 2020" starttimestamp="1576666505112" timestamp="1225346914" />
  <DocumentChange __id="217798" _type="Replace" date="Fri Jan 10 10:09:52 EST 2020" docASTNodeCount="5134" docActiveCodeLength="37681" docExpressionCount="3174" docLength="43800" endLine="1100" insertionLength="18" int_docASTNodeCount="5133" int_docActiveCodeLength="37663" int_docExpressionCount="3173" int_docLength="43782" length="18" offset="42214" startLine="1100" starttimestamp="1576666505112" timestamp="2002487592">
    <deletedText><![CDATA[anAliasassignments]]></deletedText>
    <insertedText><![CDATA[anAliasAssignments]]></insertedText>
  </DocumentChange>
  <DocumentChange __id="217799" _type="Replace" date="Fri Jan 10 10:09:52 EST 2020" docASTNodeCount="5134" docActiveCodeLength="37681" docExpressionCount="3174" docLength="43800" endLine="1099" insertionLength="18" int_docASTNodeCount="5134" int_docActiveCodeLength="37663" int_docExpressionCount="3174" int_docLength="43782" length="18" offset="42062" startLine="1099" starttimestamp="1576666505112" timestamp="2002487609">
    <deletedText><![CDATA[anAliasassignments]]></deletedText>
    <insertedText><![CDATA[anAliasAssignments]]></insertedText>
  </DocumentChange>
  <Command __id="217885" _type="DiffBasedFileOpenCommand" date="Fri Jan 10 10:11:11 EST 2020" docASTNodeCount="428" docActiveCodeLength="2628" docExpressionCount="248" docLength="3166" projectName="GraderBasics" starttimestamp="1576666505112" timestamp="2002566346">
    <filePath><![CDATA[D:\dewan_backup\Java\GraderBasics\src\gradingTools\shared\testcases\openmp\scannedTree\AnSNode.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package gradingTools.shared.testcases.openmp.scannedTree;¶¶import java.util.ArrayList;¶import java.util.HashSet;¶import java.util.List;¶import java.util.Set;¶¶import gradingTools.shared.testcases.openmp.AnAssignment;¶import gradingTools.shared.testcases.openmp.Assignment;¶import gradingTools.shared.testcases.openmp.ForHeader;¶import gradingTools.shared.testcases.openmp.OpenMPPragma;¶import gradingTools.shared.testcases.openmp.OpenMPUtils;¶import gradingTools.shared.testcases.openmp.checks.OpenMPPragmaAttribute;¶¶public class AnSNode implements SNode {¶	protected List<DeclarationSNode> variableDeclarations = new ArrayList();//separate subclass for this variable?¶//	protected List<String> localVariables = new ArrayList();//separate subclass for this variable?¶	protected List<String> localVariables = new ArrayList();//separate subclass for this variable?¶	protected int lineNumber;¶	protected List<SNode> children = new ArrayList();¶	protected List<Assignment> assignments = new ArrayList();¶	protected List<ForSNode> forNodes = new ArrayList();¶	protected List<OMPSNode> ompSNodes = new ArrayList();¶	protected Set<OpenMPPragmaAttribute> attributes = new HashSet();¶	protected SNode parent;¶	boolean inParallel = false;¶	boolean inCritical = false;¶¶	int numberOfNestingFors;¶¶	public AnSNode(int lineNumber) {¶		super();¶		this.lineNumber = lineNumber;		¶	}¶	¶	@Override¶	public int getLineNumber() {¶		return lineNumber;¶	}¶	¶	@Override¶	public List<ForSNode> getForNodes() {¶		return forNodes;¶	}¶	//	@Override¶//	public void setAnnotatedText(List<String> nextNonEmptyString) {¶//		this.annotatedText = nextNonEmptyString;¶//	}¶	¶	@Override¶	public SNode getParent() {¶		return parent;¶	}¶	@Override¶	public void setParent(SNode parent) {¶		this.parent = parent;¶		parent.getChildren().add(this);¶		inParallel = OMPSNodeUtils.hasParallelAncestor(this);		¶		inCritical = OMPSNodeUtils.hasCriticalAncestor(this);	¶		numberOfNestingFors = OMPSNodeUtils.numberOfNestingFors(parent);¶¶¶	}¶	@Override¶	public List<SNode> getChildren() {¶		return children;¶	}¶	¶	¶	@Override¶	public List<Assignment> getAssignments() {¶		return assignments;¶	}¶	// are the two method below the same? Or is a local variable something that is declared and not shared?¶	@Override¶	public List<DeclarationSNode> getVariableDeclarations() {¶		return variableDeclarations;¶	}¶	@Override¶	public List<String> getLocalVariableIdentifiers() {¶		return localVariables;¶	}¶	@Override¶	public List<OMPSNode> getOmpSNodes() {¶		return ompSNodes;¶	}¶	¶	@Override¶	public void addChild(SNode aChild) {¶		this.getChildren().add(aChild);¶//		if (aChild instanceof DeclaringAssignmentSNode) {¶//			localVariables.add(((DeclaringAssignmentSNode) aChild).getLhsVariable());¶//		}¶	}¶	@Override¶	public Set<OpenMPPragmaAttribute> getAttributes() {¶		return attributes;¶	}¶	@Override¶	public boolean isInParallel() {¶		return inParallel;¶	}¶	@Override¶	public boolean isInCritical() {¶		return inCritical;¶	}¶	@Override¶	public boolean isLeaf() {¶		return getChildren().isEmpty();¶	}¶¶}¶")]]]></diff>
  </Command>
  <Command __id="217889" _type="DiffBasedFileOpenCommand" date="Fri Jan 10 10:11:14 EST 2020" docASTNodeCount="5134" docActiveCodeLength="37681" docExpressionCount="3174" docLength="43800" projectName="GraderBasics" starttimestamp="1576666505112" timestamp="2002569070">
    <filePath><![CDATA[D:\dewan_backup\Java\GraderBasics\src\gradingTools\shared\testcases\openmp\scannedTree\OMPSNodeUtils.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package gradingTools.shared.testcases.openmp.scannedTree;¶¶import java.util.ArrayList;¶import java.util.Arrays;¶import java.util.HashMap;¶import java.util.HashSet;¶import java.util.List;¶import java.util.Map;¶import java.util.Set;¶import java.util.Stack;¶import java.util.regex.Matcher;¶import java.util.regex.Pattern;¶¶import org.apache.commons.lang.StringUtils;¶¶import grader.basics.project.source.ABasicTextManager;¶import gradingTools.shared.testcases.openmp.OpenMPKeywordEnum;¶import gradingTools.shared.testcases.openmp.OpenMPParallelPragma;¶import gradingTools.shared.testcases.openmp.OpenMPUtils;¶import gradingTools.shared.testcases.openmp.scannedTree.ADeclarationSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.ADeclaringAssignmentSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.AForSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.ATextSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.AnAssignmentSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.AnOMPCriticalSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.AnOMPForSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.AnOMPParallelSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.AnOMPSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.AnSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.AssignmentSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.DeclarationSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.DeclaringAssignmentSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.ForSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.OMPForSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.OMPSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.SNode;¶¶public class OMPSNodeUtils extends OpenMPUtils {¶¶	public static RootOfFileSNode getSNode(String aFileName, StringBuffer aFileBuffer) {¶		String[] aFileLines = aFileBuffer.toString().split("\n");¶		return getSNode(aFileName, aFileLines);¶	}¶¶	public static AssignmentSNode getAssignmentSNode(int aLineNumber, String aString) {¶		if (aString == null) {¶			return null;¶		}¶		String[] aTokens = aString.split("=");¶		if (aTokens.length == 1) {¶			return new AnAssignmentSNode(aLineNumber, aTokens[0], null);¶		} else {¶		return new AnAssignmentSNode(aLineNumber, aTokens[0], aTokens[1]);¶		}¶	}¶¶	public static DeclarationSNode getDeclarationSNode(int aLineNumber, String aString) {¶		String[] aTokens = aString.split(" ");¶		return new ADeclarationSNode(aLineNumber, aTokens[0], aTokens[1]);¶	}¶¶	public static DeclaringAssignmentSNode getDeclaringAssignmentSNode(int aLineNumber, String aString) {¶		String[] anLHSAndRHS = aString.split("=");¶		String[] aTypeAndVariable = anLHSAndRHS[0].split(" ");¶		return new ADeclaringAssignmentSNode(aLineNumber, aTypeAndVariable[0], aTypeAndVariable[1], anLHSAndRHS[1]);¶	}¶	public static ConstDeclarationSNode getConstDeclarationSNode(int aLineNumber, String aString) {¶		String anAssignmentString = aString.substring(CONST.length()).trim();¶		String[] anLHSAndRHS = anAssignmentString.split("=");¶		String[] aTypeAndVariable = anLHSAndRHS[0].split(" ");¶		return new AConstDeclarationSNode(aLineNumber, aTypeAndVariable[0], aTypeAndVariable[1], anLHSAndRHS[1]);¶	}¶¶	public static boolean isDeclaringAssignment(String aFileLine) {¶		return startsWithTypeName(aFileLine) && aFileLine.contains("=");¶	}¶	public static boolean isConstDeclaration(String aFileLine) {¶		return aFileLine.startsWith(CONST);¶	}¶	public static boolean isMethodDeclaration(String aFileLine) {¶		return startsWithTypeName(aFileLine) && ¶				aFileLine.contains("(") &&¶				!aFileLine.contains("=");¶	}¶	public static boolean isExternalMethodDeclaration(String aFileLine) {¶		return isMethodDeclaration(aFileLine) && aFileLine.endsWith(";");¶	}¶¶¶	public static boolean isVariableDeclaration(String aFileLine) {¶¶		return startsWithTypeName(aFileLine) && !aFileLine.contains("(");¶	}¶¶	public static boolean isAssignment(String aFileLine) {¶		return aFileLine.contains("=") && !aFileLine.contains("==");¶	}¶¶	public static boolean isForNode(String aFileLine) {¶		return aFileLine.startsWith("for");¶	}¶¶	public static ForSNode getForSNode(int aLineNumber, String aFileLine) {¶¶		int aLeftParenIndex = aFileLine.indexOf("(");¶		int aRightParenIndex = aFileLine.indexOf(")");¶		if (aLeftParenIndex < 0 || aRightParenIndex < 0) {¶			return null;¶		}¶		String aHeaderString = aFileLine.substring(aLeftParenIndex + 1, aRightParenIndex);¶		String[] aForComponents = aHeaderString.split(";");¶		AssignmentSNode anAssignmentSNode = null;¶		String aForInitializaton = aForComponents[0];¶		if (!aForInitializaton.isEmpty() && aForInitializaton.contains("=")) {¶			if (isDeclaringAssignment(aForInitializaton)) {¶				anAssignmentSNode = getDeclaringAssignmentSNode(aLineNumber, aForInitializaton);¶			} else {¶				anAssignmentSNode = getAssignmentSNode(aLineNumber, aForInitializaton);¶			}¶¶		}		¶		return new AForSNode(aLineNumber, anAssignmentSNode, aForComponents[1], getAssignmentSNode(aLineNumber, aForComponents[2]));¶	}¶	static String[] emptyArray = {};¶	public static MethodSNode getMethodSNode(int aLineNumber, String aFileLine, boolean isInternal) {¶¶		int aLeftParenIndex = aFileLine.indexOf("(");¶		int aRightParenIndex = aFileLine.indexOf(")");¶		if (aLeftParenIndex < 0 || aRightParenIndex < 0) {¶			return null;¶		}¶		String aMethodNameAndType = aFileLine.substring(0, aLeftParenIndex);¶		String[] aMethodNameAndTypeTokens = aMethodNameAndType.split("\\s+"); ¶		¶		String aMethodParameters = aFileLine.substring(aLeftParenIndex +1 , aRightParenIndex);¶		String[] aMethodParameterTokens = aMethodParameters.isEmpty()?emptyArray:¶		 aMethodParameters.split(",");¶		¶//		String[] aMethodParameterTypes = new String[aMethodParameterTokens.length];¶//		String[] aMethodParameterNames = new String[aMethodParameterTokens.length];¶		List<DeclarationSNode> aDeclarationSNodeList = new ArrayList();¶		for (int i = 0; i < aMethodParameterTokens.length; i++ ) {¶			String[] aTypeAndName = aMethodParameterTokens[i].trim().split("\\s+");¶			if (aTypeAndName.length < 2) {¶				continue;¶			}¶			aDeclarationSNodeList.add(new ADeclarationSNode(aLineNumber, aTypeAndName[0].trim(), aTypeAndName[1].trim()));¶//			aMethodParameterTypes[i] = aTypeAndName[0].trim();¶//			aMethodParameterNames[i] = aTypeAndName[1].trim();¶		}¶		if (isInternal)¶//		return new AMethodSNode(aLineNumber, aMethodNameAndTypeTokens[0], aMethodNameAndTypeTokens[1], aMethodParameterTypes,aMethodParameterNames );¶			return new AMethodSNode(aLineNumber, aMethodNameAndTypeTokens[0], aMethodNameAndTypeTokens[1], aDeclarationSNodeList );¶		else¶			return new AnExternalMethodSNode(aLineNumber, aMethodNameAndTypeTokens[0], aMethodNameAndTypeTokens[1], aDeclarationSNodeList );¶	}¶¶	public static void setReductionData(OMPForSNode lastChild, String aStoredToken, int aLeftParenIndex,¶			int aRightParenIndex) {¶		int aColonIndex = aStoredToken.indexOf(":");¶		if (aLeftParenIndex != -1 && aRightParenIndex != -1 && aColonIndex != -1) {¶			String anOperationString = aStoredToken.substring(aLeftParenIndex + 1, aColonIndex).trim();¶			String aVariableString = aStoredToken.substring(aColonIndex + 1, aRightParenIndex).trim();¶			((OMPForSNode) lastChild).setReductionVariable(aVariableString);¶			((OMPForSNode) lastChild).setReductionOperation(anOperationString);¶		}¶	}¶¶	public static void setSharedOrPrivateData(OMPSNode lastChild, String aStoredToken, int aLeftParenIndex,¶			int aRightParenIndex, boolean isShared) {¶//		int aColonIndex = aStoredToken.indexOf(":");¶		if (aLeftParenIndex != -1 && aRightParenIndex != -1) {¶			String aVariableDeclarations = aStoredToken.substring(aLeftParenIndex + 1, aRightParenIndex);¶			String[] aVariables = aVariableDeclarations.split(",");¶			if (isShared) {¶				lastChild.setSharedVariables(aVariables);¶			} else {¶				lastChild.setPrivateVariables(aVariables);¶			}¶		}¶	}¶¶	public static RootOfFileSNode getSNode(String aFileName, String[] aFileLines) {¶		Stack<SNode> anSNodes = new Stack();¶¶		RootOfFileSNode retVal = new ARootOfFileSNode(aFileName);¶		anSNodes.add(retVal);¶		SNode previousHeaderNode = null;¶		for (int i = 0; i < aFileLines.length; i++) {¶			String aFileLine = aFileLines[i].trim();¶			if (!isCodeLine(aFileLine)) {¶				continue;¶			}¶			if (isForNode(aFileLine)) {¶				ForSNode aForSNode = getForSNode(i, aFileLine);¶				SNode aParent = previousHeaderNode != null?previousHeaderNode:anSNodes.peek();¶				aForSNode.setParent(anSNodes.peek());¶				aForSNode.setParent(aParent);¶¶//				anSNodes.push(aForSNode);¶				previousHeaderNode = aForSNode;¶				if (aFileLine.endsWith(")")) {¶					continue;¶				}¶			}¶			if (isExternalMethodDeclaration(aFileLine)) {¶				MethodSNode aMethodSNode = getMethodSNode(i, aFileLine, false);¶				aMethodSNode.setParent(anSNodes.peek());¶//				anSNodes.push(aForSNode);¶				previousHeaderNode = aMethodSNode;¶				if (aFileLine.endsWith(")")) {¶					continue;¶				}¶			}¶			if (isMethodDeclaration(aFileLine)) {¶				MethodSNode aMethodSNode = getMethodSNode(i, aFileLine, true);¶				aMethodSNode.setParent(anSNodes.peek());¶//				anSNodes.push(aForSNode);¶				previousHeaderNode = aMethodSNode;¶				if (aFileLine.endsWith(")")) {¶					continue;¶				}¶			}¶			if (isPragmaStart(aFileLine)) {¶				OMPSNode anOMPSNode = getOMPSNode(i, anSNodes.peek(), aFileLine);¶//				anSNodes.push(anOMPSNode);¶				previousHeaderNode = anOMPSNode;¶				continue;¶			}¶			if (isBlockStart(aFileLine)) {¶				SNode aBlockSNode = new ABlockSNode(i);¶				if (previousHeaderNode != null) {¶					aBlockSNode.setParent(previousHeaderNode);¶				} else {¶					aBlockSNode.setParent(anSNodes.peek());¶				}¶				anSNodes.push(aBlockSNode);¶				previousHeaderNode = null;¶				continue;¶			}¶//			} else ¶			if (isBlockEnd(aFileLine)) {¶				anSNodes.pop();¶				continue;¶			}¶			SNode aNewLeafNode = null;¶			if (isConstDeclaration(aFileLine)) {¶				aNewLeafNode = getConstDeclarationSNode(i, aFileLine);¶¶			} else if (isDeclaringAssignment(aFileLine)) {¶				aNewLeafNode = getDeclaringAssignmentSNode(i, aFileLine);¶¶			} else if (isAssignment(aFileLine)) {¶				aNewLeafNode = getAssignmentSNode(i, aFileLine);¶			} else if (isVariableDeclaration(aFileLine)) {¶				aNewLeafNode = getDeclarationSNode(i, aFileLine);¶			} else {¶				List<MethodCall> aCalls = callsIn(i, aFileLine, null); // parent will be assigned below¶				if (aCalls != null && aCalls.size() == 1) {¶					aNewLeafNode = aCalls.get(0);¶				} else {¶					aNewLeafNode = new ATextSNode(i, aFileLine);¶				}¶			}¶//			else {¶//				aNewLeafNode = new ATextSNode(i, aFileLine);¶//			}¶			if (previousHeaderNode != null) {¶				aNewLeafNode.setParent(previousHeaderNode);¶			} else {¶				aNewLeafNode.setParent(anSNodes.peek());¶			}¶¶		}¶¶		return retVal;¶	}¶¶	public static OMPSNode getOMPSNode(int aLineIndex, SNode aParentNode, String aFileLine) {¶		String[] aTokens = aFileLine.split("\\s+");¶		if (aTokens.length <= 2) {¶			return null;¶		}¶		if (!aTokens[1].equals("omp")) {¶			return null;¶		}¶		if (aTokens.length < 3) {¶			return null;¶		}¶		String aFirstToken = aTokens[2];¶		OpenMPKeywordEnum anOpenMPKeyword = stringToOpenMPKeyword.get(aFirstToken);¶//		List<OpenMPPragma> retVal = new ArrayList();¶		OMPSNode lastChild = null;¶		int aStartIndex = 2;¶		OMPSNode aNewNode = null;¶		OMPForSNode aForChild = null;¶		switch (anOpenMPKeyword) {¶		case PARALLEL:¶			aNewNode = new AnOMPParallelSNode(aLineIndex);¶¶			if (aTokens.length > 3 && aTokens[3].equals("for")) {¶				aForChild = new AnOMPForSNode(aLineIndex);¶				aForChild.setParent(aNewNode);¶¶				aStartIndex++;¶			}¶			break;¶		case FOR:¶			aNewNode = new AnOMPForSNode(aLineIndex);¶			;¶			break;¶		case CRITICAL:¶			aNewNode = new AnOMPCriticalSNode(aLineIndex);¶//			retVal.add (lastChild);¶			break;¶		default:¶			aNewNode = new AnOMPSNode(aLineIndex);¶¶		}¶¶		if (lastChild != null) {¶			aNewNode.setParent(lastChild);¶		} else {¶			aNewNode.setParent(aParentNode);¶		}¶		lastChild = aForChild == null ? aNewNode : aForChild;¶¶		for (int i = aStartIndex; i < aTokens.length; i++) {¶			String aStoredToken = aTokens[i].trim();¶			if (aStoredToken.isEmpty()) {¶				continue;¶			}¶			if (aStoredToken.startsWith("reduction") || aStoredToken.startsWith("shared")¶					|| aStoredToken.startsWith("private")) {¶				// combine all tokens until ")" into one for normalization¶				while (!aStoredToken.endsWith(")")) {¶					i++;¶					if (i >= aTokens.length) {¶						break;¶					}¶					String aNewToken = aTokens[i].trim();¶					aStoredToken += aNewToken;¶				}¶				int aLeftParenIndex = aStoredToken.indexOf("(");¶				int aRightParenIndex = aStoredToken.indexOf(")");¶				if (aStoredToken.startsWith("reduction")) {¶					setReductionData((OMPForSNode) lastChild, aStoredToken, aLeftParenIndex, aRightParenIndex);¶				} else if (aStoredToken.startsWith("private")) {¶					setSharedOrPrivateData((OMPSNode) lastChild, aStoredToken, aLeftParenIndex, aRightParenIndex,¶							false);¶¶				} else if (aStoredToken.startsWith("shared")) {¶					setSharedOrPrivateData(lastChild, aStoredToken, aLeftParenIndex, aRightParenIndex, true);¶¶				}¶¶			}¶¶			lastChild.getOpenMPTokens().add(aStoredToken);¶		}¶¶		return lastChild;¶¶	}¶¶	public static boolean hasParallelAncestor(SNode anSNode) {¶		if (anSNode == null) {¶			return false;¶		}¶		if (anSNode instanceof OMPParallelSNode) {¶			return true;¶		}¶		return hasParallelAncestor(anSNode.getParent());¶	}¶	public static boolean hasCriticalAncestor(SNode anSNode) {¶		if (anSNode == null) {¶			return false;¶		}¶		if (anSNode instanceof OMPCriticalSNode) {¶			return true;¶		}¶		return hasCriticalAncestor(anSNode.getParent());¶	}¶¶¶	public static Boolean isDeclaredShared(OMPSNode anOMPSNode, String anLHS) {¶		if (Arrays.asList(anOMPSNode.getSharedVariables()).contains(anLHS)) {¶			return true;¶		}¶		if (Arrays.asList(anOMPSNode.getPrivateVariables()).contains(anLHS)) {¶			return false;¶		}¶		return null;¶¶	}¶¶	public static boolean isSharedVariable(SNode anSNode, String anLHS) {¶		if (anSNode == null) {¶			return false;¶		}¶		if (anSNode.getLocalVariableIdentifiers().contains(anLHS)) {¶			if (!(anSNode instanceof OMPSNode)) { // no shared and private declarations¶				return !hasParallelAncestor(anSNode); // shared if not inParallel¶			}¶			OMPSNode anOMPSNode = (OMPSNode) anSNode;¶			return (Arrays.asList(anOMPSNode.getSharedVariables()).contains(anLHS)); // private unless declared shared¶		}¶		if (anSNode instanceof OMPSNode) {¶			OMPSNode anOMPSNode = (OMPSNode) anSNode;¶			// the variable is global to this scope, check if it has have been made shared¶			// or private by this scope¶			Boolean isDeclaredShared = isDeclaredShared(anOMPSNode, anLHS);¶			if (isDeclaredShared != null) {¶				return isDeclaredShared;¶			}¶		}¶		// check the parent¶		return isSharedVariable(anSNode.getParent(), anLHS);¶	}¶¶	public static List<SNode> getAllLeafNodes(SNode aTopNode) {¶		List<SNode> retVal = new ArrayList();¶		addLeafNodes(aTopNode, retVal);¶		return retVal;¶	}¶¶	public static void addLeafNodes(SNode aTopNode, List<SNode> retVal) {¶		for (SNode aChild : aTopNode.getChildren()) {¶			if (aChild.isLeaf()) {¶				retVal.add(aChild);¶			} else {¶				addLeafNodes(aChild, retVal);¶			}¶		}¶	}¶¶	public static List<SNode> getNonParallelLeafNodes(SNode aTopNode) {¶		List<SNode> retVal = new ArrayList();¶		addNonParallelLeafNodes(aTopNode, retVal);¶		return retVal;¶	}¶¶	public static void addNonParallelLeafNodes(SNode aTopNode, List<SNode> retVal) {¶		if (aTopNode.isInParallel()) {¶			return;¶		}¶		for (SNode aChild : aTopNode.getChildren()) {¶			if (aChild.isLeaf()) {¶				retVal.add(aChild);¶			} else {¶				addLeafNodes(aChild, retVal);¶			}¶		}¶	}¶	static String callRegex = "([a-zA-Z_$][a-zA-Z_$0-9]*)\\(.*?\\)";¶	static Pattern callPattern = Pattern.compile(callRegex);¶¶	static String identifierRegex = "[a-zA-Z_$][a-zA-Z_$0-9]*";¶	static Pattern identifierPattern = Pattern.compile(identifierRegex);¶	public static List<String> identifiersIn(String aString) {¶		if (aString == null)¶			return null;¶//		Pattern mypattern = Pattern.compile("[a-zA-Z_$][a-zA-Z_$0-9]*");¶//		Matcher mymatcher = mypattern.matcher(aString);¶		Matcher mymatcher = identifierPattern.matcher(aString);¶		List<String> retVal = new ArrayList();¶		while (mymatcher.find()) {¶			String find = mymatcher.group(0);¶			retVal.add(find);¶		}¶		return retVal;¶	}¶	public static List<MethodCall> callsIn(int aLineNumber, String aString, SNode aParent) {¶		if (aString == null)¶			return emptyList;¶		if (isMethodDeclaration(aString)) {¶			return emptyList;¶		}¶//		Pattern mypattern = Pattern.compile("[a-zA-Z_$][a-zA-Z_$0-9]*");¶//		Matcher mymatcher = mypattern.matcher(aString);¶		Matcher mymatcher = callPattern.matcher(aString);¶		List<MethodCall> retVal = new ArrayList();¶		while (mymatcher.find()) {¶			String find = mymatcher.group(0);¶			int aLeftParenIndex = find.indexOf("(");¶			int aRightParenIndex = find.indexOf(")");¶			String aMethodName = find.substring(0, aLeftParenIndex).trim();¶			String aParameters = find.substring(aLeftParenIndex + 1, aRightParenIndex);¶			List<String> aParameterList = new ArrayList();¶			String[] aParameterTokens = aParameters.split(",");¶			for (String aParameter:aParameterTokens) {¶				String aParameterTrimmed = aParameter.trim();¶				if (!aParameterTrimmed.isEmpty())¶				aParameterList.add(aParameterTrimmed);¶			}¶			retVal.add(new AMethodCall(aLineNumber, aMethodName, aParameterList, aParent));¶¶//			aCallStrings.add(find);¶		}¶		return retVal;¶	}¶	static String numberRegex = "(\\d+\\.\\d+)|(\\d+)";¶	static Pattern numberPattern = Pattern.compile(numberRegex);¶	public static List<String> numbersIn(String aString) {¶		if (aString == null)¶			return null;¶//		String regex = "(\\d+\\.\\d+)|(\\d+)";¶//¶//		Matcher m = Pattern.compile(regex).matcher(aString);¶		Matcher m =numberPattern.matcher(aString);¶¶¶		List<String> retVal = new ArrayList();¶¶		while (m.find()) {¶			retVal.add(m.group());¶		}¶		return retVal;¶	}¶¶	public static String subscriptIn(String aString) {¶		if (aString == null)¶			return null;¶		return StringUtils.substringBetween(aString, "[", "]");¶	}¶	static String[] emptyStringArray = {};¶	static List emptyList = new ArrayList();¶¶	public static String[] subscriptsIn(String aString) {¶		if (aString == null)¶			return emptyStringArray;¶		return StringUtils.substringsBetween(aString, "[", "]");¶	}¶	static  String operatorRegex = "([+-/*///^])|([/(/)])";¶	static Pattern operatorPattern = Pattern.compile(operatorRegex);¶¶	public static List<String> operatorsIn(String aString) {¶		if (aString == null)¶			return null;¶//		String operatorRegex = "([+-/*///^])|([/(/)])";¶//¶//		Matcher m = Pattern.compile(operatorRegex).matcher(aString);¶		¶		Matcher m = operatorPattern.matcher(aString);¶¶¶		List<String> retVal = new ArrayList();¶¶		while (m.find()) {¶			retVal.add(m.group());¶		}¶		return retVal;¶	}¶	¶	public static int numberOfNestingFors (SNode anSNode) {¶		if (anSNode == null) {¶			return 0;¶		}¶		int retVal = numberOfNestingFors (anSNode.getParent()) ;¶¶		if (anSNode instanceof ForSNode) {¶			retVal++;¶		} else if (anSNode instanceof MethodSNode) {¶			List<MethodCall> aMethodCalls = ((MethodSNode) anSNode).getCalls();¶			int aMaxNestingLevel = 0;¶			for (MethodCall aMethodCall:aMethodCalls) {¶				MethodSNode aCallerMethodSNode = getDeclarationOfCalledMethod(anSNode, aMethodCall);¶				int aCallerNumberOfNestingFors = numberOfNestingFors(aCallerMethodSNode);¶				aMaxNestingLevel = Math.max(aCallerNumberOfNestingFors, aMaxNestingLevel);				¶			}¶			return retVal + aMaxNestingLevel;¶		}¶		return retVal;¶	}¶	public static boolean hasOperator (SNode anSNode, String anOperator) {¶		boolean retVal = false;¶		if (anSNode instanceof AssignmentSNode) {¶			AssignmentSNode anAssignmentSNode = (AssignmentSNode) anSNode;¶			 retVal = (anAssignmentSNode.getLhsOperators().contains(anOperator) || ¶					anAssignmentSNode.getRhsOperators().contains(anOperator)) ;¶			if (retVal) {¶				return retVal;¶			} else {¶				List<MethodCall> aMethodCalls = anAssignmentSNode.getRhsCalls();¶				for (MethodCall aMethodCall:aMethodCalls) {¶					MethodSNode aMethodSNode = getDeclarationOfCalledMethod(anSNode, aMethodCall);¶					retVal = hasOperator(aMethodSNode, anOperator);¶					if (retVal) {¶						return retVal;¶					}¶					¶				}¶				return false;¶			}¶			¶		}¶		for (SNode aChild:anSNode.getChildren()) {¶			retVal = hasOperator(aChild, anOperator);¶			if (retVal) {¶				return retVal;¶			}¶		}¶		return false;¶	}¶	public static boolean hasMethodCall (SNode anSNode, String anOperator) {¶		boolean retVal = false;¶		if (anSNode instanceof AssignmentSNode) {¶			AssignmentSNode anAssignmentSNode = (AssignmentSNode) anSNode;¶			 retVal = (anAssignmentSNode.getLhsOperators().contains(anOperator) || ¶					anAssignmentSNode.getRhsOperators().contains(anOperator)) ;¶			if (retVal) {¶				return retVal;¶			} else {¶				List<MethodCall> aMethodCalls = anAssignmentSNode.getRhsCalls();¶				for (MethodCall aMethodCall:aMethodCalls) {¶					MethodSNode aMethodSNode = getDeclarationOfCalledMethod(anSNode, aMethodCall);¶					retVal = hasOperator(aMethodSNode, anOperator);¶					if (retVal) {¶						return retVal;¶					}¶					¶				}¶				return false;¶			}¶			¶		}¶		for (SNode aChild:anSNode.getChildren()) {¶			retVal = hasOperator(aChild, anOperator);¶			if (retVal) {¶				return retVal;¶			}¶		}¶		return false;¶	}¶	public static boolean dependsOn (AssignmentSNode anAssignmentSNode, String aVariable, String aCallIdentifier) {¶		// This assignment does not change aVariable¶		if (!aVariable.equals(anAssignmentSNode.getLhsFirstIdentifier())) {¶			return false;¶		}¶		return dependsOn(anAssignmentSNode.getExpressionSNode(), aCallIdentifier);¶//		List<String> aCallIdentifiers = anAssignmentSNode.getRhsCallIdentifiers();¶//		boolean retVal = false;¶//		if (aCallIdentifiers != null && aCallIdentifiers.contains(aCallIdentifier)) {¶//			return true; // this assignment has aCallIdentifier in the rhs¶//		}¶//		// check if some referenced rhs variable depends on aCallIdentifier¶//		List<String> aReferencedVariableIdentifiers = anAssignmentSNode.getRhsVariableIdentifiers();¶//		SNode anAssignmentParent = anAssignmentSNode.getParent();¶//		if (anAssignmentParent == null) { // should never be trye¶//			return false;¶//		}¶//		int aLineNumber = anAssignmentSNode.getLineNumber();¶//		for (String aReferencedVariableIdentifier:aReferencedVariableIdentifiers ) {¶//			if (dependsOn (anAssignmentParent, aLineNumber, aReferencedVariableIdentifier, aCallIdentifier)) {¶//				return true;¶//			}¶//		}¶//		return false;¶	}¶	public static boolean dependsOn (ExpressionSNode anExpressionSNode, String aCallIdentifier) {¶		// This assignment does not change aVariable¶		¶		List<String> aCallIdentifiers = anExpressionSNode.getRhsCallIdentifiers();¶		boolean retVal = false;¶		if (aCallIdentifiers != null && aCallIdentifiers.contains(aCallIdentifier)) {¶			return true; // this assignment has aCallIdentifier in the rhs¶		}¶		// check if some referenced rhs variable depends on aCallIdentifier¶		List<String> aReferencedVariableIdentifiers = anExpressionSNode.getRhsVariableIdentifiers();¶		SNode anAssignmentParent = anExpressionSNode.getParent().getParent();¶		if (anAssignmentParent == null) { // should never be trye¶			return false;¶		}¶		int aLineNumber = anExpressionSNode.getLineNumber();¶		for (String aReferencedVariableIdentifier:aReferencedVariableIdentifiers ) {¶			if (dependsOn (anAssignmentParent, aLineNumber, aReferencedVariableIdentifier, aCallIdentifier)) {¶				return true;¶			}¶		}¶		return false;¶	}¶	public static Set<AssignmentSNode> assignmentsToSharedVariables(SNode anSNode) {¶		Set<AssignmentSNode> retVal =  new HashSet();¶		fillAssignmentsToShared(anSNode, retVal);¶		return retVal;¶		¶	}¶	public static Set<AssignmentSNode> assignmentsToSharedArrays(SNode anSNode) {¶		Set<AssignmentSNode> anAllSharedAssignments =  assignmentsToSharedVariables(anSNode);¶		Set<AssignmentSNode> aRetVal = new HashSet();¶		for (AssignmentSNode anAssignmentSNode:anAllSharedAssignments) {¶			if (anAssignmentSNode.getLhsSubscripts().length > 0) {¶				aRetVal.add(anAssignmentSNode);¶			}¶		}¶		return aRetVal;¶		¶	}¶	public static Set<AssignmentSNode> assignmentsToParallelCriticalSharedVariables(SNode anSNode) {¶		Set<AssignmentSNode> anAllSharedAssignments =  assignmentsToSharedVariables(anSNode);¶		Set<AssignmentSNode> aRetVal = new HashSet();¶		for (AssignmentSNode anAssignmentSNode:anAllSharedAssignments) {¶			if (anAssignmentSNode.isInParallel() &&¶					anAssignmentSNode.isInCritical()) {¶				aRetVal.add(anAssignmentSNode);¶			}¶		}¶		return aRetVal;¶		¶	}¶	public static Set<AssignmentSNode> assignmentsToNonParallelCriticalSharedVariables(SNode anSNode) {¶		Set<AssignmentSNode> anAllSharedAssignments =  assignmentsToSharedVariables(anSNode);¶		Set<AssignmentSNode> aRetVal = new HashSet();¶		for (AssignmentSNode anAssignmentSNode:anAllSharedAssignments) {¶			if (!anAssignmentSNode.isInParallel() &&¶					anAssignmentSNode.isInCritical()) {¶				aRetVal.add(anAssignmentSNode);¶			}¶		}¶		return aRetVal;¶		¶	}¶	public static Set<AssignmentSNode> assignmentsToParallelNonCriticalSharedVariables(SNode anSNode) {¶		Set<AssignmentSNode> anAllSharedAssignments =  assignmentsToSharedVariables(anSNode);¶		Set<AssignmentSNode> aRetVal = new HashSet();¶		for (AssignmentSNode anAssignmentSNode:anAllSharedAssignments) {¶			if (anAssignmentSNode.isInParallel() &&¶					!anAssignmentSNode.isInCritical()) {¶				aRetVal.add(anAssignmentSNode);¶			}¶		}¶		return aRetVal;¶		¶	}¶    public static void fillAssignmentsToShared(SNode anSNode, Set<AssignmentSNode> retVal) {¶    	if (anSNode instanceof AssignmentSNode) {¶			AssignmentSNode anAssignmentSNode = (AssignmentSNode) anSNode;¶			String anLHS = anAssignmentSNode.getLhsFirstIdentifier();¶			if (isSharedVariable(anSNode, anLHS)) {¶				retVal.add(anAssignmentSNode);¶				return;¶			}¶		}¶    	for (SNode aChild:anSNode.getChildren()) {¶    		fillAssignmentsToShared(aChild, retVal);¶    	}¶		¶	}¶    public static void fillInstancesOfNodeType(Class<? extends SNode> aNodeType, SNode anSNode, Set<SNode> retVal) {¶    	if (aNodeType.isAssignableFrom(anSNode.getClass())) {¶			¶				retVal.add(anSNode);¶				return;¶			}¶		¶    	for (SNode aChild:anSNode.getChildren()) {¶    		fillInstancesOfNodeType(aNodeType, aChild, retVal);¶    	}¶		¶	}¶    public static Set<AssignmentSNode>  assignmentSNodes(SNode anSNode) {¶    	Set retVal = new HashSet();    	¶    	fillInstancesOfNodeType(AssignmentSNode.class, anSNode, retVal );¶    	return retVal;¶	}¶   ¶    ¶    public static Set<OMPParallelSNode>  ompParallelSNodes(SNode anSNode) {¶    	Set retVal = new HashSet();    	¶    	fillInstancesOfNodeType(OMPParallelSNode.class, anSNode, retVal );¶    	return retVal;¶	}¶//    public static void fillOMPParallelSNodes(SNode anSNode, Set<OMPParallelSNode> retVal) {¶//    	if (anSNode instanceof OMPParallelSNode) {¶//    		retVal.add((OMPParallelSNode) anSNode);¶//		}¶//    	for (SNode aChild:anSNode.getChildren()) {¶//    		fillOMPParallelSNodes(aChild, retVal);¶//    	}		¶//	}¶    public static Set<ForSNode>  forSNodes(SNode anSNode) {¶    	Set retVal = new HashSet();    	¶    	fillInstancesOfNodeType(ForSNode.class, anSNode, retVal );¶    	return retVal;¶	}¶//    public static void fillForSNodes(SNode anSNode, Set<ForSNode> retVal) {¶//    	if (anSNode instanceof ForSNode) {¶//    		retVal.add((ForSNode) anSNode);¶//		}¶//    	for (SNode aChild:anSNode.getChildren()) {¶//    		fillForSNodes(aChild, retVal);¶//    	}		¶//	}¶    public static Set<OMPForSNode>  ompForSNodes(SNode anSNode) {¶    	Set retVal = new HashSet();    	¶    	fillInstancesOfNodeType(OMPForSNode.class, anSNode, retVal );¶    	return retVal;¶	}¶//    public static void fillOMPForSNodes(SNode anSNode, Set<OMPForSNode> retVal) {¶//    	if (anSNode instanceof OMPForSNode) {¶//    		retVal.add((OMPForSNode) anSNode);¶//		}¶//    	for (SNode aChild:anSNode.getChildren()) {¶//    		fillOMPForSNodes(aChild, retVal);¶//    	}		¶//	}¶    public static Set<OMPForSNode> ompReducingForNodes(SNode anSNode) {¶		Set<OMPForSNode> anAllOMPForSNodes =  ompForSNodes(anSNode);¶		Set<OMPForSNode> aRetVal = new HashSet();¶		for (OMPForSNode anOMPForSNode:anAllOMPForSNodes) {¶			if (anOMPForSNode.getReductionOperation() != null) {¶				aRetVal.add(anOMPForSNode);¶			}¶		}¶		return aRetVal;		¶	}¶    public static Set<AssignmentSNode> assignmentsToOMPReducingForNode(OMPForSNode anOMPForSNode) {¶    	String aReductionVariable = anOMPForSNode.getReductionVariable();¶    	return directAssignmentsOfVariableAndItsAliases(anOMPForSNode, aReductionVariable)	;¶    	¶    }¶	public static boolean dependsOn (SNode anSNode, int aVariableLineNumber, String aVariable, String aCallIdentifier) {¶		List<SNode> aListSNodes = anSNode.getChildren();¶		boolean retVal = false;¶		/*¶		 * Should probably ignore line number as it assumes straight line code¶		 */¶		for (int i = aVariableLineNumber; i >= 0; i--) {¶			SNode anSNodeChild = aListSNodes.get(i);¶			if (anSNodeChild instanceof AssignmentSNode) {¶				// does this statement in anSNode directly invoke aCallIdentifier ¶				if (dependsOn((AssignmentSNode) anSNodeChild, aVariable, aCallIdentifier))¶					return true;¶			} else if (!anSNode.isLeaf()) {¶					// child is overriding the variable so forget checking its assignment statements¶					if (anSNodeChild.getLocalVariableIdentifiers().contains(aVariable)) {¶						continue;¶					}¶					// some subblock of anSNode that has access to aVariable changes variable¶¶					if (dependsOn(anSNodeChild, anSNodeChild.getChildren().size() - 1, aVariable, aCallIdentifier)) {¶						return true;¶					}¶			}¶			¶		}¶		// none of the statements in anSNode or its descendents  have the required call¶		// is the variable a  method parameter ¶		if (anSNode instanceof MethodSNode) {¶			MethodSNode aMethodSNode = (MethodSNode) anSNode;¶			¶			int aParameterNumber = aMethodSNode.getLocalVariableIdentifiers().indexOf(aVariable);¶			if (aParameterNumber != -1) {¶				List <MethodCall> aCalls = aMethodSNode.getCalls();¶				for (MethodCall aCall:aCalls) {¶//					if (!aCall.getMethodActuals().contains(aVariable))¶//						continue;¶//					¶					MethodSNode aCallerSNode = getDeclarationOfCalledMethod(aMethodSNode, aCall);¶					if (dependsOn(aMethodSNode, aCallerSNode.getLineNumber(), aCallerSNode.getLocalVariableIdentifiers().get(aParameterNumber), aCallIdentifier));¶//				    if (aCallerDepends) {¶				    	return true;¶//				    }¶				}¶				return false;¶				// need to find all callers of method and see if any of the aliases for the variable in these¶				// calls depend on aCallIndentifier¶			}			¶			¶		} else if (anSNode.getLocalVariableIdentifiers().contains(aVariable)) {¶			// before going to the parent node, let us see if aVariable is declared here as a non  parameter ¶¶			return false; // no point going to parent¶		}¶		// not a local variable (parameter or declarated variable)¶		SNode anSNodeParent = anSNode.getParent() ;¶		if (anSNodeParent == null)  {¶			return false;¶		}¶		int anSNodeLineNumber = anSNodeParent.getChildren().indexOf(anSNode);¶		return dependsOn(anSNodeParent, anSNodeLineNumber, aVariable, aCallIdentifier);¶		¶	}¶	"), Diff(INSERT,"public static Set<AssignmentSNode> assignmentsOfVariableAliases (SNode anSNode,  String aVariable) {¶		Set<AssignmentSNode> retVal = new HashSet();¶		fillDirectAssignmentsOfVariableAndItsAliases(anSNode, aVariable, retVal);¶		return retVal;¶	}¶	public static void fillDirectAssignmentsOfVariableAliases (SNode anSNode,  String aVariable, Set<AssignmentSNode> retVal) {¶		if (anSNode instanceof MethodCall) {¶			MethodCall aMethodCall = (MethodCall) anSNode;¶			int aParameterNumber = aMethodCall.getMethodActualIdentifiers().indexOf(aVariable);¶			if (aParameterNumber < 0) {¶				return;¶			}¶			MethodSNode aDeclaringMethodSNode = getDeclarationOfCalledMethod(anSNode, aMethodCall);¶			String aFormalParameter = aDeclaringMethodSNode.getLocalVariableIdentifiers().get(aParameterNumber);¶//			Set<AssignmentSNode> aCallAssignments = ;¶			fillDirectAssignmentsOfVariableAliases(aDeclaringMethodSNode, aFormalParameter, retVal);¶		} else {¶			List<SNode> aChildren = anSNode.getChildren();¶			for (SNode aChild:aChildren) {¶				fillDirectAssignmentsOfVariableAliases(aChild, aVariable, retVal);¶			}¶		}		¶		¶	}¶	"), Diff(EQUAL,"¶	/*¶	 * will not consider assignments to variables in the RHS of these assignments¶	 */¶	public static Set<AssignmentSNode> directAssignmentsOfVariableAndItsAliases (SNode anSNode,  String aVariable) {¶		Set<AssignmentSNode> retVal = new HashSet();¶		fillDirectAssignmentsOfVariableAndItsAliases(anSNode, aVariable, retVal);¶		return retVal;¶	}¶"), Diff(INSERT,"	¶"), Diff(EQUAL,"//	public static Set<AssignmentSNode> assignmentsEffectingVariableAndItsAliases (SNode anSNode,  String aVariable) {¶//		Set<AssignmentSNode> retVal = directAssignmentsOfVariableAndItsAliases(anSNode, aVariable);¶//		¶//	}¶	public static void fillDirectAssignmentsOfVariableAndItsAliases (SNode anSNode,  String aVariable, Set<AssignmentSNode> retVal) {¶		if (anSNode instanceof AssignmentSNode) {¶			AssignmentSNode anAssignmentSNode = (AssignmentSNode) anSNode;¶			if (anAssignmentSNode.getLhsFirstIdentifier().equals(aVariable)) {¶				retVal.add(anAssignmentSNode);¶			}¶		}¶		¶		else if (anSNode instanceof MethodCall) {¶			MethodCall aMethodCall = (MethodCall) anSNode;¶			int aParameterNumber = aMethodCall.getMethodActualIdentifiers().indexOf(aVariable);¶			if (aParameterNumber < 0) {¶				return;¶			}¶			MethodSNode aDeclaringMethodSNode = getDeclarationOfCalledMethod(anSNode, aMethodCall);¶			String aFormalParameter = aDeclaringMethodSNode.getLocalVariableIdentifiers().get(aParameterNumber);¶//			Set<AssignmentSNode> aCallAssignments = ;¶			fillDirectAssignmentsOfVariableAndItsAliases(aDeclaringMethodSNode, aFormalParameter, retVal);¶		} else {¶			List<SNode> aChildren = anSNode.getChildren();¶			for (SNode aChild:aChildren) {¶				fillDirectAssignmentsOfVariableAndItsAliases(aChild, aVariable, retVal);¶			}¶		}		¶		¶	}¶	¶	public static RootOfFileSNode getRootOfFileNode(SNode aCurrentSNode ) {¶		if (aCurrentSNode instanceof RootOfFileSNode) {¶			return (RootOfFileSNode) aCurrentSNode;¶		}¶		SNode aParentSNode = aCurrentSNode.getParent() ;¶		¶		if (aParentSNode == null) {¶			return null;¶		}¶		¶		return getRootOfFileNode(aParentSNode);¶		¶	}¶	public static boolean match (MethodSNode aMethodSNode, MethodCall aMethodCall) {¶		return aMethodSNode.getMethodName().equals(aMethodCall.getMethodName()) ¶				&& aMethodSNode.getLocalVariableIdentifiers().size() == aMethodCall.getMethodActuals().size();¶	}¶	public static DeclarationSNode getDeclarationOfVariableIdentifier(SNode aCurrentSNode, String anIdentifier) {¶		if (aCurrentSNode == null) {¶			return null;¶		}¶		¶		¶		int anIndex = aCurrentSNode.getLocalVariableIdentifiers().indexOf(anIdentifier);¶		if (anIndex < 0) {¶			return getDeclarationOfVariableIdentifier(aCurrentSNode.getParent(), anIdentifier);¶		}¶		DeclarationSNode retVal = aCurrentSNode.getVariableDeclarations().get(anIndex);¶//		retVal.getAssignmentsToDeclaredVariable().add(anAssignmentSNode);¶//		anAssignmentSNode.setLhsFirstIdentifierDeclaration(retVal);¶		return retVal;¶	}¶	¶	public static DeclarationSNode getDeclarationOfAssignedVariable(SNode aCurrentSNode, AssignmentSNode anAssignmentSNode) {¶		if (aCurrentSNode == null) {¶			return null;¶		}¶		if (anAssignmentSNode instanceof ADeclaringAssignmentSNode) {¶			return (ADeclaringAssignmentSNode) anAssignmentSNode;¶		}¶		int anIndex = aCurrentSNode.getLocalVariableIdentifiers().indexOf(anAssignmentSNode.getLhsFirstIdentifier());¶		if (anIndex < 0) {¶			return getDeclarationOfAssignedVariable(aCurrentSNode.getParent(), anAssignmentSNode);¶		}¶		DeclarationSNode retVal = aCurrentSNode.getVariableDeclarations().get(anIndex);¶//		retVal.getAssignmentsToDeclaredVariable().add(anAssignmentSNode);¶//		anAssignmentSNode.setLhsFirstIdentifierDeclaration(retVal);¶		return retVal;¶	}¶	¶	public static MethodSNode getDeclarationOfCalledMethod(SNode aCurrentSNode, MethodCall aMethodCall ) {¶		SNode aRootNode = getRootOfFileNode(aCurrentSNode);¶		for (SNode aChild:aRootNode.getChildren()) {¶			if (aChild instanceof MethodSNode) {¶				MethodSNode aMethodSNode = (MethodSNode) aChild;¶				if (match (aMethodSNode, aMethodCall)) {¶					return aMethodSNode;¶				}¶			}¶		}¶		return null; // this should never happen;¶	}¶	¶	public static RootOfProgramSNode getRootOfProgramSNode(String aSource) {¶		RootOfProgramSNode retVal = new ARootOfProgramSNode();¶		Map<String, StringBuffer> aFileNameToContents = ABasicTextManager.extractFileContents(aSource);¶		for (String aFileName:aFileNameToContents.keySet()) {¶			StringBuffer aFileContents = aFileNameToContents.get(aFileName);¶//			List<OpenMPPragma> anOpenMPPragmas = OpenMPUtils.getOpemMPPragmas(aFileContents);¶			RootOfFileSNode anSNode = OMPSNodeUtils.getSNode(aFileName, aFileContents);¶			retVal.getFileNameToSNode().put(aFileName, anSNode);¶			anSNode.setParent(retVal);¶//			System.out.println("file name:" + aFileName);¶//			System.out.println("pragmas:" + anSNode);¶		}¶		processExternalMethodSNodes(retVal);¶		processIndirectAssignments(retVal);¶		return retVal;¶	}¶//	public static void processIndirectAssignments (S aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode) {¶//		for (SNode anSNode:aRootOfFileSNode.getChildren()) {¶//			-----¶//		}¶//	}¶	public static void processExternalMethodSNodes (RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode) {¶		for (SNode anSNode:aRootOfFileSNode.getChildren()) {¶			if (anSNode instanceof ExternalMethodSNode) {¶				processExternalMethodSNode(aRootOfProgramSNode, aRootOfFileSNode, (ExternalMethodSNode) anSNode);¶			}¶		}¶	}¶	public static void processExternalMethodSNode (RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode, ExternalMethodSNode anExternalMethodSNode) {¶		MethodSNode aMethodSNode = aRootOfProgramSNode.getExternalToInternalMethod().get(anExternalMethodSNode.toString());¶		if (aMethodSNode == null) {¶			aMethodSNode = findMethodSNode(aRootOfProgramSNode, aRootOfFileSNode, anExternalMethodSNode);¶			if (aMethodSNode != null) {¶				aRootOfProgramSNode.getExternalToInternalMethod().put(anExternalMethodSNode.toString(),aMethodSNode );¶			}¶		}¶		if (aMethodSNode != null) {¶			anExternalMethodSNode.setActualMethodSNode(aMethodSNode);¶			aMethodSNode.getCalls().addAll(anExternalMethodSNode.getLocalCalls());¶		}¶	}¶	¶	public static MethodSNode findMethodSNode (RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode, ExternalMethodSNode anExternalMethodSNode) {¶//		MethodSNode foundMethodSNode = null;¶		for (String aFileName:aRootOfProgramSNode.getFileNameToSNode().keySet()) {¶			if (aFileName.equals(aRootOfFileSNode.getFileName()))¶				continue;¶			¶			RootOfFileSNode aSearchedRootOfFileSNode = aRootOfProgramSNode.getFileNameToSNode().get(aFileName);¶			 for (SNode anSNode:aSearchedRootOfFileSNode.getChildren()) {¶				if (anSNode instanceof MethodSNode && !(anSNode instanceof ExternalMethodSNode)) {¶					if (anSNode.toString().equals(anExternalMethodSNode.toString())) {¶						return (MethodSNode) anSNode;¶						¶					}¶//					processExternalMethodSNode(aRootOfProgramSNode, aRootOfFileSNode, (ExternalMethodSNode) anSNode);¶				}¶			}¶		}¶		return null;¶	}¶	public static void processExternalMethodSNodes (RootOfProgramSNode aRootOfProgramSNode) {¶		for (String aFileName:aRootOfProgramSNode.getFileNameToSNode().keySet()) {¶			RootOfFileSNode aRootOfFileSNode = aRootOfProgramSNode.getFileNameToSNode().get(aFileName);¶			processExternalMethodSNodes(aRootOfProgramSNode, aRootOfFileSNode);¶			aRootOfFileSNode.getOmp_get_num_threads_SNode().¶				setActualMethodSNode(aRootOfProgramSNode.getOmp_get_num_threads_SNode());¶			aRootOfFileSNode.getOmp_get_thread_num_SNode().¶				setActualMethodSNode(aRootOfProgramSNode.getOmp_get_thread_num_SNode());¶			aRootOfFileSNode.getOmp_get_wtime_SNode().¶			setActualMethodSNode(aRootOfProgramSNode.getOmp_get_wtime_SNode());¶		}¶¶	}¶	public static void processIndirectAssignments (SNode anSNode) {¶		if (anSNode instanceof ConstDeclarationSNode) {¶			return;¶		}¶		if (anSNode instanceof DeclarationSNode) {¶			DeclarationSNode aDeclarationSNode = (DeclarationSNode) anSNode;¶			Set<AssignmentSNode> anIndirectAssignments = aDeclarationSNode.getAssignmentsEffectingDeclaredIdentifier();¶			if (anIndirectAssignments != null) {¶				return; // already assigned¶			}¶			anIndirectAssignments = new HashSet<>();¶			aDeclarationSNode.setAssignmentsEffectingDeclaredIdentifier(anIndirectAssignments);¶			Set<AssignmentSNode> aDirectAssignments = aDeclarationSNode.getAssignmentsToDeclaredVariable();¶			anIndirectAssignments.addAll(aDirectAssignments);¶			"), Diff(INSERT,"Set<AssignmentSNode> anAliasAssignments = assignmentsOfVariableAliases(aDeclarationSNode.getParent(), aDeclarationSNode.getVariableName());¶			anIndirectAssignments.addAll(anAliasAssignments);¶			"), Diff(EQUAL,"for (AssignmentSNode aDirectAssignment:aDirectAssignments) {¶				List<String> aVariableIdentifiers = aDirectAssignment.getRhsVariableIdentifiers();¶				¶				for (String aVariableIdentifier:aVariableIdentifiers) {¶					DeclarationSNode aDependeeDeclarationSNode = getDeclarationOfVariableIdentifier(aDirectAssignment, aVariableIdentifier);¶					if (aDependeeDeclarationSNode == null) {¶						System.err.println("Could not find declaration of:" + aVariableIdentifier + " referenced in:" + aDirectAssignment );¶						continue;¶					}¶					processIndirectAssignments(aDependeeDeclarationSNode);¶					Set<AssignmentSNode> aDependeeIndirectAssignments = aDeclarationSNode.getAssignmentsEffectingDeclaredIdentifier();¶					anIndirectAssignments.addAll(aDependeeIndirectAssignments);¶					¶				}¶			}¶		} else {¶			for (SNode aChild: anSNode.getChildren()) {¶				processIndirectAssignments(aChild);¶			}¶		}¶		¶	}¶	¶//	public static void fillIndirectAssignments (SNode anSNode, Set<AssignmentSNode> retVal ) {¶//		¶//	}¶	¶¶//	public static void main(String[] args) {¶//		List<MethodCall> aTokens = callsIn("foo(bar, hgf)/foo2()*foo3(b, a c,)");¶//		System.out.println(aTokens);¶//		¶//		¶////		List<String> aTokens = identifiersIn("a[i] + b*2/3");¶////		System.out.println(aTokens);¶////		aTokens = numbersIn("a[i] + b*2/3");¶////		System.out.println(aTokens);¶////		aTokens = operatorsIn("a[i] + b*2/3");¶////		System.out.println(aTokens);¶////¶////		System.out.println(StringUtils.substringBetween("a", "[", "]"));¶//	}¶¶}¶")]]]></diff>
    <snapshot><![CDATA[package gradingTools.shared.testcases.openmp.scannedTree;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Stack;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.apache.commons.lang.StringUtils;

import grader.basics.project.source.ABasicTextManager;
import gradingTools.shared.testcases.openmp.OpenMPKeywordEnum;
import gradingTools.shared.testcases.openmp.OpenMPParallelPragma;
import gradingTools.shared.testcases.openmp.OpenMPUtils;
import gradingTools.shared.testcases.openmp.scannedTree.ADeclarationSNode;
import gradingTools.shared.testcases.openmp.scannedTree.ADeclaringAssignmentSNode;
import gradingTools.shared.testcases.openmp.scannedTree.AForSNode;
import gradingTools.shared.testcases.openmp.scannedTree.ATextSNode;
import gradingTools.shared.testcases.openmp.scannedTree.AnAssignmentSNode;
import gradingTools.shared.testcases.openmp.scannedTree.AnOMPCriticalSNode;
import gradingTools.shared.testcases.openmp.scannedTree.AnOMPForSNode;
import gradingTools.shared.testcases.openmp.scannedTree.AnOMPParallelSNode;
import gradingTools.shared.testcases.openmp.scannedTree.AnOMPSNode;
import gradingTools.shared.testcases.openmp.scannedTree.AnSNode;
import gradingTools.shared.testcases.openmp.scannedTree.AssignmentSNode;
import gradingTools.shared.testcases.openmp.scannedTree.DeclarationSNode;
import gradingTools.shared.testcases.openmp.scannedTree.DeclaringAssignmentSNode;
import gradingTools.shared.testcases.openmp.scannedTree.ForSNode;
import gradingTools.shared.testcases.openmp.scannedTree.OMPForSNode;
import gradingTools.shared.testcases.openmp.scannedTree.OMPSNode;
import gradingTools.shared.testcases.openmp.scannedTree.SNode;

public class OMPSNodeUtils extends OpenMPUtils {

	public static RootOfFileSNode getSNode(String aFileName, StringBuffer aFileBuffer) {
		String[] aFileLines = aFileBuffer.toString().split("\n");
		return getSNode(aFileName, aFileLines);
	}

	public static AssignmentSNode getAssignmentSNode(int aLineNumber, String aString) {
		if (aString == null) {
			return null;
		}
		String[] aTokens = aString.split("=");
		if (aTokens.length == 1) {
			return new AnAssignmentSNode(aLineNumber, aTokens[0], null);
		} else {
		return new AnAssignmentSNode(aLineNumber, aTokens[0], aTokens[1]);
		}
	}

	public static DeclarationSNode getDeclarationSNode(int aLineNumber, String aString) {
		String[] aTokens = aString.split(" ");
		return new ADeclarationSNode(aLineNumber, aTokens[0], aTokens[1]);
	}

	public static DeclaringAssignmentSNode getDeclaringAssignmentSNode(int aLineNumber, String aString) {
		String[] anLHSAndRHS = aString.split("=");
		String[] aTypeAndVariable = anLHSAndRHS[0].split(" ");
		return new ADeclaringAssignmentSNode(aLineNumber, aTypeAndVariable[0], aTypeAndVariable[1], anLHSAndRHS[1]);
	}
	public static ConstDeclarationSNode getConstDeclarationSNode(int aLineNumber, String aString) {
		String anAssignmentString = aString.substring(CONST.length()).trim();
		String[] anLHSAndRHS = anAssignmentString.split("=");
		String[] aTypeAndVariable = anLHSAndRHS[0].split(" ");
		return new AConstDeclarationSNode(aLineNumber, aTypeAndVariable[0], aTypeAndVariable[1], anLHSAndRHS[1]);
	}

	public static boolean isDeclaringAssignment(String aFileLine) {
		return startsWithTypeName(aFileLine) && aFileLine.contains("=");
	}
	public static boolean isConstDeclaration(String aFileLine) {
		return aFileLine.startsWith(CONST);
	}
	public static boolean isMethodDeclaration(String aFileLine) {
		return startsWithTypeName(aFileLine) && 
				aFileLine.contains("(") &&
				!aFileLine.contains("=");
	}
	public static boolean isExternalMethodDeclaration(String aFileLine) {
		return isMethodDeclaration(aFileLine) && aFileLine.endsWith(";");
	}


	public static boolean isVariableDeclaration(String aFileLine) {

		return startsWithTypeName(aFileLine) && !aFileLine.contains("(");
	}

	public static boolean isAssignment(String aFileLine) {
		return aFileLine.contains("=") && !aFileLine.contains("==");
	}

	public static boolean isForNode(String aFileLine) {
		return aFileLine.startsWith("for");
	}

	public static ForSNode getForSNode(int aLineNumber, String aFileLine) {

		int aLeftParenIndex = aFileLine.indexOf("(");
		int aRightParenIndex = aFileLine.indexOf(")");
		if (aLeftParenIndex < 0 || aRightParenIndex < 0) {
			return null;
		}
		String aHeaderString = aFileLine.substring(aLeftParenIndex + 1, aRightParenIndex);
		String[] aForComponents = aHeaderString.split(";");
		AssignmentSNode anAssignmentSNode = null;
		String aForInitializaton = aForComponents[0];
		if (!aForInitializaton.isEmpty() && aForInitializaton.contains("=")) {
			if (isDeclaringAssignment(aForInitializaton)) {
				anAssignmentSNode = getDeclaringAssignmentSNode(aLineNumber, aForInitializaton);
			} else {
				anAssignmentSNode = getAssignmentSNode(aLineNumber, aForInitializaton);
			}

		}		
		return new AForSNode(aLineNumber, anAssignmentSNode, aForComponents[1], getAssignmentSNode(aLineNumber, aForComponents[2]));
	}
	static String[] emptyArray = {};
	public static MethodSNode getMethodSNode(int aLineNumber, String aFileLine, boolean isInternal) {

		int aLeftParenIndex = aFileLine.indexOf("(");
		int aRightParenIndex = aFileLine.indexOf(")");
		if (aLeftParenIndex < 0 || aRightParenIndex < 0) {
			return null;
		}
		String aMethodNameAndType = aFileLine.substring(0, aLeftParenIndex);
		String[] aMethodNameAndTypeTokens = aMethodNameAndType.split("\\s+"); 
		
		String aMethodParameters = aFileLine.substring(aLeftParenIndex +1 , aRightParenIndex);
		String[] aMethodParameterTokens = aMethodParameters.isEmpty()?emptyArray:
		 aMethodParameters.split(",");
		
//		String[] aMethodParameterTypes = new String[aMethodParameterTokens.length];
//		String[] aMethodParameterNames = new String[aMethodParameterTokens.length];
		List<DeclarationSNode> aDeclarationSNodeList = new ArrayList();
		for (int i = 0; i < aMethodParameterTokens.length; i++ ) {
			String[] aTypeAndName = aMethodParameterTokens[i].trim().split("\\s+");
			if (aTypeAndName.length < 2) {
				continue;
			}
			aDeclarationSNodeList.add(new ADeclarationSNode(aLineNumber, aTypeAndName[0].trim(), aTypeAndName[1].trim()));
//			aMethodParameterTypes[i] = aTypeAndName[0].trim();
//			aMethodParameterNames[i] = aTypeAndName[1].trim();
		}
		if (isInternal)
//		return new AMethodSNode(aLineNumber, aMethodNameAndTypeTokens[0], aMethodNameAndTypeTokens[1], aMethodParameterTypes,aMethodParameterNames );
			return new AMethodSNode(aLineNumber, aMethodNameAndTypeTokens[0], aMethodNameAndTypeTokens[1], aDeclarationSNodeList );
		else
			return new AnExternalMethodSNode(aLineNumber, aMethodNameAndTypeTokens[0], aMethodNameAndTypeTokens[1], aDeclarationSNodeList );
	}

	public static void setReductionData(OMPForSNode lastChild, String aStoredToken, int aLeftParenIndex,
			int aRightParenIndex) {
		int aColonIndex = aStoredToken.indexOf(":");
		if (aLeftParenIndex != -1 && aRightParenIndex != -1 && aColonIndex != -1) {
			String anOperationString = aStoredToken.substring(aLeftParenIndex + 1, aColonIndex).trim();
			String aVariableString = aStoredToken.substring(aColonIndex + 1, aRightParenIndex).trim();
			((OMPForSNode) lastChild).setReductionVariable(aVariableString);
			((OMPForSNode) lastChild).setReductionOperation(anOperationString);
		}
	}

	public static void setSharedOrPrivateData(OMPSNode lastChild, String aStoredToken, int aLeftParenIndex,
			int aRightParenIndex, boolean isShared) {
//		int aColonIndex = aStoredToken.indexOf(":");
		if (aLeftParenIndex != -1 && aRightParenIndex != -1) {
			String aVariableDeclarations = aStoredToken.substring(aLeftParenIndex + 1, aRightParenIndex);
			String[] aVariables = aVariableDeclarations.split(",");
			if (isShared) {
				lastChild.setSharedVariables(aVariables);
			} else {
				lastChild.setPrivateVariables(aVariables);
			}
		}
	}

	public static RootOfFileSNode getSNode(String aFileName, String[] aFileLines) {
		Stack<SNode> anSNodes = new Stack();

		RootOfFileSNode retVal = new ARootOfFileSNode(aFileName);
		anSNodes.add(retVal);
		SNode previousHeaderNode = null;
		for (int i = 0; i < aFileLines.length; i++) {
			String aFileLine = aFileLines[i].trim();
			if (!isCodeLine(aFileLine)) {
				continue;
			}
			if (isForNode(aFileLine)) {
				ForSNode aForSNode = getForSNode(i, aFileLine);
				SNode aParent = previousHeaderNode != null?previousHeaderNode:anSNodes.peek();
				aForSNode.setParent(anSNodes.peek());
				aForSNode.setParent(aParent);

//				anSNodes.push(aForSNode);
				previousHeaderNode = aForSNode;
				if (aFileLine.endsWith(")")) {
					continue;
				}
			}
			if (isExternalMethodDeclaration(aFileLine)) {
				MethodSNode aMethodSNode = getMethodSNode(i, aFileLine, false);
				aMethodSNode.setParent(anSNodes.peek());
//				anSNodes.push(aForSNode);
				previousHeaderNode = aMethodSNode;
				if (aFileLine.endsWith(")")) {
					continue;
				}
			}
			if (isMethodDeclaration(aFileLine)) {
				MethodSNode aMethodSNode = getMethodSNode(i, aFileLine, true);
				aMethodSNode.setParent(anSNodes.peek());
//				anSNodes.push(aForSNode);
				previousHeaderNode = aMethodSNode;
				if (aFileLine.endsWith(")")) {
					continue;
				}
			}
			if (isPragmaStart(aFileLine)) {
				OMPSNode anOMPSNode = getOMPSNode(i, anSNodes.peek(), aFileLine);
//				anSNodes.push(anOMPSNode);
				previousHeaderNode = anOMPSNode;
				continue;
			}
			if (isBlockStart(aFileLine)) {
				SNode aBlockSNode = new ABlockSNode(i);
				if (previousHeaderNode != null) {
					aBlockSNode.setParent(previousHeaderNode);
				} else {
					aBlockSNode.setParent(anSNodes.peek());
				}
				anSNodes.push(aBlockSNode);
				previousHeaderNode = null;
				continue;
			}
//			} else 
			if (isBlockEnd(aFileLine)) {
				anSNodes.pop();
				continue;
			}
			SNode aNewLeafNode = null;
			if (isConstDeclaration(aFileLine)) {
				aNewLeafNode = getConstDeclarationSNode(i, aFileLine);

			} else if (isDeclaringAssignment(aFileLine)) {
				aNewLeafNode = getDeclaringAssignmentSNode(i, aFileLine);

			} else if (isAssignment(aFileLine)) {
				aNewLeafNode = getAssignmentSNode(i, aFileLine);
			} else if (isVariableDeclaration(aFileLine)) {
				aNewLeafNode = getDeclarationSNode(i, aFileLine);
			} else {
				List<MethodCall> aCalls = callsIn(i, aFileLine, null); // parent will be assigned below
				if (aCalls != null && aCalls.size() == 1) {
					aNewLeafNode = aCalls.get(0);
				} else {
					aNewLeafNode = new ATextSNode(i, aFileLine);
				}
			}
//			else {
//				aNewLeafNode = new ATextSNode(i, aFileLine);
//			}
			if (previousHeaderNode != null) {
				aNewLeafNode.setParent(previousHeaderNode);
			} else {
				aNewLeafNode.setParent(anSNodes.peek());
			}

		}

		return retVal;
	}

	public static OMPSNode getOMPSNode(int aLineIndex, SNode aParentNode, String aFileLine) {
		String[] aTokens = aFileLine.split("\\s+");
		if (aTokens.length <= 2) {
			return null;
		}
		if (!aTokens[1].equals("omp")) {
			return null;
		}
		if (aTokens.length < 3) {
			return null;
		}
		String aFirstToken = aTokens[2];
		OpenMPKeywordEnum anOpenMPKeyword = stringToOpenMPKeyword.get(aFirstToken);
//		List<OpenMPPragma> retVal = new ArrayList();
		OMPSNode lastChild = null;
		int aStartIndex = 2;
		OMPSNode aNewNode = null;
		OMPForSNode aForChild = null;
		switch (anOpenMPKeyword) {
		case PARALLEL:
			aNewNode = new AnOMPParallelSNode(aLineIndex);

			if (aTokens.length > 3 && aTokens[3].equals("for")) {
				aForChild = new AnOMPForSNode(aLineIndex);
				aForChild.setParent(aNewNode);

				aStartIndex++;
			}
			break;
		case FOR:
			aNewNode = new AnOMPForSNode(aLineIndex);
			;
			break;
		case CRITICAL:
			aNewNode = new AnOMPCriticalSNode(aLineIndex);
//			retVal.add (lastChild);
			break;
		default:
			aNewNode = new AnOMPSNode(aLineIndex);

		}

		if (lastChild != null) {
			aNewNode.setParent(lastChild);
		} else {
			aNewNode.setParent(aParentNode);
		}
		lastChild = aForChild == null ? aNewNode : aForChild;

		for (int i = aStartIndex; i < aTokens.length; i++) {
			String aStoredToken = aTokens[i].trim();
			if (aStoredToken.isEmpty()) {
				continue;
			}
			if (aStoredToken.startsWith("reduction") || aStoredToken.startsWith("shared")
					|| aStoredToken.startsWith("private")) {
				// combine all tokens until ")" into one for normalization
				while (!aStoredToken.endsWith(")")) {
					i++;
					if (i >= aTokens.length) {
						break;
					}
					String aNewToken = aTokens[i].trim();
					aStoredToken += aNewToken;
				}
				int aLeftParenIndex = aStoredToken.indexOf("(");
				int aRightParenIndex = aStoredToken.indexOf(")");
				if (aStoredToken.startsWith("reduction")) {
					setReductionData((OMPForSNode) lastChild, aStoredToken, aLeftParenIndex, aRightParenIndex);
				} else if (aStoredToken.startsWith("private")) {
					setSharedOrPrivateData((OMPSNode) lastChild, aStoredToken, aLeftParenIndex, aRightParenIndex,
							false);

				} else if (aStoredToken.startsWith("shared")) {
					setSharedOrPrivateData(lastChild, aStoredToken, aLeftParenIndex, aRightParenIndex, true);

				}

			}

			lastChild.getOpenMPTokens().add(aStoredToken);
		}

		return lastChild;

	}

	public static boolean hasParallelAncestor(SNode anSNode) {
		if (anSNode == null) {
			return false;
		}
		if (anSNode instanceof OMPParallelSNode) {
			return true;
		}
		return hasParallelAncestor(anSNode.getParent());
	}
	public static boolean hasCriticalAncestor(SNode anSNode) {
		if (anSNode == null) {
			return false;
		}
		if (anSNode instanceof OMPCriticalSNode) {
			return true;
		}
		return hasCriticalAncestor(anSNode.getParent());
	}


	public static Boolean isDeclaredShared(OMPSNode anOMPSNode, String anLHS) {
		if (Arrays.asList(anOMPSNode.getSharedVariables()).contains(anLHS)) {
			return true;
		}
		if (Arrays.asList(anOMPSNode.getPrivateVariables()).contains(anLHS)) {
			return false;
		}
		return null;

	}

	public static boolean isSharedVariable(SNode anSNode, String anLHS) {
		if (anSNode == null) {
			return false;
		}
		if (anSNode.getLocalVariableIdentifiers().contains(anLHS)) {
			if (!(anSNode instanceof OMPSNode)) { // no shared and private declarations
				return !hasParallelAncestor(anSNode); // shared if not inParallel
			}
			OMPSNode anOMPSNode = (OMPSNode) anSNode;
			return (Arrays.asList(anOMPSNode.getSharedVariables()).contains(anLHS)); // private unless declared shared
		}
		if (anSNode instanceof OMPSNode) {
			OMPSNode anOMPSNode = (OMPSNode) anSNode;
			// the variable is global to this scope, check if it has have been made shared
			// or private by this scope
			Boolean isDeclaredShared = isDeclaredShared(anOMPSNode, anLHS);
			if (isDeclaredShared != null) {
				return isDeclaredShared;
			}
		}
		// check the parent
		return isSharedVariable(anSNode.getParent(), anLHS);
	}

	public static List<SNode> getAllLeafNodes(SNode aTopNode) {
		List<SNode> retVal = new ArrayList();
		addLeafNodes(aTopNode, retVal);
		return retVal;
	}

	public static void addLeafNodes(SNode aTopNode, List<SNode> retVal) {
		for (SNode aChild : aTopNode.getChildren()) {
			if (aChild.isLeaf()) {
				retVal.add(aChild);
			} else {
				addLeafNodes(aChild, retVal);
			}
		}
	}

	public static List<SNode> getNonParallelLeafNodes(SNode aTopNode) {
		List<SNode> retVal = new ArrayList();
		addNonParallelLeafNodes(aTopNode, retVal);
		return retVal;
	}

	public static void addNonParallelLeafNodes(SNode aTopNode, List<SNode> retVal) {
		if (aTopNode.isInParallel()) {
			return;
		}
		for (SNode aChild : aTopNode.getChildren()) {
			if (aChild.isLeaf()) {
				retVal.add(aChild);
			} else {
				addLeafNodes(aChild, retVal);
			}
		}
	}
	static String callRegex = "([a-zA-Z_$][a-zA-Z_$0-9]*)\\(.*?\\)";
	static Pattern callPattern = Pattern.compile(callRegex);

	static String identifierRegex = "[a-zA-Z_$][a-zA-Z_$0-9]*";
	static Pattern identifierPattern = Pattern.compile(identifierRegex);
	public static List<String> identifiersIn(String aString) {
		if (aString == null)
			return null;
//		Pattern mypattern = Pattern.compile("[a-zA-Z_$][a-zA-Z_$0-9]*");
//		Matcher mymatcher = mypattern.matcher(aString);
		Matcher mymatcher = identifierPattern.matcher(aString);
		List<String> retVal = new ArrayList();
		while (mymatcher.find()) {
			String find = mymatcher.group(0);
			retVal.add(find);
		}
		return retVal;
	}
	public static List<MethodCall> callsIn(int aLineNumber, String aString, SNode aParent) {
		if (aString == null)
			return emptyList;
		if (isMethodDeclaration(aString)) {
			return emptyList;
		}
//		Pattern mypattern = Pattern.compile("[a-zA-Z_$][a-zA-Z_$0-9]*");
//		Matcher mymatcher = mypattern.matcher(aString);
		Matcher mymatcher = callPattern.matcher(aString);
		List<MethodCall> retVal = new ArrayList();
		while (mymatcher.find()) {
			String find = mymatcher.group(0);
			int aLeftParenIndex = find.indexOf("(");
			int aRightParenIndex = find.indexOf(")");
			String aMethodName = find.substring(0, aLeftParenIndex).trim();
			String aParameters = find.substring(aLeftParenIndex + 1, aRightParenIndex);
			List<String> aParameterList = new ArrayList();
			String[] aParameterTokens = aParameters.split(",");
			for (String aParameter:aParameterTokens) {
				String aParameterTrimmed = aParameter.trim();
				if (!aParameterTrimmed.isEmpty())
				aParameterList.add(aParameterTrimmed);
			}
			retVal.add(new AMethodCall(aLineNumber, aMethodName, aParameterList, aParent));

//			aCallStrings.add(find);
		}
		return retVal;
	}
	static String numberRegex = "(\\d+\\.\\d+)|(\\d+)";
	static Pattern numberPattern = Pattern.compile(numberRegex);
	public static List<String> numbersIn(String aString) {
		if (aString == null)
			return null;
//		String regex = "(\\d+\\.\\d+)|(\\d+)";
//
//		Matcher m = Pattern.compile(regex).matcher(aString);
		Matcher m =numberPattern.matcher(aString);


		List<String> retVal = new ArrayList();

		while (m.find()) {
			retVal.add(m.group());
		}
		return retVal;
	}

	public static String subscriptIn(String aString) {
		if (aString == null)
			return null;
		return StringUtils.substringBetween(aString, "[", "]");
	}
	static String[] emptyStringArray = {};
	static List emptyList = new ArrayList();

	public static String[] subscriptsIn(String aString) {
		if (aString == null)
			return emptyStringArray;
		return StringUtils.substringsBetween(aString, "[", "]");
	}
	static  String operatorRegex = "([+-/*///^])|([/(/)])";
	static Pattern operatorPattern = Pattern.compile(operatorRegex);

	public static List<String> operatorsIn(String aString) {
		if (aString == null)
			return null;
//		String operatorRegex = "([+-/*///^])|([/(/)])";
//
//		Matcher m = Pattern.compile(operatorRegex).matcher(aString);
		
		Matcher m = operatorPattern.matcher(aString);


		List<String> retVal = new ArrayList();

		while (m.find()) {
			retVal.add(m.group());
		}
		return retVal;
	}
	
	public static int numberOfNestingFors (SNode anSNode) {
		if (anSNode == null) {
			return 0;
		}
		int retVal = numberOfNestingFors (anSNode.getParent()) ;

		if (anSNode instanceof ForSNode) {
			retVal++;
		} else if (anSNode instanceof MethodSNode) {
			List<MethodCall> aMethodCalls = ((MethodSNode) anSNode).getCalls();
			int aMaxNestingLevel = 0;
			for (MethodCall aMethodCall:aMethodCalls) {
				MethodSNode aCallerMethodSNode = getDeclarationOfCalledMethod(anSNode, aMethodCall);
				int aCallerNumberOfNestingFors = numberOfNestingFors(aCallerMethodSNode);
				aMaxNestingLevel = Math.max(aCallerNumberOfNestingFors, aMaxNestingLevel);				
			}
			return retVal + aMaxNestingLevel;
		}
		return retVal;
	}
	public static boolean hasOperator (SNode anSNode, String anOperator) {
		boolean retVal = false;
		if (anSNode instanceof AssignmentSNode) {
			AssignmentSNode anAssignmentSNode = (AssignmentSNode) anSNode;
			 retVal = (anAssignmentSNode.getLhsOperators().contains(anOperator) || 
					anAssignmentSNode.getRhsOperators().contains(anOperator)) ;
			if (retVal) {
				return retVal;
			} else {
				List<MethodCall> aMethodCalls = anAssignmentSNode.getRhsCalls();
				for (MethodCall aMethodCall:aMethodCalls) {
					MethodSNode aMethodSNode = getDeclarationOfCalledMethod(anSNode, aMethodCall);
					retVal = hasOperator(aMethodSNode, anOperator);
					if (retVal) {
						return retVal;
					}
					
				}
				return false;
			}
			
		}
		for (SNode aChild:anSNode.getChildren()) {
			retVal = hasOperator(aChild, anOperator);
			if (retVal) {
				return retVal;
			}
		}
		return false;
	}
	public static boolean hasMethodCall (SNode anSNode, String anOperator) {
		boolean retVal = false;
		if (anSNode instanceof AssignmentSNode) {
			AssignmentSNode anAssignmentSNode = (AssignmentSNode) anSNode;
			 retVal = (anAssignmentSNode.getLhsOperators().contains(anOperator) || 
					anAssignmentSNode.getRhsOperators().contains(anOperator)) ;
			if (retVal) {
				return retVal;
			} else {
				List<MethodCall> aMethodCalls = anAssignmentSNode.getRhsCalls();
				for (MethodCall aMethodCall:aMethodCalls) {
					MethodSNode aMethodSNode = getDeclarationOfCalledMethod(anSNode, aMethodCall);
					retVal = hasOperator(aMethodSNode, anOperator);
					if (retVal) {
						return retVal;
					}
					
				}
				return false;
			}
			
		}
		for (SNode aChild:anSNode.getChildren()) {
			retVal = hasOperator(aChild, anOperator);
			if (retVal) {
				return retVal;
			}
		}
		return false;
	}
	public static boolean dependsOn (AssignmentSNode anAssignmentSNode, String aVariable, String aCallIdentifier) {
		// This assignment does not change aVariable
		if (!aVariable.equals(anAssignmentSNode.getLhsFirstIdentifier())) {
			return false;
		}
		return dependsOn(anAssignmentSNode.getExpressionSNode(), aCallIdentifier);
//		List<String> aCallIdentifiers = anAssignmentSNode.getRhsCallIdentifiers();
//		boolean retVal = false;
//		if (aCallIdentifiers != null && aCallIdentifiers.contains(aCallIdentifier)) {
//			return true; // this assignment has aCallIdentifier in the rhs
//		}
//		// check if some referenced rhs variable depends on aCallIdentifier
//		List<String> aReferencedVariableIdentifiers = anAssignmentSNode.getRhsVariableIdentifiers();
//		SNode anAssignmentParent = anAssignmentSNode.getParent();
//		if (anAssignmentParent == null) { // should never be trye
//			return false;
//		}
//		int aLineNumber = anAssignmentSNode.getLineNumber();
//		for (String aReferencedVariableIdentifier:aReferencedVariableIdentifiers ) {
//			if (dependsOn (anAssignmentParent, aLineNumber, aReferencedVariableIdentifier, aCallIdentifier)) {
//				return true;
//			}
//		}
//		return false;
	}
	public static boolean dependsOn (ExpressionSNode anExpressionSNode, String aCallIdentifier) {
		// This assignment does not change aVariable
		
		List<String> aCallIdentifiers = anExpressionSNode.getRhsCallIdentifiers();
		boolean retVal = false;
		if (aCallIdentifiers != null && aCallIdentifiers.contains(aCallIdentifier)) {
			return true; // this assignment has aCallIdentifier in the rhs
		}
		// check if some referenced rhs variable depends on aCallIdentifier
		List<String> aReferencedVariableIdentifiers = anExpressionSNode.getRhsVariableIdentifiers();
		SNode anAssignmentParent = anExpressionSNode.getParent().getParent();
		if (anAssignmentParent == null) { // should never be trye
			return false;
		}
		int aLineNumber = anExpressionSNode.getLineNumber();
		for (String aReferencedVariableIdentifier:aReferencedVariableIdentifiers ) {
			if (dependsOn (anAssignmentParent, aLineNumber, aReferencedVariableIdentifier, aCallIdentifier)) {
				return true;
			}
		}
		return false;
	}
	public static Set<AssignmentSNode> assignmentsToSharedVariables(SNode anSNode) {
		Set<AssignmentSNode> retVal =  new HashSet();
		fillAssignmentsToShared(anSNode, retVal);
		return retVal;
		
	}
	public static Set<AssignmentSNode> assignmentsToSharedArrays(SNode anSNode) {
		Set<AssignmentSNode> anAllSharedAssignments =  assignmentsToSharedVariables(anSNode);
		Set<AssignmentSNode> aRetVal = new HashSet();
		for (AssignmentSNode anAssignmentSNode:anAllSharedAssignments) {
			if (anAssignmentSNode.getLhsSubscripts().length > 0) {
				aRetVal.add(anAssignmentSNode);
			}
		}
		return aRetVal;
		
	}
	public static Set<AssignmentSNode> assignmentsToParallelCriticalSharedVariables(SNode anSNode) {
		Set<AssignmentSNode> anAllSharedAssignments =  assignmentsToSharedVariables(anSNode);
		Set<AssignmentSNode> aRetVal = new HashSet();
		for (AssignmentSNode anAssignmentSNode:anAllSharedAssignments) {
			if (anAssignmentSNode.isInParallel() &&
					anAssignmentSNode.isInCritical()) {
				aRetVal.add(anAssignmentSNode);
			}
		}
		return aRetVal;
		
	}
	public static Set<AssignmentSNode> assignmentsToNonParallelCriticalSharedVariables(SNode anSNode) {
		Set<AssignmentSNode> anAllSharedAssignments =  assignmentsToSharedVariables(anSNode);
		Set<AssignmentSNode> aRetVal = new HashSet();
		for (AssignmentSNode anAssignmentSNode:anAllSharedAssignments) {
			if (!anAssignmentSNode.isInParallel() &&
					anAssignmentSNode.isInCritical()) {
				aRetVal.add(anAssignmentSNode);
			}
		}
		return aRetVal;
		
	}
	public static Set<AssignmentSNode> assignmentsToParallelNonCriticalSharedVariables(SNode anSNode) {
		Set<AssignmentSNode> anAllSharedAssignments =  assignmentsToSharedVariables(anSNode);
		Set<AssignmentSNode> aRetVal = new HashSet();
		for (AssignmentSNode anAssignmentSNode:anAllSharedAssignments) {
			if (anAssignmentSNode.isInParallel() &&
					!anAssignmentSNode.isInCritical()) {
				aRetVal.add(anAssignmentSNode);
			}
		}
		return aRetVal;
		
	}
    public static void fillAssignmentsToShared(SNode anSNode, Set<AssignmentSNode> retVal) {
    	if (anSNode instanceof AssignmentSNode) {
			AssignmentSNode anAssignmentSNode = (AssignmentSNode) anSNode;
			String anLHS = anAssignmentSNode.getLhsFirstIdentifier();
			if (isSharedVariable(anSNode, anLHS)) {
				retVal.add(anAssignmentSNode);
				return;
			}
		}
    	for (SNode aChild:anSNode.getChildren()) {
    		fillAssignmentsToShared(aChild, retVal);
    	}
		
	}
    public static void fillInstancesOfNodeType(Class<? extends SNode> aNodeType, SNode anSNode, Set<SNode> retVal) {
    	if (aNodeType.isAssignableFrom(anSNode.getClass())) {
			
				retVal.add(anSNode);
				return;
			}
		
    	for (SNode aChild:anSNode.getChildren()) {
    		fillInstancesOfNodeType(aNodeType, aChild, retVal);
    	}
		
	}
    public static Set<AssignmentSNode>  assignmentSNodes(SNode anSNode) {
    	Set retVal = new HashSet();    	
    	fillInstancesOfNodeType(AssignmentSNode.class, anSNode, retVal );
    	return retVal;
	}
   
    
    public static Set<OMPParallelSNode>  ompParallelSNodes(SNode anSNode) {
    	Set retVal = new HashSet();    	
    	fillInstancesOfNodeType(OMPParallelSNode.class, anSNode, retVal );
    	return retVal;
	}
//    public static void fillOMPParallelSNodes(SNode anSNode, Set<OMPParallelSNode> retVal) {
//    	if (anSNode instanceof OMPParallelSNode) {
//    		retVal.add((OMPParallelSNode) anSNode);
//		}
//    	for (SNode aChild:anSNode.getChildren()) {
//    		fillOMPParallelSNodes(aChild, retVal);
//    	}		
//	}
    public static Set<ForSNode>  forSNodes(SNode anSNode) {
    	Set retVal = new HashSet();    	
    	fillInstancesOfNodeType(ForSNode.class, anSNode, retVal );
    	return retVal;
	}
//    public static void fillForSNodes(SNode anSNode, Set<ForSNode> retVal) {
//    	if (anSNode instanceof ForSNode) {
//    		retVal.add((ForSNode) anSNode);
//		}
//    	for (SNode aChild:anSNode.getChildren()) {
//    		fillForSNodes(aChild, retVal);
//    	}		
//	}
    public static Set<OMPForSNode>  ompForSNodes(SNode anSNode) {
    	Set retVal = new HashSet();    	
    	fillInstancesOfNodeType(OMPForSNode.class, anSNode, retVal );
    	return retVal;
	}
//    public static void fillOMPForSNodes(SNode anSNode, Set<OMPForSNode> retVal) {
//    	if (anSNode instanceof OMPForSNode) {
//    		retVal.add((OMPForSNode) anSNode);
//		}
//    	for (SNode aChild:anSNode.getChildren()) {
//    		fillOMPForSNodes(aChild, retVal);
//    	}		
//	}
    public static Set<OMPForSNode> ompReducingForNodes(SNode anSNode) {
		Set<OMPForSNode> anAllOMPForSNodes =  ompForSNodes(anSNode);
		Set<OMPForSNode> aRetVal = new HashSet();
		for (OMPForSNode anOMPForSNode:anAllOMPForSNodes) {
			if (anOMPForSNode.getReductionOperation() != null) {
				aRetVal.add(anOMPForSNode);
			}
		}
		return aRetVal;		
	}
    public static Set<AssignmentSNode> assignmentsToOMPReducingForNode(OMPForSNode anOMPForSNode) {
    	String aReductionVariable = anOMPForSNode.getReductionVariable();
    	return directAssignmentsOfVariableAndItsAliases(anOMPForSNode, aReductionVariable)	;
    	
    }
	public static boolean dependsOn (SNode anSNode, int aVariableLineNumber, String aVariable, String aCallIdentifier) {
		List<SNode> aListSNodes = anSNode.getChildren();
		boolean retVal = false;
		/*
		 * Should probably ignore line number as it assumes straight line code
		 */
		for (int i = aVariableLineNumber; i >= 0; i--) {
			SNode anSNodeChild = aListSNodes.get(i);
			if (anSNodeChild instanceof AssignmentSNode) {
				// does this statement in anSNode directly invoke aCallIdentifier 
				if (dependsOn((AssignmentSNode) anSNodeChild, aVariable, aCallIdentifier))
					return true;
			} else if (!anSNode.isLeaf()) {
					// child is overriding the variable so forget checking its assignment statements
					if (anSNodeChild.getLocalVariableIdentifiers().contains(aVariable)) {
						continue;
					}
					// some subblock of anSNode that has access to aVariable changes variable

					if (dependsOn(anSNodeChild, anSNodeChild.getChildren().size() - 1, aVariable, aCallIdentifier)) {
						return true;
					}
			}
			
		}
		// none of the statements in anSNode or its descendents  have the required call
		// is the variable a  method parameter 
		if (anSNode instanceof MethodSNode) {
			MethodSNode aMethodSNode = (MethodSNode) anSNode;
			
			int aParameterNumber = aMethodSNode.getLocalVariableIdentifiers().indexOf(aVariable);
			if (aParameterNumber != -1) {
				List <MethodCall> aCalls = aMethodSNode.getCalls();
				for (MethodCall aCall:aCalls) {
//					if (!aCall.getMethodActuals().contains(aVariable))
//						continue;
//					
					MethodSNode aCallerSNode = getDeclarationOfCalledMethod(aMethodSNode, aCall);
					if (dependsOn(aMethodSNode, aCallerSNode.getLineNumber(), aCallerSNode.getLocalVariableIdentifiers().get(aParameterNumber), aCallIdentifier));
//				    if (aCallerDepends) {
				    	return true;
//				    }
				}
				return false;
				// need to find all callers of method and see if any of the aliases for the variable in these
				// calls depend on aCallIndentifier
			}			
			
		} else if (anSNode.getLocalVariableIdentifiers().contains(aVariable)) {
			// before going to the parent node, let us see if aVariable is declared here as a non  parameter 

			return false; // no point going to parent
		}
		// not a local variable (parameter or declarated variable)
		SNode anSNodeParent = anSNode.getParent() ;
		if (anSNodeParent == null)  {
			return false;
		}
		int anSNodeLineNumber = anSNodeParent.getChildren().indexOf(anSNode);
		return dependsOn(anSNodeParent, anSNodeLineNumber, aVariable, aCallIdentifier);
		
	}
	public static Set<AssignmentSNode> assignmentsOfVariableAliases (SNode anSNode,  String aVariable) {
		Set<AssignmentSNode> retVal = new HashSet();
		fillDirectAssignmentsOfVariableAndItsAliases(anSNode, aVariable, retVal);
		return retVal;
	}
	public static void fillDirectAssignmentsOfVariableAliases (SNode anSNode,  String aVariable, Set<AssignmentSNode> retVal) {
		if (anSNode instanceof MethodCall) {
			MethodCall aMethodCall = (MethodCall) anSNode;
			int aParameterNumber = aMethodCall.getMethodActualIdentifiers().indexOf(aVariable);
			if (aParameterNumber < 0) {
				return;
			}
			MethodSNode aDeclaringMethodSNode = getDeclarationOfCalledMethod(anSNode, aMethodCall);
			String aFormalParameter = aDeclaringMethodSNode.getLocalVariableIdentifiers().get(aParameterNumber);
//			Set<AssignmentSNode> aCallAssignments = ;
			fillDirectAssignmentsOfVariableAliases(aDeclaringMethodSNode, aFormalParameter, retVal);
		} else {
			List<SNode> aChildren = anSNode.getChildren();
			for (SNode aChild:aChildren) {
				fillDirectAssignmentsOfVariableAliases(aChild, aVariable, retVal);
			}
		}		
		
	}
	
	/*
	 * will not consider assignments to variables in the RHS of these assignments
	 */
	public static Set<AssignmentSNode> directAssignmentsOfVariableAndItsAliases (SNode anSNode,  String aVariable) {
		Set<AssignmentSNode> retVal = new HashSet();
		fillDirectAssignmentsOfVariableAndItsAliases(anSNode, aVariable, retVal);
		return retVal;
	}
	
//	public static Set<AssignmentSNode> assignmentsEffectingVariableAndItsAliases (SNode anSNode,  String aVariable) {
//		Set<AssignmentSNode> retVal = directAssignmentsOfVariableAndItsAliases(anSNode, aVariable);
//		
//	}
	public static void fillDirectAssignmentsOfVariableAndItsAliases (SNode anSNode,  String aVariable, Set<AssignmentSNode> retVal) {
		if (anSNode instanceof AssignmentSNode) {
			AssignmentSNode anAssignmentSNode = (AssignmentSNode) anSNode;
			if (anAssignmentSNode.getLhsFirstIdentifier().equals(aVariable)) {
				retVal.add(anAssignmentSNode);
			}
		}
		
		else if (anSNode instanceof MethodCall) {
			MethodCall aMethodCall = (MethodCall) anSNode;
			int aParameterNumber = aMethodCall.getMethodActualIdentifiers().indexOf(aVariable);
			if (aParameterNumber < 0) {
				return;
			}
			MethodSNode aDeclaringMethodSNode = getDeclarationOfCalledMethod(anSNode, aMethodCall);
			String aFormalParameter = aDeclaringMethodSNode.getLocalVariableIdentifiers().get(aParameterNumber);
//			Set<AssignmentSNode> aCallAssignments = ;
			fillDirectAssignmentsOfVariableAndItsAliases(aDeclaringMethodSNode, aFormalParameter, retVal);
		} else {
			List<SNode> aChildren = anSNode.getChildren();
			for (SNode aChild:aChildren) {
				fillDirectAssignmentsOfVariableAndItsAliases(aChild, aVariable, retVal);
			}
		}		
		
	}
	
	public static RootOfFileSNode getRootOfFileNode(SNode aCurrentSNode ) {
		if (aCurrentSNode instanceof RootOfFileSNode) {
			return (RootOfFileSNode) aCurrentSNode;
		}
		SNode aParentSNode = aCurrentSNode.getParent() ;
		
		if (aParentSNode == null) {
			return null;
		}
		
		return getRootOfFileNode(aParentSNode);
		
	}
	public static boolean match (MethodSNode aMethodSNode, MethodCall aMethodCall) {
		return aMethodSNode.getMethodName().equals(aMethodCall.getMethodName()) 
				&& aMethodSNode.getLocalVariableIdentifiers().size() == aMethodCall.getMethodActuals().size();
	}
	public static DeclarationSNode getDeclarationOfVariableIdentifier(SNode aCurrentSNode, String anIdentifier) {
		if (aCurrentSNode == null) {
			return null;
		}
		
		
		int anIndex = aCurrentSNode.getLocalVariableIdentifiers().indexOf(anIdentifier);
		if (anIndex < 0) {
			return getDeclarationOfVariableIdentifier(aCurrentSNode.getParent(), anIdentifier);
		}
		DeclarationSNode retVal = aCurrentSNode.getVariableDeclarations().get(anIndex);
//		retVal.getAssignmentsToDeclaredVariable().add(anAssignmentSNode);
//		anAssignmentSNode.setLhsFirstIdentifierDeclaration(retVal);
		return retVal;
	}
	
	public static DeclarationSNode getDeclarationOfAssignedVariable(SNode aCurrentSNode, AssignmentSNode anAssignmentSNode) {
		if (aCurrentSNode == null) {
			return null;
		}
		if (anAssignmentSNode instanceof ADeclaringAssignmentSNode) {
			return (ADeclaringAssignmentSNode) anAssignmentSNode;
		}
		int anIndex = aCurrentSNode.getLocalVariableIdentifiers().indexOf(anAssignmentSNode.getLhsFirstIdentifier());
		if (anIndex < 0) {
			return getDeclarationOfAssignedVariable(aCurrentSNode.getParent(), anAssignmentSNode);
		}
		DeclarationSNode retVal = aCurrentSNode.getVariableDeclarations().get(anIndex);
//		retVal.getAssignmentsToDeclaredVariable().add(anAssignmentSNode);
//		anAssignmentSNode.setLhsFirstIdentifierDeclaration(retVal);
		return retVal;
	}
	
	public static MethodSNode getDeclarationOfCalledMethod(SNode aCurrentSNode, MethodCall aMethodCall ) {
		SNode aRootNode = getRootOfFileNode(aCurrentSNode);
		for (SNode aChild:aRootNode.getChildren()) {
			if (aChild instanceof MethodSNode) {
				MethodSNode aMethodSNode = (MethodSNode) aChild;
				if (match (aMethodSNode, aMethodCall)) {
					return aMethodSNode;
				}
			}
		}
		return null; // this should never happen;
	}
	
	public static RootOfProgramSNode getRootOfProgramSNode(String aSource) {
		RootOfProgramSNode retVal = new ARootOfProgramSNode();
		Map<String, StringBuffer> aFileNameToContents = ABasicTextManager.extractFileContents(aSource);
		for (String aFileName:aFileNameToContents.keySet()) {
			StringBuffer aFileContents = aFileNameToContents.get(aFileName);
//			List<OpenMPPragma> anOpenMPPragmas = OpenMPUtils.getOpemMPPragmas(aFileContents);
			RootOfFileSNode anSNode = OMPSNodeUtils.getSNode(aFileName, aFileContents);
			retVal.getFileNameToSNode().put(aFileName, anSNode);
			anSNode.setParent(retVal);
//			System.out.println("file name:" + aFileName);
//			System.out.println("pragmas:" + anSNode);
		}
		processExternalMethodSNodes(retVal);
		processIndirectAssignments(retVal);
		return retVal;
	}
//	public static void processIndirectAssignments (S aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode) {
//		for (SNode anSNode:aRootOfFileSNode.getChildren()) {
//			-----
//		}
//	}
	public static void processExternalMethodSNodes (RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode) {
		for (SNode anSNode:aRootOfFileSNode.getChildren()) {
			if (anSNode instanceof ExternalMethodSNode) {
				processExternalMethodSNode(aRootOfProgramSNode, aRootOfFileSNode, (ExternalMethodSNode) anSNode);
			}
		}
	}
	public static void processExternalMethodSNode (RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode, ExternalMethodSNode anExternalMethodSNode) {
		MethodSNode aMethodSNode = aRootOfProgramSNode.getExternalToInternalMethod().get(anExternalMethodSNode.toString());
		if (aMethodSNode == null) {
			aMethodSNode = findMethodSNode(aRootOfProgramSNode, aRootOfFileSNode, anExternalMethodSNode);
			if (aMethodSNode != null) {
				aRootOfProgramSNode.getExternalToInternalMethod().put(anExternalMethodSNode.toString(),aMethodSNode );
			}
		}
		if (aMethodSNode != null) {
			anExternalMethodSNode.setActualMethodSNode(aMethodSNode);
			aMethodSNode.getCalls().addAll(anExternalMethodSNode.getLocalCalls());
		}
	}
	
	public static MethodSNode findMethodSNode (RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode, ExternalMethodSNode anExternalMethodSNode) {
//		MethodSNode foundMethodSNode = null;
		for (String aFileName:aRootOfProgramSNode.getFileNameToSNode().keySet()) {
			if (aFileName.equals(aRootOfFileSNode.getFileName()))
				continue;
			
			RootOfFileSNode aSearchedRootOfFileSNode = aRootOfProgramSNode.getFileNameToSNode().get(aFileName);
			 for (SNode anSNode:aSearchedRootOfFileSNode.getChildren()) {
				if (anSNode instanceof MethodSNode && !(anSNode instanceof ExternalMethodSNode)) {
					if (anSNode.toString().equals(anExternalMethodSNode.toString())) {
						return (MethodSNode) anSNode;
						
					}
//					processExternalMethodSNode(aRootOfProgramSNode, aRootOfFileSNode, (ExternalMethodSNode) anSNode);
				}
			}
		}
		return null;
	}
	public static void processExternalMethodSNodes (RootOfProgramSNode aRootOfProgramSNode) {
		for (String aFileName:aRootOfProgramSNode.getFileNameToSNode().keySet()) {
			RootOfFileSNode aRootOfFileSNode = aRootOfProgramSNode.getFileNameToSNode().get(aFileName);
			processExternalMethodSNodes(aRootOfProgramSNode, aRootOfFileSNode);
			aRootOfFileSNode.getOmp_get_num_threads_SNode().
				setActualMethodSNode(aRootOfProgramSNode.getOmp_get_num_threads_SNode());
			aRootOfFileSNode.getOmp_get_thread_num_SNode().
				setActualMethodSNode(aRootOfProgramSNode.getOmp_get_thread_num_SNode());
			aRootOfFileSNode.getOmp_get_wtime_SNode().
			setActualMethodSNode(aRootOfProgramSNode.getOmp_get_wtime_SNode());
		}

	}
	public static void processIndirectAssignments (SNode anSNode) {
		if (anSNode instanceof ConstDeclarationSNode) {
			return;
		}
		if (anSNode instanceof DeclarationSNode) {
			DeclarationSNode aDeclarationSNode = (DeclarationSNode) anSNode;
			Set<AssignmentSNode> anIndirectAssignments = aDeclarationSNode.getAssignmentsEffectingDeclaredIdentifier();
			if (anIndirectAssignments != null) {
				return; // already assigned
			}
			anIndirectAssignments = new HashSet<>();
			aDeclarationSNode.setAssignmentsEffectingDeclaredIdentifier(anIndirectAssignments);
			Set<AssignmentSNode> aDirectAssignments = aDeclarationSNode.getAssignmentsToDeclaredVariable();
			anIndirectAssignments.addAll(aDirectAssignments);
			Set<AssignmentSNode> anAliasAssignments = assignmentsOfVariableAliases(aDeclarationSNode.getParent(), aDeclarationSNode.getVariableName());
			anIndirectAssignments.addAll(anAliasAssignments);
			for (AssignmentSNode aDirectAssignment:aDirectAssignments) {
				List<String> aVariableIdentifiers = aDirectAssignment.getRhsVariableIdentifiers();
				
				for (String aVariableIdentifier:aVariableIdentifiers) {
					DeclarationSNode aDependeeDeclarationSNode = getDeclarationOfVariableIdentifier(aDirectAssignment, aVariableIdentifier);
					if (aDependeeDeclarationSNode == null) {
						System.err.println("Could not find declaration of:" + aVariableIdentifier + " referenced in:" + aDirectAssignment );
						continue;
					}
					processIndirectAssignments(aDependeeDeclarationSNode);
					Set<AssignmentSNode> aDependeeIndirectAssignments = aDeclarationSNode.getAssignmentsEffectingDeclaredIdentifier();
					anIndirectAssignments.addAll(aDependeeIndirectAssignments);
					
				}
			}
		} else {
			for (SNode aChild: anSNode.getChildren()) {
				processIndirectAssignments(aChild);
			}
		}
		
	}
	
//	public static void fillIndirectAssignments (SNode anSNode, Set<AssignmentSNode> retVal ) {
//		
//	}
	

//	public static void main(String[] args) {
//		List<MethodCall> aTokens = callsIn("foo(bar, hgf)/foo2()*foo3(b, a c,)");
//		System.out.println(aTokens);
//		
//		
////		List<String> aTokens = identifiersIn("a[i] + b*2/3");
////		System.out.println(aTokens);
////		aTokens = numbersIn("a[i] + b*2/3");
////		System.out.println(aTokens);
////		aTokens = operatorsIn("a[i] + b*2/3");
////		System.out.println(aTokens);
////
////		System.out.println(StringUtils.substringBetween("a", "[", "]"));
//	}

}
]]></snapshot>
  </Command>
  <Command __id="217893" _type="DiffBasedFileOpenCommand" date="Fri Jan 10 10:11:17 EST 2020" docASTNodeCount="399" docActiveCodeLength="3066" docExpressionCount="228" docLength="4804" projectName="GraderBasics" starttimestamp="1576666505112" timestamp="2002572340">
    <filePath><![CDATA[D:\dewan_backup\Java\GraderBasics\src\gradingTools\shared\testcases\openmp\scannedTree\AnAssignmentSNode.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package gradingTools.shared.testcases.openmp.scannedTree;¶¶import java.util.ArrayList;¶import java.util.List;¶import java.util.Set;¶¶public class AnAssignmentSNode extends AnSNode implements AssignmentSNode {¶	static String[] emptyStringArray = {};¶	String lhs;¶	String[] lhsSubscripts = emptyStringArray;¶	String lhsFirstIdentifier;¶	List<String> lhsOperators;¶	String operationAndRHS;¶	ExpressionSNode expressionSNode;¶	DeclarationSNode lhsFirstIdentifierDeclaration;¶//	List<String> rhsVariableIdentifiers;¶//	List<String> rhsOperators;¶//	List<String> rhsNumbers;¶//	List<MethodCall> rhsCalls;¶	¶//	List<String> rhsCallIdentifiers;¶	¶	¶¶	public AnAssignmentSNode(int aLineNumber, String lhs, String operationAndRHS) {¶		super(aLineNumber);¶		this.lhs = lhs;¶		this.operationAndRHS = operationAndRHS;¶		lhsFirstIdentifier = OMPSNodeUtils.identifiersIn(lhs).get(0);¶		lhsOperators =  OMPSNodeUtils.operatorsIn(lhs);		¶		lhsSubscripts = OMPSNodeUtils.subscriptsIn(lhs);¶		if (lhsSubscripts == null) {¶			lhsSubscripts = emptyStringArray;¶		}¶		expressionSNode = new AnExpressionSNode(aLineNumber, operationAndRHS);¶//		expressionSNode.setParent(this);¶//		rhsVariableIdentifiers = OMPSNodeUtils.identifiersIn(operationAndRHS);¶//		rhsNumbers = OMPSNodeUtils.numbersIn(operationAndRHS);¶//		rhsOperators = OMPSNodeUtils.operatorsIn(operationAndRHS);	¶//		rhsCalls = OMPSNodeUtils.callsIn(aLineNumber, operationAndRHS, this);¶//		if (rhsCalls == null) {¶//			return;¶//		}¶//		rhsCallIdentifiers = new ArrayList();¶//		for (MethodCall aMethodCall:rhsCalls) {¶//			MethodSNode aMethodSNode = OMPSNodeUtils.getDeclarationOfCalledMethod(this, aMethodCall);¶//			if (aMethodSNode != null) {¶//				aMethodSNode.getCallsToMe().add(aMethodCall);¶//			}¶//			String aMethodName = aMethodCall.getMethodName();¶//			rhsCallIdentifiers.add(aMethodName);¶//			if (rhsVariableIdentifiers.contains(aMethodName)) {¶//				rhsVariableIdentifiers.remove(aMethodName);¶//			}¶//		}¶		¶	}¶//	protected void setCalledMethodData() {¶//		if (rhsCalls == null) {¶//			return;¶//		}¶//		rhsCallIdentifiers = new ArrayList();¶//		for (MethodCall aMethodCall:rhsCalls) {¶//			MethodSNode aMethodSNode = OMPSNodeUtils.getDeclarationOfCalledMethod(this, aMethodCall);¶//			if (aMethodSNode != null) {¶//				aMethodSNode.getCalls().add(aMethodCall);¶//			}¶//			String aMethodName = aMethodCall.getMethodName();¶//			rhsCallIdentifiers.add(aMethodName);¶//			if (rhsVariableIdentifiers.contains(aMethodName)) {¶//				rhsVariableIdentifiers.remove(aMethodName);¶//			}¶//		}¶//	}¶	@Override¶	public String getLHS() {¶		return lhs;¶	}¶	@Override¶	public String getOperationAndRHS() {¶		return operationAndRHS;¶	}¶	public String[] getLhsSubscripts() {¶		return lhsSubscripts;¶	}¶	public String getVariableName() {¶		return lhsFirstIdentifier;¶	}¶	public List<String> getLhsOperators() {¶		return lhsOperators;¶	}¶	public List<String> getRhsIdentifiers() {¶//		return rhsVariableIdentifiers;¶		return expressionSNode.getRhsIdentifiers();¶	}¶	public List<String> getRhsOperators() {¶//		return rhsOperators;¶		return expressionSNode.getRhsOperators();¶	}¶	public List<String> getRhsNumbers() {¶//		return rhsNumbers;¶		return expressionSNode.getRhsNumbers();¶	}¶	@Override¶	public List<String> getRhsVariableIdentifiers() {¶		return expressionSNode.getRhsVariableIdentifiers();¶//		return rhsVariableIdentifiers;¶	}¶	@Override¶	public List<MethodCall> getRhsCalls() {¶//		return rhsCalls;¶		return expressionSNode.getRhsCalls();¶	}¶	@Override¶	public List<String> getRhsCallIdentifiers() {¶//		return rhsCallIdentifiers;¶		return expressionSNode.getRhsCallIdentifiers();¶	}¶	@Override¶	public String getLhsFirstIdentifier() {¶		return lhsFirstIdentifier;¶	}¶	@Override¶	public void setParent (SNode aParent) {¶		super.setParent(aParent);¶		expressionSNode.setParent(this);¶		DeclarationSNode aDeclarationSNode = OMPSNodeUtils.getDeclarationOfAssignedVariable(this, this);¶		if (aDeclarationSNode == null) {¶			System.err.println("Null declaration node for assignment:" + this);¶		}¶		aDeclarationSNode.getAssignmentsToDeclaredVariable().add(this);¶		setLhsFirstIdentifierDeclaration(aDeclarationSNode);¶//		setCalledMethodData();¶	}¶	@Override¶	public ExpressionSNode getExpressionSNode() {¶		return expressionSNode;¶	}¶	public String toString() {¶		return lhs + "=" + operationAndRHS;¶	}¶	@Override¶	public DeclarationSNode getLhsFirstIdentifierDeclaration() {¶		return lhsFirstIdentifierDeclaration;¶	}¶	@Override¶	public void setLhsFirstIdentifierDeclaration(DeclarationSNode lhsFirstIdentifierDeclaration) {¶		this.lhsFirstIdentifierDeclaration = lhsFirstIdentifierDeclaration;¶	}¶	¶}¶")]]]></diff>
  </Command>
  <Command __id="217897" _type="DiffBasedFileOpenCommand" date="Fri Jan 10 10:11:19 EST 2020" docASTNodeCount="5134" docActiveCodeLength="37681" docExpressionCount="3174" docLength="43800" projectName="GraderBasics" starttimestamp="1576666505112" timestamp="2002574003">
    <filePath><![CDATA[D:\dewan_backup\Java\GraderBasics\src\gradingTools\shared\testcases\openmp\scannedTree\OMPSNodeUtils.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package gradingTools.shared.testcases.openmp.scannedTree;¶¶import java.util.ArrayList;¶import java.util.Arrays;¶import java.util.HashMap;¶import java.util.HashSet;¶import java.util.List;¶import java.util.Map;¶import java.util.Set;¶import java.util.Stack;¶import java.util.regex.Matcher;¶import java.util.regex.Pattern;¶¶import org.apache.commons.lang.StringUtils;¶¶import grader.basics.project.source.ABasicTextManager;¶import gradingTools.shared.testcases.openmp.OpenMPKeywordEnum;¶import gradingTools.shared.testcases.openmp.OpenMPParallelPragma;¶import gradingTools.shared.testcases.openmp.OpenMPUtils;¶import gradingTools.shared.testcases.openmp.scannedTree.ADeclarationSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.ADeclaringAssignmentSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.AForSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.ATextSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.AnAssignmentSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.AnOMPCriticalSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.AnOMPForSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.AnOMPParallelSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.AnOMPSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.AnSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.AssignmentSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.DeclarationSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.DeclaringAssignmentSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.ForSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.OMPForSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.OMPSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.SNode;¶¶public class OMPSNodeUtils extends OpenMPUtils {¶¶	public static RootOfFileSNode getSNode(String aFileName, StringBuffer aFileBuffer) {¶		String[] aFileLines = aFileBuffer.toString().split("\n");¶		return getSNode(aFileName, aFileLines);¶	}¶¶	public static AssignmentSNode getAssignmentSNode(int aLineNumber, String aString) {¶		if (aString == null) {¶			return null;¶		}¶		String[] aTokens = aString.split("=");¶		if (aTokens.length == 1) {¶			return new AnAssignmentSNode(aLineNumber, aTokens[0], null);¶		} else {¶		return new AnAssignmentSNode(aLineNumber, aTokens[0], aTokens[1]);¶		}¶	}¶¶	public static DeclarationSNode getDeclarationSNode(int aLineNumber, String aString) {¶		String[] aTokens = aString.split(" ");¶		return new ADeclarationSNode(aLineNumber, aTokens[0], aTokens[1]);¶	}¶¶	public static DeclaringAssignmentSNode getDeclaringAssignmentSNode(int aLineNumber, String aString) {¶		String[] anLHSAndRHS = aString.split("=");¶		String[] aTypeAndVariable = anLHSAndRHS[0].split(" ");¶		return new ADeclaringAssignmentSNode(aLineNumber, aTypeAndVariable[0], aTypeAndVariable[1], anLHSAndRHS[1]);¶	}¶	public static ConstDeclarationSNode getConstDeclarationSNode(int aLineNumber, String aString) {¶		String anAssignmentString = aString.substring(CONST.length()).trim();¶		String[] anLHSAndRHS = anAssignmentString.split("=");¶		String[] aTypeAndVariable = anLHSAndRHS[0].split(" ");¶		return new AConstDeclarationSNode(aLineNumber, aTypeAndVariable[0], aTypeAndVariable[1], anLHSAndRHS[1]);¶	}¶¶	public static boolean isDeclaringAssignment(String aFileLine) {¶		return startsWithTypeName(aFileLine) && aFileLine.contains("=");¶	}¶	public static boolean isConstDeclaration(String aFileLine) {¶		return aFileLine.startsWith(CONST);¶	}¶	public static boolean isMethodDeclaration(String aFileLine) {¶		return startsWithTypeName(aFileLine) && ¶				aFileLine.contains("(") &&¶				!aFileLine.contains("=");¶	}¶	public static boolean isExternalMethodDeclaration(String aFileLine) {¶		return isMethodDeclaration(aFileLine) && aFileLine.endsWith(";");¶	}¶¶¶	public static boolean isVariableDeclaration(String aFileLine) {¶¶		return startsWithTypeName(aFileLine) && !aFileLine.contains("(");¶	}¶¶	public static boolean isAssignment(String aFileLine) {¶		return aFileLine.contains("=") && !aFileLine.contains("==");¶	}¶¶	public static boolean isForNode(String aFileLine) {¶		return aFileLine.startsWith("for");¶	}¶¶	public static ForSNode getForSNode(int aLineNumber, String aFileLine) {¶¶		int aLeftParenIndex = aFileLine.indexOf("(");¶		int aRightParenIndex = aFileLine.indexOf(")");¶		if (aLeftParenIndex < 0 || aRightParenIndex < 0) {¶			return null;¶		}¶		String aHeaderString = aFileLine.substring(aLeftParenIndex + 1, aRightParenIndex);¶		String[] aForComponents = aHeaderString.split(";");¶		AssignmentSNode anAssignmentSNode = null;¶		String aForInitializaton = aForComponents[0];¶		if (!aForInitializaton.isEmpty() && aForInitializaton.contains("=")) {¶			if (isDeclaringAssignment(aForInitializaton)) {¶				anAssignmentSNode = getDeclaringAssignmentSNode(aLineNumber, aForInitializaton);¶			} else {¶				anAssignmentSNode = getAssignmentSNode(aLineNumber, aForInitializaton);¶			}¶¶		}		¶		return new AForSNode(aLineNumber, anAssignmentSNode, aForComponents[1], getAssignmentSNode(aLineNumber, aForComponents[2]));¶	}¶	static String[] emptyArray = {};¶	public static MethodSNode getMethodSNode(int aLineNumber, String aFileLine, boolean isInternal) {¶¶		int aLeftParenIndex = aFileLine.indexOf("(");¶		int aRightParenIndex = aFileLine.indexOf(")");¶		if (aLeftParenIndex < 0 || aRightParenIndex < 0) {¶			return null;¶		}¶		String aMethodNameAndType = aFileLine.substring(0, aLeftParenIndex);¶		String[] aMethodNameAndTypeTokens = aMethodNameAndType.split("\\s+"); ¶		¶		String aMethodParameters = aFileLine.substring(aLeftParenIndex +1 , aRightParenIndex);¶		String[] aMethodParameterTokens = aMethodParameters.isEmpty()?emptyArray:¶		 aMethodParameters.split(",");¶		¶//		String[] aMethodParameterTypes = new String[aMethodParameterTokens.length];¶//		String[] aMethodParameterNames = new String[aMethodParameterTokens.length];¶		List<DeclarationSNode> aDeclarationSNodeList = new ArrayList();¶		for (int i = 0; i < aMethodParameterTokens.length; i++ ) {¶			String[] aTypeAndName = aMethodParameterTokens[i].trim().split("\\s+");¶			if (aTypeAndName.length < 2) {¶				continue;¶			}¶			aDeclarationSNodeList.add(new ADeclarationSNode(aLineNumber, aTypeAndName[0].trim(), aTypeAndName[1].trim()));¶//			aMethodParameterTypes[i] = aTypeAndName[0].trim();¶//			aMethodParameterNames[i] = aTypeAndName[1].trim();¶		}¶		if (isInternal)¶//		return new AMethodSNode(aLineNumber, aMethodNameAndTypeTokens[0], aMethodNameAndTypeTokens[1], aMethodParameterTypes,aMethodParameterNames );¶			return new AMethodSNode(aLineNumber, aMethodNameAndTypeTokens[0], aMethodNameAndTypeTokens[1], aDeclarationSNodeList );¶		else¶			return new AnExternalMethodSNode(aLineNumber, aMethodNameAndTypeTokens[0], aMethodNameAndTypeTokens[1], aDeclarationSNodeList );¶	}¶¶	public static void setReductionData(OMPForSNode lastChild, String aStoredToken, int aLeftParenIndex,¶			int aRightParenIndex) {¶		int aColonIndex = aStoredToken.indexOf(":");¶		if (aLeftParenIndex != -1 && aRightParenIndex != -1 && aColonIndex != -1) {¶			String anOperationString = aStoredToken.substring(aLeftParenIndex + 1, aColonIndex).trim();¶			String aVariableString = aStoredToken.substring(aColonIndex + 1, aRightParenIndex).trim();¶			((OMPForSNode) lastChild).setReductionVariable(aVariableString);¶			((OMPForSNode) lastChild).setReductionOperation(anOperationString);¶		}¶	}¶¶	public static void setSharedOrPrivateData(OMPSNode lastChild, String aStoredToken, int aLeftParenIndex,¶			int aRightParenIndex, boolean isShared) {¶//		int aColonIndex = aStoredToken.indexOf(":");¶		if (aLeftParenIndex != -1 && aRightParenIndex != -1) {¶			String aVariableDeclarations = aStoredToken.substring(aLeftParenIndex + 1, aRightParenIndex);¶			String[] aVariables = aVariableDeclarations.split(",");¶			if (isShared) {¶				lastChild.setSharedVariables(aVariables);¶			} else {¶				lastChild.setPrivateVariables(aVariables);¶			}¶		}¶	}¶¶	public static RootOfFileSNode getSNode(String aFileName, String[] aFileLines) {¶		Stack<SNode> anSNodes = new Stack();¶¶		RootOfFileSNode retVal = new ARootOfFileSNode(aFileName);¶		anSNodes.add(retVal);¶		SNode previousHeaderNode = null;¶		for (int i = 0; i < aFileLines.length; i++) {¶			String aFileLine = aFileLines[i].trim();¶			if (!isCodeLine(aFileLine)) {¶				continue;¶			}¶			if (isForNode(aFileLine)) {¶				ForSNode aForSNode = getForSNode(i, aFileLine);¶				SNode aParent = previousHeaderNode != null?previousHeaderNode:anSNodes.peek();¶				aForSNode.setParent(anSNodes.peek());¶				aForSNode.setParent(aParent);¶¶//				anSNodes.push(aForSNode);¶				previousHeaderNode = aForSNode;¶				if (aFileLine.endsWith(")")) {¶					continue;¶				}¶			}¶			if (isExternalMethodDeclaration(aFileLine)) {¶				MethodSNode aMethodSNode = getMethodSNode(i, aFileLine, false);¶				aMethodSNode.setParent(anSNodes.peek());¶//				anSNodes.push(aForSNode);¶				previousHeaderNode = aMethodSNode;¶				if (aFileLine.endsWith(")")) {¶					continue;¶				}¶			}¶			if (isMethodDeclaration(aFileLine)) {¶				MethodSNode aMethodSNode = getMethodSNode(i, aFileLine, true);¶				aMethodSNode.setParent(anSNodes.peek());¶//				anSNodes.push(aForSNode);¶				previousHeaderNode = aMethodSNode;¶				if (aFileLine.endsWith(")")) {¶					continue;¶				}¶			}¶			if (isPragmaStart(aFileLine)) {¶				OMPSNode anOMPSNode = getOMPSNode(i, anSNodes.peek(), aFileLine);¶//				anSNodes.push(anOMPSNode);¶				previousHeaderNode = anOMPSNode;¶				continue;¶			}¶			if (isBlockStart(aFileLine)) {¶				SNode aBlockSNode = new ABlockSNode(i);¶				if (previousHeaderNode != null) {¶					aBlockSNode.setParent(previousHeaderNode);¶				} else {¶					aBlockSNode.setParent(anSNodes.peek());¶				}¶				anSNodes.push(aBlockSNode);¶				previousHeaderNode = null;¶				continue;¶			}¶//			} else ¶			if (isBlockEnd(aFileLine)) {¶				anSNodes.pop();¶				continue;¶			}¶			SNode aNewLeafNode = null;¶			if (isConstDeclaration(aFileLine)) {¶				aNewLeafNode = getConstDeclarationSNode(i, aFileLine);¶¶			} else if (isDeclaringAssignment(aFileLine)) {¶				aNewLeafNode = getDeclaringAssignmentSNode(i, aFileLine);¶¶			} else if (isAssignment(aFileLine)) {¶				aNewLeafNode = getAssignmentSNode(i, aFileLine);¶			} else if (isVariableDeclaration(aFileLine)) {¶				aNewLeafNode = getDeclarationSNode(i, aFileLine);¶			} else {¶				List<MethodCall> aCalls = callsIn(i, aFileLine, null); // parent will be assigned below¶				if (aCalls != null && aCalls.size() == 1) {¶					aNewLeafNode = aCalls.get(0);¶				} else {¶					aNewLeafNode = new ATextSNode(i, aFileLine);¶				}¶			}¶//			else {¶//				aNewLeafNode = new ATextSNode(i, aFileLine);¶//			}¶			if (previousHeaderNode != null) {¶				aNewLeafNode.setParent(previousHeaderNode);¶			} else {¶				aNewLeafNode.setParent(anSNodes.peek());¶			}¶¶		}¶¶		return retVal;¶	}¶¶	public static OMPSNode getOMPSNode(int aLineIndex, SNode aParentNode, String aFileLine) {¶		String[] aTokens = aFileLine.split("\\s+");¶		if (aTokens.length <= 2) {¶			return null;¶		}¶		if (!aTokens[1].equals("omp")) {¶			return null;¶		}¶		if (aTokens.length < 3) {¶			return null;¶		}¶		String aFirstToken = aTokens[2];¶		OpenMPKeywordEnum anOpenMPKeyword = stringToOpenMPKeyword.get(aFirstToken);¶//		List<OpenMPPragma> retVal = new ArrayList();¶		OMPSNode lastChild = null;¶		int aStartIndex = 2;¶		OMPSNode aNewNode = null;¶		OMPForSNode aForChild = null;¶		switch (anOpenMPKeyword) {¶		case PARALLEL:¶			aNewNode = new AnOMPParallelSNode(aLineIndex);¶¶			if (aTokens.length > 3 && aTokens[3].equals("for")) {¶				aForChild = new AnOMPForSNode(aLineIndex);¶				aForChild.setParent(aNewNode);¶¶				aStartIndex++;¶			}¶			break;¶		case FOR:¶			aNewNode = new AnOMPForSNode(aLineIndex);¶			;¶			break;¶		case CRITICAL:¶			aNewNode = new AnOMPCriticalSNode(aLineIndex);¶//			retVal.add (lastChild);¶			break;¶		default:¶			aNewNode = new AnOMPSNode(aLineIndex);¶¶		}¶¶		if (lastChild != null) {¶			aNewNode.setParent(lastChild);¶		} else {¶			aNewNode.setParent(aParentNode);¶		}¶		lastChild = aForChild == null ? aNewNode : aForChild;¶¶		for (int i = aStartIndex; i < aTokens.length; i++) {¶			String aStoredToken = aTokens[i].trim();¶			if (aStoredToken.isEmpty()) {¶				continue;¶			}¶			if (aStoredToken.startsWith("reduction") || aStoredToken.startsWith("shared")¶					|| aStoredToken.startsWith("private")) {¶				// combine all tokens until ")" into one for normalization¶				while (!aStoredToken.endsWith(")")) {¶					i++;¶					if (i >= aTokens.length) {¶						break;¶					}¶					String aNewToken = aTokens[i].trim();¶					aStoredToken += aNewToken;¶				}¶				int aLeftParenIndex = aStoredToken.indexOf("(");¶				int aRightParenIndex = aStoredToken.indexOf(")");¶				if (aStoredToken.startsWith("reduction")) {¶					setReductionData((OMPForSNode) lastChild, aStoredToken, aLeftParenIndex, aRightParenIndex);¶				} else if (aStoredToken.startsWith("private")) {¶					setSharedOrPrivateData((OMPSNode) lastChild, aStoredToken, aLeftParenIndex, aRightParenIndex,¶							false);¶¶				} else if (aStoredToken.startsWith("shared")) {¶					setSharedOrPrivateData(lastChild, aStoredToken, aLeftParenIndex, aRightParenIndex, true);¶¶				}¶¶			}¶¶			lastChild.getOpenMPTokens().add(aStoredToken);¶		}¶¶		return lastChild;¶¶	}¶¶	public static boolean hasParallelAncestor(SNode anSNode) {¶		if (anSNode == null) {¶			return false;¶		}¶		if (anSNode instanceof OMPParallelSNode) {¶			return true;¶		}¶		return hasParallelAncestor(anSNode.getParent());¶	}¶	public static boolean hasCriticalAncestor(SNode anSNode) {¶		if (anSNode == null) {¶			return false;¶		}¶		if (anSNode instanceof OMPCriticalSNode) {¶			return true;¶		}¶		return hasCriticalAncestor(anSNode.getParent());¶	}¶¶¶	public static Boolean isDeclaredShared(OMPSNode anOMPSNode, String anLHS) {¶		if (Arrays.asList(anOMPSNode.getSharedVariables()).contains(anLHS)) {¶			return true;¶		}¶		if (Arrays.asList(anOMPSNode.getPrivateVariables()).contains(anLHS)) {¶			return false;¶		}¶		return null;¶¶	}¶¶	public static boolean isSharedVariable(SNode anSNode, String anLHS) {¶		if (anSNode == null) {¶			return false;¶		}¶		if (anSNode.getLocalVariableIdentifiers().contains(anLHS)) {¶			if (!(anSNode instanceof OMPSNode)) { // no shared and private declarations¶				return !hasParallelAncestor(anSNode); // shared if not inParallel¶			}¶			OMPSNode anOMPSNode = (OMPSNode) anSNode;¶			return (Arrays.asList(anOMPSNode.getSharedVariables()).contains(anLHS)); // private unless declared shared¶		}¶		if (anSNode instanceof OMPSNode) {¶			OMPSNode anOMPSNode = (OMPSNode) anSNode;¶			// the variable is global to this scope, check if it has have been made shared¶			// or private by this scope¶			Boolean isDeclaredShared = isDeclaredShared(anOMPSNode, anLHS);¶			if (isDeclaredShared != null) {¶				return isDeclaredShared;¶			}¶		}¶		// check the parent¶		return isSharedVariable(anSNode.getParent(), anLHS);¶	}¶¶	public static List<SNode> getAllLeafNodes(SNode aTopNode) {¶		List<SNode> retVal = new ArrayList();¶		addLeafNodes(aTopNode, retVal);¶		return retVal;¶	}¶¶	public static void addLeafNodes(SNode aTopNode, List<SNode> retVal) {¶		for (SNode aChild : aTopNode.getChildren()) {¶			if (aChild.isLeaf()) {¶				retVal.add(aChild);¶			} else {¶				addLeafNodes(aChild, retVal);¶			}¶		}¶	}¶¶	public static List<SNode> getNonParallelLeafNodes(SNode aTopNode) {¶		List<SNode> retVal = new ArrayList();¶		addNonParallelLeafNodes(aTopNode, retVal);¶		return retVal;¶	}¶¶	public static void addNonParallelLeafNodes(SNode aTopNode, List<SNode> retVal) {¶		if (aTopNode.isInParallel()) {¶			return;¶		}¶		for (SNode aChild : aTopNode.getChildren()) {¶			if (aChild.isLeaf()) {¶				retVal.add(aChild);¶			} else {¶				addLeafNodes(aChild, retVal);¶			}¶		}¶	}¶	static String callRegex = "([a-zA-Z_$][a-zA-Z_$0-9]*)\\(.*?\\)";¶	static Pattern callPattern = Pattern.compile(callRegex);¶¶	static String identifierRegex = "[a-zA-Z_$][a-zA-Z_$0-9]*";¶	static Pattern identifierPattern = Pattern.compile(identifierRegex);¶	public static List<String> identifiersIn(String aString) {¶		if (aString == null)¶			return null;¶//		Pattern mypattern = Pattern.compile("[a-zA-Z_$][a-zA-Z_$0-9]*");¶//		Matcher mymatcher = mypattern.matcher(aString);¶		Matcher mymatcher = identifierPattern.matcher(aString);¶		List<String> retVal = new ArrayList();¶		while (mymatcher.find()) {¶			String find = mymatcher.group(0);¶			retVal.add(find);¶		}¶		return retVal;¶	}¶	public static List<MethodCall> callsIn(int aLineNumber, String aString, SNode aParent) {¶		if (aString == null)¶			return emptyList;¶		if (isMethodDeclaration(aString)) {¶			return emptyList;¶		}¶//		Pattern mypattern = Pattern.compile("[a-zA-Z_$][a-zA-Z_$0-9]*");¶//		Matcher mymatcher = mypattern.matcher(aString);¶		Matcher mymatcher = callPattern.matcher(aString);¶		List<MethodCall> retVal = new ArrayList();¶		while (mymatcher.find()) {¶			String find = mymatcher.group(0);¶			int aLeftParenIndex = find.indexOf("(");¶			int aRightParenIndex = find.indexOf(")");¶			String aMethodName = find.substring(0, aLeftParenIndex).trim();¶			String aParameters = find.substring(aLeftParenIndex + 1, aRightParenIndex);¶			List<String> aParameterList = new ArrayList();¶			String[] aParameterTokens = aParameters.split(",");¶			for (String aParameter:aParameterTokens) {¶				String aParameterTrimmed = aParameter.trim();¶				if (!aParameterTrimmed.isEmpty())¶				aParameterList.add(aParameterTrimmed);¶			}¶			retVal.add(new AMethodCall(aLineNumber, aMethodName, aParameterList, aParent));¶¶//			aCallStrings.add(find);¶		}¶		return retVal;¶	}¶	static String numberRegex = "(\\d+\\.\\d+)|(\\d+)";¶	static Pattern numberPattern = Pattern.compile(numberRegex);¶	public static List<String> numbersIn(String aString) {¶		if (aString == null)¶			return null;¶//		String regex = "(\\d+\\.\\d+)|(\\d+)";¶//¶//		Matcher m = Pattern.compile(regex).matcher(aString);¶		Matcher m =numberPattern.matcher(aString);¶¶¶		List<String> retVal = new ArrayList();¶¶		while (m.find()) {¶			retVal.add(m.group());¶		}¶		return retVal;¶	}¶¶	public static String subscriptIn(String aString) {¶		if (aString == null)¶			return null;¶		return StringUtils.substringBetween(aString, "[", "]");¶	}¶	static String[] emptyStringArray = {};¶	static List emptyList = new ArrayList();¶¶	public static String[] subscriptsIn(String aString) {¶		if (aString == null)¶			return emptyStringArray;¶		return StringUtils.substringsBetween(aString, "[", "]");¶	}¶	static  String operatorRegex = "([+-/*///^])|([/(/)])";¶	static Pattern operatorPattern = Pattern.compile(operatorRegex);¶¶	public static List<String> operatorsIn(String aString) {¶		if (aString == null)¶			return null;¶//		String operatorRegex = "([+-/*///^])|([/(/)])";¶//¶//		Matcher m = Pattern.compile(operatorRegex).matcher(aString);¶		¶		Matcher m = operatorPattern.matcher(aString);¶¶¶		List<String> retVal = new ArrayList();¶¶		while (m.find()) {¶			retVal.add(m.group());¶		}¶		return retVal;¶	}¶	¶	public static int numberOfNestingFors (SNode anSNode) {¶		if (anSNode == null) {¶			return 0;¶		}¶		int retVal = numberOfNestingFors (anSNode.getParent()) ;¶¶		if (anSNode instanceof ForSNode) {¶			retVal++;¶		} else if (anSNode instanceof MethodSNode) {¶			List<MethodCall> aMethodCalls = ((MethodSNode) anSNode).getCalls();¶			int aMaxNestingLevel = 0;¶			for (MethodCall aMethodCall:aMethodCalls) {¶				MethodSNode aCallerMethodSNode = getDeclarationOfCalledMethod(anSNode, aMethodCall);¶				int aCallerNumberOfNestingFors = numberOfNestingFors(aCallerMethodSNode);¶				aMaxNestingLevel = Math.max(aCallerNumberOfNestingFors, aMaxNestingLevel);				¶			}¶			return retVal + aMaxNestingLevel;¶		}¶		return retVal;¶	}¶	public static boolean hasOperator (SNode anSNode, String anOperator) {¶		boolean retVal = false;¶		if (anSNode instanceof AssignmentSNode) {¶			AssignmentSNode anAssignmentSNode = (AssignmentSNode) anSNode;¶			 retVal = (anAssignmentSNode.getLhsOperators().contains(anOperator) || ¶					anAssignmentSNode.getRhsOperators().contains(anOperator)) ;¶			if (retVal) {¶				return retVal;¶			} else {¶				List<MethodCall> aMethodCalls = anAssignmentSNode.getRhsCalls();¶				for (MethodCall aMethodCall:aMethodCalls) {¶					MethodSNode aMethodSNode = getDeclarationOfCalledMethod(anSNode, aMethodCall);¶					retVal = hasOperator(aMethodSNode, anOperator);¶					if (retVal) {¶						return retVal;¶					}¶					¶				}¶				return false;¶			}¶			¶		}¶		for (SNode aChild:anSNode.getChildren()) {¶			retVal = hasOperator(aChild, anOperator);¶			if (retVal) {¶				return retVal;¶			}¶		}¶		return false;¶	}¶	public static boolean hasMethodCall (SNode anSNode, String anOperator) {¶		boolean retVal = false;¶		if (anSNode instanceof AssignmentSNode) {¶			AssignmentSNode anAssignmentSNode = (AssignmentSNode) anSNode;¶			 retVal = (anAssignmentSNode.getLhsOperators().contains(anOperator) || ¶					anAssignmentSNode.getRhsOperators().contains(anOperator)) ;¶			if (retVal) {¶				return retVal;¶			} else {¶				List<MethodCall> aMethodCalls = anAssignmentSNode.getRhsCalls();¶				for (MethodCall aMethodCall:aMethodCalls) {¶					MethodSNode aMethodSNode = getDeclarationOfCalledMethod(anSNode, aMethodCall);¶					retVal = hasOperator(aMethodSNode, anOperator);¶					if (retVal) {¶						return retVal;¶					}¶					¶				}¶				return false;¶			}¶			¶		}¶		for (SNode aChild:anSNode.getChildren()) {¶			retVal = hasOperator(aChild, anOperator);¶			if (retVal) {¶				return retVal;¶			}¶		}¶		return false;¶	}¶	public static boolean dependsOn (AssignmentSNode anAssignmentSNode, String aVariable, String aCallIdentifier) {¶		// This assignment does not change aVariable¶		if (!aVariable.equals(anAssignmentSNode.getLhsFirstIdentifier())) {¶			return false;¶		}¶		return dependsOn(anAssignmentSNode.getExpressionSNode(), aCallIdentifier);¶//		List<String> aCallIdentifiers = anAssignmentSNode.getRhsCallIdentifiers();¶//		boolean retVal = false;¶//		if (aCallIdentifiers != null && aCallIdentifiers.contains(aCallIdentifier)) {¶//			return true; // this assignment has aCallIdentifier in the rhs¶//		}¶//		// check if some referenced rhs variable depends on aCallIdentifier¶//		List<String> aReferencedVariableIdentifiers = anAssignmentSNode.getRhsVariableIdentifiers();¶//		SNode anAssignmentParent = anAssignmentSNode.getParent();¶//		if (anAssignmentParent == null) { // should never be trye¶//			return false;¶//		}¶//		int aLineNumber = anAssignmentSNode.getLineNumber();¶//		for (String aReferencedVariableIdentifier:aReferencedVariableIdentifiers ) {¶//			if (dependsOn (anAssignmentParent, aLineNumber, aReferencedVariableIdentifier, aCallIdentifier)) {¶//				return true;¶//			}¶//		}¶//		return false;¶	}¶	public static boolean dependsOn (ExpressionSNode anExpressionSNode, String aCallIdentifier) {¶		// This assignment does not change aVariable¶		¶		List<String> aCallIdentifiers = anExpressionSNode.getRhsCallIdentifiers();¶		boolean retVal = false;¶		if (aCallIdentifiers != null && aCallIdentifiers.contains(aCallIdentifier)) {¶			return true; // this assignment has aCallIdentifier in the rhs¶		}¶		// check if some referenced rhs variable depends on aCallIdentifier¶		List<String> aReferencedVariableIdentifiers = anExpressionSNode.getRhsVariableIdentifiers();¶		SNode anAssignmentParent = anExpressionSNode.getParent().getParent();¶		if (anAssignmentParent == null) { // should never be trye¶			return false;¶		}¶		int aLineNumber = anExpressionSNode.getLineNumber();¶		for (String aReferencedVariableIdentifier:aReferencedVariableIdentifiers ) {¶			if (dependsOn (anAssignmentParent, aLineNumber, aReferencedVariableIdentifier, aCallIdentifier)) {¶				return true;¶			}¶		}¶		return false;¶	}¶	public static Set<AssignmentSNode> assignmentsToSharedVariables(SNode anSNode) {¶		Set<AssignmentSNode> retVal =  new HashSet();¶		fillAssignmentsToShared(anSNode, retVal);¶		return retVal;¶		¶	}¶	public static Set<AssignmentSNode> assignmentsToSharedArrays(SNode anSNode) {¶		Set<AssignmentSNode> anAllSharedAssignments =  assignmentsToSharedVariables(anSNode);¶		Set<AssignmentSNode> aRetVal = new HashSet();¶		for (AssignmentSNode anAssignmentSNode:anAllSharedAssignments) {¶			if (anAssignmentSNode.getLhsSubscripts().length > 0) {¶				aRetVal.add(anAssignmentSNode);¶			}¶		}¶		return aRetVal;¶		¶	}¶	public static Set<AssignmentSNode> assignmentsToParallelCriticalSharedVariables(SNode anSNode) {¶		Set<AssignmentSNode> anAllSharedAssignments =  assignmentsToSharedVariables(anSNode);¶		Set<AssignmentSNode> aRetVal = new HashSet();¶		for (AssignmentSNode anAssignmentSNode:anAllSharedAssignments) {¶			if (anAssignmentSNode.isInParallel() &&¶					anAssignmentSNode.isInCritical()) {¶				aRetVal.add(anAssignmentSNode);¶			}¶		}¶		return aRetVal;¶		¶	}¶	public static Set<AssignmentSNode> assignmentsToNonParallelCriticalSharedVariables(SNode anSNode) {¶		Set<AssignmentSNode> anAllSharedAssignments =  assignmentsToSharedVariables(anSNode);¶		Set<AssignmentSNode> aRetVal = new HashSet();¶		for (AssignmentSNode anAssignmentSNode:anAllSharedAssignments) {¶			if (!anAssignmentSNode.isInParallel() &&¶					anAssignmentSNode.isInCritical()) {¶				aRetVal.add(anAssignmentSNode);¶			}¶		}¶		return aRetVal;¶		¶	}¶	public static Set<AssignmentSNode> assignmentsToParallelNonCriticalSharedVariables(SNode anSNode) {¶		Set<AssignmentSNode> anAllSharedAssignments =  assignmentsToSharedVariables(anSNode);¶		Set<AssignmentSNode> aRetVal = new HashSet();¶		for (AssignmentSNode anAssignmentSNode:anAllSharedAssignments) {¶			if (anAssignmentSNode.isInParallel() &&¶					!anAssignmentSNode.isInCritical()) {¶				aRetVal.add(anAssignmentSNode);¶			}¶		}¶		return aRetVal;¶		¶	}¶    public static void fillAssignmentsToShared(SNode anSNode, Set<AssignmentSNode> retVal) {¶    	if (anSNode instanceof AssignmentSNode) {¶			AssignmentSNode anAssignmentSNode = (AssignmentSNode) anSNode;¶			String anLHS = anAssignmentSNode.getLhsFirstIdentifier();¶			if (isSharedVariable(anSNode, anLHS)) {¶				retVal.add(anAssignmentSNode);¶				return;¶			}¶		}¶    	for (SNode aChild:anSNode.getChildren()) {¶    		fillAssignmentsToShared(aChild, retVal);¶    	}¶		¶	}¶    public static void fillInstancesOfNodeType(Class<? extends SNode> aNodeType, SNode anSNode, Set<SNode> retVal) {¶    	if (aNodeType.isAssignableFrom(anSNode.getClass())) {¶			¶				retVal.add(anSNode);¶				return;¶			}¶		¶    	for (SNode aChild:anSNode.getChildren()) {¶    		fillInstancesOfNodeType(aNodeType, aChild, retVal);¶    	}¶		¶	}¶    public static Set<AssignmentSNode>  assignmentSNodes(SNode anSNode) {¶    	Set retVal = new HashSet();    	¶    	fillInstancesOfNodeType(AssignmentSNode.class, anSNode, retVal );¶    	return retVal;¶	}¶   ¶    ¶    public static Set<OMPParallelSNode>  ompParallelSNodes(SNode anSNode) {¶    	Set retVal = new HashSet();    	¶    	fillInstancesOfNodeType(OMPParallelSNode.class, anSNode, retVal );¶    	return retVal;¶	}¶//    public static void fillOMPParallelSNodes(SNode anSNode, Set<OMPParallelSNode> retVal) {¶//    	if (anSNode instanceof OMPParallelSNode) {¶//    		retVal.add((OMPParallelSNode) anSNode);¶//		}¶//    	for (SNode aChild:anSNode.getChildren()) {¶//    		fillOMPParallelSNodes(aChild, retVal);¶//    	}		¶//	}¶    public static Set<ForSNode>  forSNodes(SNode anSNode) {¶    	Set retVal = new HashSet();    	¶    	fillInstancesOfNodeType(ForSNode.class, anSNode, retVal );¶    	return retVal;¶	}¶//    public static void fillForSNodes(SNode anSNode, Set<ForSNode> retVal) {¶//    	if (anSNode instanceof ForSNode) {¶//    		retVal.add((ForSNode) anSNode);¶//		}¶//    	for (SNode aChild:anSNode.getChildren()) {¶//    		fillForSNodes(aChild, retVal);¶//    	}		¶//	}¶    public static Set<OMPForSNode>  ompForSNodes(SNode anSNode) {¶    	Set retVal = new HashSet();    	¶    	fillInstancesOfNodeType(OMPForSNode.class, anSNode, retVal );¶    	return retVal;¶	}¶//    public static void fillOMPForSNodes(SNode anSNode, Set<OMPForSNode> retVal) {¶//    	if (anSNode instanceof OMPForSNode) {¶//    		retVal.add((OMPForSNode) anSNode);¶//		}¶//    	for (SNode aChild:anSNode.getChildren()) {¶//    		fillOMPForSNodes(aChild, retVal);¶//    	}		¶//	}¶    public static Set<OMPForSNode> ompReducingForNodes(SNode anSNode) {¶		Set<OMPForSNode> anAllOMPForSNodes =  ompForSNodes(anSNode);¶		Set<OMPForSNode> aRetVal = new HashSet();¶		for (OMPForSNode anOMPForSNode:anAllOMPForSNodes) {¶			if (anOMPForSNode.getReductionOperation() != null) {¶				aRetVal.add(anOMPForSNode);¶			}¶		}¶		return aRetVal;		¶	}¶    public static Set<AssignmentSNode> assignmentsToOMPReducingForNode(OMPForSNode anOMPForSNode) {¶    	String aReductionVariable = anOMPForSNode.getReductionVariable();¶    	return directAssignmentsOfVariableAndItsAliases(anOMPForSNode, aReductionVariable)	;¶    	¶    }¶	public static boolean dependsOn (SNode anSNode, int aVariableLineNumber, String aVariable, String aCallIdentifier) {¶		List<SNode> aListSNodes = anSNode.getChildren();¶		boolean retVal = false;¶		/*¶		 * Should probably ignore line number as it assumes straight line code¶		 */¶		for (int i = aVariableLineNumber; i >= 0; i--) {¶			SNode anSNodeChild = aListSNodes.get(i);¶			if (anSNodeChild instanceof AssignmentSNode) {¶				// does this statement in anSNode directly invoke aCallIdentifier ¶				if (dependsOn((AssignmentSNode) anSNodeChild, aVariable, aCallIdentifier))¶					return true;¶			} else if (!anSNode.isLeaf()) {¶					// child is overriding the variable so forget checking its assignment statements¶					if (anSNodeChild.getLocalVariableIdentifiers().contains(aVariable)) {¶						continue;¶					}¶					// some subblock of anSNode that has access to aVariable changes variable¶¶					if (dependsOn(anSNodeChild, anSNodeChild.getChildren().size() - 1, aVariable, aCallIdentifier)) {¶						return true;¶					}¶			}¶			¶		}¶		// none of the statements in anSNode or its descendents  have the required call¶		// is the variable a  method parameter ¶		if (anSNode instanceof MethodSNode) {¶			MethodSNode aMethodSNode = (MethodSNode) anSNode;¶			¶			int aParameterNumber = aMethodSNode.getLocalVariableIdentifiers().indexOf(aVariable);¶			if (aParameterNumber != -1) {¶				List <MethodCall> aCalls = aMethodSNode.getCalls();¶				for (MethodCall aCall:aCalls) {¶//					if (!aCall.getMethodActuals().contains(aVariable))¶//						continue;¶//					¶					MethodSNode aCallerSNode = getDeclarationOfCalledMethod(aMethodSNode, aCall);¶					if (dependsOn(aMethodSNode, aCallerSNode.getLineNumber(), aCallerSNode.getLocalVariableIdentifiers().get(aParameterNumber), aCallIdentifier));¶//				    if (aCallerDepends) {¶				    	return true;¶//				    }¶				}¶				return false;¶				// need to find all callers of method and see if any of the aliases for the variable in these¶				// calls depend on aCallIndentifier¶			}			¶			¶		} else if (anSNode.getLocalVariableIdentifiers().contains(aVariable)) {¶			// before going to the parent node, let us see if aVariable is declared here as a non  parameter ¶¶			return false; // no point going to parent¶		}¶		// not a local variable (parameter or declarated variable)¶		SNode anSNodeParent = anSNode.getParent() ;¶		if (anSNodeParent == null)  {¶			return false;¶		}¶		int anSNodeLineNumber = anSNodeParent.getChildren().indexOf(anSNode);¶		return dependsOn(anSNodeParent, anSNodeLineNumber, aVariable, aCallIdentifier);¶		¶	}¶	public static Set<AssignmentSNode> assignmentsOfVariableAliases (SNode anSNode,  String aVariable) {¶		Set<AssignmentSNode> retVal = new HashSet();¶		fillDirectAssignmentsOfVariableAndItsAliases(anSNode, aVariable, retVal);¶		return retVal;¶	}¶	public static void fillDirectAssignmentsOfVariableAliases (SNode anSNode,  String aVariable, Set<AssignmentSNode> retVal) {¶		if (anSNode instanceof MethodCall) {¶			MethodCall aMethodCall = (MethodCall) anSNode;¶			int aParameterNumber = aMethodCall.getMethodActualIdentifiers().indexOf(aVariable);¶			if (aParameterNumber < 0) {¶				return;¶			}¶			MethodSNode aDeclaringMethodSNode = getDeclarationOfCalledMethod(anSNode, aMethodCall);¶			String aFormalParameter = aDeclaringMethodSNode.getLocalVariableIdentifiers().get(aParameterNumber);¶//			Set<AssignmentSNode> aCallAssignments = ;¶			fillDirectAssignmentsOfVariableAliases(aDeclaringMethodSNode, aFormalParameter, retVal);¶		} else {¶			List<SNode> aChildren = anSNode.getChildren();¶			for (SNode aChild:aChildren) {¶				fillDirectAssignmentsOfVariableAliases(aChild, aVariable, retVal);¶			}¶		}		¶		¶	}¶	¶	/*¶	 * will not consider assignments to variables in the RHS of these assignments¶	 */¶	public static Set<AssignmentSNode> directAssignmentsOfVariableAndItsAliases (SNode anSNode,  String aVariable) {¶		Set<AssignmentSNode> retVal = new HashSet();¶		fillDirectAssignmentsOfVariableAndItsAliases(anSNode, aVariable, retVal);¶		return retVal;¶	}¶	¶//	public static Set<AssignmentSNode> assignmentsEffectingVariableAndItsAliases (SNode anSNode,  String aVariable) {¶//		Set<AssignmentSNode> retVal = directAssignmentsOfVariableAndItsAliases(anSNode, aVariable);¶//		¶//	}¶	public static void fillDirectAssignmentsOfVariableAndItsAliases (SNode anSNode,  String aVariable, Set<AssignmentSNode> retVal) {¶		if (anSNode instanceof AssignmentSNode) {¶			AssignmentSNode anAssignmentSNode = (AssignmentSNode) anSNode;¶			if (anAssignmentSNode.getLhsFirstIdentifier().equals(aVariable)) {¶				retVal.add(anAssignmentSNode);¶			}¶		}¶		¶		else if (anSNode instanceof MethodCall) {¶			MethodCall aMethodCall = (MethodCall) anSNode;¶			int aParameterNumber = aMethodCall.getMethodActualIdentifiers().indexOf(aVariable);¶			if (aParameterNumber < 0) {¶				return;¶			}¶			MethodSNode aDeclaringMethodSNode = getDeclarationOfCalledMethod(anSNode, aMethodCall);¶			String aFormalParameter = aDeclaringMethodSNode.getLocalVariableIdentifiers().get(aParameterNumber);¶//			Set<AssignmentSNode> aCallAssignments = ;¶			fillDirectAssignmentsOfVariableAndItsAliases(aDeclaringMethodSNode, aFormalParameter, retVal);¶		} else {¶			List<SNode> aChildren = anSNode.getChildren();¶			for (SNode aChild:aChildren) {¶				fillDirectAssignmentsOfVariableAndItsAliases(aChild, aVariable, retVal);¶			}¶		}		¶		¶	}¶	¶	public static RootOfFileSNode getRootOfFileNode(SNode aCurrentSNode ) {¶		if (aCurrentSNode instanceof RootOfFileSNode) {¶			return (RootOfFileSNode) aCurrentSNode;¶		}¶		SNode aParentSNode = aCurrentSNode.getParent() ;¶		¶		if (aParentSNode == null) {¶			return null;¶		}¶		¶		return getRootOfFileNode(aParentSNode);¶		¶	}¶	public static boolean match (MethodSNode aMethodSNode, MethodCall aMethodCall) {¶		return aMethodSNode.getMethodName().equals(aMethodCall.getMethodName()) ¶				&& aMethodSNode.getLocalVariableIdentifiers().size() == aMethodCall.getMethodActuals().size();¶	}¶	public static DeclarationSNode getDeclarationOfVariableIdentifier(SNode aCurrentSNode, String anIdentifier) {¶		if (aCurrentSNode == null) {¶			return null;¶		}¶		¶		¶		int anIndex = aCurrentSNode.getLocalVariableIdentifiers().indexOf(anIdentifier);¶		if (anIndex < 0) {¶			return getDeclarationOfVariableIdentifier(aCurrentSNode.getParent(), anIdentifier);¶		}¶		DeclarationSNode retVal = aCurrentSNode.getVariableDeclarations().get(anIndex);¶//		retVal.getAssignmentsToDeclaredVariable().add(anAssignmentSNode);¶//		anAssignmentSNode.setLhsFirstIdentifierDeclaration(retVal);¶		return retVal;¶	}¶	¶	public static DeclarationSNode getDeclarationOfAssignedVariable(SNode aCurrentSNode, AssignmentSNode anAssignmentSNode) {¶		if (aCurrentSNode == null) {¶			return null;¶		}¶		if (anAssignmentSNode instanceof ADeclaringAssignmentSNode) {¶			return (ADeclaringAssignmentSNode) anAssignmentSNode;¶		}¶		int anIndex = aCurrentSNode.getLocalVariableIdentifiers().indexOf(anAssignmentSNode.getLhsFirstIdentifier());¶		if (anIndex < 0) {¶			return getDeclarationOfAssignedVariable(aCurrentSNode.getParent(), anAssignmentSNode);¶		}¶		DeclarationSNode retVal = aCurrentSNode.getVariableDeclarations().get(anIndex);¶//		retVal.getAssignmentsToDeclaredVariable().add(anAssignmentSNode);¶//		anAssignmentSNode.setLhsFirstIdentifierDeclaration(retVal);¶		return retVal;¶	}¶	¶	public static MethodSNode getDeclarationOfCalledMethod(SNode aCurrentSNode, MethodCall aMethodCall ) {¶		SNode aRootNode = getRootOfFileNode(aCurrentSNode);¶		for (SNode aChild:aRootNode.getChildren()) {¶			if (aChild instanceof MethodSNode) {¶				MethodSNode aMethodSNode = (MethodSNode) aChild;¶				if (match (aMethodSNode, aMethodCall)) {¶					return aMethodSNode;¶				}¶			}¶		}¶		return null; // this should never happen;¶	}¶	¶	public static RootOfProgramSNode getRootOfProgramSNode(String aSource) {¶		RootOfProgramSNode retVal = new ARootOfProgramSNode();¶		Map<String, StringBuffer> aFileNameToContents = ABasicTextManager.extractFileContents(aSource);¶		for (String aFileName:aFileNameToContents.keySet()) {¶			StringBuffer aFileContents = aFileNameToContents.get(aFileName);¶//			List<OpenMPPragma> anOpenMPPragmas = OpenMPUtils.getOpemMPPragmas(aFileContents);¶			RootOfFileSNode anSNode = OMPSNodeUtils.getSNode(aFileName, aFileContents);¶			retVal.getFileNameToSNode().put(aFileName, anSNode);¶			anSNode.setParent(retVal);¶//			System.out.println("file name:" + aFileName);¶//			System.out.println("pragmas:" + anSNode);¶		}¶		processExternalMethodSNodes(retVal);¶		processIndirectAssignments(retVal);¶		return retVal;¶	}¶//	public static void processIndirectAssignments (S aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode) {¶//		for (SNode anSNode:aRootOfFileSNode.getChildren()) {¶//			-----¶//		}¶//	}¶	public static void processExternalMethodSNodes (RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode) {¶		for (SNode anSNode:aRootOfFileSNode.getChildren()) {¶			if (anSNode instanceof ExternalMethodSNode) {¶				processExternalMethodSNode(aRootOfProgramSNode, aRootOfFileSNode, (ExternalMethodSNode) anSNode);¶			}¶		}¶	}¶	public static void processExternalMethodSNode (RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode, ExternalMethodSNode anExternalMethodSNode) {¶		MethodSNode aMethodSNode = aRootOfProgramSNode.getExternalToInternalMethod().get(anExternalMethodSNode.toString());¶		if (aMethodSNode == null) {¶			aMethodSNode = findMethodSNode(aRootOfProgramSNode, aRootOfFileSNode, anExternalMethodSNode);¶			if (aMethodSNode != null) {¶				aRootOfProgramSNode.getExternalToInternalMethod().put(anExternalMethodSNode.toString(),aMethodSNode );¶			}¶		}¶		if (aMethodSNode != null) {¶			anExternalMethodSNode.setActualMethodSNode(aMethodSNode);¶			aMethodSNode.getCalls().addAll(anExternalMethodSNode.getLocalCalls());¶		}¶	}¶	¶	public static MethodSNode findMethodSNode (RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode, ExternalMethodSNode anExternalMethodSNode) {¶//		MethodSNode foundMethodSNode = null;¶		for (String aFileName:aRootOfProgramSNode.getFileNameToSNode().keySet()) {¶			if (aFileName.equals(aRootOfFileSNode.getFileName()))¶				continue;¶			¶			RootOfFileSNode aSearchedRootOfFileSNode = aRootOfProgramSNode.getFileNameToSNode().get(aFileName);¶			 for (SNode anSNode:aSearchedRootOfFileSNode.getChildren()) {¶				if (anSNode instanceof MethodSNode && !(anSNode instanceof ExternalMethodSNode)) {¶					if (anSNode.toString().equals(anExternalMethodSNode.toString())) {¶						return (MethodSNode) anSNode;¶						¶					}¶//					processExternalMethodSNode(aRootOfProgramSNode, aRootOfFileSNode, (ExternalMethodSNode) anSNode);¶				}¶			}¶		}¶		return null;¶	}¶	public static void processExternalMethodSNodes (RootOfProgramSNode aRootOfProgramSNode) {¶		for (String aFileName:aRootOfProgramSNode.getFileNameToSNode().keySet()) {¶			RootOfFileSNode aRootOfFileSNode = aRootOfProgramSNode.getFileNameToSNode().get(aFileName);¶			processExternalMethodSNodes(aRootOfProgramSNode, aRootOfFileSNode);¶			aRootOfFileSNode.getOmp_get_num_threads_SNode().¶				setActualMethodSNode(aRootOfProgramSNode.getOmp_get_num_threads_SNode());¶			aRootOfFileSNode.getOmp_get_thread_num_SNode().¶				setActualMethodSNode(aRootOfProgramSNode.getOmp_get_thread_num_SNode());¶			aRootOfFileSNode.getOmp_get_wtime_SNode().¶			setActualMethodSNode(aRootOfProgramSNode.getOmp_get_wtime_SNode());¶		}¶¶	}¶	public static void processIndirectAssignments (SNode anSNode) {¶		if (anSNode instanceof ConstDeclarationSNode) {¶			return;¶		}¶		if (anSNode instanceof DeclarationSNode) {¶			DeclarationSNode aDeclarationSNode = (DeclarationSNode) anSNode;¶			Set<AssignmentSNode> anIndirectAssignments = aDeclarationSNode.getAssignmentsEffectingDeclaredIdentifier();¶			if (anIndirectAssignments != null) {¶				return; // already assigned¶			}¶			anIndirectAssignments = new HashSet<>();¶			aDeclarationSNode.setAssignmentsEffectingDeclaredIdentifier(anIndirectAssignments);¶			Set<AssignmentSNode> aDirectAssignments = aDeclarationSNode.getAssignmentsToDeclaredVariable();¶			anIndirectAssignments.addAll(aDirectAssignments);¶			Set<AssignmentSNode> anAliasAssignments = assignmentsOfVariableAliases(aDeclarationSNode.getParent(), aDeclarationSNode.getVariableName());¶			anIndirectAssignments.addAll(anAliasAssignments);¶			for (AssignmentSNode aDirectAssignment:aDirectAssignments) {¶				List<String> aVariableIdentifiers = aDirectAssignment.getRhsVariableIdentifiers();¶				¶				for (String aVariableIdentifier:aVariableIdentifiers) {¶					DeclarationSNode aDependeeDeclarationSNode = getDeclarationOfVariableIdentifier(aDirectAssignment, aVariableIdentifier);¶					if (aDependeeDeclarationSNode == null) {¶						System.err.println("Could not find declaration of:" + aVariableIdentifier + " referenced in:" + aDirectAssignment );¶						continue;¶					}¶					processIndirectAssignments(aDependeeDeclarationSNode);¶					Set<AssignmentSNode> aDependeeIndirectAssignments = aDeclarationSNode.getAssignmentsEffectingDeclaredIdentifier();¶					anIndirectAssignments.addAll(aDependeeIndirectAssignments);¶					¶				}¶			}¶		} else {¶			for (SNode aChild: anSNode.getChildren()) {¶				processIndirectAssignments(aChild);¶			}¶		}¶		¶	}¶	¶//	public static void fillIndirectAssignments (SNode anSNode, Set<AssignmentSNode> retVal ) {¶//		¶//	}¶	¶¶//	public static void main(String[] args) {¶//		List<MethodCall> aTokens = callsIn("foo(bar, hgf)/foo2()*foo3(b, a c,)");¶//		System.out.println(aTokens);¶//		¶//		¶////		List<String> aTokens = identifiersIn("a[i] + b*2/3");¶////		System.out.println(aTokens);¶////		aTokens = numbersIn("a[i] + b*2/3");¶////		System.out.println(aTokens);¶////		aTokens = operatorsIn("a[i] + b*2/3");¶////		System.out.println(aTokens);¶////¶////		System.out.println(StringUtils.substringBetween("a", "[", "]"));¶//	}¶¶}¶")]]]></diff>
  </Command>
  <DocumentChange __id="217904" _type="Delete" date="Fri Jan 10 10:11:32 EST 2020" docASTNodeCount="5134" docActiveCodeLength="37675" docExpressionCount="3174" docLength="43794" endLine="885" length="6" offset="32453" startLine="885" starttimestamp="1576666505112" timestamp="2002586949">
    <text><![CDATA[AndIts]]></text>
  </DocumentChange>
  <Command __id="218084" _type="DiffBasedFileOpenCommand" date="Fri Jan 10 10:18:29 EST 2020" docASTNodeCount="428" docActiveCodeLength="2628" docExpressionCount="248" docLength="3166" projectName="GraderBasics" starttimestamp="1576666505112" timestamp="2003004085">
    <filePath><![CDATA[D:\dewan_backup\Java\GraderBasics\src\gradingTools\shared\testcases\openmp\scannedTree\AnSNode.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package gradingTools.shared.testcases.openmp.scannedTree;¶¶import java.util.ArrayList;¶import java.util.HashSet;¶import java.util.List;¶import java.util.Set;¶¶import gradingTools.shared.testcases.openmp.AnAssignment;¶import gradingTools.shared.testcases.openmp.Assignment;¶import gradingTools.shared.testcases.openmp.ForHeader;¶import gradingTools.shared.testcases.openmp.OpenMPPragma;¶import gradingTools.shared.testcases.openmp.OpenMPUtils;¶import gradingTools.shared.testcases.openmp.checks.OpenMPPragmaAttribute;¶¶public class AnSNode implements SNode {¶	protected List<DeclarationSNode> variableDeclarations = new ArrayList();//separate subclass for this variable?¶//	protected List<String> localVariables = new ArrayList();//separate subclass for this variable?¶	protected List<String> localVariables = new ArrayList();//separate subclass for this variable?¶	protected int lineNumber;¶	protected List<SNode> children = new ArrayList();¶	protected List<Assignment> assignments = new ArrayList();¶	protected List<ForSNode> forNodes = new ArrayList();¶	protected List<OMPSNode> ompSNodes = new ArrayList();¶	protected Set<OpenMPPragmaAttribute> attributes = new HashSet();¶	protected SNode parent;¶	boolean inParallel = false;¶	boolean inCritical = false;¶¶	int numberOfNestingFors;¶¶	public AnSNode(int lineNumber) {¶		super();¶		this.lineNumber = lineNumber;		¶	}¶	¶	@Override¶	public int getLineNumber() {¶		return lineNumber;¶	}¶	¶	@Override¶	public List<ForSNode> getForNodes() {¶		return forNodes;¶	}¶	//	@Override¶//	public void setAnnotatedText(List<String> nextNonEmptyString) {¶//		this.annotatedText = nextNonEmptyString;¶//	}¶	¶	@Override¶	public SNode getParent() {¶		return parent;¶	}¶	@Override¶	public void setParent(SNode parent) {¶		this.parent = parent;¶		parent.getChildren().add(this);¶		inParallel = OMPSNodeUtils.hasParallelAncestor(this);		¶		inCritical = OMPSNodeUtils.hasCriticalAncestor(this);	¶		numberOfNestingFors = OMPSNodeUtils.numberOfNestingFors(parent);¶¶¶	}¶	@Override¶	public List<SNode> getChildren() {¶		return children;¶	}¶	¶	¶	@Override¶	public List<Assignment> getAssignments() {¶		return assignments;¶	}¶	// are the two method below the same? Or is a local variable something that is declared and not shared?¶	@Override¶	public List<DeclarationSNode> getVariableDeclarations() {¶		return variableDeclarations;¶	}¶	@Override¶	public List<String> getLocalVariableIdentifiers() {¶		return localVariables;¶	}¶	@Override¶	public List<OMPSNode> getOmpSNodes() {¶		return ompSNodes;¶	}¶	¶	@Override¶	public void addChild(SNode aChild) {¶		this.getChildren().add(aChild);¶//		if (aChild instanceof DeclaringAssignmentSNode) {¶//			localVariables.add(((DeclaringAssignmentSNode) aChild).getLhsVariable());¶//		}¶	}¶	@Override¶	public Set<OpenMPPragmaAttribute> getAttributes() {¶		return attributes;¶	}¶	@Override¶	public boolean isInParallel() {¶		return inParallel;¶	}¶	@Override¶	public boolean isInCritical() {¶		return inCritical;¶	}¶	@Override¶	public boolean isLeaf() {¶		return getChildren().isEmpty();¶	}¶¶}¶")]]]></diff>
  </Command>
  <Command __id="218088" _type="DiffBasedFileOpenCommand" date="Fri Jan 10 10:18:30 EST 2020" docASTNodeCount="5134" docActiveCodeLength="37675" docExpressionCount="3174" docLength="43794" projectName="GraderBasics" starttimestamp="1576666505112" timestamp="2003005617">
    <filePath><![CDATA[D:\dewan_backup\Java\GraderBasics\src\gradingTools\shared\testcases\openmp\scannedTree\OMPSNodeUtils.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package gradingTools.shared.testcases.openmp.scannedTree;¶¶import java.util.ArrayList;¶import java.util.Arrays;¶import java.util.HashMap;¶import java.util.HashSet;¶import java.util.List;¶import java.util.Map;¶import java.util.Set;¶import java.util.Stack;¶import java.util.regex.Matcher;¶import java.util.regex.Pattern;¶¶import org.apache.commons.lang.StringUtils;¶¶import grader.basics.project.source.ABasicTextManager;¶import gradingTools.shared.testcases.openmp.OpenMPKeywordEnum;¶import gradingTools.shared.testcases.openmp.OpenMPParallelPragma;¶import gradingTools.shared.testcases.openmp.OpenMPUtils;¶import gradingTools.shared.testcases.openmp.scannedTree.ADeclarationSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.ADeclaringAssignmentSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.AForSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.ATextSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.AnAssignmentSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.AnOMPCriticalSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.AnOMPForSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.AnOMPParallelSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.AnOMPSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.AnSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.AssignmentSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.DeclarationSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.DeclaringAssignmentSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.ForSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.OMPForSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.OMPSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.SNode;¶¶public class OMPSNodeUtils extends OpenMPUtils {¶¶	public static RootOfFileSNode getSNode(String aFileName, StringBuffer aFileBuffer) {¶		String[] aFileLines = aFileBuffer.toString().split("\n");¶		return getSNode(aFileName, aFileLines);¶	}¶¶	public static AssignmentSNode getAssignmentSNode(int aLineNumber, String aString) {¶		if (aString == null) {¶			return null;¶		}¶		String[] aTokens = aString.split("=");¶		if (aTokens.length == 1) {¶			return new AnAssignmentSNode(aLineNumber, aTokens[0], null);¶		} else {¶		return new AnAssignmentSNode(aLineNumber, aTokens[0], aTokens[1]);¶		}¶	}¶¶	public static DeclarationSNode getDeclarationSNode(int aLineNumber, String aString) {¶		String[] aTokens = aString.split(" ");¶		return new ADeclarationSNode(aLineNumber, aTokens[0], aTokens[1]);¶	}¶¶	public static DeclaringAssignmentSNode getDeclaringAssignmentSNode(int aLineNumber, String aString) {¶		String[] anLHSAndRHS = aString.split("=");¶		String[] aTypeAndVariable = anLHSAndRHS[0].split(" ");¶		return new ADeclaringAssignmentSNode(aLineNumber, aTypeAndVariable[0], aTypeAndVariable[1], anLHSAndRHS[1]);¶	}¶	public static ConstDeclarationSNode getConstDeclarationSNode(int aLineNumber, String aString) {¶		String anAssignmentString = aString.substring(CONST.length()).trim();¶		String[] anLHSAndRHS = anAssignmentString.split("=");¶		String[] aTypeAndVariable = anLHSAndRHS[0].split(" ");¶		return new AConstDeclarationSNode(aLineNumber, aTypeAndVariable[0], aTypeAndVariable[1], anLHSAndRHS[1]);¶	}¶¶	public static boolean isDeclaringAssignment(String aFileLine) {¶		return startsWithTypeName(aFileLine) && aFileLine.contains("=");¶	}¶	public static boolean isConstDeclaration(String aFileLine) {¶		return aFileLine.startsWith(CONST);¶	}¶	public static boolean isMethodDeclaration(String aFileLine) {¶		return startsWithTypeName(aFileLine) && ¶				aFileLine.contains("(") &&¶				!aFileLine.contains("=");¶	}¶	public static boolean isExternalMethodDeclaration(String aFileLine) {¶		return isMethodDeclaration(aFileLine) && aFileLine.endsWith(";");¶	}¶¶¶	public static boolean isVariableDeclaration(String aFileLine) {¶¶		return startsWithTypeName(aFileLine) && !aFileLine.contains("(");¶	}¶¶	public static boolean isAssignment(String aFileLine) {¶		return aFileLine.contains("=") && !aFileLine.contains("==");¶	}¶¶	public static boolean isForNode(String aFileLine) {¶		return aFileLine.startsWith("for");¶	}¶¶	public static ForSNode getForSNode(int aLineNumber, String aFileLine) {¶¶		int aLeftParenIndex = aFileLine.indexOf("(");¶		int aRightParenIndex = aFileLine.indexOf(")");¶		if (aLeftParenIndex < 0 || aRightParenIndex < 0) {¶			return null;¶		}¶		String aHeaderString = aFileLine.substring(aLeftParenIndex + 1, aRightParenIndex);¶		String[] aForComponents = aHeaderString.split(";");¶		AssignmentSNode anAssignmentSNode = null;¶		String aForInitializaton = aForComponents[0];¶		if (!aForInitializaton.isEmpty() && aForInitializaton.contains("=")) {¶			if (isDeclaringAssignment(aForInitializaton)) {¶				anAssignmentSNode = getDeclaringAssignmentSNode(aLineNumber, aForInitializaton);¶			} else {¶				anAssignmentSNode = getAssignmentSNode(aLineNumber, aForInitializaton);¶			}¶¶		}		¶		return new AForSNode(aLineNumber, anAssignmentSNode, aForComponents[1], getAssignmentSNode(aLineNumber, aForComponents[2]));¶	}¶	static String[] emptyArray = {};¶	public static MethodSNode getMethodSNode(int aLineNumber, String aFileLine, boolean isInternal) {¶¶		int aLeftParenIndex = aFileLine.indexOf("(");¶		int aRightParenIndex = aFileLine.indexOf(")");¶		if (aLeftParenIndex < 0 || aRightParenIndex < 0) {¶			return null;¶		}¶		String aMethodNameAndType = aFileLine.substring(0, aLeftParenIndex);¶		String[] aMethodNameAndTypeTokens = aMethodNameAndType.split("\\s+"); ¶		¶		String aMethodParameters = aFileLine.substring(aLeftParenIndex +1 , aRightParenIndex);¶		String[] aMethodParameterTokens = aMethodParameters.isEmpty()?emptyArray:¶		 aMethodParameters.split(",");¶		¶//		String[] aMethodParameterTypes = new String[aMethodParameterTokens.length];¶//		String[] aMethodParameterNames = new String[aMethodParameterTokens.length];¶		List<DeclarationSNode> aDeclarationSNodeList = new ArrayList();¶		for (int i = 0; i < aMethodParameterTokens.length; i++ ) {¶			String[] aTypeAndName = aMethodParameterTokens[i].trim().split("\\s+");¶			if (aTypeAndName.length < 2) {¶				continue;¶			}¶			aDeclarationSNodeList.add(new ADeclarationSNode(aLineNumber, aTypeAndName[0].trim(), aTypeAndName[1].trim()));¶//			aMethodParameterTypes[i] = aTypeAndName[0].trim();¶//			aMethodParameterNames[i] = aTypeAndName[1].trim();¶		}¶		if (isInternal)¶//		return new AMethodSNode(aLineNumber, aMethodNameAndTypeTokens[0], aMethodNameAndTypeTokens[1], aMethodParameterTypes,aMethodParameterNames );¶			return new AMethodSNode(aLineNumber, aMethodNameAndTypeTokens[0], aMethodNameAndTypeTokens[1], aDeclarationSNodeList );¶		else¶			return new AnExternalMethodSNode(aLineNumber, aMethodNameAndTypeTokens[0], aMethodNameAndTypeTokens[1], aDeclarationSNodeList );¶	}¶¶	public static void setReductionData(OMPForSNode lastChild, String aStoredToken, int aLeftParenIndex,¶			int aRightParenIndex) {¶		int aColonIndex = aStoredToken.indexOf(":");¶		if (aLeftParenIndex != -1 && aRightParenIndex != -1 && aColonIndex != -1) {¶			String anOperationString = aStoredToken.substring(aLeftParenIndex + 1, aColonIndex).trim();¶			String aVariableString = aStoredToken.substring(aColonIndex + 1, aRightParenIndex).trim();¶			((OMPForSNode) lastChild).setReductionVariable(aVariableString);¶			((OMPForSNode) lastChild).setReductionOperation(anOperationString);¶		}¶	}¶¶	public static void setSharedOrPrivateData(OMPSNode lastChild, String aStoredToken, int aLeftParenIndex,¶			int aRightParenIndex, boolean isShared) {¶//		int aColonIndex = aStoredToken.indexOf(":");¶		if (aLeftParenIndex != -1 && aRightParenIndex != -1) {¶			String aVariableDeclarations = aStoredToken.substring(aLeftParenIndex + 1, aRightParenIndex);¶			String[] aVariables = aVariableDeclarations.split(",");¶			if (isShared) {¶				lastChild.setSharedVariables(aVariables);¶			} else {¶				lastChild.setPrivateVariables(aVariables);¶			}¶		}¶	}¶¶	public static RootOfFileSNode getSNode(String aFileName, String[] aFileLines) {¶		Stack<SNode> anSNodes = new Stack();¶¶		RootOfFileSNode retVal = new ARootOfFileSNode(aFileName);¶		anSNodes.add(retVal);¶		SNode previousHeaderNode = null;¶		for (int i = 0; i < aFileLines.length; i++) {¶			String aFileLine = aFileLines[i].trim();¶			if (!isCodeLine(aFileLine)) {¶				continue;¶			}¶			if (isForNode(aFileLine)) {¶				ForSNode aForSNode = getForSNode(i, aFileLine);¶				SNode aParent = previousHeaderNode != null?previousHeaderNode:anSNodes.peek();¶				aForSNode.setParent(anSNodes.peek());¶				aForSNode.setParent(aParent);¶¶//				anSNodes.push(aForSNode);¶				previousHeaderNode = aForSNode;¶				if (aFileLine.endsWith(")")) {¶					continue;¶				}¶			}¶			if (isExternalMethodDeclaration(aFileLine)) {¶				MethodSNode aMethodSNode = getMethodSNode(i, aFileLine, false);¶				aMethodSNode.setParent(anSNodes.peek());¶//				anSNodes.push(aForSNode);¶				previousHeaderNode = aMethodSNode;¶				if (aFileLine.endsWith(")")) {¶					continue;¶				}¶			}¶			if (isMethodDeclaration(aFileLine)) {¶				MethodSNode aMethodSNode = getMethodSNode(i, aFileLine, true);¶				aMethodSNode.setParent(anSNodes.peek());¶//				anSNodes.push(aForSNode);¶				previousHeaderNode = aMethodSNode;¶				if (aFileLine.endsWith(")")) {¶					continue;¶				}¶			}¶			if (isPragmaStart(aFileLine)) {¶				OMPSNode anOMPSNode = getOMPSNode(i, anSNodes.peek(), aFileLine);¶//				anSNodes.push(anOMPSNode);¶				previousHeaderNode = anOMPSNode;¶				continue;¶			}¶			if (isBlockStart(aFileLine)) {¶				SNode aBlockSNode = new ABlockSNode(i);¶				if (previousHeaderNode != null) {¶					aBlockSNode.setParent(previousHeaderNode);¶				} else {¶					aBlockSNode.setParent(anSNodes.peek());¶				}¶				anSNodes.push(aBlockSNode);¶				previousHeaderNode = null;¶				continue;¶			}¶//			} else ¶			if (isBlockEnd(aFileLine)) {¶				anSNodes.pop();¶				continue;¶			}¶			SNode aNewLeafNode = null;¶			if (isConstDeclaration(aFileLine)) {¶				aNewLeafNode = getConstDeclarationSNode(i, aFileLine);¶¶			} else if (isDeclaringAssignment(aFileLine)) {¶				aNewLeafNode = getDeclaringAssignmentSNode(i, aFileLine);¶¶			} else if (isAssignment(aFileLine)) {¶				aNewLeafNode = getAssignmentSNode(i, aFileLine);¶			} else if (isVariableDeclaration(aFileLine)) {¶				aNewLeafNode = getDeclarationSNode(i, aFileLine);¶			} else {¶				List<MethodCall> aCalls = callsIn(i, aFileLine, null); // parent will be assigned below¶				if (aCalls != null && aCalls.size() == 1) {¶					aNewLeafNode = aCalls.get(0);¶				} else {¶					aNewLeafNode = new ATextSNode(i, aFileLine);¶				}¶			}¶//			else {¶//				aNewLeafNode = new ATextSNode(i, aFileLine);¶//			}¶			if (previousHeaderNode != null) {¶				aNewLeafNode.setParent(previousHeaderNode);¶			} else {¶				aNewLeafNode.setParent(anSNodes.peek());¶			}¶¶		}¶¶		return retVal;¶	}¶¶	public static OMPSNode getOMPSNode(int aLineIndex, SNode aParentNode, String aFileLine) {¶		String[] aTokens = aFileLine.split("\\s+");¶		if (aTokens.length <= 2) {¶			return null;¶		}¶		if (!aTokens[1].equals("omp")) {¶			return null;¶		}¶		if (aTokens.length < 3) {¶			return null;¶		}¶		String aFirstToken = aTokens[2];¶		OpenMPKeywordEnum anOpenMPKeyword = stringToOpenMPKeyword.get(aFirstToken);¶//		List<OpenMPPragma> retVal = new ArrayList();¶		OMPSNode lastChild = null;¶		int aStartIndex = 2;¶		OMPSNode aNewNode = null;¶		OMPForSNode aForChild = null;¶		switch (anOpenMPKeyword) {¶		case PARALLEL:¶			aNewNode = new AnOMPParallelSNode(aLineIndex);¶¶			if (aTokens.length > 3 && aTokens[3].equals("for")) {¶				aForChild = new AnOMPForSNode(aLineIndex);¶				aForChild.setParent(aNewNode);¶¶				aStartIndex++;¶			}¶			break;¶		case FOR:¶			aNewNode = new AnOMPForSNode(aLineIndex);¶			;¶			break;¶		case CRITICAL:¶			aNewNode = new AnOMPCriticalSNode(aLineIndex);¶//			retVal.add (lastChild);¶			break;¶		default:¶			aNewNode = new AnOMPSNode(aLineIndex);¶¶		}¶¶		if (lastChild != null) {¶			aNewNode.setParent(lastChild);¶		} else {¶			aNewNode.setParent(aParentNode);¶		}¶		lastChild = aForChild == null ? aNewNode : aForChild;¶¶		for (int i = aStartIndex; i < aTokens.length; i++) {¶			String aStoredToken = aTokens[i].trim();¶			if (aStoredToken.isEmpty()) {¶				continue;¶			}¶			if (aStoredToken.startsWith("reduction") || aStoredToken.startsWith("shared")¶					|| aStoredToken.startsWith("private")) {¶				// combine all tokens until ")" into one for normalization¶				while (!aStoredToken.endsWith(")")) {¶					i++;¶					if (i >= aTokens.length) {¶						break;¶					}¶					String aNewToken = aTokens[i].trim();¶					aStoredToken += aNewToken;¶				}¶				int aLeftParenIndex = aStoredToken.indexOf("(");¶				int aRightParenIndex = aStoredToken.indexOf(")");¶				if (aStoredToken.startsWith("reduction")) {¶					setReductionData((OMPForSNode) lastChild, aStoredToken, aLeftParenIndex, aRightParenIndex);¶				} else if (aStoredToken.startsWith("private")) {¶					setSharedOrPrivateData((OMPSNode) lastChild, aStoredToken, aLeftParenIndex, aRightParenIndex,¶							false);¶¶				} else if (aStoredToken.startsWith("shared")) {¶					setSharedOrPrivateData(lastChild, aStoredToken, aLeftParenIndex, aRightParenIndex, true);¶¶				}¶¶			}¶¶			lastChild.getOpenMPTokens().add(aStoredToken);¶		}¶¶		return lastChild;¶¶	}¶¶	public static boolean hasParallelAncestor(SNode anSNode) {¶		if (anSNode == null) {¶			return false;¶		}¶		if (anSNode instanceof OMPParallelSNode) {¶			return true;¶		}¶		return hasParallelAncestor(anSNode.getParent());¶	}¶	public static boolean hasCriticalAncestor(SNode anSNode) {¶		if (anSNode == null) {¶			return false;¶		}¶		if (anSNode instanceof OMPCriticalSNode) {¶			return true;¶		}¶		return hasCriticalAncestor(anSNode.getParent());¶	}¶¶¶	public static Boolean isDeclaredShared(OMPSNode anOMPSNode, String anLHS) {¶		if (Arrays.asList(anOMPSNode.getSharedVariables()).contains(anLHS)) {¶			return true;¶		}¶		if (Arrays.asList(anOMPSNode.getPrivateVariables()).contains(anLHS)) {¶			return false;¶		}¶		return null;¶¶	}¶¶	public static boolean isSharedVariable(SNode anSNode, String anLHS) {¶		if (anSNode == null) {¶			return false;¶		}¶		if (anSNode.getLocalVariableIdentifiers().contains(anLHS)) {¶			if (!(anSNode instanceof OMPSNode)) { // no shared and private declarations¶				return !hasParallelAncestor(anSNode); // shared if not inParallel¶			}¶			OMPSNode anOMPSNode = (OMPSNode) anSNode;¶			return (Arrays.asList(anOMPSNode.getSharedVariables()).contains(anLHS)); // private unless declared shared¶		}¶		if (anSNode instanceof OMPSNode) {¶			OMPSNode anOMPSNode = (OMPSNode) anSNode;¶			// the variable is global to this scope, check if it has have been made shared¶			// or private by this scope¶			Boolean isDeclaredShared = isDeclaredShared(anOMPSNode, anLHS);¶			if (isDeclaredShared != null) {¶				return isDeclaredShared;¶			}¶		}¶		// check the parent¶		return isSharedVariable(anSNode.getParent(), anLHS);¶	}¶¶	public static List<SNode> getAllLeafNodes(SNode aTopNode) {¶		List<SNode> retVal = new ArrayList();¶		addLeafNodes(aTopNode, retVal);¶		return retVal;¶	}¶¶	public static void addLeafNodes(SNode aTopNode, List<SNode> retVal) {¶		for (SNode aChild : aTopNode.getChildren()) {¶			if (aChild.isLeaf()) {¶				retVal.add(aChild);¶			} else {¶				addLeafNodes(aChild, retVal);¶			}¶		}¶	}¶¶	public static List<SNode> getNonParallelLeafNodes(SNode aTopNode) {¶		List<SNode> retVal = new ArrayList();¶		addNonParallelLeafNodes(aTopNode, retVal);¶		return retVal;¶	}¶¶	public static void addNonParallelLeafNodes(SNode aTopNode, List<SNode> retVal) {¶		if (aTopNode.isInParallel()) {¶			return;¶		}¶		for (SNode aChild : aTopNode.getChildren()) {¶			if (aChild.isLeaf()) {¶				retVal.add(aChild);¶			} else {¶				addLeafNodes(aChild, retVal);¶			}¶		}¶	}¶	static String callRegex = "([a-zA-Z_$][a-zA-Z_$0-9]*)\\(.*?\\)";¶	static Pattern callPattern = Pattern.compile(callRegex);¶¶	static String identifierRegex = "[a-zA-Z_$][a-zA-Z_$0-9]*";¶	static Pattern identifierPattern = Pattern.compile(identifierRegex);¶	public static List<String> identifiersIn(String aString) {¶		if (aString == null)¶			return null;¶//		Pattern mypattern = Pattern.compile("[a-zA-Z_$][a-zA-Z_$0-9]*");¶//		Matcher mymatcher = mypattern.matcher(aString);¶		Matcher mymatcher = identifierPattern.matcher(aString);¶		List<String> retVal = new ArrayList();¶		while (mymatcher.find()) {¶			String find = mymatcher.group(0);¶			retVal.add(find);¶		}¶		return retVal;¶	}¶	public static List<MethodCall> callsIn(int aLineNumber, String aString, SNode aParent) {¶		if (aString == null)¶			return emptyList;¶		if (isMethodDeclaration(aString)) {¶			return emptyList;¶		}¶//		Pattern mypattern = Pattern.compile("[a-zA-Z_$][a-zA-Z_$0-9]*");¶//		Matcher mymatcher = mypattern.matcher(aString);¶		Matcher mymatcher = callPattern.matcher(aString);¶		List<MethodCall> retVal = new ArrayList();¶		while (mymatcher.find()) {¶			String find = mymatcher.group(0);¶			int aLeftParenIndex = find.indexOf("(");¶			int aRightParenIndex = find.indexOf(")");¶			String aMethodName = find.substring(0, aLeftParenIndex).trim();¶			String aParameters = find.substring(aLeftParenIndex + 1, aRightParenIndex);¶			List<String> aParameterList = new ArrayList();¶			String[] aParameterTokens = aParameters.split(",");¶			for (String aParameter:aParameterTokens) {¶				String aParameterTrimmed = aParameter.trim();¶				if (!aParameterTrimmed.isEmpty())¶				aParameterList.add(aParameterTrimmed);¶			}¶			retVal.add(new AMethodCall(aLineNumber, aMethodName, aParameterList, aParent));¶¶//			aCallStrings.add(find);¶		}¶		return retVal;¶	}¶	static String numberRegex = "(\\d+\\.\\d+)|(\\d+)";¶	static Pattern numberPattern = Pattern.compile(numberRegex);¶	public static List<String> numbersIn(String aString) {¶		if (aString == null)¶			return null;¶//		String regex = "(\\d+\\.\\d+)|(\\d+)";¶//¶//		Matcher m = Pattern.compile(regex).matcher(aString);¶		Matcher m =numberPattern.matcher(aString);¶¶¶		List<String> retVal = new ArrayList();¶¶		while (m.find()) {¶			retVal.add(m.group());¶		}¶		return retVal;¶	}¶¶	public static String subscriptIn(String aString) {¶		if (aString == null)¶			return null;¶		return StringUtils.substringBetween(aString, "[", "]");¶	}¶	static String[] emptyStringArray = {};¶	static List emptyList = new ArrayList();¶¶	public static String[] subscriptsIn(String aString) {¶		if (aString == null)¶			return emptyStringArray;¶		return StringUtils.substringsBetween(aString, "[", "]");¶	}¶	static  String operatorRegex = "([+-/*///^])|([/(/)])";¶	static Pattern operatorPattern = Pattern.compile(operatorRegex);¶¶	public static List<String> operatorsIn(String aString) {¶		if (aString == null)¶			return null;¶//		String operatorRegex = "([+-/*///^])|([/(/)])";¶//¶//		Matcher m = Pattern.compile(operatorRegex).matcher(aString);¶		¶		Matcher m = operatorPattern.matcher(aString);¶¶¶		List<String> retVal = new ArrayList();¶¶		while (m.find()) {¶			retVal.add(m.group());¶		}¶		return retVal;¶	}¶	¶	public static int numberOfNestingFors (SNode anSNode) {¶		if (anSNode == null) {¶			return 0;¶		}¶		int retVal = numberOfNestingFors (anSNode.getParent()) ;¶¶		if (anSNode instanceof ForSNode) {¶			retVal++;¶		} else if (anSNode instanceof MethodSNode) {¶			List<MethodCall> aMethodCalls = ((MethodSNode) anSNode).getCalls();¶			int aMaxNestingLevel = 0;¶			for (MethodCall aMethodCall:aMethodCalls) {¶				MethodSNode aCallerMethodSNode = getDeclarationOfCalledMethod(anSNode, aMethodCall);¶				int aCallerNumberOfNestingFors = numberOfNestingFors(aCallerMethodSNode);¶				aMaxNestingLevel = Math.max(aCallerNumberOfNestingFors, aMaxNestingLevel);				¶			}¶			return retVal + aMaxNestingLevel;¶		}¶		return retVal;¶	}¶	public static boolean hasOperator (SNode anSNode, String anOperator) {¶		boolean retVal = false;¶		if (anSNode instanceof AssignmentSNode) {¶			AssignmentSNode anAssignmentSNode = (AssignmentSNode) anSNode;¶			 retVal = (anAssignmentSNode.getLhsOperators().contains(anOperator) || ¶					anAssignmentSNode.getRhsOperators().contains(anOperator)) ;¶			if (retVal) {¶				return retVal;¶			} else {¶				List<MethodCall> aMethodCalls = anAssignmentSNode.getRhsCalls();¶				for (MethodCall aMethodCall:aMethodCalls) {¶					MethodSNode aMethodSNode = getDeclarationOfCalledMethod(anSNode, aMethodCall);¶					retVal = hasOperator(aMethodSNode, anOperator);¶					if (retVal) {¶						return retVal;¶					}¶					¶				}¶				return false;¶			}¶			¶		}¶		for (SNode aChild:anSNode.getChildren()) {¶			retVal = hasOperator(aChild, anOperator);¶			if (retVal) {¶				return retVal;¶			}¶		}¶		return false;¶	}¶	public static boolean hasMethodCall (SNode anSNode, String anOperator) {¶		boolean retVal = false;¶		if (anSNode instanceof AssignmentSNode) {¶			AssignmentSNode anAssignmentSNode = (AssignmentSNode) anSNode;¶			 retVal = (anAssignmentSNode.getLhsOperators().contains(anOperator) || ¶					anAssignmentSNode.getRhsOperators().contains(anOperator)) ;¶			if (retVal) {¶				return retVal;¶			} else {¶				List<MethodCall> aMethodCalls = anAssignmentSNode.getRhsCalls();¶				for (MethodCall aMethodCall:aMethodCalls) {¶					MethodSNode aMethodSNode = getDeclarationOfCalledMethod(anSNode, aMethodCall);¶					retVal = hasOperator(aMethodSNode, anOperator);¶					if (retVal) {¶						return retVal;¶					}¶					¶				}¶				return false;¶			}¶			¶		}¶		for (SNode aChild:anSNode.getChildren()) {¶			retVal = hasOperator(aChild, anOperator);¶			if (retVal) {¶				return retVal;¶			}¶		}¶		return false;¶	}¶	public static boolean dependsOn (AssignmentSNode anAssignmentSNode, String aVariable, String aCallIdentifier) {¶		// This assignment does not change aVariable¶		if (!aVariable.equals(anAssignmentSNode.getLhsFirstIdentifier())) {¶			return false;¶		}¶		return dependsOn(anAssignmentSNode.getExpressionSNode(), aCallIdentifier);¶//		List<String> aCallIdentifiers = anAssignmentSNode.getRhsCallIdentifiers();¶//		boolean retVal = false;¶//		if (aCallIdentifiers != null && aCallIdentifiers.contains(aCallIdentifier)) {¶//			return true; // this assignment has aCallIdentifier in the rhs¶//		}¶//		// check if some referenced rhs variable depends on aCallIdentifier¶//		List<String> aReferencedVariableIdentifiers = anAssignmentSNode.getRhsVariableIdentifiers();¶//		SNode anAssignmentParent = anAssignmentSNode.getParent();¶//		if (anAssignmentParent == null) { // should never be trye¶//			return false;¶//		}¶//		int aLineNumber = anAssignmentSNode.getLineNumber();¶//		for (String aReferencedVariableIdentifier:aReferencedVariableIdentifiers ) {¶//			if (dependsOn (anAssignmentParent, aLineNumber, aReferencedVariableIdentifier, aCallIdentifier)) {¶//				return true;¶//			}¶//		}¶//		return false;¶	}¶	public static boolean dependsOn (ExpressionSNode anExpressionSNode, String aCallIdentifier) {¶		// This assignment does not change aVariable¶		¶		List<String> aCallIdentifiers = anExpressionSNode.getRhsCallIdentifiers();¶		boolean retVal = false;¶		if (aCallIdentifiers != null && aCallIdentifiers.contains(aCallIdentifier)) {¶			return true; // this assignment has aCallIdentifier in the rhs¶		}¶		// check if some referenced rhs variable depends on aCallIdentifier¶		List<String> aReferencedVariableIdentifiers = anExpressionSNode.getRhsVariableIdentifiers();¶		SNode anAssignmentParent = anExpressionSNode.getParent().getParent();¶		if (anAssignmentParent == null) { // should never be trye¶			return false;¶		}¶		int aLineNumber = anExpressionSNode.getLineNumber();¶		for (String aReferencedVariableIdentifier:aReferencedVariableIdentifiers ) {¶			if (dependsOn (anAssignmentParent, aLineNumber, aReferencedVariableIdentifier, aCallIdentifier)) {¶				return true;¶			}¶		}¶		return false;¶	}¶	public static Set<AssignmentSNode> assignmentsToSharedVariables(SNode anSNode) {¶		Set<AssignmentSNode> retVal =  new HashSet();¶		fillAssignmentsToShared(anSNode, retVal);¶		return retVal;¶		¶	}¶	public static Set<AssignmentSNode> assignmentsToSharedArrays(SNode anSNode) {¶		Set<AssignmentSNode> anAllSharedAssignments =  assignmentsToSharedVariables(anSNode);¶		Set<AssignmentSNode> aRetVal = new HashSet();¶		for (AssignmentSNode anAssignmentSNode:anAllSharedAssignments) {¶			if (anAssignmentSNode.getLhsSubscripts().length > 0) {¶				aRetVal.add(anAssignmentSNode);¶			}¶		}¶		return aRetVal;¶		¶	}¶	public static Set<AssignmentSNode> assignmentsToParallelCriticalSharedVariables(SNode anSNode) {¶		Set<AssignmentSNode> anAllSharedAssignments =  assignmentsToSharedVariables(anSNode);¶		Set<AssignmentSNode> aRetVal = new HashSet();¶		for (AssignmentSNode anAssignmentSNode:anAllSharedAssignments) {¶			if (anAssignmentSNode.isInParallel() &&¶					anAssignmentSNode.isInCritical()) {¶				aRetVal.add(anAssignmentSNode);¶			}¶		}¶		return aRetVal;¶		¶	}¶	public static Set<AssignmentSNode> assignmentsToNonParallelCriticalSharedVariables(SNode anSNode) {¶		Set<AssignmentSNode> anAllSharedAssignments =  assignmentsToSharedVariables(anSNode);¶		Set<AssignmentSNode> aRetVal = new HashSet();¶		for (AssignmentSNode anAssignmentSNode:anAllSharedAssignments) {¶			if (!anAssignmentSNode.isInParallel() &&¶					anAssignmentSNode.isInCritical()) {¶				aRetVal.add(anAssignmentSNode);¶			}¶		}¶		return aRetVal;¶		¶	}¶	public static Set<AssignmentSNode> assignmentsToParallelNonCriticalSharedVariables(SNode anSNode) {¶		Set<AssignmentSNode> anAllSharedAssignments =  assignmentsToSharedVariables(anSNode);¶		Set<AssignmentSNode> aRetVal = new HashSet();¶		for (AssignmentSNode anAssignmentSNode:anAllSharedAssignments) {¶			if (anAssignmentSNode.isInParallel() &&¶					!anAssignmentSNode.isInCritical()) {¶				aRetVal.add(anAssignmentSNode);¶			}¶		}¶		return aRetVal;¶		¶	}¶    public static void fillAssignmentsToShared(SNode anSNode, Set<AssignmentSNode> retVal) {¶    	if (anSNode instanceof AssignmentSNode) {¶			AssignmentSNode anAssignmentSNode = (AssignmentSNode) anSNode;¶			String anLHS = anAssignmentSNode.getLhsFirstIdentifier();¶			if (isSharedVariable(anSNode, anLHS)) {¶				retVal.add(anAssignmentSNode);¶				return;¶			}¶		}¶    	for (SNode aChild:anSNode.getChildren()) {¶    		fillAssignmentsToShared(aChild, retVal);¶    	}¶		¶	}¶    public static void fillInstancesOfNodeType(Class<? extends SNode> aNodeType, SNode anSNode, Set<SNode> retVal) {¶    	if (aNodeType.isAssignableFrom(anSNode.getClass())) {¶			¶				retVal.add(anSNode);¶				return;¶			}¶		¶    	for (SNode aChild:anSNode.getChildren()) {¶    		fillInstancesOfNodeType(aNodeType, aChild, retVal);¶    	}¶		¶	}¶    public static Set<AssignmentSNode>  assignmentSNodes(SNode anSNode) {¶    	Set retVal = new HashSet();    	¶    	fillInstancesOfNodeType(AssignmentSNode.class, anSNode, retVal );¶    	return retVal;¶	}¶   ¶    ¶    public static Set<OMPParallelSNode>  ompParallelSNodes(SNode anSNode) {¶    	Set retVal = new HashSet();    	¶    	fillInstancesOfNodeType(OMPParallelSNode.class, anSNode, retVal );¶    	return retVal;¶	}¶//    public static void fillOMPParallelSNodes(SNode anSNode, Set<OMPParallelSNode> retVal) {¶//    	if (anSNode instanceof OMPParallelSNode) {¶//    		retVal.add((OMPParallelSNode) anSNode);¶//		}¶//    	for (SNode aChild:anSNode.getChildren()) {¶//    		fillOMPParallelSNodes(aChild, retVal);¶//    	}		¶//	}¶    public static Set<ForSNode>  forSNodes(SNode anSNode) {¶    	Set retVal = new HashSet();    	¶    	fillInstancesOfNodeType(ForSNode.class, anSNode, retVal );¶    	return retVal;¶	}¶//    public static void fillForSNodes(SNode anSNode, Set<ForSNode> retVal) {¶//    	if (anSNode instanceof ForSNode) {¶//    		retVal.add((ForSNode) anSNode);¶//		}¶//    	for (SNode aChild:anSNode.getChildren()) {¶//    		fillForSNodes(aChild, retVal);¶//    	}		¶//	}¶    public static Set<OMPForSNode>  ompForSNodes(SNode anSNode) {¶    	Set retVal = new HashSet();    	¶    	fillInstancesOfNodeType(OMPForSNode.class, anSNode, retVal );¶    	return retVal;¶	}¶//    public static void fillOMPForSNodes(SNode anSNode, Set<OMPForSNode> retVal) {¶//    	if (anSNode instanceof OMPForSNode) {¶//    		retVal.add((OMPForSNode) anSNode);¶//		}¶//    	for (SNode aChild:anSNode.getChildren()) {¶//    		fillOMPForSNodes(aChild, retVal);¶//    	}		¶//	}¶    public static Set<OMPForSNode> ompReducingForNodes(SNode anSNode) {¶		Set<OMPForSNode> anAllOMPForSNodes =  ompForSNodes(anSNode);¶		Set<OMPForSNode> aRetVal = new HashSet();¶		for (OMPForSNode anOMPForSNode:anAllOMPForSNodes) {¶			if (anOMPForSNode.getReductionOperation() != null) {¶				aRetVal.add(anOMPForSNode);¶			}¶		}¶		return aRetVal;		¶	}¶    public static Set<AssignmentSNode> assignmentsToOMPReducingForNode(OMPForSNode anOMPForSNode) {¶    	String aReductionVariable = anOMPForSNode.getReductionVariable();¶    	return directAssignmentsOfVariableAndItsAliases(anOMPForSNode, aReductionVariable)	;¶    	¶    }¶	public static boolean dependsOn (SNode anSNode, int aVariableLineNumber, String aVariable, String aCallIdentifier) {¶		List<SNode> aListSNodes = anSNode.getChildren();¶		boolean retVal = false;¶		/*¶		 * Should probably ignore line number as it assumes straight line code¶		 */¶		for (int i = aVariableLineNumber; i >= 0; i--) {¶			SNode anSNodeChild = aListSNodes.get(i);¶			if (anSNodeChild instanceof AssignmentSNode) {¶				// does this statement in anSNode directly invoke aCallIdentifier ¶				if (dependsOn((AssignmentSNode) anSNodeChild, aVariable, aCallIdentifier))¶					return true;¶			} else if (!anSNode.isLeaf()) {¶					// child is overriding the variable so forget checking its assignment statements¶					if (anSNodeChild.getLocalVariableIdentifiers().contains(aVariable)) {¶						continue;¶					}¶					// some subblock of anSNode that has access to aVariable changes variable¶¶					if (dependsOn(anSNodeChild, anSNodeChild.getChildren().size() - 1, aVariable, aCallIdentifier)) {¶						return true;¶					}¶			}¶			¶		}¶		// none of the statements in anSNode or its descendents  have the required call¶		// is the variable a  method parameter ¶		if (anSNode instanceof MethodSNode) {¶			MethodSNode aMethodSNode = (MethodSNode) anSNode;¶			¶			int aParameterNumber = aMethodSNode.getLocalVariableIdentifiers().indexOf(aVariable);¶			if (aParameterNumber != -1) {¶				List <MethodCall> aCalls = aMethodSNode.getCalls();¶				for (MethodCall aCall:aCalls) {¶//					if (!aCall.getMethodActuals().contains(aVariable))¶//						continue;¶//					¶					MethodSNode aCallerSNode = getDeclarationOfCalledMethod(aMethodSNode, aCall);¶					if (dependsOn(aMethodSNode, aCallerSNode.getLineNumber(), aCallerSNode.getLocalVariableIdentifiers().get(aParameterNumber), aCallIdentifier));¶//				    if (aCallerDepends) {¶				    	return true;¶//				    }¶				}¶				return false;¶				// need to find all callers of method and see if any of the aliases for the variable in these¶				// calls depend on aCallIndentifier¶			}			¶			¶		} else if (anSNode.getLocalVariableIdentifiers().contains(aVariable)) {¶			// before going to the parent node, let us see if aVariable is declared here as a non  parameter ¶¶			return false; // no point going to parent¶		}¶		// not a local variable (parameter or declarated variable)¶		SNode anSNodeParent = anSNode.getParent() ;¶		if (anSNodeParent == null)  {¶			return false;¶		}¶		int anSNodeLineNumber = anSNodeParent.getChildren().indexOf(anSNode);¶		return dependsOn(anSNodeParent, anSNodeLineNumber, aVariable, aCallIdentifier);¶		¶	}¶	public static Set<AssignmentSNode> assignmentsOfVariableAliases (SNode anSNode,  String aVariable) {¶		Set<AssignmentSNode> retVal = new HashSet();¶		fillDirectAssignmentsOfVariableA"), Diff(DELETE,"ndItsA"), Diff(EQUAL,"liases(anSNode, aVariable, retVal);¶		return retVal;¶	}¶	public static void fillDirectAssignmentsOfVariableAliases (SNode anSNode,  String aVariable, Set<AssignmentSNode> retVal) {¶		if (anSNode instanceof MethodCall) {¶			MethodCall aMethodCall = (MethodCall) anSNode;¶			int aParameterNumber = aMethodCall.getMethodActualIdentifiers().indexOf(aVariable);¶			if (aParameterNumber < 0) {¶				return;¶			}¶			MethodSNode aDeclaringMethodSNode = getDeclarationOfCalledMethod(anSNode, aMethodCall);¶			String aFormalParameter = aDeclaringMethodSNode.getLocalVariableIdentifiers().get(aParameterNumber);¶//			Set<AssignmentSNode> aCallAssignments = ;¶			fillDirectAssignmentsOfVariableAliases(aDeclaringMethodSNode, aFormalParameter, retVal);¶		} else {¶			List<SNode> aChildren = anSNode.getChildren();¶			for (SNode aChild:aChildren) {¶				fillDirectAssignmentsOfVariableAliases(aChild, aVariable, retVal);¶			}¶		}		¶		¶	}¶	¶	/*¶	 * will not consider assignments to variables in the RHS of these assignments¶	 */¶	public static Set<AssignmentSNode> directAssignmentsOfVariableAndItsAliases (SNode anSNode,  String aVariable) {¶		Set<AssignmentSNode> retVal = new HashSet();¶		fillDirectAssignmentsOfVariableAndItsAliases(anSNode, aVariable, retVal);¶		return retVal;¶	}¶	¶//	public static Set<AssignmentSNode> assignmentsEffectingVariableAndItsAliases (SNode anSNode,  String aVariable) {¶//		Set<AssignmentSNode> retVal = directAssignmentsOfVariableAndItsAliases(anSNode, aVariable);¶//		¶//	}¶	public static void fillDirectAssignmentsOfVariableAndItsAliases (SNode anSNode,  String aVariable, Set<AssignmentSNode> retVal) {¶		if (anSNode instanceof AssignmentSNode) {¶			AssignmentSNode anAssignmentSNode = (AssignmentSNode) anSNode;¶			if (anAssignmentSNode.getLhsFirstIdentifier().equals(aVariable)) {¶				retVal.add(anAssignmentSNode);¶			}¶		}¶		¶		else if (anSNode instanceof MethodCall) {¶			MethodCall aMethodCall = (MethodCall) anSNode;¶			int aParameterNumber = aMethodCall.getMethodActualIdentifiers().indexOf(aVariable);¶			if (aParameterNumber < 0) {¶				return;¶			}¶			MethodSNode aDeclaringMethodSNode = getDeclarationOfCalledMethod(anSNode, aMethodCall);¶			String aFormalParameter = aDeclaringMethodSNode.getLocalVariableIdentifiers().get(aParameterNumber);¶//			Set<AssignmentSNode> aCallAssignments = ;¶			fillDirectAssignmentsOfVariableAndItsAliases(aDeclaringMethodSNode, aFormalParameter, retVal);¶		} else {¶			List<SNode> aChildren = anSNode.getChildren();¶			for (SNode aChild:aChildren) {¶				fillDirectAssignmentsOfVariableAndItsAliases(aChild, aVariable, retVal);¶			}¶		}		¶		¶	}¶	¶	public static RootOfFileSNode getRootOfFileNode(SNode aCurrentSNode ) {¶		if (aCurrentSNode instanceof RootOfFileSNode) {¶			return (RootOfFileSNode) aCurrentSNode;¶		}¶		SNode aParentSNode = aCurrentSNode.getParent() ;¶		¶		if (aParentSNode == null) {¶			return null;¶		}¶		¶		return getRootOfFileNode(aParentSNode);¶		¶	}¶	public static boolean match (MethodSNode aMethodSNode, MethodCall aMethodCall) {¶		return aMethodSNode.getMethodName().equals(aMethodCall.getMethodName()) ¶				&& aMethodSNode.getLocalVariableIdentifiers().size() == aMethodCall.getMethodActuals().size();¶	}¶	public static DeclarationSNode getDeclarationOfVariableIdentifier(SNode aCurrentSNode, String anIdentifier) {¶		if (aCurrentSNode == null) {¶			return null;¶		}¶		¶		¶		int anIndex = aCurrentSNode.getLocalVariableIdentifiers().indexOf(anIdentifier);¶		if (anIndex < 0) {¶			return getDeclarationOfVariableIdentifier(aCurrentSNode.getParent(), anIdentifier);¶		}¶		DeclarationSNode retVal = aCurrentSNode.getVariableDeclarations().get(anIndex);¶//		retVal.getAssignmentsToDeclaredVariable().add(anAssignmentSNode);¶//		anAssignmentSNode.setLhsFirstIdentifierDeclaration(retVal);¶		return retVal;¶	}¶	¶	public static DeclarationSNode getDeclarationOfAssignedVariable(SNode aCurrentSNode, AssignmentSNode anAssignmentSNode) {¶		if (aCurrentSNode == null) {¶			return null;¶		}¶		if (anAssignmentSNode instanceof ADeclaringAssignmentSNode) {¶			return (ADeclaringAssignmentSNode) anAssignmentSNode;¶		}¶		int anIndex = aCurrentSNode.getLocalVariableIdentifiers().indexOf(anAssignmentSNode.getLhsFirstIdentifier());¶		if (anIndex < 0) {¶			return getDeclarationOfAssignedVariable(aCurrentSNode.getParent(), anAssignmentSNode);¶		}¶		DeclarationSNode retVal = aCurrentSNode.getVariableDeclarations().get(anIndex);¶//		retVal.getAssignmentsToDeclaredVariable().add(anAssignmentSNode);¶//		anAssignmentSNode.setLhsFirstIdentifierDeclaration(retVal);¶		return retVal;¶	}¶	¶	public static MethodSNode getDeclarationOfCalledMethod(SNode aCurrentSNode, MethodCall aMethodCall ) {¶		SNode aRootNode = getRootOfFileNode(aCurrentSNode);¶		for (SNode aChild:aRootNode.getChildren()) {¶			if (aChild instanceof MethodSNode) {¶				MethodSNode aMethodSNode = (MethodSNode) aChild;¶				if (match (aMethodSNode, aMethodCall)) {¶					return aMethodSNode;¶				}¶			}¶		}¶		return null; // this should never happen;¶	}¶	¶	public static RootOfProgramSNode getRootOfProgramSNode(String aSource) {¶		RootOfProgramSNode retVal = new ARootOfProgramSNode();¶		Map<String, StringBuffer> aFileNameToContents = ABasicTextManager.extractFileContents(aSource);¶		for (String aFileName:aFileNameToContents.keySet()) {¶			StringBuffer aFileContents = aFileNameToContents.get(aFileName);¶//			List<OpenMPPragma> anOpenMPPragmas = OpenMPUtils.getOpemMPPragmas(aFileContents);¶			RootOfFileSNode anSNode = OMPSNodeUtils.getSNode(aFileName, aFileContents);¶			retVal.getFileNameToSNode().put(aFileName, anSNode);¶			anSNode.setParent(retVal);¶//			System.out.println("file name:" + aFileName);¶//			System.out.println("pragmas:" + anSNode);¶		}¶		processExternalMethodSNodes(retVal);¶		processIndirectAssignments(retVal);¶		return retVal;¶	}¶//	public static void processIndirectAssignments (S aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode) {¶//		for (SNode anSNode:aRootOfFileSNode.getChildren()) {¶//			-----¶//		}¶//	}¶	public static void processExternalMethodSNodes (RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode) {¶		for (SNode anSNode:aRootOfFileSNode.getChildren()) {¶			if (anSNode instanceof ExternalMethodSNode) {¶				processExternalMethodSNode(aRootOfProgramSNode, aRootOfFileSNode, (ExternalMethodSNode) anSNode);¶			}¶		}¶	}¶	public static void processExternalMethodSNode (RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode, ExternalMethodSNode anExternalMethodSNode) {¶		MethodSNode aMethodSNode = aRootOfProgramSNode.getExternalToInternalMethod().get(anExternalMethodSNode.toString());¶		if (aMethodSNode == null) {¶			aMethodSNode = findMethodSNode(aRootOfProgramSNode, aRootOfFileSNode, anExternalMethodSNode);¶			if (aMethodSNode != null) {¶				aRootOfProgramSNode.getExternalToInternalMethod().put(anExternalMethodSNode.toString(),aMethodSNode );¶			}¶		}¶		if (aMethodSNode != null) {¶			anExternalMethodSNode.setActualMethodSNode(aMethodSNode);¶			aMethodSNode.getCalls().addAll(anExternalMethodSNode.getLocalCalls());¶		}¶	}¶	¶	public static MethodSNode findMethodSNode (RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode, ExternalMethodSNode anExternalMethodSNode) {¶//		MethodSNode foundMethodSNode = null;¶		for (String aFileName:aRootOfProgramSNode.getFileNameToSNode().keySet()) {¶			if (aFileName.equals(aRootOfFileSNode.getFileName()))¶				continue;¶			¶			RootOfFileSNode aSearchedRootOfFileSNode = aRootOfProgramSNode.getFileNameToSNode().get(aFileName);¶			 for (SNode anSNode:aSearchedRootOfFileSNode.getChildren()) {¶				if (anSNode instanceof MethodSNode && !(anSNode instanceof ExternalMethodSNode)) {¶					if (anSNode.toString().equals(anExternalMethodSNode.toString())) {¶						return (MethodSNode) anSNode;¶						¶					}¶//					processExternalMethodSNode(aRootOfProgramSNode, aRootOfFileSNode, (ExternalMethodSNode) anSNode);¶				}¶			}¶		}¶		return null;¶	}¶	public static void processExternalMethodSNodes (RootOfProgramSNode aRootOfProgramSNode) {¶		for (String aFileName:aRootOfProgramSNode.getFileNameToSNode().keySet()) {¶			RootOfFileSNode aRootOfFileSNode = aRootOfProgramSNode.getFileNameToSNode().get(aFileName);¶			processExternalMethodSNodes(aRootOfProgramSNode, aRootOfFileSNode);¶			aRootOfFileSNode.getOmp_get_num_threads_SNode().¶				setActualMethodSNode(aRootOfProgramSNode.getOmp_get_num_threads_SNode());¶			aRootOfFileSNode.getOmp_get_thread_num_SNode().¶				setActualMethodSNode(aRootOfProgramSNode.getOmp_get_thread_num_SNode());¶			aRootOfFileSNode.getOmp_get_wtime_SNode().¶			setActualMethodSNode(aRootOfProgramSNode.getOmp_get_wtime_SNode());¶		}¶¶	}¶	public static void processIndirectAssignments (SNode anSNode) {¶		if (anSNode instanceof ConstDeclarationSNode) {¶			return;¶		}¶		if (anSNode instanceof DeclarationSNode) {¶			DeclarationSNode aDeclarationSNode = (DeclarationSNode) anSNode;¶			Set<AssignmentSNode> anIndirectAssignments = aDeclarationSNode.getAssignmentsEffectingDeclaredIdentifier();¶			if (anIndirectAssignments != null) {¶				return; // already assigned¶			}¶			anIndirectAssignments = new HashSet<>();¶			aDeclarationSNode.setAssignmentsEffectingDeclaredIdentifier(anIndirectAssignments);¶			Set<AssignmentSNode> aDirectAssignments = aDeclarationSNode.getAssignmentsToDeclaredVariable();¶			anIndirectAssignments.addAll(aDirectAssignments);¶			Set<AssignmentSNode> anAliasAssignments = assignmentsOfVariableAliases(aDeclarationSNode.getParent(), aDeclarationSNode.getVariableName());¶			anIndirectAssignments.addAll(anAliasAssignments);¶			for (AssignmentSNode aDirectAssignment:aDirectAssignments) {¶				List<String> aVariableIdentifiers = aDirectAssignment.getRhsVariableIdentifiers();¶				¶				for (String aVariableIdentifier:aVariableIdentifiers) {¶					DeclarationSNode aDependeeDeclarationSNode = getDeclarationOfVariableIdentifier(aDirectAssignment, aVariableIdentifier);¶					if (aDependeeDeclarationSNode == null) {¶						System.err.println("Could not find declaration of:" + aVariableIdentifier + " referenced in:" + aDirectAssignment );¶						continue;¶					}¶					processIndirectAssignments(aDependeeDeclarationSNode);¶					Set<AssignmentSNode> aDependeeIndirectAssignments = aDeclarationSNode.getAssignmentsEffectingDeclaredIdentifier();¶					anIndirectAssignments.addAll(aDependeeIndirectAssignments);¶					¶				}¶			}¶		} else {¶			for (SNode aChild: anSNode.getChildren()) {¶				processIndirectAssignments(aChild);¶			}¶		}¶		¶	}¶	¶//	public static void fillIndirectAssignments (SNode anSNode, Set<AssignmentSNode> retVal ) {¶//		¶//	}¶	¶¶//	public static void main(String[] args) {¶//		List<MethodCall> aTokens = callsIn("foo(bar, hgf)/foo2()*foo3(b, a c,)");¶//		System.out.println(aTokens);¶//		¶//		¶////		List<String> aTokens = identifiersIn("a[i] + b*2/3");¶////		System.out.println(aTokens);¶////		aTokens = numbersIn("a[i] + b*2/3");¶////		System.out.println(aTokens);¶////		aTokens = operatorsIn("a[i] + b*2/3");¶////		System.out.println(aTokens);¶////¶////		System.out.println(StringUtils.substringBetween("a", "[", "]"));¶//	}¶¶}¶")]]]></diff>
    <snapshot><![CDATA[package gradingTools.shared.testcases.openmp.scannedTree;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Stack;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.apache.commons.lang.StringUtils;

import grader.basics.project.source.ABasicTextManager;
import gradingTools.shared.testcases.openmp.OpenMPKeywordEnum;
import gradingTools.shared.testcases.openmp.OpenMPParallelPragma;
import gradingTools.shared.testcases.openmp.OpenMPUtils;
import gradingTools.shared.testcases.openmp.scannedTree.ADeclarationSNode;
import gradingTools.shared.testcases.openmp.scannedTree.ADeclaringAssignmentSNode;
import gradingTools.shared.testcases.openmp.scannedTree.AForSNode;
import gradingTools.shared.testcases.openmp.scannedTree.ATextSNode;
import gradingTools.shared.testcases.openmp.scannedTree.AnAssignmentSNode;
import gradingTools.shared.testcases.openmp.scannedTree.AnOMPCriticalSNode;
import gradingTools.shared.testcases.openmp.scannedTree.AnOMPForSNode;
import gradingTools.shared.testcases.openmp.scannedTree.AnOMPParallelSNode;
import gradingTools.shared.testcases.openmp.scannedTree.AnOMPSNode;
import gradingTools.shared.testcases.openmp.scannedTree.AnSNode;
import gradingTools.shared.testcases.openmp.scannedTree.AssignmentSNode;
import gradingTools.shared.testcases.openmp.scannedTree.DeclarationSNode;
import gradingTools.shared.testcases.openmp.scannedTree.DeclaringAssignmentSNode;
import gradingTools.shared.testcases.openmp.scannedTree.ForSNode;
import gradingTools.shared.testcases.openmp.scannedTree.OMPForSNode;
import gradingTools.shared.testcases.openmp.scannedTree.OMPSNode;
import gradingTools.shared.testcases.openmp.scannedTree.SNode;

public class OMPSNodeUtils extends OpenMPUtils {

	public static RootOfFileSNode getSNode(String aFileName, StringBuffer aFileBuffer) {
		String[] aFileLines = aFileBuffer.toString().split("\n");
		return getSNode(aFileName, aFileLines);
	}

	public static AssignmentSNode getAssignmentSNode(int aLineNumber, String aString) {
		if (aString == null) {
			return null;
		}
		String[] aTokens = aString.split("=");
		if (aTokens.length == 1) {
			return new AnAssignmentSNode(aLineNumber, aTokens[0], null);
		} else {
		return new AnAssignmentSNode(aLineNumber, aTokens[0], aTokens[1]);
		}
	}

	public static DeclarationSNode getDeclarationSNode(int aLineNumber, String aString) {
		String[] aTokens = aString.split(" ");
		return new ADeclarationSNode(aLineNumber, aTokens[0], aTokens[1]);
	}

	public static DeclaringAssignmentSNode getDeclaringAssignmentSNode(int aLineNumber, String aString) {
		String[] anLHSAndRHS = aString.split("=");
		String[] aTypeAndVariable = anLHSAndRHS[0].split(" ");
		return new ADeclaringAssignmentSNode(aLineNumber, aTypeAndVariable[0], aTypeAndVariable[1], anLHSAndRHS[1]);
	}
	public static ConstDeclarationSNode getConstDeclarationSNode(int aLineNumber, String aString) {
		String anAssignmentString = aString.substring(CONST.length()).trim();
		String[] anLHSAndRHS = anAssignmentString.split("=");
		String[] aTypeAndVariable = anLHSAndRHS[0].split(" ");
		return new AConstDeclarationSNode(aLineNumber, aTypeAndVariable[0], aTypeAndVariable[1], anLHSAndRHS[1]);
	}

	public static boolean isDeclaringAssignment(String aFileLine) {
		return startsWithTypeName(aFileLine) && aFileLine.contains("=");
	}
	public static boolean isConstDeclaration(String aFileLine) {
		return aFileLine.startsWith(CONST);
	}
	public static boolean isMethodDeclaration(String aFileLine) {
		return startsWithTypeName(aFileLine) && 
				aFileLine.contains("(") &&
				!aFileLine.contains("=");
	}
	public static boolean isExternalMethodDeclaration(String aFileLine) {
		return isMethodDeclaration(aFileLine) && aFileLine.endsWith(";");
	}


	public static boolean isVariableDeclaration(String aFileLine) {

		return startsWithTypeName(aFileLine) && !aFileLine.contains("(");
	}

	public static boolean isAssignment(String aFileLine) {
		return aFileLine.contains("=") && !aFileLine.contains("==");
	}

	public static boolean isForNode(String aFileLine) {
		return aFileLine.startsWith("for");
	}

	public static ForSNode getForSNode(int aLineNumber, String aFileLine) {

		int aLeftParenIndex = aFileLine.indexOf("(");
		int aRightParenIndex = aFileLine.indexOf(")");
		if (aLeftParenIndex < 0 || aRightParenIndex < 0) {
			return null;
		}
		String aHeaderString = aFileLine.substring(aLeftParenIndex + 1, aRightParenIndex);
		String[] aForComponents = aHeaderString.split(";");
		AssignmentSNode anAssignmentSNode = null;
		String aForInitializaton = aForComponents[0];
		if (!aForInitializaton.isEmpty() && aForInitializaton.contains("=")) {
			if (isDeclaringAssignment(aForInitializaton)) {
				anAssignmentSNode = getDeclaringAssignmentSNode(aLineNumber, aForInitializaton);
			} else {
				anAssignmentSNode = getAssignmentSNode(aLineNumber, aForInitializaton);
			}

		}		
		return new AForSNode(aLineNumber, anAssignmentSNode, aForComponents[1], getAssignmentSNode(aLineNumber, aForComponents[2]));
	}
	static String[] emptyArray = {};
	public static MethodSNode getMethodSNode(int aLineNumber, String aFileLine, boolean isInternal) {

		int aLeftParenIndex = aFileLine.indexOf("(");
		int aRightParenIndex = aFileLine.indexOf(")");
		if (aLeftParenIndex < 0 || aRightParenIndex < 0) {
			return null;
		}
		String aMethodNameAndType = aFileLine.substring(0, aLeftParenIndex);
		String[] aMethodNameAndTypeTokens = aMethodNameAndType.split("\\s+"); 
		
		String aMethodParameters = aFileLine.substring(aLeftParenIndex +1 , aRightParenIndex);
		String[] aMethodParameterTokens = aMethodParameters.isEmpty()?emptyArray:
		 aMethodParameters.split(",");
		
//		String[] aMethodParameterTypes = new String[aMethodParameterTokens.length];
//		String[] aMethodParameterNames = new String[aMethodParameterTokens.length];
		List<DeclarationSNode> aDeclarationSNodeList = new ArrayList();
		for (int i = 0; i < aMethodParameterTokens.length; i++ ) {
			String[] aTypeAndName = aMethodParameterTokens[i].trim().split("\\s+");
			if (aTypeAndName.length < 2) {
				continue;
			}
			aDeclarationSNodeList.add(new ADeclarationSNode(aLineNumber, aTypeAndName[0].trim(), aTypeAndName[1].trim()));
//			aMethodParameterTypes[i] = aTypeAndName[0].trim();
//			aMethodParameterNames[i] = aTypeAndName[1].trim();
		}
		if (isInternal)
//		return new AMethodSNode(aLineNumber, aMethodNameAndTypeTokens[0], aMethodNameAndTypeTokens[1], aMethodParameterTypes,aMethodParameterNames );
			return new AMethodSNode(aLineNumber, aMethodNameAndTypeTokens[0], aMethodNameAndTypeTokens[1], aDeclarationSNodeList );
		else
			return new AnExternalMethodSNode(aLineNumber, aMethodNameAndTypeTokens[0], aMethodNameAndTypeTokens[1], aDeclarationSNodeList );
	}

	public static void setReductionData(OMPForSNode lastChild, String aStoredToken, int aLeftParenIndex,
			int aRightParenIndex) {
		int aColonIndex = aStoredToken.indexOf(":");
		if (aLeftParenIndex != -1 && aRightParenIndex != -1 && aColonIndex != -1) {
			String anOperationString = aStoredToken.substring(aLeftParenIndex + 1, aColonIndex).trim();
			String aVariableString = aStoredToken.substring(aColonIndex + 1, aRightParenIndex).trim();
			((OMPForSNode) lastChild).setReductionVariable(aVariableString);
			((OMPForSNode) lastChild).setReductionOperation(anOperationString);
		}
	}

	public static void setSharedOrPrivateData(OMPSNode lastChild, String aStoredToken, int aLeftParenIndex,
			int aRightParenIndex, boolean isShared) {
//		int aColonIndex = aStoredToken.indexOf(":");
		if (aLeftParenIndex != -1 && aRightParenIndex != -1) {
			String aVariableDeclarations = aStoredToken.substring(aLeftParenIndex + 1, aRightParenIndex);
			String[] aVariables = aVariableDeclarations.split(",");
			if (isShared) {
				lastChild.setSharedVariables(aVariables);
			} else {
				lastChild.setPrivateVariables(aVariables);
			}
		}
	}

	public static RootOfFileSNode getSNode(String aFileName, String[] aFileLines) {
		Stack<SNode> anSNodes = new Stack();

		RootOfFileSNode retVal = new ARootOfFileSNode(aFileName);
		anSNodes.add(retVal);
		SNode previousHeaderNode = null;
		for (int i = 0; i < aFileLines.length; i++) {
			String aFileLine = aFileLines[i].trim();
			if (!isCodeLine(aFileLine)) {
				continue;
			}
			if (isForNode(aFileLine)) {
				ForSNode aForSNode = getForSNode(i, aFileLine);
				SNode aParent = previousHeaderNode != null?previousHeaderNode:anSNodes.peek();
				aForSNode.setParent(anSNodes.peek());
				aForSNode.setParent(aParent);

//				anSNodes.push(aForSNode);
				previousHeaderNode = aForSNode;
				if (aFileLine.endsWith(")")) {
					continue;
				}
			}
			if (isExternalMethodDeclaration(aFileLine)) {
				MethodSNode aMethodSNode = getMethodSNode(i, aFileLine, false);
				aMethodSNode.setParent(anSNodes.peek());
//				anSNodes.push(aForSNode);
				previousHeaderNode = aMethodSNode;
				if (aFileLine.endsWith(")")) {
					continue;
				}
			}
			if (isMethodDeclaration(aFileLine)) {
				MethodSNode aMethodSNode = getMethodSNode(i, aFileLine, true);
				aMethodSNode.setParent(anSNodes.peek());
//				anSNodes.push(aForSNode);
				previousHeaderNode = aMethodSNode;
				if (aFileLine.endsWith(")")) {
					continue;
				}
			}
			if (isPragmaStart(aFileLine)) {
				OMPSNode anOMPSNode = getOMPSNode(i, anSNodes.peek(), aFileLine);
//				anSNodes.push(anOMPSNode);
				previousHeaderNode = anOMPSNode;
				continue;
			}
			if (isBlockStart(aFileLine)) {
				SNode aBlockSNode = new ABlockSNode(i);
				if (previousHeaderNode != null) {
					aBlockSNode.setParent(previousHeaderNode);
				} else {
					aBlockSNode.setParent(anSNodes.peek());
				}
				anSNodes.push(aBlockSNode);
				previousHeaderNode = null;
				continue;
			}
//			} else 
			if (isBlockEnd(aFileLine)) {
				anSNodes.pop();
				continue;
			}
			SNode aNewLeafNode = null;
			if (isConstDeclaration(aFileLine)) {
				aNewLeafNode = getConstDeclarationSNode(i, aFileLine);

			} else if (isDeclaringAssignment(aFileLine)) {
				aNewLeafNode = getDeclaringAssignmentSNode(i, aFileLine);

			} else if (isAssignment(aFileLine)) {
				aNewLeafNode = getAssignmentSNode(i, aFileLine);
			} else if (isVariableDeclaration(aFileLine)) {
				aNewLeafNode = getDeclarationSNode(i, aFileLine);
			} else {
				List<MethodCall> aCalls = callsIn(i, aFileLine, null); // parent will be assigned below
				if (aCalls != null && aCalls.size() == 1) {
					aNewLeafNode = aCalls.get(0);
				} else {
					aNewLeafNode = new ATextSNode(i, aFileLine);
				}
			}
//			else {
//				aNewLeafNode = new ATextSNode(i, aFileLine);
//			}
			if (previousHeaderNode != null) {
				aNewLeafNode.setParent(previousHeaderNode);
			} else {
				aNewLeafNode.setParent(anSNodes.peek());
			}

		}

		return retVal;
	}

	public static OMPSNode getOMPSNode(int aLineIndex, SNode aParentNode, String aFileLine) {
		String[] aTokens = aFileLine.split("\\s+");
		if (aTokens.length <= 2) {
			return null;
		}
		if (!aTokens[1].equals("omp")) {
			return null;
		}
		if (aTokens.length < 3) {
			return null;
		}
		String aFirstToken = aTokens[2];
		OpenMPKeywordEnum anOpenMPKeyword = stringToOpenMPKeyword.get(aFirstToken);
//		List<OpenMPPragma> retVal = new ArrayList();
		OMPSNode lastChild = null;
		int aStartIndex = 2;
		OMPSNode aNewNode = null;
		OMPForSNode aForChild = null;
		switch (anOpenMPKeyword) {
		case PARALLEL:
			aNewNode = new AnOMPParallelSNode(aLineIndex);

			if (aTokens.length > 3 && aTokens[3].equals("for")) {
				aForChild = new AnOMPForSNode(aLineIndex);
				aForChild.setParent(aNewNode);

				aStartIndex++;
			}
			break;
		case FOR:
			aNewNode = new AnOMPForSNode(aLineIndex);
			;
			break;
		case CRITICAL:
			aNewNode = new AnOMPCriticalSNode(aLineIndex);
//			retVal.add (lastChild);
			break;
		default:
			aNewNode = new AnOMPSNode(aLineIndex);

		}

		if (lastChild != null) {
			aNewNode.setParent(lastChild);
		} else {
			aNewNode.setParent(aParentNode);
		}
		lastChild = aForChild == null ? aNewNode : aForChild;

		for (int i = aStartIndex; i < aTokens.length; i++) {
			String aStoredToken = aTokens[i].trim();
			if (aStoredToken.isEmpty()) {
				continue;
			}
			if (aStoredToken.startsWith("reduction") || aStoredToken.startsWith("shared")
					|| aStoredToken.startsWith("private")) {
				// combine all tokens until ")" into one for normalization
				while (!aStoredToken.endsWith(")")) {
					i++;
					if (i >= aTokens.length) {
						break;
					}
					String aNewToken = aTokens[i].trim();
					aStoredToken += aNewToken;
				}
				int aLeftParenIndex = aStoredToken.indexOf("(");
				int aRightParenIndex = aStoredToken.indexOf(")");
				if (aStoredToken.startsWith("reduction")) {
					setReductionData((OMPForSNode) lastChild, aStoredToken, aLeftParenIndex, aRightParenIndex);
				} else if (aStoredToken.startsWith("private")) {
					setSharedOrPrivateData((OMPSNode) lastChild, aStoredToken, aLeftParenIndex, aRightParenIndex,
							false);

				} else if (aStoredToken.startsWith("shared")) {
					setSharedOrPrivateData(lastChild, aStoredToken, aLeftParenIndex, aRightParenIndex, true);

				}

			}

			lastChild.getOpenMPTokens().add(aStoredToken);
		}

		return lastChild;

	}

	public static boolean hasParallelAncestor(SNode anSNode) {
		if (anSNode == null) {
			return false;
		}
		if (anSNode instanceof OMPParallelSNode) {
			return true;
		}
		return hasParallelAncestor(anSNode.getParent());
	}
	public static boolean hasCriticalAncestor(SNode anSNode) {
		if (anSNode == null) {
			return false;
		}
		if (anSNode instanceof OMPCriticalSNode) {
			return true;
		}
		return hasCriticalAncestor(anSNode.getParent());
	}


	public static Boolean isDeclaredShared(OMPSNode anOMPSNode, String anLHS) {
		if (Arrays.asList(anOMPSNode.getSharedVariables()).contains(anLHS)) {
			return true;
		}
		if (Arrays.asList(anOMPSNode.getPrivateVariables()).contains(anLHS)) {
			return false;
		}
		return null;

	}

	public static boolean isSharedVariable(SNode anSNode, String anLHS) {
		if (anSNode == null) {
			return false;
		}
		if (anSNode.getLocalVariableIdentifiers().contains(anLHS)) {
			if (!(anSNode instanceof OMPSNode)) { // no shared and private declarations
				return !hasParallelAncestor(anSNode); // shared if not inParallel
			}
			OMPSNode anOMPSNode = (OMPSNode) anSNode;
			return (Arrays.asList(anOMPSNode.getSharedVariables()).contains(anLHS)); // private unless declared shared
		}
		if (anSNode instanceof OMPSNode) {
			OMPSNode anOMPSNode = (OMPSNode) anSNode;
			// the variable is global to this scope, check if it has have been made shared
			// or private by this scope
			Boolean isDeclaredShared = isDeclaredShared(anOMPSNode, anLHS);
			if (isDeclaredShared != null) {
				return isDeclaredShared;
			}
		}
		// check the parent
		return isSharedVariable(anSNode.getParent(), anLHS);
	}

	public static List<SNode> getAllLeafNodes(SNode aTopNode) {
		List<SNode> retVal = new ArrayList();
		addLeafNodes(aTopNode, retVal);
		return retVal;
	}

	public static void addLeafNodes(SNode aTopNode, List<SNode> retVal) {
		for (SNode aChild : aTopNode.getChildren()) {
			if (aChild.isLeaf()) {
				retVal.add(aChild);
			} else {
				addLeafNodes(aChild, retVal);
			}
		}
	}

	public static List<SNode> getNonParallelLeafNodes(SNode aTopNode) {
		List<SNode> retVal = new ArrayList();
		addNonParallelLeafNodes(aTopNode, retVal);
		return retVal;
	}

	public static void addNonParallelLeafNodes(SNode aTopNode, List<SNode> retVal) {
		if (aTopNode.isInParallel()) {
			return;
		}
		for (SNode aChild : aTopNode.getChildren()) {
			if (aChild.isLeaf()) {
				retVal.add(aChild);
			} else {
				addLeafNodes(aChild, retVal);
			}
		}
	}
	static String callRegex = "([a-zA-Z_$][a-zA-Z_$0-9]*)\\(.*?\\)";
	static Pattern callPattern = Pattern.compile(callRegex);

	static String identifierRegex = "[a-zA-Z_$][a-zA-Z_$0-9]*";
	static Pattern identifierPattern = Pattern.compile(identifierRegex);
	public static List<String> identifiersIn(String aString) {
		if (aString == null)
			return null;
//		Pattern mypattern = Pattern.compile("[a-zA-Z_$][a-zA-Z_$0-9]*");
//		Matcher mymatcher = mypattern.matcher(aString);
		Matcher mymatcher = identifierPattern.matcher(aString);
		List<String> retVal = new ArrayList();
		while (mymatcher.find()) {
			String find = mymatcher.group(0);
			retVal.add(find);
		}
		return retVal;
	}
	public static List<MethodCall> callsIn(int aLineNumber, String aString, SNode aParent) {
		if (aString == null)
			return emptyList;
		if (isMethodDeclaration(aString)) {
			return emptyList;
		}
//		Pattern mypattern = Pattern.compile("[a-zA-Z_$][a-zA-Z_$0-9]*");
//		Matcher mymatcher = mypattern.matcher(aString);
		Matcher mymatcher = callPattern.matcher(aString);
		List<MethodCall> retVal = new ArrayList();
		while (mymatcher.find()) {
			String find = mymatcher.group(0);
			int aLeftParenIndex = find.indexOf("(");
			int aRightParenIndex = find.indexOf(")");
			String aMethodName = find.substring(0, aLeftParenIndex).trim();
			String aParameters = find.substring(aLeftParenIndex + 1, aRightParenIndex);
			List<String> aParameterList = new ArrayList();
			String[] aParameterTokens = aParameters.split(",");
			for (String aParameter:aParameterTokens) {
				String aParameterTrimmed = aParameter.trim();
				if (!aParameterTrimmed.isEmpty())
				aParameterList.add(aParameterTrimmed);
			}
			retVal.add(new AMethodCall(aLineNumber, aMethodName, aParameterList, aParent));

//			aCallStrings.add(find);
		}
		return retVal;
	}
	static String numberRegex = "(\\d+\\.\\d+)|(\\d+)";
	static Pattern numberPattern = Pattern.compile(numberRegex);
	public static List<String> numbersIn(String aString) {
		if (aString == null)
			return null;
//		String regex = "(\\d+\\.\\d+)|(\\d+)";
//
//		Matcher m = Pattern.compile(regex).matcher(aString);
		Matcher m =numberPattern.matcher(aString);


		List<String> retVal = new ArrayList();

		while (m.find()) {
			retVal.add(m.group());
		}
		return retVal;
	}

	public static String subscriptIn(String aString) {
		if (aString == null)
			return null;
		return StringUtils.substringBetween(aString, "[", "]");
	}
	static String[] emptyStringArray = {};
	static List emptyList = new ArrayList();

	public static String[] subscriptsIn(String aString) {
		if (aString == null)
			return emptyStringArray;
		return StringUtils.substringsBetween(aString, "[", "]");
	}
	static  String operatorRegex = "([+-/*///^])|([/(/)])";
	static Pattern operatorPattern = Pattern.compile(operatorRegex);

	public static List<String> operatorsIn(String aString) {
		if (aString == null)
			return null;
//		String operatorRegex = "([+-/*///^])|([/(/)])";
//
//		Matcher m = Pattern.compile(operatorRegex).matcher(aString);
		
		Matcher m = operatorPattern.matcher(aString);


		List<String> retVal = new ArrayList();

		while (m.find()) {
			retVal.add(m.group());
		}
		return retVal;
	}
	
	public static int numberOfNestingFors (SNode anSNode) {
		if (anSNode == null) {
			return 0;
		}
		int retVal = numberOfNestingFors (anSNode.getParent()) ;

		if (anSNode instanceof ForSNode) {
			retVal++;
		} else if (anSNode instanceof MethodSNode) {
			List<MethodCall> aMethodCalls = ((MethodSNode) anSNode).getCalls();
			int aMaxNestingLevel = 0;
			for (MethodCall aMethodCall:aMethodCalls) {
				MethodSNode aCallerMethodSNode = getDeclarationOfCalledMethod(anSNode, aMethodCall);
				int aCallerNumberOfNestingFors = numberOfNestingFors(aCallerMethodSNode);
				aMaxNestingLevel = Math.max(aCallerNumberOfNestingFors, aMaxNestingLevel);				
			}
			return retVal + aMaxNestingLevel;
		}
		return retVal;
	}
	public static boolean hasOperator (SNode anSNode, String anOperator) {
		boolean retVal = false;
		if (anSNode instanceof AssignmentSNode) {
			AssignmentSNode anAssignmentSNode = (AssignmentSNode) anSNode;
			 retVal = (anAssignmentSNode.getLhsOperators().contains(anOperator) || 
					anAssignmentSNode.getRhsOperators().contains(anOperator)) ;
			if (retVal) {
				return retVal;
			} else {
				List<MethodCall> aMethodCalls = anAssignmentSNode.getRhsCalls();
				for (MethodCall aMethodCall:aMethodCalls) {
					MethodSNode aMethodSNode = getDeclarationOfCalledMethod(anSNode, aMethodCall);
					retVal = hasOperator(aMethodSNode, anOperator);
					if (retVal) {
						return retVal;
					}
					
				}
				return false;
			}
			
		}
		for (SNode aChild:anSNode.getChildren()) {
			retVal = hasOperator(aChild, anOperator);
			if (retVal) {
				return retVal;
			}
		}
		return false;
	}
	public static boolean hasMethodCall (SNode anSNode, String anOperator) {
		boolean retVal = false;
		if (anSNode instanceof AssignmentSNode) {
			AssignmentSNode anAssignmentSNode = (AssignmentSNode) anSNode;
			 retVal = (anAssignmentSNode.getLhsOperators().contains(anOperator) || 
					anAssignmentSNode.getRhsOperators().contains(anOperator)) ;
			if (retVal) {
				return retVal;
			} else {
				List<MethodCall> aMethodCalls = anAssignmentSNode.getRhsCalls();
				for (MethodCall aMethodCall:aMethodCalls) {
					MethodSNode aMethodSNode = getDeclarationOfCalledMethod(anSNode, aMethodCall);
					retVal = hasOperator(aMethodSNode, anOperator);
					if (retVal) {
						return retVal;
					}
					
				}
				return false;
			}
			
		}
		for (SNode aChild:anSNode.getChildren()) {
			retVal = hasOperator(aChild, anOperator);
			if (retVal) {
				return retVal;
			}
		}
		return false;
	}
	public static boolean dependsOn (AssignmentSNode anAssignmentSNode, String aVariable, String aCallIdentifier) {
		// This assignment does not change aVariable
		if (!aVariable.equals(anAssignmentSNode.getLhsFirstIdentifier())) {
			return false;
		}
		return dependsOn(anAssignmentSNode.getExpressionSNode(), aCallIdentifier);
//		List<String> aCallIdentifiers = anAssignmentSNode.getRhsCallIdentifiers();
//		boolean retVal = false;
//		if (aCallIdentifiers != null && aCallIdentifiers.contains(aCallIdentifier)) {
//			return true; // this assignment has aCallIdentifier in the rhs
//		}
//		// check if some referenced rhs variable depends on aCallIdentifier
//		List<String> aReferencedVariableIdentifiers = anAssignmentSNode.getRhsVariableIdentifiers();
//		SNode anAssignmentParent = anAssignmentSNode.getParent();
//		if (anAssignmentParent == null) { // should never be trye
//			return false;
//		}
//		int aLineNumber = anAssignmentSNode.getLineNumber();
//		for (String aReferencedVariableIdentifier:aReferencedVariableIdentifiers ) {
//			if (dependsOn (anAssignmentParent, aLineNumber, aReferencedVariableIdentifier, aCallIdentifier)) {
//				return true;
//			}
//		}
//		return false;
	}
	public static boolean dependsOn (ExpressionSNode anExpressionSNode, String aCallIdentifier) {
		// This assignment does not change aVariable
		
		List<String> aCallIdentifiers = anExpressionSNode.getRhsCallIdentifiers();
		boolean retVal = false;
		if (aCallIdentifiers != null && aCallIdentifiers.contains(aCallIdentifier)) {
			return true; // this assignment has aCallIdentifier in the rhs
		}
		// check if some referenced rhs variable depends on aCallIdentifier
		List<String> aReferencedVariableIdentifiers = anExpressionSNode.getRhsVariableIdentifiers();
		SNode anAssignmentParent = anExpressionSNode.getParent().getParent();
		if (anAssignmentParent == null) { // should never be trye
			return false;
		}
		int aLineNumber = anExpressionSNode.getLineNumber();
		for (String aReferencedVariableIdentifier:aReferencedVariableIdentifiers ) {
			if (dependsOn (anAssignmentParent, aLineNumber, aReferencedVariableIdentifier, aCallIdentifier)) {
				return true;
			}
		}
		return false;
	}
	public static Set<AssignmentSNode> assignmentsToSharedVariables(SNode anSNode) {
		Set<AssignmentSNode> retVal =  new HashSet();
		fillAssignmentsToShared(anSNode, retVal);
		return retVal;
		
	}
	public static Set<AssignmentSNode> assignmentsToSharedArrays(SNode anSNode) {
		Set<AssignmentSNode> anAllSharedAssignments =  assignmentsToSharedVariables(anSNode);
		Set<AssignmentSNode> aRetVal = new HashSet();
		for (AssignmentSNode anAssignmentSNode:anAllSharedAssignments) {
			if (anAssignmentSNode.getLhsSubscripts().length > 0) {
				aRetVal.add(anAssignmentSNode);
			}
		}
		return aRetVal;
		
	}
	public static Set<AssignmentSNode> assignmentsToParallelCriticalSharedVariables(SNode anSNode) {
		Set<AssignmentSNode> anAllSharedAssignments =  assignmentsToSharedVariables(anSNode);
		Set<AssignmentSNode> aRetVal = new HashSet();
		for (AssignmentSNode anAssignmentSNode:anAllSharedAssignments) {
			if (anAssignmentSNode.isInParallel() &&
					anAssignmentSNode.isInCritical()) {
				aRetVal.add(anAssignmentSNode);
			}
		}
		return aRetVal;
		
	}
	public static Set<AssignmentSNode> assignmentsToNonParallelCriticalSharedVariables(SNode anSNode) {
		Set<AssignmentSNode> anAllSharedAssignments =  assignmentsToSharedVariables(anSNode);
		Set<AssignmentSNode> aRetVal = new HashSet();
		for (AssignmentSNode anAssignmentSNode:anAllSharedAssignments) {
			if (!anAssignmentSNode.isInParallel() &&
					anAssignmentSNode.isInCritical()) {
				aRetVal.add(anAssignmentSNode);
			}
		}
		return aRetVal;
		
	}
	public static Set<AssignmentSNode> assignmentsToParallelNonCriticalSharedVariables(SNode anSNode) {
		Set<AssignmentSNode> anAllSharedAssignments =  assignmentsToSharedVariables(anSNode);
		Set<AssignmentSNode> aRetVal = new HashSet();
		for (AssignmentSNode anAssignmentSNode:anAllSharedAssignments) {
			if (anAssignmentSNode.isInParallel() &&
					!anAssignmentSNode.isInCritical()) {
				aRetVal.add(anAssignmentSNode);
			}
		}
		return aRetVal;
		
	}
    public static void fillAssignmentsToShared(SNode anSNode, Set<AssignmentSNode> retVal) {
    	if (anSNode instanceof AssignmentSNode) {
			AssignmentSNode anAssignmentSNode = (AssignmentSNode) anSNode;
			String anLHS = anAssignmentSNode.getLhsFirstIdentifier();
			if (isSharedVariable(anSNode, anLHS)) {
				retVal.add(anAssignmentSNode);
				return;
			}
		}
    	for (SNode aChild:anSNode.getChildren()) {
    		fillAssignmentsToShared(aChild, retVal);
    	}
		
	}
    public static void fillInstancesOfNodeType(Class<? extends SNode> aNodeType, SNode anSNode, Set<SNode> retVal) {
    	if (aNodeType.isAssignableFrom(anSNode.getClass())) {
			
				retVal.add(anSNode);
				return;
			}
		
    	for (SNode aChild:anSNode.getChildren()) {
    		fillInstancesOfNodeType(aNodeType, aChild, retVal);
    	}
		
	}
    public static Set<AssignmentSNode>  assignmentSNodes(SNode anSNode) {
    	Set retVal = new HashSet();    	
    	fillInstancesOfNodeType(AssignmentSNode.class, anSNode, retVal );
    	return retVal;
	}
   
    
    public static Set<OMPParallelSNode>  ompParallelSNodes(SNode anSNode) {
    	Set retVal = new HashSet();    	
    	fillInstancesOfNodeType(OMPParallelSNode.class, anSNode, retVal );
    	return retVal;
	}
//    public static void fillOMPParallelSNodes(SNode anSNode, Set<OMPParallelSNode> retVal) {
//    	if (anSNode instanceof OMPParallelSNode) {
//    		retVal.add((OMPParallelSNode) anSNode);
//		}
//    	for (SNode aChild:anSNode.getChildren()) {
//    		fillOMPParallelSNodes(aChild, retVal);
//    	}		
//	}
    public static Set<ForSNode>  forSNodes(SNode anSNode) {
    	Set retVal = new HashSet();    	
    	fillInstancesOfNodeType(ForSNode.class, anSNode, retVal );
    	return retVal;
	}
//    public static void fillForSNodes(SNode anSNode, Set<ForSNode> retVal) {
//    	if (anSNode instanceof ForSNode) {
//    		retVal.add((ForSNode) anSNode);
//		}
//    	for (SNode aChild:anSNode.getChildren()) {
//    		fillForSNodes(aChild, retVal);
//    	}		
//	}
    public static Set<OMPForSNode>  ompForSNodes(SNode anSNode) {
    	Set retVal = new HashSet();    	
    	fillInstancesOfNodeType(OMPForSNode.class, anSNode, retVal );
    	return retVal;
	}
//    public static void fillOMPForSNodes(SNode anSNode, Set<OMPForSNode> retVal) {
//    	if (anSNode instanceof OMPForSNode) {
//    		retVal.add((OMPForSNode) anSNode);
//		}
//    	for (SNode aChild:anSNode.getChildren()) {
//    		fillOMPForSNodes(aChild, retVal);
//    	}		
//	}
    public static Set<OMPForSNode> ompReducingForNodes(SNode anSNode) {
		Set<OMPForSNode> anAllOMPForSNodes =  ompForSNodes(anSNode);
		Set<OMPForSNode> aRetVal = new HashSet();
		for (OMPForSNode anOMPForSNode:anAllOMPForSNodes) {
			if (anOMPForSNode.getReductionOperation() != null) {
				aRetVal.add(anOMPForSNode);
			}
		}
		return aRetVal;		
	}
    public static Set<AssignmentSNode> assignmentsToOMPReducingForNode(OMPForSNode anOMPForSNode) {
    	String aReductionVariable = anOMPForSNode.getReductionVariable();
    	return directAssignmentsOfVariableAndItsAliases(anOMPForSNode, aReductionVariable)	;
    	
    }
	public static boolean dependsOn (SNode anSNode, int aVariableLineNumber, String aVariable, String aCallIdentifier) {
		List<SNode> aListSNodes = anSNode.getChildren();
		boolean retVal = false;
		/*
		 * Should probably ignore line number as it assumes straight line code
		 */
		for (int i = aVariableLineNumber; i >= 0; i--) {
			SNode anSNodeChild = aListSNodes.get(i);
			if (anSNodeChild instanceof AssignmentSNode) {
				// does this statement in anSNode directly invoke aCallIdentifier 
				if (dependsOn((AssignmentSNode) anSNodeChild, aVariable, aCallIdentifier))
					return true;
			} else if (!anSNode.isLeaf()) {
					// child is overriding the variable so forget checking its assignment statements
					if (anSNodeChild.getLocalVariableIdentifiers().contains(aVariable)) {
						continue;
					}
					// some subblock of anSNode that has access to aVariable changes variable

					if (dependsOn(anSNodeChild, anSNodeChild.getChildren().size() - 1, aVariable, aCallIdentifier)) {
						return true;
					}
			}
			
		}
		// none of the statements in anSNode or its descendents  have the required call
		// is the variable a  method parameter 
		if (anSNode instanceof MethodSNode) {
			MethodSNode aMethodSNode = (MethodSNode) anSNode;
			
			int aParameterNumber = aMethodSNode.getLocalVariableIdentifiers().indexOf(aVariable);
			if (aParameterNumber != -1) {
				List <MethodCall> aCalls = aMethodSNode.getCalls();
				for (MethodCall aCall:aCalls) {
//					if (!aCall.getMethodActuals().contains(aVariable))
//						continue;
//					
					MethodSNode aCallerSNode = getDeclarationOfCalledMethod(aMethodSNode, aCall);
					if (dependsOn(aMethodSNode, aCallerSNode.getLineNumber(), aCallerSNode.getLocalVariableIdentifiers().get(aParameterNumber), aCallIdentifier));
//				    if (aCallerDepends) {
				    	return true;
//				    }
				}
				return false;
				// need to find all callers of method and see if any of the aliases for the variable in these
				// calls depend on aCallIndentifier
			}			
			
		} else if (anSNode.getLocalVariableIdentifiers().contains(aVariable)) {
			// before going to the parent node, let us see if aVariable is declared here as a non  parameter 

			return false; // no point going to parent
		}
		// not a local variable (parameter or declarated variable)
		SNode anSNodeParent = anSNode.getParent() ;
		if (anSNodeParent == null)  {
			return false;
		}
		int anSNodeLineNumber = anSNodeParent.getChildren().indexOf(anSNode);
		return dependsOn(anSNodeParent, anSNodeLineNumber, aVariable, aCallIdentifier);
		
	}
	public static Set<AssignmentSNode> assignmentsOfVariableAliases (SNode anSNode,  String aVariable) {
		Set<AssignmentSNode> retVal = new HashSet();
		fillDirectAssignmentsOfVariableAliases(anSNode, aVariable, retVal);
		return retVal;
	}
	public static void fillDirectAssignmentsOfVariableAliases (SNode anSNode,  String aVariable, Set<AssignmentSNode> retVal) {
		if (anSNode instanceof MethodCall) {
			MethodCall aMethodCall = (MethodCall) anSNode;
			int aParameterNumber = aMethodCall.getMethodActualIdentifiers().indexOf(aVariable);
			if (aParameterNumber < 0) {
				return;
			}
			MethodSNode aDeclaringMethodSNode = getDeclarationOfCalledMethod(anSNode, aMethodCall);
			String aFormalParameter = aDeclaringMethodSNode.getLocalVariableIdentifiers().get(aParameterNumber);
//			Set<AssignmentSNode> aCallAssignments = ;
			fillDirectAssignmentsOfVariableAliases(aDeclaringMethodSNode, aFormalParameter, retVal);
		} else {
			List<SNode> aChildren = anSNode.getChildren();
			for (SNode aChild:aChildren) {
				fillDirectAssignmentsOfVariableAliases(aChild, aVariable, retVal);
			}
		}		
		
	}
	
	/*
	 * will not consider assignments to variables in the RHS of these assignments
	 */
	public static Set<AssignmentSNode> directAssignmentsOfVariableAndItsAliases (SNode anSNode,  String aVariable) {
		Set<AssignmentSNode> retVal = new HashSet();
		fillDirectAssignmentsOfVariableAndItsAliases(anSNode, aVariable, retVal);
		return retVal;
	}
	
//	public static Set<AssignmentSNode> assignmentsEffectingVariableAndItsAliases (SNode anSNode,  String aVariable) {
//		Set<AssignmentSNode> retVal = directAssignmentsOfVariableAndItsAliases(anSNode, aVariable);
//		
//	}
	public static void fillDirectAssignmentsOfVariableAndItsAliases (SNode anSNode,  String aVariable, Set<AssignmentSNode> retVal) {
		if (anSNode instanceof AssignmentSNode) {
			AssignmentSNode anAssignmentSNode = (AssignmentSNode) anSNode;
			if (anAssignmentSNode.getLhsFirstIdentifier().equals(aVariable)) {
				retVal.add(anAssignmentSNode);
			}
		}
		
		else if (anSNode instanceof MethodCall) {
			MethodCall aMethodCall = (MethodCall) anSNode;
			int aParameterNumber = aMethodCall.getMethodActualIdentifiers().indexOf(aVariable);
			if (aParameterNumber < 0) {
				return;
			}
			MethodSNode aDeclaringMethodSNode = getDeclarationOfCalledMethod(anSNode, aMethodCall);
			String aFormalParameter = aDeclaringMethodSNode.getLocalVariableIdentifiers().get(aParameterNumber);
//			Set<AssignmentSNode> aCallAssignments = ;
			fillDirectAssignmentsOfVariableAndItsAliases(aDeclaringMethodSNode, aFormalParameter, retVal);
		} else {
			List<SNode> aChildren = anSNode.getChildren();
			for (SNode aChild:aChildren) {
				fillDirectAssignmentsOfVariableAndItsAliases(aChild, aVariable, retVal);
			}
		}		
		
	}
	
	public static RootOfFileSNode getRootOfFileNode(SNode aCurrentSNode ) {
		if (aCurrentSNode instanceof RootOfFileSNode) {
			return (RootOfFileSNode) aCurrentSNode;
		}
		SNode aParentSNode = aCurrentSNode.getParent() ;
		
		if (aParentSNode == null) {
			return null;
		}
		
		return getRootOfFileNode(aParentSNode);
		
	}
	public static boolean match (MethodSNode aMethodSNode, MethodCall aMethodCall) {
		return aMethodSNode.getMethodName().equals(aMethodCall.getMethodName()) 
				&& aMethodSNode.getLocalVariableIdentifiers().size() == aMethodCall.getMethodActuals().size();
	}
	public static DeclarationSNode getDeclarationOfVariableIdentifier(SNode aCurrentSNode, String anIdentifier) {
		if (aCurrentSNode == null) {
			return null;
		}
		
		
		int anIndex = aCurrentSNode.getLocalVariableIdentifiers().indexOf(anIdentifier);
		if (anIndex < 0) {
			return getDeclarationOfVariableIdentifier(aCurrentSNode.getParent(), anIdentifier);
		}
		DeclarationSNode retVal = aCurrentSNode.getVariableDeclarations().get(anIndex);
//		retVal.getAssignmentsToDeclaredVariable().add(anAssignmentSNode);
//		anAssignmentSNode.setLhsFirstIdentifierDeclaration(retVal);
		return retVal;
	}
	
	public static DeclarationSNode getDeclarationOfAssignedVariable(SNode aCurrentSNode, AssignmentSNode anAssignmentSNode) {
		if (aCurrentSNode == null) {
			return null;
		}
		if (anAssignmentSNode instanceof ADeclaringAssignmentSNode) {
			return (ADeclaringAssignmentSNode) anAssignmentSNode;
		}
		int anIndex = aCurrentSNode.getLocalVariableIdentifiers().indexOf(anAssignmentSNode.getLhsFirstIdentifier());
		if (anIndex < 0) {
			return getDeclarationOfAssignedVariable(aCurrentSNode.getParent(), anAssignmentSNode);
		}
		DeclarationSNode retVal = aCurrentSNode.getVariableDeclarations().get(anIndex);
//		retVal.getAssignmentsToDeclaredVariable().add(anAssignmentSNode);
//		anAssignmentSNode.setLhsFirstIdentifierDeclaration(retVal);
		return retVal;
	}
	
	public static MethodSNode getDeclarationOfCalledMethod(SNode aCurrentSNode, MethodCall aMethodCall ) {
		SNode aRootNode = getRootOfFileNode(aCurrentSNode);
		for (SNode aChild:aRootNode.getChildren()) {
			if (aChild instanceof MethodSNode) {
				MethodSNode aMethodSNode = (MethodSNode) aChild;
				if (match (aMethodSNode, aMethodCall)) {
					return aMethodSNode;
				}
			}
		}
		return null; // this should never happen;
	}
	
	public static RootOfProgramSNode getRootOfProgramSNode(String aSource) {
		RootOfProgramSNode retVal = new ARootOfProgramSNode();
		Map<String, StringBuffer> aFileNameToContents = ABasicTextManager.extractFileContents(aSource);
		for (String aFileName:aFileNameToContents.keySet()) {
			StringBuffer aFileContents = aFileNameToContents.get(aFileName);
//			List<OpenMPPragma> anOpenMPPragmas = OpenMPUtils.getOpemMPPragmas(aFileContents);
			RootOfFileSNode anSNode = OMPSNodeUtils.getSNode(aFileName, aFileContents);
			retVal.getFileNameToSNode().put(aFileName, anSNode);
			anSNode.setParent(retVal);
//			System.out.println("file name:" + aFileName);
//			System.out.println("pragmas:" + anSNode);
		}
		processExternalMethodSNodes(retVal);
		processIndirectAssignments(retVal);
		return retVal;
	}
//	public static void processIndirectAssignments (S aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode) {
//		for (SNode anSNode:aRootOfFileSNode.getChildren()) {
//			-----
//		}
//	}
	public static void processExternalMethodSNodes (RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode) {
		for (SNode anSNode:aRootOfFileSNode.getChildren()) {
			if (anSNode instanceof ExternalMethodSNode) {
				processExternalMethodSNode(aRootOfProgramSNode, aRootOfFileSNode, (ExternalMethodSNode) anSNode);
			}
		}
	}
	public static void processExternalMethodSNode (RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode, ExternalMethodSNode anExternalMethodSNode) {
		MethodSNode aMethodSNode = aRootOfProgramSNode.getExternalToInternalMethod().get(anExternalMethodSNode.toString());
		if (aMethodSNode == null) {
			aMethodSNode = findMethodSNode(aRootOfProgramSNode, aRootOfFileSNode, anExternalMethodSNode);
			if (aMethodSNode != null) {
				aRootOfProgramSNode.getExternalToInternalMethod().put(anExternalMethodSNode.toString(),aMethodSNode );
			}
		}
		if (aMethodSNode != null) {
			anExternalMethodSNode.setActualMethodSNode(aMethodSNode);
			aMethodSNode.getCalls().addAll(anExternalMethodSNode.getLocalCalls());
		}
	}
	
	public static MethodSNode findMethodSNode (RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode, ExternalMethodSNode anExternalMethodSNode) {
//		MethodSNode foundMethodSNode = null;
		for (String aFileName:aRootOfProgramSNode.getFileNameToSNode().keySet()) {
			if (aFileName.equals(aRootOfFileSNode.getFileName()))
				continue;
			
			RootOfFileSNode aSearchedRootOfFileSNode = aRootOfProgramSNode.getFileNameToSNode().get(aFileName);
			 for (SNode anSNode:aSearchedRootOfFileSNode.getChildren()) {
				if (anSNode instanceof MethodSNode && !(anSNode instanceof ExternalMethodSNode)) {
					if (anSNode.toString().equals(anExternalMethodSNode.toString())) {
						return (MethodSNode) anSNode;
						
					}
//					processExternalMethodSNode(aRootOfProgramSNode, aRootOfFileSNode, (ExternalMethodSNode) anSNode);
				}
			}
		}
		return null;
	}
	public static void processExternalMethodSNodes (RootOfProgramSNode aRootOfProgramSNode) {
		for (String aFileName:aRootOfProgramSNode.getFileNameToSNode().keySet()) {
			RootOfFileSNode aRootOfFileSNode = aRootOfProgramSNode.getFileNameToSNode().get(aFileName);
			processExternalMethodSNodes(aRootOfProgramSNode, aRootOfFileSNode);
			aRootOfFileSNode.getOmp_get_num_threads_SNode().
				setActualMethodSNode(aRootOfProgramSNode.getOmp_get_num_threads_SNode());
			aRootOfFileSNode.getOmp_get_thread_num_SNode().
				setActualMethodSNode(aRootOfProgramSNode.getOmp_get_thread_num_SNode());
			aRootOfFileSNode.getOmp_get_wtime_SNode().
			setActualMethodSNode(aRootOfProgramSNode.getOmp_get_wtime_SNode());
		}

	}
	public static void processIndirectAssignments (SNode anSNode) {
		if (anSNode instanceof ConstDeclarationSNode) {
			return;
		}
		if (anSNode instanceof DeclarationSNode) {
			DeclarationSNode aDeclarationSNode = (DeclarationSNode) anSNode;
			Set<AssignmentSNode> anIndirectAssignments = aDeclarationSNode.getAssignmentsEffectingDeclaredIdentifier();
			if (anIndirectAssignments != null) {
				return; // already assigned
			}
			anIndirectAssignments = new HashSet<>();
			aDeclarationSNode.setAssignmentsEffectingDeclaredIdentifier(anIndirectAssignments);
			Set<AssignmentSNode> aDirectAssignments = aDeclarationSNode.getAssignmentsToDeclaredVariable();
			anIndirectAssignments.addAll(aDirectAssignments);
			Set<AssignmentSNode> anAliasAssignments = assignmentsOfVariableAliases(aDeclarationSNode.getParent(), aDeclarationSNode.getVariableName());
			anIndirectAssignments.addAll(anAliasAssignments);
			for (AssignmentSNode aDirectAssignment:aDirectAssignments) {
				List<String> aVariableIdentifiers = aDirectAssignment.getRhsVariableIdentifiers();
				
				for (String aVariableIdentifier:aVariableIdentifiers) {
					DeclarationSNode aDependeeDeclarationSNode = getDeclarationOfVariableIdentifier(aDirectAssignment, aVariableIdentifier);
					if (aDependeeDeclarationSNode == null) {
						System.err.println("Could not find declaration of:" + aVariableIdentifier + " referenced in:" + aDirectAssignment );
						continue;
					}
					processIndirectAssignments(aDependeeDeclarationSNode);
					Set<AssignmentSNode> aDependeeIndirectAssignments = aDeclarationSNode.getAssignmentsEffectingDeclaredIdentifier();
					anIndirectAssignments.addAll(aDependeeIndirectAssignments);
					
				}
			}
		} else {
			for (SNode aChild: anSNode.getChildren()) {
				processIndirectAssignments(aChild);
			}
		}
		
	}
	
//	public static void fillIndirectAssignments (SNode anSNode, Set<AssignmentSNode> retVal ) {
//		
//	}
	

//	public static void main(String[] args) {
//		List<MethodCall> aTokens = callsIn("foo(bar, hgf)/foo2()*foo3(b, a c,)");
//		System.out.println(aTokens);
//		
//		
////		List<String> aTokens = identifiersIn("a[i] + b*2/3");
////		System.out.println(aTokens);
////		aTokens = numbersIn("a[i] + b*2/3");
////		System.out.println(aTokens);
////		aTokens = operatorsIn("a[i] + b*2/3");
////		System.out.println(aTokens);
////
////		System.out.println(StringUtils.substringBetween("a", "[", "]"));
//	}

}
]]></snapshot>
  </Command>
  <Command __id="218092" _type="DiffBasedFileOpenCommand" date="Fri Jan 10 10:18:32 EST 2020" docASTNodeCount="305" docActiveCodeLength="2199" docExpressionCount="180" docLength="2357" projectName="GraderBasics" starttimestamp="1576666505112" timestamp="2003007161">
    <filePath><![CDATA[D:\dewan_backup\Java\GraderBasics\src\gradingTools\shared\testcases\openmp\scannedTree\ADeclarationSNode.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package gradingTools.shared.testcases.openmp.scannedTree;¶¶import java.util.ArrayList;¶import java.util.HashSet;¶import java.util.List;¶import java.util.Set;¶¶public class ADeclarationSNode extends AnSNode implements DeclarationSNode {¶	String variableName;¶	¶	String typeName;¶	List<String> operators;¶	¶¶	String variableIdentifier;¶	String typeIdentifier;¶	Set<AssignmentSNode> assignmentsToDeclaredVariable = new HashSet();¶	Set<AssignmentSNode> assignmentsEffectingDeclaredIdentifier;¶¶	¶	¶	public ADeclarationSNode(int aLineNumber, String aTypeName, String aVariableName) {¶		super(aLineNumber);¶		typeName = aTypeName;¶		variableName = aVariableName;¶		operators = OMPSNodeUtils.operatorsIn(typeName);¶		operators.addAll(OMPSNodeUtils.operatorsIn(typeName));¶		variableIdentifier = OMPSNodeUtils.identifiersIn(variableName).get(0);¶		typeIdentifier =  OMPSNodeUtils.identifiersIn(typeName).get(0);¶	}¶	@Override¶	public String getTypeName() {¶		return typeName;¶	}¶	@Override¶	public void setTypeName(String typeName) {¶		this.typeName = typeName;¶	}¶	@Override¶	public String getVariableName() {¶		return variableName;¶	}¶	@Override¶	public void setParent(SNode anSNode) {¶		super.setParent(anSNode);¶		anSNode.getVariableDeclarations().add(this);¶//		anSNode.getLocalVariables().add(variableName);¶		anSNode.getLocalVariableIdentifiers().add(variableIdentifier);¶¶	}¶	public String toString() {¶		return typeName + " " + variableName;¶	}¶	@Override¶	public String getVariableIdentifier() {¶		return variableIdentifier;¶	}¶	¶	@Override¶	public String getTypeIdentifier() {¶		return typeIdentifier;¶	}¶	@Override¶	public List<String> getOperators() {¶		return operators;¶	}¶	@Override¶	public Set<AssignmentSNode> getAssignmentsToDeclaredVariable() {¶		return assignmentsToDeclaredVariable;¶	}¶//	@Override¶//¶//	public void setVariableName(String variableName) {¶//		this.variableName = variableName;¶//	}¶	@Override¶	public Set<AssignmentSNode> getAssignmentsEffectingDeclaredIdentifier() {¶		return assignmentsEffectingDeclaredIdentifier;¶	}¶	@Override¶	public void setAssignmentsEffectingDeclaredIdentifier(Set<AssignmentSNode> assignmentsEffectingDeclaredIdentifier) {¶		this.assignmentsEffectingDeclaredIdentifier = assignmentsEffectingDeclaredIdentifier;¶	}¶}¶")]]]></diff>
  </Command>
  <Command __id="218096" _type="DiffBasedFileOpenCommand" date="Fri Jan 10 10:18:33 EST 2020" docASTNodeCount="5134" docActiveCodeLength="37675" docExpressionCount="3174" docLength="43794" projectName="GraderBasics" starttimestamp="1576666505112" timestamp="2003008766">
    <filePath><![CDATA[D:\dewan_backup\Java\GraderBasics\src\gradingTools\shared\testcases\openmp\scannedTree\OMPSNodeUtils.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package gradingTools.shared.testcases.openmp.scannedTree;¶¶import java.util.ArrayList;¶import java.util.Arrays;¶import java.util.HashMap;¶import java.util.HashSet;¶import java.util.List;¶import java.util.Map;¶import java.util.Set;¶import java.util.Stack;¶import java.util.regex.Matcher;¶import java.util.regex.Pattern;¶¶import org.apache.commons.lang.StringUtils;¶¶import grader.basics.project.source.ABasicTextManager;¶import gradingTools.shared.testcases.openmp.OpenMPKeywordEnum;¶import gradingTools.shared.testcases.openmp.OpenMPParallelPragma;¶import gradingTools.shared.testcases.openmp.OpenMPUtils;¶import gradingTools.shared.testcases.openmp.scannedTree.ADeclarationSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.ADeclaringAssignmentSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.AForSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.ATextSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.AnAssignmentSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.AnOMPCriticalSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.AnOMPForSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.AnOMPParallelSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.AnOMPSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.AnSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.AssignmentSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.DeclarationSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.DeclaringAssignmentSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.ForSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.OMPForSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.OMPSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.SNode;¶¶public class OMPSNodeUtils extends OpenMPUtils {¶¶	public static RootOfFileSNode getSNode(String aFileName, StringBuffer aFileBuffer) {¶		String[] aFileLines = aFileBuffer.toString().split("\n");¶		return getSNode(aFileName, aFileLines);¶	}¶¶	public static AssignmentSNode getAssignmentSNode(int aLineNumber, String aString) {¶		if (aString == null) {¶			return null;¶		}¶		String[] aTokens = aString.split("=");¶		if (aTokens.length == 1) {¶			return new AnAssignmentSNode(aLineNumber, aTokens[0], null);¶		} else {¶		return new AnAssignmentSNode(aLineNumber, aTokens[0], aTokens[1]);¶		}¶	}¶¶	public static DeclarationSNode getDeclarationSNode(int aLineNumber, String aString) {¶		String[] aTokens = aString.split(" ");¶		return new ADeclarationSNode(aLineNumber, aTokens[0], aTokens[1]);¶	}¶¶	public static DeclaringAssignmentSNode getDeclaringAssignmentSNode(int aLineNumber, String aString) {¶		String[] anLHSAndRHS = aString.split("=");¶		String[] aTypeAndVariable = anLHSAndRHS[0].split(" ");¶		return new ADeclaringAssignmentSNode(aLineNumber, aTypeAndVariable[0], aTypeAndVariable[1], anLHSAndRHS[1]);¶	}¶	public static ConstDeclarationSNode getConstDeclarationSNode(int aLineNumber, String aString) {¶		String anAssignmentString = aString.substring(CONST.length()).trim();¶		String[] anLHSAndRHS = anAssignmentString.split("=");¶		String[] aTypeAndVariable = anLHSAndRHS[0].split(" ");¶		return new AConstDeclarationSNode(aLineNumber, aTypeAndVariable[0], aTypeAndVariable[1], anLHSAndRHS[1]);¶	}¶¶	public static boolean isDeclaringAssignment(String aFileLine) {¶		return startsWithTypeName(aFileLine) && aFileLine.contains("=");¶	}¶	public static boolean isConstDeclaration(String aFileLine) {¶		return aFileLine.startsWith(CONST);¶	}¶	public static boolean isMethodDeclaration(String aFileLine) {¶		return startsWithTypeName(aFileLine) && ¶				aFileLine.contains("(") &&¶				!aFileLine.contains("=");¶	}¶	public static boolean isExternalMethodDeclaration(String aFileLine) {¶		return isMethodDeclaration(aFileLine) && aFileLine.endsWith(";");¶	}¶¶¶	public static boolean isVariableDeclaration(String aFileLine) {¶¶		return startsWithTypeName(aFileLine) && !aFileLine.contains("(");¶	}¶¶	public static boolean isAssignment(String aFileLine) {¶		return aFileLine.contains("=") && !aFileLine.contains("==");¶	}¶¶	public static boolean isForNode(String aFileLine) {¶		return aFileLine.startsWith("for");¶	}¶¶	public static ForSNode getForSNode(int aLineNumber, String aFileLine) {¶¶		int aLeftParenIndex = aFileLine.indexOf("(");¶		int aRightParenIndex = aFileLine.indexOf(")");¶		if (aLeftParenIndex < 0 || aRightParenIndex < 0) {¶			return null;¶		}¶		String aHeaderString = aFileLine.substring(aLeftParenIndex + 1, aRightParenIndex);¶		String[] aForComponents = aHeaderString.split(";");¶		AssignmentSNode anAssignmentSNode = null;¶		String aForInitializaton = aForComponents[0];¶		if (!aForInitializaton.isEmpty() && aForInitializaton.contains("=")) {¶			if (isDeclaringAssignment(aForInitializaton)) {¶				anAssignmentSNode = getDeclaringAssignmentSNode(aLineNumber, aForInitializaton);¶			} else {¶				anAssignmentSNode = getAssignmentSNode(aLineNumber, aForInitializaton);¶			}¶¶		}		¶		return new AForSNode(aLineNumber, anAssignmentSNode, aForComponents[1], getAssignmentSNode(aLineNumber, aForComponents[2]));¶	}¶	static String[] emptyArray = {};¶	public static MethodSNode getMethodSNode(int aLineNumber, String aFileLine, boolean isInternal) {¶¶		int aLeftParenIndex = aFileLine.indexOf("(");¶		int aRightParenIndex = aFileLine.indexOf(")");¶		if (aLeftParenIndex < 0 || aRightParenIndex < 0) {¶			return null;¶		}¶		String aMethodNameAndType = aFileLine.substring(0, aLeftParenIndex);¶		String[] aMethodNameAndTypeTokens = aMethodNameAndType.split("\\s+"); ¶		¶		String aMethodParameters = aFileLine.substring(aLeftParenIndex +1 , aRightParenIndex);¶		String[] aMethodParameterTokens = aMethodParameters.isEmpty()?emptyArray:¶		 aMethodParameters.split(",");¶		¶//		String[] aMethodParameterTypes = new String[aMethodParameterTokens.length];¶//		String[] aMethodParameterNames = new String[aMethodParameterTokens.length];¶		List<DeclarationSNode> aDeclarationSNodeList = new ArrayList();¶		for (int i = 0; i < aMethodParameterTokens.length; i++ ) {¶			String[] aTypeAndName = aMethodParameterTokens[i].trim().split("\\s+");¶			if (aTypeAndName.length < 2) {¶				continue;¶			}¶			aDeclarationSNodeList.add(new ADeclarationSNode(aLineNumber, aTypeAndName[0].trim(), aTypeAndName[1].trim()));¶//			aMethodParameterTypes[i] = aTypeAndName[0].trim();¶//			aMethodParameterNames[i] = aTypeAndName[1].trim();¶		}¶		if (isInternal)¶//		return new AMethodSNode(aLineNumber, aMethodNameAndTypeTokens[0], aMethodNameAndTypeTokens[1], aMethodParameterTypes,aMethodParameterNames );¶			return new AMethodSNode(aLineNumber, aMethodNameAndTypeTokens[0], aMethodNameAndTypeTokens[1], aDeclarationSNodeList );¶		else¶			return new AnExternalMethodSNode(aLineNumber, aMethodNameAndTypeTokens[0], aMethodNameAndTypeTokens[1], aDeclarationSNodeList );¶	}¶¶	public static void setReductionData(OMPForSNode lastChild, String aStoredToken, int aLeftParenIndex,¶			int aRightParenIndex) {¶		int aColonIndex = aStoredToken.indexOf(":");¶		if (aLeftParenIndex != -1 && aRightParenIndex != -1 && aColonIndex != -1) {¶			String anOperationString = aStoredToken.substring(aLeftParenIndex + 1, aColonIndex).trim();¶			String aVariableString = aStoredToken.substring(aColonIndex + 1, aRightParenIndex).trim();¶			((OMPForSNode) lastChild).setReductionVariable(aVariableString);¶			((OMPForSNode) lastChild).setReductionOperation(anOperationString);¶		}¶	}¶¶	public static void setSharedOrPrivateData(OMPSNode lastChild, String aStoredToken, int aLeftParenIndex,¶			int aRightParenIndex, boolean isShared) {¶//		int aColonIndex = aStoredToken.indexOf(":");¶		if (aLeftParenIndex != -1 && aRightParenIndex != -1) {¶			String aVariableDeclarations = aStoredToken.substring(aLeftParenIndex + 1, aRightParenIndex);¶			String[] aVariables = aVariableDeclarations.split(",");¶			if (isShared) {¶				lastChild.setSharedVariables(aVariables);¶			} else {¶				lastChild.setPrivateVariables(aVariables);¶			}¶		}¶	}¶¶	public static RootOfFileSNode getSNode(String aFileName, String[] aFileLines) {¶		Stack<SNode> anSNodes = new Stack();¶¶		RootOfFileSNode retVal = new ARootOfFileSNode(aFileName);¶		anSNodes.add(retVal);¶		SNode previousHeaderNode = null;¶		for (int i = 0; i < aFileLines.length; i++) {¶			String aFileLine = aFileLines[i].trim();¶			if (!isCodeLine(aFileLine)) {¶				continue;¶			}¶			if (isForNode(aFileLine)) {¶				ForSNode aForSNode = getForSNode(i, aFileLine);¶				SNode aParent = previousHeaderNode != null?previousHeaderNode:anSNodes.peek();¶				aForSNode.setParent(anSNodes.peek());¶				aForSNode.setParent(aParent);¶¶//				anSNodes.push(aForSNode);¶				previousHeaderNode = aForSNode;¶				if (aFileLine.endsWith(")")) {¶					continue;¶				}¶			}¶			if (isExternalMethodDeclaration(aFileLine)) {¶				MethodSNode aMethodSNode = getMethodSNode(i, aFileLine, false);¶				aMethodSNode.setParent(anSNodes.peek());¶//				anSNodes.push(aForSNode);¶				previousHeaderNode = aMethodSNode;¶				if (aFileLine.endsWith(")")) {¶					continue;¶				}¶			}¶			if (isMethodDeclaration(aFileLine)) {¶				MethodSNode aMethodSNode = getMethodSNode(i, aFileLine, true);¶				aMethodSNode.setParent(anSNodes.peek());¶//				anSNodes.push(aForSNode);¶				previousHeaderNode = aMethodSNode;¶				if (aFileLine.endsWith(")")) {¶					continue;¶				}¶			}¶			if (isPragmaStart(aFileLine)) {¶				OMPSNode anOMPSNode = getOMPSNode(i, anSNodes.peek(), aFileLine);¶//				anSNodes.push(anOMPSNode);¶				previousHeaderNode = anOMPSNode;¶				continue;¶			}¶			if (isBlockStart(aFileLine)) {¶				SNode aBlockSNode = new ABlockSNode(i);¶				if (previousHeaderNode != null) {¶					aBlockSNode.setParent(previousHeaderNode);¶				} else {¶					aBlockSNode.setParent(anSNodes.peek());¶				}¶				anSNodes.push(aBlockSNode);¶				previousHeaderNode = null;¶				continue;¶			}¶//			} else ¶			if (isBlockEnd(aFileLine)) {¶				anSNodes.pop();¶				continue;¶			}¶			SNode aNewLeafNode = null;¶			if (isConstDeclaration(aFileLine)) {¶				aNewLeafNode = getConstDeclarationSNode(i, aFileLine);¶¶			} else if (isDeclaringAssignment(aFileLine)) {¶				aNewLeafNode = getDeclaringAssignmentSNode(i, aFileLine);¶¶			} else if (isAssignment(aFileLine)) {¶				aNewLeafNode = getAssignmentSNode(i, aFileLine);¶			} else if (isVariableDeclaration(aFileLine)) {¶				aNewLeafNode = getDeclarationSNode(i, aFileLine);¶			} else {¶				List<MethodCall> aCalls = callsIn(i, aFileLine, null); // parent will be assigned below¶				if (aCalls != null && aCalls.size() == 1) {¶					aNewLeafNode = aCalls.get(0);¶				} else {¶					aNewLeafNode = new ATextSNode(i, aFileLine);¶				}¶			}¶//			else {¶//				aNewLeafNode = new ATextSNode(i, aFileLine);¶//			}¶			if (previousHeaderNode != null) {¶				aNewLeafNode.setParent(previousHeaderNode);¶			} else {¶				aNewLeafNode.setParent(anSNodes.peek());¶			}¶¶		}¶¶		return retVal;¶	}¶¶	public static OMPSNode getOMPSNode(int aLineIndex, SNode aParentNode, String aFileLine) {¶		String[] aTokens = aFileLine.split("\\s+");¶		if (aTokens.length <= 2) {¶			return null;¶		}¶		if (!aTokens[1].equals("omp")) {¶			return null;¶		}¶		if (aTokens.length < 3) {¶			return null;¶		}¶		String aFirstToken = aTokens[2];¶		OpenMPKeywordEnum anOpenMPKeyword = stringToOpenMPKeyword.get(aFirstToken);¶//		List<OpenMPPragma> retVal = new ArrayList();¶		OMPSNode lastChild = null;¶		int aStartIndex = 2;¶		OMPSNode aNewNode = null;¶		OMPForSNode aForChild = null;¶		switch (anOpenMPKeyword) {¶		case PARALLEL:¶			aNewNode = new AnOMPParallelSNode(aLineIndex);¶¶			if (aTokens.length > 3 && aTokens[3].equals("for")) {¶				aForChild = new AnOMPForSNode(aLineIndex);¶				aForChild.setParent(aNewNode);¶¶				aStartIndex++;¶			}¶			break;¶		case FOR:¶			aNewNode = new AnOMPForSNode(aLineIndex);¶			;¶			break;¶		case CRITICAL:¶			aNewNode = new AnOMPCriticalSNode(aLineIndex);¶//			retVal.add (lastChild);¶			break;¶		default:¶			aNewNode = new AnOMPSNode(aLineIndex);¶¶		}¶¶		if (lastChild != null) {¶			aNewNode.setParent(lastChild);¶		} else {¶			aNewNode.setParent(aParentNode);¶		}¶		lastChild = aForChild == null ? aNewNode : aForChild;¶¶		for (int i = aStartIndex; i < aTokens.length; i++) {¶			String aStoredToken = aTokens[i].trim();¶			if (aStoredToken.isEmpty()) {¶				continue;¶			}¶			if (aStoredToken.startsWith("reduction") || aStoredToken.startsWith("shared")¶					|| aStoredToken.startsWith("private")) {¶				// combine all tokens until ")" into one for normalization¶				while (!aStoredToken.endsWith(")")) {¶					i++;¶					if (i >= aTokens.length) {¶						break;¶					}¶					String aNewToken = aTokens[i].trim();¶					aStoredToken += aNewToken;¶				}¶				int aLeftParenIndex = aStoredToken.indexOf("(");¶				int aRightParenIndex = aStoredToken.indexOf(")");¶				if (aStoredToken.startsWith("reduction")) {¶					setReductionData((OMPForSNode) lastChild, aStoredToken, aLeftParenIndex, aRightParenIndex);¶				} else if (aStoredToken.startsWith("private")) {¶					setSharedOrPrivateData((OMPSNode) lastChild, aStoredToken, aLeftParenIndex, aRightParenIndex,¶							false);¶¶				} else if (aStoredToken.startsWith("shared")) {¶					setSharedOrPrivateData(lastChild, aStoredToken, aLeftParenIndex, aRightParenIndex, true);¶¶				}¶¶			}¶¶			lastChild.getOpenMPTokens().add(aStoredToken);¶		}¶¶		return lastChild;¶¶	}¶¶	public static boolean hasParallelAncestor(SNode anSNode) {¶		if (anSNode == null) {¶			return false;¶		}¶		if (anSNode instanceof OMPParallelSNode) {¶			return true;¶		}¶		return hasParallelAncestor(anSNode.getParent());¶	}¶	public static boolean hasCriticalAncestor(SNode anSNode) {¶		if (anSNode == null) {¶			return false;¶		}¶		if (anSNode instanceof OMPCriticalSNode) {¶			return true;¶		}¶		return hasCriticalAncestor(anSNode.getParent());¶	}¶¶¶	public static Boolean isDeclaredShared(OMPSNode anOMPSNode, String anLHS) {¶		if (Arrays.asList(anOMPSNode.getSharedVariables()).contains(anLHS)) {¶			return true;¶		}¶		if (Arrays.asList(anOMPSNode.getPrivateVariables()).contains(anLHS)) {¶			return false;¶		}¶		return null;¶¶	}¶¶	public static boolean isSharedVariable(SNode anSNode, String anLHS) {¶		if (anSNode == null) {¶			return false;¶		}¶		if (anSNode.getLocalVariableIdentifiers().contains(anLHS)) {¶			if (!(anSNode instanceof OMPSNode)) { // no shared and private declarations¶				return !hasParallelAncestor(anSNode); // shared if not inParallel¶			}¶			OMPSNode anOMPSNode = (OMPSNode) anSNode;¶			return (Arrays.asList(anOMPSNode.getSharedVariables()).contains(anLHS)); // private unless declared shared¶		}¶		if (anSNode instanceof OMPSNode) {¶			OMPSNode anOMPSNode = (OMPSNode) anSNode;¶			// the variable is global to this scope, check if it has have been made shared¶			// or private by this scope¶			Boolean isDeclaredShared = isDeclaredShared(anOMPSNode, anLHS);¶			if (isDeclaredShared != null) {¶				return isDeclaredShared;¶			}¶		}¶		// check the parent¶		return isSharedVariable(anSNode.getParent(), anLHS);¶	}¶¶	public static List<SNode> getAllLeafNodes(SNode aTopNode) {¶		List<SNode> retVal = new ArrayList();¶		addLeafNodes(aTopNode, retVal);¶		return retVal;¶	}¶¶	public static void addLeafNodes(SNode aTopNode, List<SNode> retVal) {¶		for (SNode aChild : aTopNode.getChildren()) {¶			if (aChild.isLeaf()) {¶				retVal.add(aChild);¶			} else {¶				addLeafNodes(aChild, retVal);¶			}¶		}¶	}¶¶	public static List<SNode> getNonParallelLeafNodes(SNode aTopNode) {¶		List<SNode> retVal = new ArrayList();¶		addNonParallelLeafNodes(aTopNode, retVal);¶		return retVal;¶	}¶¶	public static void addNonParallelLeafNodes(SNode aTopNode, List<SNode> retVal) {¶		if (aTopNode.isInParallel()) {¶			return;¶		}¶		for (SNode aChild : aTopNode.getChildren()) {¶			if (aChild.isLeaf()) {¶				retVal.add(aChild);¶			} else {¶				addLeafNodes(aChild, retVal);¶			}¶		}¶	}¶	static String callRegex = "([a-zA-Z_$][a-zA-Z_$0-9]*)\\(.*?\\)";¶	static Pattern callPattern = Pattern.compile(callRegex);¶¶	static String identifierRegex = "[a-zA-Z_$][a-zA-Z_$0-9]*";¶	static Pattern identifierPattern = Pattern.compile(identifierRegex);¶	public static List<String> identifiersIn(String aString) {¶		if (aString == null)¶			return null;¶//		Pattern mypattern = Pattern.compile("[a-zA-Z_$][a-zA-Z_$0-9]*");¶//		Matcher mymatcher = mypattern.matcher(aString);¶		Matcher mymatcher = identifierPattern.matcher(aString);¶		List<String> retVal = new ArrayList();¶		while (mymatcher.find()) {¶			String find = mymatcher.group(0);¶			retVal.add(find);¶		}¶		return retVal;¶	}¶	public static List<MethodCall> callsIn(int aLineNumber, String aString, SNode aParent) {¶		if (aString == null)¶			return emptyList;¶		if (isMethodDeclaration(aString)) {¶			return emptyList;¶		}¶//		Pattern mypattern = Pattern.compile("[a-zA-Z_$][a-zA-Z_$0-9]*");¶//		Matcher mymatcher = mypattern.matcher(aString);¶		Matcher mymatcher = callPattern.matcher(aString);¶		List<MethodCall> retVal = new ArrayList();¶		while (mymatcher.find()) {¶			String find = mymatcher.group(0);¶			int aLeftParenIndex = find.indexOf("(");¶			int aRightParenIndex = find.indexOf(")");¶			String aMethodName = find.substring(0, aLeftParenIndex).trim();¶			String aParameters = find.substring(aLeftParenIndex + 1, aRightParenIndex);¶			List<String> aParameterList = new ArrayList();¶			String[] aParameterTokens = aParameters.split(",");¶			for (String aParameter:aParameterTokens) {¶				String aParameterTrimmed = aParameter.trim();¶				if (!aParameterTrimmed.isEmpty())¶				aParameterList.add(aParameterTrimmed);¶			}¶			retVal.add(new AMethodCall(aLineNumber, aMethodName, aParameterList, aParent));¶¶//			aCallStrings.add(find);¶		}¶		return retVal;¶	}¶	static String numberRegex = "(\\d+\\.\\d+)|(\\d+)";¶	static Pattern numberPattern = Pattern.compile(numberRegex);¶	public static List<String> numbersIn(String aString) {¶		if (aString == null)¶			return null;¶//		String regex = "(\\d+\\.\\d+)|(\\d+)";¶//¶//		Matcher m = Pattern.compile(regex).matcher(aString);¶		Matcher m =numberPattern.matcher(aString);¶¶¶		List<String> retVal = new ArrayList();¶¶		while (m.find()) {¶			retVal.add(m.group());¶		}¶		return retVal;¶	}¶¶	public static String subscriptIn(String aString) {¶		if (aString == null)¶			return null;¶		return StringUtils.substringBetween(aString, "[", "]");¶	}¶	static String[] emptyStringArray = {};¶	static List emptyList = new ArrayList();¶¶	public static String[] subscriptsIn(String aString) {¶		if (aString == null)¶			return emptyStringArray;¶		return StringUtils.substringsBetween(aString, "[", "]");¶	}¶	static  String operatorRegex = "([+-/*///^])|([/(/)])";¶	static Pattern operatorPattern = Pattern.compile(operatorRegex);¶¶	public static List<String> operatorsIn(String aString) {¶		if (aString == null)¶			return null;¶//		String operatorRegex = "([+-/*///^])|([/(/)])";¶//¶//		Matcher m = Pattern.compile(operatorRegex).matcher(aString);¶		¶		Matcher m = operatorPattern.matcher(aString);¶¶¶		List<String> retVal = new ArrayList();¶¶		while (m.find()) {¶			retVal.add(m.group());¶		}¶		return retVal;¶	}¶	¶	public static int numberOfNestingFors (SNode anSNode) {¶		if (anSNode == null) {¶			return 0;¶		}¶		int retVal = numberOfNestingFors (anSNode.getParent()) ;¶¶		if (anSNode instanceof ForSNode) {¶			retVal++;¶		} else if (anSNode instanceof MethodSNode) {¶			List<MethodCall> aMethodCalls = ((MethodSNode) anSNode).getCalls();¶			int aMaxNestingLevel = 0;¶			for (MethodCall aMethodCall:aMethodCalls) {¶				MethodSNode aCallerMethodSNode = getDeclarationOfCalledMethod(anSNode, aMethodCall);¶				int aCallerNumberOfNestingFors = numberOfNestingFors(aCallerMethodSNode);¶				aMaxNestingLevel = Math.max(aCallerNumberOfNestingFors, aMaxNestingLevel);				¶			}¶			return retVal + aMaxNestingLevel;¶		}¶		return retVal;¶	}¶	public static boolean hasOperator (SNode anSNode, String anOperator) {¶		boolean retVal = false;¶		if (anSNode instanceof AssignmentSNode) {¶			AssignmentSNode anAssignmentSNode = (AssignmentSNode) anSNode;¶			 retVal = (anAssignmentSNode.getLhsOperators().contains(anOperator) || ¶					anAssignmentSNode.getRhsOperators().contains(anOperator)) ;¶			if (retVal) {¶				return retVal;¶			} else {¶				List<MethodCall> aMethodCalls = anAssignmentSNode.getRhsCalls();¶				for (MethodCall aMethodCall:aMethodCalls) {¶					MethodSNode aMethodSNode = getDeclarationOfCalledMethod(anSNode, aMethodCall);¶					retVal = hasOperator(aMethodSNode, anOperator);¶					if (retVal) {¶						return retVal;¶					}¶					¶				}¶				return false;¶			}¶			¶		}¶		for (SNode aChild:anSNode.getChildren()) {¶			retVal = hasOperator(aChild, anOperator);¶			if (retVal) {¶				return retVal;¶			}¶		}¶		return false;¶	}¶	public static boolean hasMethodCall (SNode anSNode, String anOperator) {¶		boolean retVal = false;¶		if (anSNode instanceof AssignmentSNode) {¶			AssignmentSNode anAssignmentSNode = (AssignmentSNode) anSNode;¶			 retVal = (anAssignmentSNode.getLhsOperators().contains(anOperator) || ¶					anAssignmentSNode.getRhsOperators().contains(anOperator)) ;¶			if (retVal) {¶				return retVal;¶			} else {¶				List<MethodCall> aMethodCalls = anAssignmentSNode.getRhsCalls();¶				for (MethodCall aMethodCall:aMethodCalls) {¶					MethodSNode aMethodSNode = getDeclarationOfCalledMethod(anSNode, aMethodCall);¶					retVal = hasOperator(aMethodSNode, anOperator);¶					if (retVal) {¶						return retVal;¶					}¶					¶				}¶				return false;¶			}¶			¶		}¶		for (SNode aChild:anSNode.getChildren()) {¶			retVal = hasOperator(aChild, anOperator);¶			if (retVal) {¶				return retVal;¶			}¶		}¶		return false;¶	}¶	public static boolean dependsOn (AssignmentSNode anAssignmentSNode, String aVariable, String aCallIdentifier) {¶		// This assignment does not change aVariable¶		if (!aVariable.equals(anAssignmentSNode.getLhsFirstIdentifier())) {¶			return false;¶		}¶		return dependsOn(anAssignmentSNode.getExpressionSNode(), aCallIdentifier);¶//		List<String> aCallIdentifiers = anAssignmentSNode.getRhsCallIdentifiers();¶//		boolean retVal = false;¶//		if (aCallIdentifiers != null && aCallIdentifiers.contains(aCallIdentifier)) {¶//			return true; // this assignment has aCallIdentifier in the rhs¶//		}¶//		// check if some referenced rhs variable depends on aCallIdentifier¶//		List<String> aReferencedVariableIdentifiers = anAssignmentSNode.getRhsVariableIdentifiers();¶//		SNode anAssignmentParent = anAssignmentSNode.getParent();¶//		if (anAssignmentParent == null) { // should never be trye¶//			return false;¶//		}¶//		int aLineNumber = anAssignmentSNode.getLineNumber();¶//		for (String aReferencedVariableIdentifier:aReferencedVariableIdentifiers ) {¶//			if (dependsOn (anAssignmentParent, aLineNumber, aReferencedVariableIdentifier, aCallIdentifier)) {¶//				return true;¶//			}¶//		}¶//		return false;¶	}¶	public static boolean dependsOn (ExpressionSNode anExpressionSNode, String aCallIdentifier) {¶		// This assignment does not change aVariable¶		¶		List<String> aCallIdentifiers = anExpressionSNode.getRhsCallIdentifiers();¶		boolean retVal = false;¶		if (aCallIdentifiers != null && aCallIdentifiers.contains(aCallIdentifier)) {¶			return true; // this assignment has aCallIdentifier in the rhs¶		}¶		// check if some referenced rhs variable depends on aCallIdentifier¶		List<String> aReferencedVariableIdentifiers = anExpressionSNode.getRhsVariableIdentifiers();¶		SNode anAssignmentParent = anExpressionSNode.getParent().getParent();¶		if (anAssignmentParent == null) { // should never be trye¶			return false;¶		}¶		int aLineNumber = anExpressionSNode.getLineNumber();¶		for (String aReferencedVariableIdentifier:aReferencedVariableIdentifiers ) {¶			if (dependsOn (anAssignmentParent, aLineNumber, aReferencedVariableIdentifier, aCallIdentifier)) {¶				return true;¶			}¶		}¶		return false;¶	}¶	public static Set<AssignmentSNode> assignmentsToSharedVariables(SNode anSNode) {¶		Set<AssignmentSNode> retVal =  new HashSet();¶		fillAssignmentsToShared(anSNode, retVal);¶		return retVal;¶		¶	}¶	public static Set<AssignmentSNode> assignmentsToSharedArrays(SNode anSNode) {¶		Set<AssignmentSNode> anAllSharedAssignments =  assignmentsToSharedVariables(anSNode);¶		Set<AssignmentSNode> aRetVal = new HashSet();¶		for (AssignmentSNode anAssignmentSNode:anAllSharedAssignments) {¶			if (anAssignmentSNode.getLhsSubscripts().length > 0) {¶				aRetVal.add(anAssignmentSNode);¶			}¶		}¶		return aRetVal;¶		¶	}¶	public static Set<AssignmentSNode> assignmentsToParallelCriticalSharedVariables(SNode anSNode) {¶		Set<AssignmentSNode> anAllSharedAssignments =  assignmentsToSharedVariables(anSNode);¶		Set<AssignmentSNode> aRetVal = new HashSet();¶		for (AssignmentSNode anAssignmentSNode:anAllSharedAssignments) {¶			if (anAssignmentSNode.isInParallel() &&¶					anAssignmentSNode.isInCritical()) {¶				aRetVal.add(anAssignmentSNode);¶			}¶		}¶		return aRetVal;¶		¶	}¶	public static Set<AssignmentSNode> assignmentsToNonParallelCriticalSharedVariables(SNode anSNode) {¶		Set<AssignmentSNode> anAllSharedAssignments =  assignmentsToSharedVariables(anSNode);¶		Set<AssignmentSNode> aRetVal = new HashSet();¶		for (AssignmentSNode anAssignmentSNode:anAllSharedAssignments) {¶			if (!anAssignmentSNode.isInParallel() &&¶					anAssignmentSNode.isInCritical()) {¶				aRetVal.add(anAssignmentSNode);¶			}¶		}¶		return aRetVal;¶		¶	}¶	public static Set<AssignmentSNode> assignmentsToParallelNonCriticalSharedVariables(SNode anSNode) {¶		Set<AssignmentSNode> anAllSharedAssignments =  assignmentsToSharedVariables(anSNode);¶		Set<AssignmentSNode> aRetVal = new HashSet();¶		for (AssignmentSNode anAssignmentSNode:anAllSharedAssignments) {¶			if (anAssignmentSNode.isInParallel() &&¶					!anAssignmentSNode.isInCritical()) {¶				aRetVal.add(anAssignmentSNode);¶			}¶		}¶		return aRetVal;¶		¶	}¶    public static void fillAssignmentsToShared(SNode anSNode, Set<AssignmentSNode> retVal) {¶    	if (anSNode instanceof AssignmentSNode) {¶			AssignmentSNode anAssignmentSNode = (AssignmentSNode) anSNode;¶			String anLHS = anAssignmentSNode.getLhsFirstIdentifier();¶			if (isSharedVariable(anSNode, anLHS)) {¶				retVal.add(anAssignmentSNode);¶				return;¶			}¶		}¶    	for (SNode aChild:anSNode.getChildren()) {¶    		fillAssignmentsToShared(aChild, retVal);¶    	}¶		¶	}¶    public static void fillInstancesOfNodeType(Class<? extends SNode> aNodeType, SNode anSNode, Set<SNode> retVal) {¶    	if (aNodeType.isAssignableFrom(anSNode.getClass())) {¶			¶				retVal.add(anSNode);¶				return;¶			}¶		¶    	for (SNode aChild:anSNode.getChildren()) {¶    		fillInstancesOfNodeType(aNodeType, aChild, retVal);¶    	}¶		¶	}¶    public static Set<AssignmentSNode>  assignmentSNodes(SNode anSNode) {¶    	Set retVal = new HashSet();    	¶    	fillInstancesOfNodeType(AssignmentSNode.class, anSNode, retVal );¶    	return retVal;¶	}¶   ¶    ¶    public static Set<OMPParallelSNode>  ompParallelSNodes(SNode anSNode) {¶    	Set retVal = new HashSet();    	¶    	fillInstancesOfNodeType(OMPParallelSNode.class, anSNode, retVal );¶    	return retVal;¶	}¶//    public static void fillOMPParallelSNodes(SNode anSNode, Set<OMPParallelSNode> retVal) {¶//    	if (anSNode instanceof OMPParallelSNode) {¶//    		retVal.add((OMPParallelSNode) anSNode);¶//		}¶//    	for (SNode aChild:anSNode.getChildren()) {¶//    		fillOMPParallelSNodes(aChild, retVal);¶//    	}		¶//	}¶    public static Set<ForSNode>  forSNodes(SNode anSNode) {¶    	Set retVal = new HashSet();    	¶    	fillInstancesOfNodeType(ForSNode.class, anSNode, retVal );¶    	return retVal;¶	}¶//    public static void fillForSNodes(SNode anSNode, Set<ForSNode> retVal) {¶//    	if (anSNode instanceof ForSNode) {¶//    		retVal.add((ForSNode) anSNode);¶//		}¶//    	for (SNode aChild:anSNode.getChildren()) {¶//    		fillForSNodes(aChild, retVal);¶//    	}		¶//	}¶    public static Set<OMPForSNode>  ompForSNodes(SNode anSNode) {¶    	Set retVal = new HashSet();    	¶    	fillInstancesOfNodeType(OMPForSNode.class, anSNode, retVal );¶    	return retVal;¶	}¶//    public static void fillOMPForSNodes(SNode anSNode, Set<OMPForSNode> retVal) {¶//    	if (anSNode instanceof OMPForSNode) {¶//    		retVal.add((OMPForSNode) anSNode);¶//		}¶//    	for (SNode aChild:anSNode.getChildren()) {¶//    		fillOMPForSNodes(aChild, retVal);¶//    	}		¶//	}¶    public static Set<OMPForSNode> ompReducingForNodes(SNode anSNode) {¶		Set<OMPForSNode> anAllOMPForSNodes =  ompForSNodes(anSNode);¶		Set<OMPForSNode> aRetVal = new HashSet();¶		for (OMPForSNode anOMPForSNode:anAllOMPForSNodes) {¶			if (anOMPForSNode.getReductionOperation() != null) {¶				aRetVal.add(anOMPForSNode);¶			}¶		}¶		return aRetVal;		¶	}¶    public static Set<AssignmentSNode> assignmentsToOMPReducingForNode(OMPForSNode anOMPForSNode) {¶    	String aReductionVariable = anOMPForSNode.getReductionVariable();¶    	return directAssignmentsOfVariableAndItsAliases(anOMPForSNode, aReductionVariable)	;¶    	¶    }¶	public static boolean dependsOn (SNode anSNode, int aVariableLineNumber, String aVariable, String aCallIdentifier) {¶		List<SNode> aListSNodes = anSNode.getChildren();¶		boolean retVal = false;¶		/*¶		 * Should probably ignore line number as it assumes straight line code¶		 */¶		for (int i = aVariableLineNumber; i >= 0; i--) {¶			SNode anSNodeChild = aListSNodes.get(i);¶			if (anSNodeChild instanceof AssignmentSNode) {¶				// does this statement in anSNode directly invoke aCallIdentifier ¶				if (dependsOn((AssignmentSNode) anSNodeChild, aVariable, aCallIdentifier))¶					return true;¶			} else if (!anSNode.isLeaf()) {¶					// child is overriding the variable so forget checking its assignment statements¶					if (anSNodeChild.getLocalVariableIdentifiers().contains(aVariable)) {¶						continue;¶					}¶					// some subblock of anSNode that has access to aVariable changes variable¶¶					if (dependsOn(anSNodeChild, anSNodeChild.getChildren().size() - 1, aVariable, aCallIdentifier)) {¶						return true;¶					}¶			}¶			¶		}¶		// none of the statements in anSNode or its descendents  have the required call¶		// is the variable a  method parameter ¶		if (anSNode instanceof MethodSNode) {¶			MethodSNode aMethodSNode = (MethodSNode) anSNode;¶			¶			int aParameterNumber = aMethodSNode.getLocalVariableIdentifiers().indexOf(aVariable);¶			if (aParameterNumber != -1) {¶				List <MethodCall> aCalls = aMethodSNode.getCalls();¶				for (MethodCall aCall:aCalls) {¶//					if (!aCall.getMethodActuals().contains(aVariable))¶//						continue;¶//					¶					MethodSNode aCallerSNode = getDeclarationOfCalledMethod(aMethodSNode, aCall);¶					if (dependsOn(aMethodSNode, aCallerSNode.getLineNumber(), aCallerSNode.getLocalVariableIdentifiers().get(aParameterNumber), aCallIdentifier));¶//				    if (aCallerDepends) {¶				    	return true;¶//				    }¶				}¶				return false;¶				// need to find all callers of method and see if any of the aliases for the variable in these¶				// calls depend on aCallIndentifier¶			}			¶			¶		} else if (anSNode.getLocalVariableIdentifiers().contains(aVariable)) {¶			// before going to the parent node, let us see if aVariable is declared here as a non  parameter ¶¶			return false; // no point going to parent¶		}¶		// not a local variable (parameter or declarated variable)¶		SNode anSNodeParent = anSNode.getParent() ;¶		if (anSNodeParent == null)  {¶			return false;¶		}¶		int anSNodeLineNumber = anSNodeParent.getChildren().indexOf(anSNode);¶		return dependsOn(anSNodeParent, anSNodeLineNumber, aVariable, aCallIdentifier);¶		¶	}¶	public static Set<AssignmentSNode> assignmentsOfVariableAliases (SNode anSNode,  String aVariable) {¶		Set<AssignmentSNode> retVal = new HashSet();¶		fillDirectAssignmentsOfVariableAliases(anSNode, aVariable, retVal);¶		return retVal;¶	}¶	public static void fillDirectAssignmentsOfVariableAliases (SNode anSNode,  String aVariable, Set<AssignmentSNode> retVal) {¶		if (anSNode instanceof MethodCall) {¶			MethodCall aMethodCall = (MethodCall) anSNode;¶			int aParameterNumber = aMethodCall.getMethodActualIdentifiers().indexOf(aVariable);¶			if (aParameterNumber < 0) {¶				return;¶			}¶			MethodSNode aDeclaringMethodSNode = getDeclarationOfCalledMethod(anSNode, aMethodCall);¶			String aFormalParameter = aDeclaringMethodSNode.getLocalVariableIdentifiers().get(aParameterNumber);¶//			Set<AssignmentSNode> aCallAssignments = ;¶			fillDirectAssignmentsOfVariableAliases(aDeclaringMethodSNode, aFormalParameter, retVal);¶		} else {¶			List<SNode> aChildren = anSNode.getChildren();¶			for (SNode aChild:aChildren) {¶				fillDirectAssignmentsOfVariableAliases(aChild, aVariable, retVal);¶			}¶		}		¶		¶	}¶	¶	/*¶	 * will not consider assignments to variables in the RHS of these assignments¶	 */¶	public static Set<AssignmentSNode> directAssignmentsOfVariableAndItsAliases (SNode anSNode,  String aVariable) {¶		Set<AssignmentSNode> retVal = new HashSet();¶		fillDirectAssignmentsOfVariableAndItsAliases(anSNode, aVariable, retVal);¶		return retVal;¶	}¶	¶//	public static Set<AssignmentSNode> assignmentsEffectingVariableAndItsAliases (SNode anSNode,  String aVariable) {¶//		Set<AssignmentSNode> retVal = directAssignmentsOfVariableAndItsAliases(anSNode, aVariable);¶//		¶//	}¶	public static void fillDirectAssignmentsOfVariableAndItsAliases (SNode anSNode,  String aVariable, Set<AssignmentSNode> retVal) {¶		if (anSNode instanceof AssignmentSNode) {¶			AssignmentSNode anAssignmentSNode = (AssignmentSNode) anSNode;¶			if (anAssignmentSNode.getLhsFirstIdentifier().equals(aVariable)) {¶				retVal.add(anAssignmentSNode);¶			}¶		}¶		¶		else if (anSNode instanceof MethodCall) {¶			MethodCall aMethodCall = (MethodCall) anSNode;¶			int aParameterNumber = aMethodCall.getMethodActualIdentifiers().indexOf(aVariable);¶			if (aParameterNumber < 0) {¶				return;¶			}¶			MethodSNode aDeclaringMethodSNode = getDeclarationOfCalledMethod(anSNode, aMethodCall);¶			String aFormalParameter = aDeclaringMethodSNode.getLocalVariableIdentifiers().get(aParameterNumber);¶//			Set<AssignmentSNode> aCallAssignments = ;¶			fillDirectAssignmentsOfVariableAndItsAliases(aDeclaringMethodSNode, aFormalParameter, retVal);¶		} else {¶			List<SNode> aChildren = anSNode.getChildren();¶			for (SNode aChild:aChildren) {¶				fillDirectAssignmentsOfVariableAndItsAliases(aChild, aVariable, retVal);¶			}¶		}		¶		¶	}¶	¶	public static RootOfFileSNode getRootOfFileNode(SNode aCurrentSNode ) {¶		if (aCurrentSNode instanceof RootOfFileSNode) {¶			return (RootOfFileSNode) aCurrentSNode;¶		}¶		SNode aParentSNode = aCurrentSNode.getParent() ;¶		¶		if (aParentSNode == null) {¶			return null;¶		}¶		¶		return getRootOfFileNode(aParentSNode);¶		¶	}¶	public static boolean match (MethodSNode aMethodSNode, MethodCall aMethodCall) {¶		return aMethodSNode.getMethodName().equals(aMethodCall.getMethodName()) ¶				&& aMethodSNode.getLocalVariableIdentifiers().size() == aMethodCall.getMethodActuals().size();¶	}¶	public static DeclarationSNode getDeclarationOfVariableIdentifier(SNode aCurrentSNode, String anIdentifier) {¶		if (aCurrentSNode == null) {¶			return null;¶		}¶		¶		¶		int anIndex = aCurrentSNode.getLocalVariableIdentifiers().indexOf(anIdentifier);¶		if (anIndex < 0) {¶			return getDeclarationOfVariableIdentifier(aCurrentSNode.getParent(), anIdentifier);¶		}¶		DeclarationSNode retVal = aCurrentSNode.getVariableDeclarations().get(anIndex);¶//		retVal.getAssignmentsToDeclaredVariable().add(anAssignmentSNode);¶//		anAssignmentSNode.setLhsFirstIdentifierDeclaration(retVal);¶		return retVal;¶	}¶	¶	public static DeclarationSNode getDeclarationOfAssignedVariable(SNode aCurrentSNode, AssignmentSNode anAssignmentSNode) {¶		if (aCurrentSNode == null) {¶			return null;¶		}¶		if (anAssignmentSNode instanceof ADeclaringAssignmentSNode) {¶			return (ADeclaringAssignmentSNode) anAssignmentSNode;¶		}¶		int anIndex = aCurrentSNode.getLocalVariableIdentifiers().indexOf(anAssignmentSNode.getLhsFirstIdentifier());¶		if (anIndex < 0) {¶			return getDeclarationOfAssignedVariable(aCurrentSNode.getParent(), anAssignmentSNode);¶		}¶		DeclarationSNode retVal = aCurrentSNode.getVariableDeclarations().get(anIndex);¶//		retVal.getAssignmentsToDeclaredVariable().add(anAssignmentSNode);¶//		anAssignmentSNode.setLhsFirstIdentifierDeclaration(retVal);¶		return retVal;¶	}¶	¶	public static MethodSNode getDeclarationOfCalledMethod(SNode aCurrentSNode, MethodCall aMethodCall ) {¶		SNode aRootNode = getRootOfFileNode(aCurrentSNode);¶		for (SNode aChild:aRootNode.getChildren()) {¶			if (aChild instanceof MethodSNode) {¶				MethodSNode aMethodSNode = (MethodSNode) aChild;¶				if (match (aMethodSNode, aMethodCall)) {¶					return aMethodSNode;¶				}¶			}¶		}¶		return null; // this should never happen;¶	}¶	¶	public static RootOfProgramSNode getRootOfProgramSNode(String aSource) {¶		RootOfProgramSNode retVal = new ARootOfProgramSNode();¶		Map<String, StringBuffer> aFileNameToContents = ABasicTextManager.extractFileContents(aSource);¶		for (String aFileName:aFileNameToContents.keySet()) {¶			StringBuffer aFileContents = aFileNameToContents.get(aFileName);¶//			List<OpenMPPragma> anOpenMPPragmas = OpenMPUtils.getOpemMPPragmas(aFileContents);¶			RootOfFileSNode anSNode = OMPSNodeUtils.getSNode(aFileName, aFileContents);¶			retVal.getFileNameToSNode().put(aFileName, anSNode);¶			anSNode.setParent(retVal);¶//			System.out.println("file name:" + aFileName);¶//			System.out.println("pragmas:" + anSNode);¶		}¶		processExternalMethodSNodes(retVal);¶		processIndirectAssignments(retVal);¶		return retVal;¶	}¶//	public static void processIndirectAssignments (S aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode) {¶//		for (SNode anSNode:aRootOfFileSNode.getChildren()) {¶//			-----¶//		}¶//	}¶	public static void processExternalMethodSNodes (RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode) {¶		for (SNode anSNode:aRootOfFileSNode.getChildren()) {¶			if (anSNode instanceof ExternalMethodSNode) {¶				processExternalMethodSNode(aRootOfProgramSNode, aRootOfFileSNode, (ExternalMethodSNode) anSNode);¶			}¶		}¶	}¶	public static void processExternalMethodSNode (RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode, ExternalMethodSNode anExternalMethodSNode) {¶		MethodSNode aMethodSNode = aRootOfProgramSNode.getExternalToInternalMethod().get(anExternalMethodSNode.toString());¶		if (aMethodSNode == null) {¶			aMethodSNode = findMethodSNode(aRootOfProgramSNode, aRootOfFileSNode, anExternalMethodSNode);¶			if (aMethodSNode != null) {¶				aRootOfProgramSNode.getExternalToInternalMethod().put(anExternalMethodSNode.toString(),aMethodSNode );¶			}¶		}¶		if (aMethodSNode != null) {¶			anExternalMethodSNode.setActualMethodSNode(aMethodSNode);¶			aMethodSNode.getCalls().addAll(anExternalMethodSNode.getLocalCalls());¶		}¶	}¶	¶	public static MethodSNode findMethodSNode (RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode, ExternalMethodSNode anExternalMethodSNode) {¶//		MethodSNode foundMethodSNode = null;¶		for (String aFileName:aRootOfProgramSNode.getFileNameToSNode().keySet()) {¶			if (aFileName.equals(aRootOfFileSNode.getFileName()))¶				continue;¶			¶			RootOfFileSNode aSearchedRootOfFileSNode = aRootOfProgramSNode.getFileNameToSNode().get(aFileName);¶			 for (SNode anSNode:aSearchedRootOfFileSNode.getChildren()) {¶				if (anSNode instanceof MethodSNode && !(anSNode instanceof ExternalMethodSNode)) {¶					if (anSNode.toString().equals(anExternalMethodSNode.toString())) {¶						return (MethodSNode) anSNode;¶						¶					}¶//					processExternalMethodSNode(aRootOfProgramSNode, aRootOfFileSNode, (ExternalMethodSNode) anSNode);¶				}¶			}¶		}¶		return null;¶	}¶	public static void processExternalMethodSNodes (RootOfProgramSNode aRootOfProgramSNode) {¶		for (String aFileName:aRootOfProgramSNode.getFileNameToSNode().keySet()) {¶			RootOfFileSNode aRootOfFileSNode = aRootOfProgramSNode.getFileNameToSNode().get(aFileName);¶			processExternalMethodSNodes(aRootOfProgramSNode, aRootOfFileSNode);¶			aRootOfFileSNode.getOmp_get_num_threads_SNode().¶				setActualMethodSNode(aRootOfProgramSNode.getOmp_get_num_threads_SNode());¶			aRootOfFileSNode.getOmp_get_thread_num_SNode().¶				setActualMethodSNode(aRootOfProgramSNode.getOmp_get_thread_num_SNode());¶			aRootOfFileSNode.getOmp_get_wtime_SNode().¶			setActualMethodSNode(aRootOfProgramSNode.getOmp_get_wtime_SNode());¶		}¶¶	}¶	public static void processIndirectAssignments (SNode anSNode) {¶		if (anSNode instanceof ConstDeclarationSNode) {¶			return;¶		}¶		if (anSNode instanceof DeclarationSNode) {¶			DeclarationSNode aDeclarationSNode = (DeclarationSNode) anSNode;¶			Set<AssignmentSNode> anIndirectAssignments = aDeclarationSNode.getAssignmentsEffectingDeclaredIdentifier();¶			if (anIndirectAssignments != null) {¶				return; // already assigned¶			}¶			anIndirectAssignments = new HashSet<>();¶			aDeclarationSNode.setAssignmentsEffectingDeclaredIdentifier(anIndirectAssignments);¶			Set<AssignmentSNode> aDirectAssignments = aDeclarationSNode.getAssignmentsToDeclaredVariable();¶			anIndirectAssignments.addAll(aDirectAssignments);¶			Set<AssignmentSNode> anAliasAssignments = assignmentsOfVariableAliases(aDeclarationSNode.getParent(), aDeclarationSNode.getVariableName());¶			anIndirectAssignments.addAll(anAliasAssignments);¶			for (AssignmentSNode aDirectAssignment:aDirectAssignments) {¶				List<String> aVariableIdentifiers = aDirectAssignment.getRhsVariableIdentifiers();¶				¶				for (String aVariableIdentifier:aVariableIdentifiers) {¶					DeclarationSNode aDependeeDeclarationSNode = getDeclarationOfVariableIdentifier(aDirectAssignment, aVariableIdentifier);¶					if (aDependeeDeclarationSNode == null) {¶						System.err.println("Could not find declaration of:" + aVariableIdentifier + " referenced in:" + aDirectAssignment );¶						continue;¶					}¶					processIndirectAssignments(aDependeeDeclarationSNode);¶					Set<AssignmentSNode> aDependeeIndirectAssignments = aDeclarationSNode.getAssignmentsEffectingDeclaredIdentifier();¶					anIndirectAssignments.addAll(aDependeeIndirectAssignments);¶					¶				}¶			}¶		} else {¶			for (SNode aChild: anSNode.getChildren()) {¶				processIndirectAssignments(aChild);¶			}¶		}¶		¶	}¶	¶//	public static void fillIndirectAssignments (SNode anSNode, Set<AssignmentSNode> retVal ) {¶//		¶//	}¶	¶¶//	public static void main(String[] args) {¶//		List<MethodCall> aTokens = callsIn("foo(bar, hgf)/foo2()*foo3(b, a c,)");¶//		System.out.println(aTokens);¶//		¶//		¶////		List<String> aTokens = identifiersIn("a[i] + b*2/3");¶////		System.out.println(aTokens);¶////		aTokens = numbersIn("a[i] + b*2/3");¶////		System.out.println(aTokens);¶////		aTokens = operatorsIn("a[i] + b*2/3");¶////		System.out.println(aTokens);¶////¶////		System.out.println(StringUtils.substringBetween("a", "[", "]"));¶//	}¶¶}¶")]]]></diff>
  </Command>
  <Command __id="218117" _type="ShellCommand" date="Fri Jan 10 10:20:57 EST 2020" starttimestamp="1576666505112" timestamp="2003152822" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="218216" _type="DiffBasedFileOpenCommand" date="Fri Jan 10 10:29:45 EST 2020" docASTNodeCount="5134" docActiveCodeLength="37675" docExpressionCount="3174" docLength="43794" projectName="GraderBasics" starttimestamp="1576666505112" timestamp="2003680237">
    <filePath><![CDATA[D:\dewan_backup\Java\GraderBasics\src\gradingTools\shared\testcases\openmp\scannedTree\OMPSNodeUtils.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package gradingTools.shared.testcases.openmp.scannedTree;¶¶import java.util.ArrayList;¶import java.util.Arrays;¶import java.util.HashMap;¶import java.util.HashSet;¶import java.util.List;¶import java.util.Map;¶import java.util.Set;¶import java.util.Stack;¶import java.util.regex.Matcher;¶import java.util.regex.Pattern;¶¶import org.apache.commons.lang.StringUtils;¶¶import grader.basics.project.source.ABasicTextManager;¶import gradingTools.shared.testcases.openmp.OpenMPKeywordEnum;¶import gradingTools.shared.testcases.openmp.OpenMPParallelPragma;¶import gradingTools.shared.testcases.openmp.OpenMPUtils;¶import gradingTools.shared.testcases.openmp.scannedTree.ADeclarationSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.ADeclaringAssignmentSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.AForSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.ATextSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.AnAssignmentSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.AnOMPCriticalSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.AnOMPForSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.AnOMPParallelSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.AnOMPSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.AnSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.AssignmentSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.DeclarationSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.DeclaringAssignmentSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.ForSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.OMPForSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.OMPSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.SNode;¶¶public class OMPSNodeUtils extends OpenMPUtils {¶¶	public static RootOfFileSNode getSNode(String aFileName, StringBuffer aFileBuffer) {¶		String[] aFileLines = aFileBuffer.toString().split("\n");¶		return getSNode(aFileName, aFileLines);¶	}¶¶	public static AssignmentSNode getAssignmentSNode(int aLineNumber, String aString) {¶		if (aString == null) {¶			return null;¶		}¶		String[] aTokens = aString.split("=");¶		if (aTokens.length == 1) {¶			return new AnAssignmentSNode(aLineNumber, aTokens[0], null);¶		} else {¶		return new AnAssignmentSNode(aLineNumber, aTokens[0], aTokens[1]);¶		}¶	}¶¶	public static DeclarationSNode getDeclarationSNode(int aLineNumber, String aString) {¶		String[] aTokens = aString.split(" ");¶		return new ADeclarationSNode(aLineNumber, aTokens[0], aTokens[1]);¶	}¶¶	public static DeclaringAssignmentSNode getDeclaringAssignmentSNode(int aLineNumber, String aString) {¶		String[] anLHSAndRHS = aString.split("=");¶		String[] aTypeAndVariable = anLHSAndRHS[0].split(" ");¶		return new ADeclaringAssignmentSNode(aLineNumber, aTypeAndVariable[0], aTypeAndVariable[1], anLHSAndRHS[1]);¶	}¶	public static ConstDeclarationSNode getConstDeclarationSNode(int aLineNumber, String aString) {¶		String anAssignmentString = aString.substring(CONST.length()).trim();¶		String[] anLHSAndRHS = anAssignmentString.split("=");¶		String[] aTypeAndVariable = anLHSAndRHS[0].split(" ");¶		return new AConstDeclarationSNode(aLineNumber, aTypeAndVariable[0], aTypeAndVariable[1], anLHSAndRHS[1]);¶	}¶¶	public static boolean isDeclaringAssignment(String aFileLine) {¶		return startsWithTypeName(aFileLine) && aFileLine.contains("=");¶	}¶	public static boolean isConstDeclaration(String aFileLine) {¶		return aFileLine.startsWith(CONST);¶	}¶	public static boolean isMethodDeclaration(String aFileLine) {¶		return startsWithTypeName(aFileLine) && ¶				aFileLine.contains("(") &&¶				!aFileLine.contains("=");¶	}¶	public static boolean isExternalMethodDeclaration(String aFileLine) {¶		return isMethodDeclaration(aFileLine) && aFileLine.endsWith(";");¶	}¶¶¶	public static boolean isVariableDeclaration(String aFileLine) {¶¶		return startsWithTypeName(aFileLine) && !aFileLine.contains("(");¶	}¶¶	public static boolean isAssignment(String aFileLine) {¶		return aFileLine.contains("=") && !aFileLine.contains("==");¶	}¶¶	public static boolean isForNode(String aFileLine) {¶		return aFileLine.startsWith("for");¶	}¶¶	public static ForSNode getForSNode(int aLineNumber, String aFileLine) {¶¶		int aLeftParenIndex = aFileLine.indexOf("(");¶		int aRightParenIndex = aFileLine.indexOf(")");¶		if (aLeftParenIndex < 0 || aRightParenIndex < 0) {¶			return null;¶		}¶		String aHeaderString = aFileLine.substring(aLeftParenIndex + 1, aRightParenIndex);¶		String[] aForComponents = aHeaderString.split(";");¶		AssignmentSNode anAssignmentSNode = null;¶		String aForInitializaton = aForComponents[0];¶		if (!aForInitializaton.isEmpty() && aForInitializaton.contains("=")) {¶			if (isDeclaringAssignment(aForInitializaton)) {¶				anAssignmentSNode = getDeclaringAssignmentSNode(aLineNumber, aForInitializaton);¶			} else {¶				anAssignmentSNode = getAssignmentSNode(aLineNumber, aForInitializaton);¶			}¶¶		}		¶		return new AForSNode(aLineNumber, anAssignmentSNode, aForComponents[1], getAssignmentSNode(aLineNumber, aForComponents[2]));¶	}¶	static String[] emptyArray = {};¶	public static MethodSNode getMethodSNode(int aLineNumber, String aFileLine, boolean isInternal) {¶¶		int aLeftParenIndex = aFileLine.indexOf("(");¶		int aRightParenIndex = aFileLine.indexOf(")");¶		if (aLeftParenIndex < 0 || aRightParenIndex < 0) {¶			return null;¶		}¶		String aMethodNameAndType = aFileLine.substring(0, aLeftParenIndex);¶		String[] aMethodNameAndTypeTokens = aMethodNameAndType.split("\\s+"); ¶		¶		String aMethodParameters = aFileLine.substring(aLeftParenIndex +1 , aRightParenIndex);¶		String[] aMethodParameterTokens = aMethodParameters.isEmpty()?emptyArray:¶		 aMethodParameters.split(",");¶		¶//		String[] aMethodParameterTypes = new String[aMethodParameterTokens.length];¶//		String[] aMethodParameterNames = new String[aMethodParameterTokens.length];¶		List<DeclarationSNode> aDeclarationSNodeList = new ArrayList();¶		for (int i = 0; i < aMethodParameterTokens.length; i++ ) {¶			String[] aTypeAndName = aMethodParameterTokens[i].trim().split("\\s+");¶			if (aTypeAndName.length < 2) {¶				continue;¶			}¶			aDeclarationSNodeList.add(new ADeclarationSNode(aLineNumber, aTypeAndName[0].trim(), aTypeAndName[1].trim()));¶//			aMethodParameterTypes[i] = aTypeAndName[0].trim();¶//			aMethodParameterNames[i] = aTypeAndName[1].trim();¶		}¶		if (isInternal)¶//		return new AMethodSNode(aLineNumber, aMethodNameAndTypeTokens[0], aMethodNameAndTypeTokens[1], aMethodParameterTypes,aMethodParameterNames );¶			return new AMethodSNode(aLineNumber, aMethodNameAndTypeTokens[0], aMethodNameAndTypeTokens[1], aDeclarationSNodeList );¶		else¶			return new AnExternalMethodSNode(aLineNumber, aMethodNameAndTypeTokens[0], aMethodNameAndTypeTokens[1], aDeclarationSNodeList );¶	}¶¶	public static void setReductionData(OMPForSNode lastChild, String aStoredToken, int aLeftParenIndex,¶			int aRightParenIndex) {¶		int aColonIndex = aStoredToken.indexOf(":");¶		if (aLeftParenIndex != -1 && aRightParenIndex != -1 && aColonIndex != -1) {¶			String anOperationString = aStoredToken.substring(aLeftParenIndex + 1, aColonIndex).trim();¶			String aVariableString = aStoredToken.substring(aColonIndex + 1, aRightParenIndex).trim();¶			((OMPForSNode) lastChild).setReductionVariable(aVariableString);¶			((OMPForSNode) lastChild).setReductionOperation(anOperationString);¶		}¶	}¶¶	public static void setSharedOrPrivateData(OMPSNode lastChild, String aStoredToken, int aLeftParenIndex,¶			int aRightParenIndex, boolean isShared) {¶//		int aColonIndex = aStoredToken.indexOf(":");¶		if (aLeftParenIndex != -1 && aRightParenIndex != -1) {¶			String aVariableDeclarations = aStoredToken.substring(aLeftParenIndex + 1, aRightParenIndex);¶			String[] aVariables = aVariableDeclarations.split(",");¶			if (isShared) {¶				lastChild.setSharedVariables(aVariables);¶			} else {¶				lastChild.setPrivateVariables(aVariables);¶			}¶		}¶	}¶¶	public static RootOfFileSNode getSNode(String aFileName, String[] aFileLines) {¶		Stack<SNode> anSNodes = new Stack();¶¶		RootOfFileSNode retVal = new ARootOfFileSNode(aFileName);¶		anSNodes.add(retVal);¶		SNode previousHeaderNode = null;¶		for (int i = 0; i < aFileLines.length; i++) {¶			String aFileLine = aFileLines[i].trim();¶			if (!isCodeLine(aFileLine)) {¶				continue;¶			}¶			if (isForNode(aFileLine)) {¶				ForSNode aForSNode = getForSNode(i, aFileLine);¶				SNode aParent = previousHeaderNode != null?previousHeaderNode:anSNodes.peek();¶				aForSNode.setParent(anSNodes.peek());¶				aForSNode.setParent(aParent);¶¶//				anSNodes.push(aForSNode);¶				previousHeaderNode = aForSNode;¶				if (aFileLine.endsWith(")")) {¶					continue;¶				}¶			}¶			if (isExternalMethodDeclaration(aFileLine)) {¶				MethodSNode aMethodSNode = getMethodSNode(i, aFileLine, false);¶				aMethodSNode.setParent(anSNodes.peek());¶//				anSNodes.push(aForSNode);¶				previousHeaderNode = aMethodSNode;¶				if (aFileLine.endsWith(")")) {¶					continue;¶				}¶			}¶			if (isMethodDeclaration(aFileLine)) {¶				MethodSNode aMethodSNode = getMethodSNode(i, aFileLine, true);¶				aMethodSNode.setParent(anSNodes.peek());¶//				anSNodes.push(aForSNode);¶				previousHeaderNode = aMethodSNode;¶				if (aFileLine.endsWith(")")) {¶					continue;¶				}¶			}¶			if (isPragmaStart(aFileLine)) {¶				OMPSNode anOMPSNode = getOMPSNode(i, anSNodes.peek(), aFileLine);¶//				anSNodes.push(anOMPSNode);¶				previousHeaderNode = anOMPSNode;¶				continue;¶			}¶			if (isBlockStart(aFileLine)) {¶				SNode aBlockSNode = new ABlockSNode(i);¶				if (previousHeaderNode != null) {¶					aBlockSNode.setParent(previousHeaderNode);¶				} else {¶					aBlockSNode.setParent(anSNodes.peek());¶				}¶				anSNodes.push(aBlockSNode);¶				previousHeaderNode = null;¶				continue;¶			}¶//			} else ¶			if (isBlockEnd(aFileLine)) {¶				anSNodes.pop();¶				continue;¶			}¶			SNode aNewLeafNode = null;¶			if (isConstDeclaration(aFileLine)) {¶				aNewLeafNode = getConstDeclarationSNode(i, aFileLine);¶¶			} else if (isDeclaringAssignment(aFileLine)) {¶				aNewLeafNode = getDeclaringAssignmentSNode(i, aFileLine);¶¶			} else if (isAssignment(aFileLine)) {¶				aNewLeafNode = getAssignmentSNode(i, aFileLine);¶			} else if (isVariableDeclaration(aFileLine)) {¶				aNewLeafNode = getDeclarationSNode(i, aFileLine);¶			} else {¶				List<MethodCall> aCalls = callsIn(i, aFileLine, null); // parent will be assigned below¶				if (aCalls != null && aCalls.size() == 1) {¶					aNewLeafNode = aCalls.get(0);¶				} else {¶					aNewLeafNode = new ATextSNode(i, aFileLine);¶				}¶			}¶//			else {¶//				aNewLeafNode = new ATextSNode(i, aFileLine);¶//			}¶			if (previousHeaderNode != null) {¶				aNewLeafNode.setParent(previousHeaderNode);¶			} else {¶				aNewLeafNode.setParent(anSNodes.peek());¶			}¶¶		}¶¶		return retVal;¶	}¶¶	public static OMPSNode getOMPSNode(int aLineIndex, SNode aParentNode, String aFileLine) {¶		String[] aTokens = aFileLine.split("\\s+");¶		if (aTokens.length <= 2) {¶			return null;¶		}¶		if (!aTokens[1].equals("omp")) {¶			return null;¶		}¶		if (aTokens.length < 3) {¶			return null;¶		}¶		String aFirstToken = aTokens[2];¶		OpenMPKeywordEnum anOpenMPKeyword = stringToOpenMPKeyword.get(aFirstToken);¶//		List<OpenMPPragma> retVal = new ArrayList();¶		OMPSNode lastChild = null;¶		int aStartIndex = 2;¶		OMPSNode aNewNode = null;¶		OMPForSNode aForChild = null;¶		switch (anOpenMPKeyword) {¶		case PARALLEL:¶			aNewNode = new AnOMPParallelSNode(aLineIndex);¶¶			if (aTokens.length > 3 && aTokens[3].equals("for")) {¶				aForChild = new AnOMPForSNode(aLineIndex);¶				aForChild.setParent(aNewNode);¶¶				aStartIndex++;¶			}¶			break;¶		case FOR:¶			aNewNode = new AnOMPForSNode(aLineIndex);¶			;¶			break;¶		case CRITICAL:¶			aNewNode = new AnOMPCriticalSNode(aLineIndex);¶//			retVal.add (lastChild);¶			break;¶		default:¶			aNewNode = new AnOMPSNode(aLineIndex);¶¶		}¶¶		if (lastChild != null) {¶			aNewNode.setParent(lastChild);¶		} else {¶			aNewNode.setParent(aParentNode);¶		}¶		lastChild = aForChild == null ? aNewNode : aForChild;¶¶		for (int i = aStartIndex; i < aTokens.length; i++) {¶			String aStoredToken = aTokens[i].trim();¶			if (aStoredToken.isEmpty()) {¶				continue;¶			}¶			if (aStoredToken.startsWith("reduction") || aStoredToken.startsWith("shared")¶					|| aStoredToken.startsWith("private")) {¶				// combine all tokens until ")" into one for normalization¶				while (!aStoredToken.endsWith(")")) {¶					i++;¶					if (i >= aTokens.length) {¶						break;¶					}¶					String aNewToken = aTokens[i].trim();¶					aStoredToken += aNewToken;¶				}¶				int aLeftParenIndex = aStoredToken.indexOf("(");¶				int aRightParenIndex = aStoredToken.indexOf(")");¶				if (aStoredToken.startsWith("reduction")) {¶					setReductionData((OMPForSNode) lastChild, aStoredToken, aLeftParenIndex, aRightParenIndex);¶				} else if (aStoredToken.startsWith("private")) {¶					setSharedOrPrivateData((OMPSNode) lastChild, aStoredToken, aLeftParenIndex, aRightParenIndex,¶							false);¶¶				} else if (aStoredToken.startsWith("shared")) {¶					setSharedOrPrivateData(lastChild, aStoredToken, aLeftParenIndex, aRightParenIndex, true);¶¶				}¶¶			}¶¶			lastChild.getOpenMPTokens().add(aStoredToken);¶		}¶¶		return lastChild;¶¶	}¶¶	public static boolean hasParallelAncestor(SNode anSNode) {¶		if (anSNode == null) {¶			return false;¶		}¶		if (anSNode instanceof OMPParallelSNode) {¶			return true;¶		}¶		return hasParallelAncestor(anSNode.getParent());¶	}¶	public static boolean hasCriticalAncestor(SNode anSNode) {¶		if (anSNode == null) {¶			return false;¶		}¶		if (anSNode instanceof OMPCriticalSNode) {¶			return true;¶		}¶		return hasCriticalAncestor(anSNode.getParent());¶	}¶¶¶	public static Boolean isDeclaredShared(OMPSNode anOMPSNode, String anLHS) {¶		if (Arrays.asList(anOMPSNode.getSharedVariables()).contains(anLHS)) {¶			return true;¶		}¶		if (Arrays.asList(anOMPSNode.getPrivateVariables()).contains(anLHS)) {¶			return false;¶		}¶		return null;¶¶	}¶¶	public static boolean isSharedVariable(SNode anSNode, String anLHS) {¶		if (anSNode == null) {¶			return false;¶		}¶		if (anSNode.getLocalVariableIdentifiers().contains(anLHS)) {¶			if (!(anSNode instanceof OMPSNode)) { // no shared and private declarations¶				return !hasParallelAncestor(anSNode); // shared if not inParallel¶			}¶			OMPSNode anOMPSNode = (OMPSNode) anSNode;¶			return (Arrays.asList(anOMPSNode.getSharedVariables()).contains(anLHS)); // private unless declared shared¶		}¶		if (anSNode instanceof OMPSNode) {¶			OMPSNode anOMPSNode = (OMPSNode) anSNode;¶			// the variable is global to this scope, check if it has have been made shared¶			// or private by this scope¶			Boolean isDeclaredShared = isDeclaredShared(anOMPSNode, anLHS);¶			if (isDeclaredShared != null) {¶				return isDeclaredShared;¶			}¶		}¶		// check the parent¶		return isSharedVariable(anSNode.getParent(), anLHS);¶	}¶¶	public static List<SNode> getAllLeafNodes(SNode aTopNode) {¶		List<SNode> retVal = new ArrayList();¶		addLeafNodes(aTopNode, retVal);¶		return retVal;¶	}¶¶	public static void addLeafNodes(SNode aTopNode, List<SNode> retVal) {¶		for (SNode aChild : aTopNode.getChildren()) {¶			if (aChild.isLeaf()) {¶				retVal.add(aChild);¶			} else {¶				addLeafNodes(aChild, retVal);¶			}¶		}¶	}¶¶	public static List<SNode> getNonParallelLeafNodes(SNode aTopNode) {¶		List<SNode> retVal = new ArrayList();¶		addNonParallelLeafNodes(aTopNode, retVal);¶		return retVal;¶	}¶¶	public static void addNonParallelLeafNodes(SNode aTopNode, List<SNode> retVal) {¶		if (aTopNode.isInParallel()) {¶			return;¶		}¶		for (SNode aChild : aTopNode.getChildren()) {¶			if (aChild.isLeaf()) {¶				retVal.add(aChild);¶			} else {¶				addLeafNodes(aChild, retVal);¶			}¶		}¶	}¶	static String callRegex = "([a-zA-Z_$][a-zA-Z_$0-9]*)\\(.*?\\)";¶	static Pattern callPattern = Pattern.compile(callRegex);¶¶	static String identifierRegex = "[a-zA-Z_$][a-zA-Z_$0-9]*";¶	static Pattern identifierPattern = Pattern.compile(identifierRegex);¶	public static List<String> identifiersIn(String aString) {¶		if (aString == null)¶			return null;¶//		Pattern mypattern = Pattern.compile("[a-zA-Z_$][a-zA-Z_$0-9]*");¶//		Matcher mymatcher = mypattern.matcher(aString);¶		Matcher mymatcher = identifierPattern.matcher(aString);¶		List<String> retVal = new ArrayList();¶		while (mymatcher.find()) {¶			String find = mymatcher.group(0);¶			retVal.add(find);¶		}¶		return retVal;¶	}¶	public static List<MethodCall> callsIn(int aLineNumber, String aString, SNode aParent) {¶		if (aString == null)¶			return emptyList;¶		if (isMethodDeclaration(aString)) {¶			return emptyList;¶		}¶//		Pattern mypattern = Pattern.compile("[a-zA-Z_$][a-zA-Z_$0-9]*");¶//		Matcher mymatcher = mypattern.matcher(aString);¶		Matcher mymatcher = callPattern.matcher(aString);¶		List<MethodCall> retVal = new ArrayList();¶		while (mymatcher.find()) {¶			String find = mymatcher.group(0);¶			int aLeftParenIndex = find.indexOf("(");¶			int aRightParenIndex = find.indexOf(")");¶			String aMethodName = find.substring(0, aLeftParenIndex).trim();¶			String aParameters = find.substring(aLeftParenIndex + 1, aRightParenIndex);¶			List<String> aParameterList = new ArrayList();¶			String[] aParameterTokens = aParameters.split(",");¶			for (String aParameter:aParameterTokens) {¶				String aParameterTrimmed = aParameter.trim();¶				if (!aParameterTrimmed.isEmpty())¶				aParameterList.add(aParameterTrimmed);¶			}¶			retVal.add(new AMethodCall(aLineNumber, aMethodName, aParameterList, aParent));¶¶//			aCallStrings.add(find);¶		}¶		return retVal;¶	}¶	static String numberRegex = "(\\d+\\.\\d+)|(\\d+)";¶	static Pattern numberPattern = Pattern.compile(numberRegex);¶	public static List<String> numbersIn(String aString) {¶		if (aString == null)¶			return null;¶//		String regex = "(\\d+\\.\\d+)|(\\d+)";¶//¶//		Matcher m = Pattern.compile(regex).matcher(aString);¶		Matcher m =numberPattern.matcher(aString);¶¶¶		List<String> retVal = new ArrayList();¶¶		while (m.find()) {¶			retVal.add(m.group());¶		}¶		return retVal;¶	}¶¶	public static String subscriptIn(String aString) {¶		if (aString == null)¶			return null;¶		return StringUtils.substringBetween(aString, "[", "]");¶	}¶	static String[] emptyStringArray = {};¶	static List emptyList = new ArrayList();¶¶	public static String[] subscriptsIn(String aString) {¶		if (aString == null)¶			return emptyStringArray;¶		return StringUtils.substringsBetween(aString, "[", "]");¶	}¶	static  String operatorRegex = "([+-/*///^])|([/(/)])";¶	static Pattern operatorPattern = Pattern.compile(operatorRegex);¶¶	public static List<String> operatorsIn(String aString) {¶		if (aString == null)¶			return null;¶//		String operatorRegex = "([+-/*///^])|([/(/)])";¶//¶//		Matcher m = Pattern.compile(operatorRegex).matcher(aString);¶		¶		Matcher m = operatorPattern.matcher(aString);¶¶¶		List<String> retVal = new ArrayList();¶¶		while (m.find()) {¶			retVal.add(m.group());¶		}¶		return retVal;¶	}¶	¶	public static int numberOfNestingFors (SNode anSNode) {¶		if (anSNode == null) {¶			return 0;¶		}¶		int retVal = numberOfNestingFors (anSNode.getParent()) ;¶¶		if (anSNode instanceof ForSNode) {¶			retVal++;¶		} else if (anSNode instanceof MethodSNode) {¶			List<MethodCall> aMethodCalls = ((MethodSNode) anSNode).getCalls();¶			int aMaxNestingLevel = 0;¶			for (MethodCall aMethodCall:aMethodCalls) {¶				MethodSNode aCallerMethodSNode = getDeclarationOfCalledMethod(anSNode, aMethodCall);¶				int aCallerNumberOfNestingFors = numberOfNestingFors(aCallerMethodSNode);¶				aMaxNestingLevel = Math.max(aCallerNumberOfNestingFors, aMaxNestingLevel);				¶			}¶			return retVal + aMaxNestingLevel;¶		}¶		return retVal;¶	}¶	public static boolean hasOperator (SNode anSNode, String anOperator) {¶		boolean retVal = false;¶		if (anSNode instanceof AssignmentSNode) {¶			AssignmentSNode anAssignmentSNode = (AssignmentSNode) anSNode;¶			 retVal = (anAssignmentSNode.getLhsOperators().contains(anOperator) || ¶					anAssignmentSNode.getRhsOperators().contains(anOperator)) ;¶			if (retVal) {¶				return retVal;¶			} else {¶				List<MethodCall> aMethodCalls = anAssignmentSNode.getRhsCalls();¶				for (MethodCall aMethodCall:aMethodCalls) {¶					MethodSNode aMethodSNode = getDeclarationOfCalledMethod(anSNode, aMethodCall);¶					retVal = hasOperator(aMethodSNode, anOperator);¶					if (retVal) {¶						return retVal;¶					}¶					¶				}¶				return false;¶			}¶			¶		}¶		for (SNode aChild:anSNode.getChildren()) {¶			retVal = hasOperator(aChild, anOperator);¶			if (retVal) {¶				return retVal;¶			}¶		}¶		return false;¶	}¶	public static boolean hasMethodCall (SNode anSNode, String anOperator) {¶		boolean retVal = false;¶		if (anSNode instanceof AssignmentSNode) {¶			AssignmentSNode anAssignmentSNode = (AssignmentSNode) anSNode;¶			 retVal = (anAssignmentSNode.getLhsOperators().contains(anOperator) || ¶					anAssignmentSNode.getRhsOperators().contains(anOperator)) ;¶			if (retVal) {¶				return retVal;¶			} else {¶				List<MethodCall> aMethodCalls = anAssignmentSNode.getRhsCalls();¶				for (MethodCall aMethodCall:aMethodCalls) {¶					MethodSNode aMethodSNode = getDeclarationOfCalledMethod(anSNode, aMethodCall);¶					retVal = hasOperator(aMethodSNode, anOperator);¶					if (retVal) {¶						return retVal;¶					}¶					¶				}¶				return false;¶			}¶			¶		}¶		for (SNode aChild:anSNode.getChildren()) {¶			retVal = hasOperator(aChild, anOperator);¶			if (retVal) {¶				return retVal;¶			}¶		}¶		return false;¶	}¶	public static boolean dependsOn (AssignmentSNode anAssignmentSNode, String aVariable, String aCallIdentifier) {¶		// This assignment does not change aVariable¶		if (!aVariable.equals(anAssignmentSNode.getLhsFirstIdentifier())) {¶			return false;¶		}¶		return dependsOn(anAssignmentSNode.getExpressionSNode(), aCallIdentifier);¶//		List<String> aCallIdentifiers = anAssignmentSNode.getRhsCallIdentifiers();¶//		boolean retVal = false;¶//		if (aCallIdentifiers != null && aCallIdentifiers.contains(aCallIdentifier)) {¶//			return true; // this assignment has aCallIdentifier in the rhs¶//		}¶//		// check if some referenced rhs variable depends on aCallIdentifier¶//		List<String> aReferencedVariableIdentifiers = anAssignmentSNode.getRhsVariableIdentifiers();¶//		SNode anAssignmentParent = anAssignmentSNode.getParent();¶//		if (anAssignmentParent == null) { // should never be trye¶//			return false;¶//		}¶//		int aLineNumber = anAssignmentSNode.getLineNumber();¶//		for (String aReferencedVariableIdentifier:aReferencedVariableIdentifiers ) {¶//			if (dependsOn (anAssignmentParent, aLineNumber, aReferencedVariableIdentifier, aCallIdentifier)) {¶//				return true;¶//			}¶//		}¶//		return false;¶	}¶	public static boolean dependsOn (ExpressionSNode anExpressionSNode, String aCallIdentifier) {¶		// This assignment does not change aVariable¶		¶		List<String> aCallIdentifiers = anExpressionSNode.getRhsCallIdentifiers();¶		boolean retVal = false;¶		if (aCallIdentifiers != null && aCallIdentifiers.contains(aCallIdentifier)) {¶			return true; // this assignment has aCallIdentifier in the rhs¶		}¶		// check if some referenced rhs variable depends on aCallIdentifier¶		List<String> aReferencedVariableIdentifiers = anExpressionSNode.getRhsVariableIdentifiers();¶		SNode anAssignmentParent = anExpressionSNode.getParent().getParent();¶		if (anAssignmentParent == null) { // should never be trye¶			return false;¶		}¶		int aLineNumber = anExpressionSNode.getLineNumber();¶		for (String aReferencedVariableIdentifier:aReferencedVariableIdentifiers ) {¶			if (dependsOn (anAssignmentParent, aLineNumber, aReferencedVariableIdentifier, aCallIdentifier)) {¶				return true;¶			}¶		}¶		return false;¶	}¶	public static Set<AssignmentSNode> assignmentsToSharedVariables(SNode anSNode) {¶		Set<AssignmentSNode> retVal =  new HashSet();¶		fillAssignmentsToShared(anSNode, retVal);¶		return retVal;¶		¶	}¶	public static Set<AssignmentSNode> assignmentsToSharedArrays(SNode anSNode) {¶		Set<AssignmentSNode> anAllSharedAssignments =  assignmentsToSharedVariables(anSNode);¶		Set<AssignmentSNode> aRetVal = new HashSet();¶		for (AssignmentSNode anAssignmentSNode:anAllSharedAssignments) {¶			if (anAssignmentSNode.getLhsSubscripts().length > 0) {¶				aRetVal.add(anAssignmentSNode);¶			}¶		}¶		return aRetVal;¶		¶	}¶	public static Set<AssignmentSNode> assignmentsToParallelCriticalSharedVariables(SNode anSNode) {¶		Set<AssignmentSNode> anAllSharedAssignments =  assignmentsToSharedVariables(anSNode);¶		Set<AssignmentSNode> aRetVal = new HashSet();¶		for (AssignmentSNode anAssignmentSNode:anAllSharedAssignments) {¶			if (anAssignmentSNode.isInParallel() &&¶					anAssignmentSNode.isInCritical()) {¶				aRetVal.add(anAssignmentSNode);¶			}¶		}¶		return aRetVal;¶		¶	}¶	public static Set<AssignmentSNode> assignmentsToNonParallelCriticalSharedVariables(SNode anSNode) {¶		Set<AssignmentSNode> anAllSharedAssignments =  assignmentsToSharedVariables(anSNode);¶		Set<AssignmentSNode> aRetVal = new HashSet();¶		for (AssignmentSNode anAssignmentSNode:anAllSharedAssignments) {¶			if (!anAssignmentSNode.isInParallel() &&¶					anAssignmentSNode.isInCritical()) {¶				aRetVal.add(anAssignmentSNode);¶			}¶		}¶		return aRetVal;¶		¶	}¶	public static Set<AssignmentSNode> assignmentsToParallelNonCriticalSharedVariables(SNode anSNode) {¶		Set<AssignmentSNode> anAllSharedAssignments =  assignmentsToSharedVariables(anSNode);¶		Set<AssignmentSNode> aRetVal = new HashSet();¶		for (AssignmentSNode anAssignmentSNode:anAllSharedAssignments) {¶			if (anAssignmentSNode.isInParallel() &&¶					!anAssignmentSNode.isInCritical()) {¶				aRetVal.add(anAssignmentSNode);¶			}¶		}¶		return aRetVal;¶		¶	}¶    public static void fillAssignmentsToShared(SNode anSNode, Set<AssignmentSNode> retVal) {¶    	if (anSNode instanceof AssignmentSNode) {¶			AssignmentSNode anAssignmentSNode = (AssignmentSNode) anSNode;¶			String anLHS = anAssignmentSNode.getLhsFirstIdentifier();¶			if (isSharedVariable(anSNode, anLHS)) {¶				retVal.add(anAssignmentSNode);¶				return;¶			}¶		}¶    	for (SNode aChild:anSNode.getChildren()) {¶    		fillAssignmentsToShared(aChild, retVal);¶    	}¶		¶	}¶    public static void fillInstancesOfNodeType(Class<? extends SNode> aNodeType, SNode anSNode, Set<SNode> retVal) {¶    	if (aNodeType.isAssignableFrom(anSNode.getClass())) {¶			¶				retVal.add(anSNode);¶				return;¶			}¶		¶    	for (SNode aChild:anSNode.getChildren()) {¶    		fillInstancesOfNodeType(aNodeType, aChild, retVal);¶    	}¶		¶	}¶    public static Set<AssignmentSNode>  assignmentSNodes(SNode anSNode) {¶    	Set retVal = new HashSet();    	¶    	fillInstancesOfNodeType(AssignmentSNode.class, anSNode, retVal );¶    	return retVal;¶	}¶   ¶    ¶    public static Set<OMPParallelSNode>  ompParallelSNodes(SNode anSNode) {¶    	Set retVal = new HashSet();    	¶    	fillInstancesOfNodeType(OMPParallelSNode.class, anSNode, retVal );¶    	return retVal;¶	}¶//    public static void fillOMPParallelSNodes(SNode anSNode, Set<OMPParallelSNode> retVal) {¶//    	if (anSNode instanceof OMPParallelSNode) {¶//    		retVal.add((OMPParallelSNode) anSNode);¶//		}¶//    	for (SNode aChild:anSNode.getChildren()) {¶//    		fillOMPParallelSNodes(aChild, retVal);¶//    	}		¶//	}¶    public static Set<ForSNode>  forSNodes(SNode anSNode) {¶    	Set retVal = new HashSet();    	¶    	fillInstancesOfNodeType(ForSNode.class, anSNode, retVal );¶    	return retVal;¶	}¶//    public static void fillForSNodes(SNode anSNode, Set<ForSNode> retVal) {¶//    	if (anSNode instanceof ForSNode) {¶//    		retVal.add((ForSNode) anSNode);¶//		}¶//    	for (SNode aChild:anSNode.getChildren()) {¶//    		fillForSNodes(aChild, retVal);¶//    	}		¶//	}¶    public static Set<OMPForSNode>  ompForSNodes(SNode anSNode) {¶    	Set retVal = new HashSet();    	¶    	fillInstancesOfNodeType(OMPForSNode.class, anSNode, retVal );¶    	return retVal;¶	}¶//    public static void fillOMPForSNodes(SNode anSNode, Set<OMPForSNode> retVal) {¶//    	if (anSNode instanceof OMPForSNode) {¶//    		retVal.add((OMPForSNode) anSNode);¶//		}¶//    	for (SNode aChild:anSNode.getChildren()) {¶//    		fillOMPForSNodes(aChild, retVal);¶//    	}		¶//	}¶    public static Set<OMPForSNode> ompReducingForNodes(SNode anSNode) {¶		Set<OMPForSNode> anAllOMPForSNodes =  ompForSNodes(anSNode);¶		Set<OMPForSNode> aRetVal = new HashSet();¶		for (OMPForSNode anOMPForSNode:anAllOMPForSNodes) {¶			if (anOMPForSNode.getReductionOperation() != null) {¶				aRetVal.add(anOMPForSNode);¶			}¶		}¶		return aRetVal;		¶	}¶    public static Set<AssignmentSNode> assignmentsToOMPReducingForNode(OMPForSNode anOMPForSNode) {¶    	String aReductionVariable = anOMPForSNode.getReductionVariable();¶    	return directAssignmentsOfVariableAndItsAliases(anOMPForSNode, aReductionVariable)	;¶    	¶    }¶	public static boolean dependsOn (SNode anSNode, int aVariableLineNumber, String aVariable, String aCallIdentifier) {¶		List<SNode> aListSNodes = anSNode.getChildren();¶		boolean retVal = false;¶		/*¶		 * Should probably ignore line number as it assumes straight line code¶		 */¶		for (int i = aVariableLineNumber; i >= 0; i--) {¶			SNode anSNodeChild = aListSNodes.get(i);¶			if (anSNodeChild instanceof AssignmentSNode) {¶				// does this statement in anSNode directly invoke aCallIdentifier ¶				if (dependsOn((AssignmentSNode) anSNodeChild, aVariable, aCallIdentifier))¶					return true;¶			} else if (!anSNode.isLeaf()) {¶					// child is overriding the variable so forget checking its assignment statements¶					if (anSNodeChild.getLocalVariableIdentifiers().contains(aVariable)) {¶						continue;¶					}¶					// some subblock of anSNode that has access to aVariable changes variable¶¶					if (dependsOn(anSNodeChild, anSNodeChild.getChildren().size() - 1, aVariable, aCallIdentifier)) {¶						return true;¶					}¶			}¶			¶		}¶		// none of the statements in anSNode or its descendents  have the required call¶		// is the variable a  method parameter ¶		if (anSNode instanceof MethodSNode) {¶			MethodSNode aMethodSNode = (MethodSNode) anSNode;¶			¶			int aParameterNumber = aMethodSNode.getLocalVariableIdentifiers().indexOf(aVariable);¶			if (aParameterNumber != -1) {¶				List <MethodCall> aCalls = aMethodSNode.getCalls();¶				for (MethodCall aCall:aCalls) {¶//					if (!aCall.getMethodActuals().contains(aVariable))¶//						continue;¶//					¶					MethodSNode aCallerSNode = getDeclarationOfCalledMethod(aMethodSNode, aCall);¶					if (dependsOn(aMethodSNode, aCallerSNode.getLineNumber(), aCallerSNode.getLocalVariableIdentifiers().get(aParameterNumber), aCallIdentifier));¶//				    if (aCallerDepends) {¶				    	return true;¶//				    }¶				}¶				return false;¶				// need to find all callers of method and see if any of the aliases for the variable in these¶				// calls depend on aCallIndentifier¶			}			¶			¶		} else if (anSNode.getLocalVariableIdentifiers().contains(aVariable)) {¶			// before going to the parent node, let us see if aVariable is declared here as a non  parameter ¶¶			return false; // no point going to parent¶		}¶		// not a local variable (parameter or declarated variable)¶		SNode anSNodeParent = anSNode.getParent() ;¶		if (anSNodeParent == null)  {¶			return false;¶		}¶		int anSNodeLineNumber = anSNodeParent.getChildren().indexOf(anSNode);¶		return dependsOn(anSNodeParent, anSNodeLineNumber, aVariable, aCallIdentifier);¶		¶	}¶	public static Set<AssignmentSNode> assignmentsOfVariableAliases (SNode anSNode,  String aVariable) {¶		Set<AssignmentSNode> retVal = new HashSet();¶		fillDirectAssignmentsOfVariableAliases(anSNode, aVariable, retVal);¶		return retVal;¶	}¶	public static void fillDirectAssignmentsOfVariableAliases (SNode anSNode,  String aVariable, Set<AssignmentSNode> retVal) {¶		if (anSNode instanceof MethodCall) {¶			MethodCall aMethodCall = (MethodCall) anSNode;¶			int aParameterNumber = aMethodCall.getMethodActualIdentifiers().indexOf(aVariable);¶			if (aParameterNumber < 0) {¶				return;¶			}¶			MethodSNode aDeclaringMethodSNode = getDeclarationOfCalledMethod(anSNode, aMethodCall);¶			String aFormalParameter = aDeclaringMethodSNode.getLocalVariableIdentifiers().get(aParameterNumber);¶//			Set<AssignmentSNode> aCallAssignments = ;¶			fillDirectAssignmentsOfVariableAliases(aDeclaringMethodSNode, aFormalParameter, retVal);¶		} else {¶			List<SNode> aChildren = anSNode.getChildren();¶			for (SNode aChild:aChildren) {¶				fillDirectAssignmentsOfVariableAliases(aChild, aVariable, retVal);¶			}¶		}		¶		¶	}¶	¶	/*¶	 * will not consider assignments to variables in the RHS of these assignments¶	 */¶	public static Set<AssignmentSNode> directAssignmentsOfVariableAndItsAliases (SNode anSNode,  String aVariable) {¶		Set<AssignmentSNode> retVal = new HashSet();¶		fillDirectAssignmentsOfVariableAndItsAliases(anSNode, aVariable, retVal);¶		return retVal;¶	}¶	¶//	public static Set<AssignmentSNode> assignmentsEffectingVariableAndItsAliases (SNode anSNode,  String aVariable) {¶//		Set<AssignmentSNode> retVal = directAssignmentsOfVariableAndItsAliases(anSNode, aVariable);¶//		¶//	}¶	public static void fillDirectAssignmentsOfVariableAndItsAliases (SNode anSNode,  String aVariable, Set<AssignmentSNode> retVal) {¶		if (anSNode instanceof AssignmentSNode) {¶			AssignmentSNode anAssignmentSNode = (AssignmentSNode) anSNode;¶			if (anAssignmentSNode.getLhsFirstIdentifier().equals(aVariable)) {¶				retVal.add(anAssignmentSNode);¶			}¶		}¶		¶		else if (anSNode instanceof MethodCall) {¶			MethodCall aMethodCall = (MethodCall) anSNode;¶			int aParameterNumber = aMethodCall.getMethodActualIdentifiers().indexOf(aVariable);¶			if (aParameterNumber < 0) {¶				return;¶			}¶			MethodSNode aDeclaringMethodSNode = getDeclarationOfCalledMethod(anSNode, aMethodCall);¶			String aFormalParameter = aDeclaringMethodSNode.getLocalVariableIdentifiers().get(aParameterNumber);¶//			Set<AssignmentSNode> aCallAssignments = ;¶			fillDirectAssignmentsOfVariableAndItsAliases(aDeclaringMethodSNode, aFormalParameter, retVal);¶		} else {¶			List<SNode> aChildren = anSNode.getChildren();¶			for (SNode aChild:aChildren) {¶				fillDirectAssignmentsOfVariableAndItsAliases(aChild, aVariable, retVal);¶			}¶		}		¶		¶	}¶	¶	public static RootOfFileSNode getRootOfFileNode(SNode aCurrentSNode ) {¶		if (aCurrentSNode instanceof RootOfFileSNode) {¶			return (RootOfFileSNode) aCurrentSNode;¶		}¶		SNode aParentSNode = aCurrentSNode.getParent() ;¶		¶		if (aParentSNode == null) {¶			return null;¶		}¶		¶		return getRootOfFileNode(aParentSNode);¶		¶	}¶	public static boolean match (MethodSNode aMethodSNode, MethodCall aMethodCall) {¶		return aMethodSNode.getMethodName().equals(aMethodCall.getMethodName()) ¶				&& aMethodSNode.getLocalVariableIdentifiers().size() == aMethodCall.getMethodActuals().size();¶	}¶	public static DeclarationSNode getDeclarationOfVariableIdentifier(SNode aCurrentSNode, String anIdentifier) {¶		if (aCurrentSNode == null) {¶			return null;¶		}¶		¶		¶		int anIndex = aCurrentSNode.getLocalVariableIdentifiers().indexOf(anIdentifier);¶		if (anIndex < 0) {¶			return getDeclarationOfVariableIdentifier(aCurrentSNode.getParent(), anIdentifier);¶		}¶		DeclarationSNode retVal = aCurrentSNode.getVariableDeclarations().get(anIndex);¶//		retVal.getAssignmentsToDeclaredVariable().add(anAssignmentSNode);¶//		anAssignmentSNode.setLhsFirstIdentifierDeclaration(retVal);¶		return retVal;¶	}¶	¶	public static DeclarationSNode getDeclarationOfAssignedVariable(SNode aCurrentSNode, AssignmentSNode anAssignmentSNode) {¶		if (aCurrentSNode == null) {¶			return null;¶		}¶		if (anAssignmentSNode instanceof ADeclaringAssignmentSNode) {¶			return (ADeclaringAssignmentSNode) anAssignmentSNode;¶		}¶		int anIndex = aCurrentSNode.getLocalVariableIdentifiers().indexOf(anAssignmentSNode.getLhsFirstIdentifier());¶		if (anIndex < 0) {¶			return getDeclarationOfAssignedVariable(aCurrentSNode.getParent(), anAssignmentSNode);¶		}¶		DeclarationSNode retVal = aCurrentSNode.getVariableDeclarations().get(anIndex);¶//		retVal.getAssignmentsToDeclaredVariable().add(anAssignmentSNode);¶//		anAssignmentSNode.setLhsFirstIdentifierDeclaration(retVal);¶		return retVal;¶	}¶	¶	public static MethodSNode getDeclarationOfCalledMethod(SNode aCurrentSNode, MethodCall aMethodCall ) {¶		SNode aRootNode = getRootOfFileNode(aCurrentSNode);¶		for (SNode aChild:aRootNode.getChildren()) {¶			if (aChild instanceof MethodSNode) {¶				MethodSNode aMethodSNode = (MethodSNode) aChild;¶				if (match (aMethodSNode, aMethodCall)) {¶					return aMethodSNode;¶				}¶			}¶		}¶		return null; // this should never happen;¶	}¶	¶	public static RootOfProgramSNode getRootOfProgramSNode(String aSource) {¶		RootOfProgramSNode retVal = new ARootOfProgramSNode();¶		Map<String, StringBuffer> aFileNameToContents = ABasicTextManager.extractFileContents(aSource);¶		for (String aFileName:aFileNameToContents.keySet()) {¶			StringBuffer aFileContents = aFileNameToContents.get(aFileName);¶//			List<OpenMPPragma> anOpenMPPragmas = OpenMPUtils.getOpemMPPragmas(aFileContents);¶			RootOfFileSNode anSNode = OMPSNodeUtils.getSNode(aFileName, aFileContents);¶			retVal.getFileNameToSNode().put(aFileName, anSNode);¶			anSNode.setParent(retVal);¶//			System.out.println("file name:" + aFileName);¶//			System.out.println("pragmas:" + anSNode);¶		}¶		processExternalMethodSNodes(retVal);¶		processIndirectAssignments(retVal);¶		return retVal;¶	}¶//	public static void processIndirectAssignments (S aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode) {¶//		for (SNode anSNode:aRootOfFileSNode.getChildren()) {¶//			-----¶//		}¶//	}¶	public static void processExternalMethodSNodes (RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode) {¶		for (SNode anSNode:aRootOfFileSNode.getChildren()) {¶			if (anSNode instanceof ExternalMethodSNode) {¶				processExternalMethodSNode(aRootOfProgramSNode, aRootOfFileSNode, (ExternalMethodSNode) anSNode);¶			}¶		}¶	}¶	public static void processExternalMethodSNode (RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode, ExternalMethodSNode anExternalMethodSNode) {¶		MethodSNode aMethodSNode = aRootOfProgramSNode.getExternalToInternalMethod().get(anExternalMethodSNode.toString());¶		if (aMethodSNode == null) {¶			aMethodSNode = findMethodSNode(aRootOfProgramSNode, aRootOfFileSNode, anExternalMethodSNode);¶			if (aMethodSNode != null) {¶				aRootOfProgramSNode.getExternalToInternalMethod().put(anExternalMethodSNode.toString(),aMethodSNode );¶			}¶		}¶		if (aMethodSNode != null) {¶			anExternalMethodSNode.setActualMethodSNode(aMethodSNode);¶			aMethodSNode.getCalls().addAll(anExternalMethodSNode.getLocalCalls());¶		}¶	}¶	¶	public static MethodSNode findMethodSNode (RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode, ExternalMethodSNode anExternalMethodSNode) {¶//		MethodSNode foundMethodSNode = null;¶		for (String aFileName:aRootOfProgramSNode.getFileNameToSNode().keySet()) {¶			if (aFileName.equals(aRootOfFileSNode.getFileName()))¶				continue;¶			¶			RootOfFileSNode aSearchedRootOfFileSNode = aRootOfProgramSNode.getFileNameToSNode().get(aFileName);¶			 for (SNode anSNode:aSearchedRootOfFileSNode.getChildren()) {¶				if (anSNode instanceof MethodSNode && !(anSNode instanceof ExternalMethodSNode)) {¶					if (anSNode.toString().equals(anExternalMethodSNode.toString())) {¶						return (MethodSNode) anSNode;¶						¶					}¶//					processExternalMethodSNode(aRootOfProgramSNode, aRootOfFileSNode, (ExternalMethodSNode) anSNode);¶				}¶			}¶		}¶		return null;¶	}¶	public static void processExternalMethodSNodes (RootOfProgramSNode aRootOfProgramSNode) {¶		for (String aFileName:aRootOfProgramSNode.getFileNameToSNode().keySet()) {¶			RootOfFileSNode aRootOfFileSNode = aRootOfProgramSNode.getFileNameToSNode().get(aFileName);¶			processExternalMethodSNodes(aRootOfProgramSNode, aRootOfFileSNode);¶			aRootOfFileSNode.getOmp_get_num_threads_SNode().¶				setActualMethodSNode(aRootOfProgramSNode.getOmp_get_num_threads_SNode());¶			aRootOfFileSNode.getOmp_get_thread_num_SNode().¶				setActualMethodSNode(aRootOfProgramSNode.getOmp_get_thread_num_SNode());¶			aRootOfFileSNode.getOmp_get_wtime_SNode().¶			setActualMethodSNode(aRootOfProgramSNode.getOmp_get_wtime_SNode());¶		}¶¶	}¶	public static void processIndirectAssignments (SNode anSNode) {¶		if (anSNode instanceof ConstDeclarationSNode) {¶			return;¶		}¶		if (anSNode instanceof DeclarationSNode) {¶			DeclarationSNode aDeclarationSNode = (DeclarationSNode) anSNode;¶			Set<AssignmentSNode> anIndirectAssignments = aDeclarationSNode.getAssignmentsEffectingDeclaredIdentifier();¶			if (anIndirectAssignments != null) {¶				return; // already assigned¶			}¶			anIndirectAssignments = new HashSet<>();¶			aDeclarationSNode.setAssignmentsEffectingDeclaredIdentifier(anIndirectAssignments);¶			Set<AssignmentSNode> aDirectAssignments = aDeclarationSNode.getAssignmentsToDeclaredVariable();¶			anIndirectAssignments.addAll(aDirectAssignments);¶			Set<AssignmentSNode> anAliasAssignments = assignmentsOfVariableAliases(aDeclarationSNode.getParent(), aDeclarationSNode.getVariableName());¶			anIndirectAssignments.addAll(anAliasAssignments);¶			for (AssignmentSNode aDirectAssignment:aDirectAssignments) {¶				List<String> aVariableIdentifiers = aDirectAssignment.getRhsVariableIdentifiers();¶				¶				for (String aVariableIdentifier:aVariableIdentifiers) {¶					DeclarationSNode aDependeeDeclarationSNode = getDeclarationOfVariableIdentifier(aDirectAssignment, aVariableIdentifier);¶					if (aDependeeDeclarationSNode == null) {¶						System.err.println("Could not find declaration of:" + aVariableIdentifier + " referenced in:" + aDirectAssignment );¶						continue;¶					}¶					processIndirectAssignments(aDependeeDeclarationSNode);¶					Set<AssignmentSNode> aDependeeIndirectAssignments = aDeclarationSNode.getAssignmentsEffectingDeclaredIdentifier();¶					anIndirectAssignments.addAll(aDependeeIndirectAssignments);¶					¶				}¶			}¶		} else {¶			for (SNode aChild: anSNode.getChildren()) {¶				processIndirectAssignments(aChild);¶			}¶		}¶		¶	}¶	¶//	public static void fillIndirectAssignments (SNode anSNode, Set<AssignmentSNode> retVal ) {¶//		¶//	}¶	¶¶//	public static void main(String[] args) {¶//		List<MethodCall> aTokens = callsIn("foo(bar, hgf)/foo2()*foo3(b, a c,)");¶//		System.out.println(aTokens);¶//		¶//		¶////		List<String> aTokens = identifiersIn("a[i] + b*2/3");¶////		System.out.println(aTokens);¶////		aTokens = numbersIn("a[i] + b*2/3");¶////		System.out.println(aTokens);¶////		aTokens = operatorsIn("a[i] + b*2/3");¶////		System.out.println(aTokens);¶////¶////		System.out.println(StringUtils.substringBetween("a", "[", "]"));¶//	}¶¶}¶")]]]></diff>
  </Command>
  <Command __id="218218" _type="RunCommand" date="Fri Jan 10 10:29:48 EST 2020" kind="StepInto" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="2003683616" type="Run" />
  <Command __id="222038" _type="RunCommand" date="Fri Jan 10 14:08:39 EST 2020" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="2016814382" type="Run" />
  <Command __id="222039" _type="EclipseCommand" commandID="" date="Fri Jan 10 14:08:39 EST 2020" starttimestamp="1576666505112" timestamp="2016814486" />
  <Command __id="222040" _type="EclipseCommand" commandID="" date="Fri Jan 10 14:08:40 EST 2020" starttimestamp="1576666505112" timestamp="2016815170" />
  <Command __id="222041" _type="EclipseCommand" commandID="" date="Fri Jan 10 14:08:40 EST 2020" starttimestamp="1576666505112" timestamp="2016815170" />
  <Command __id="222042" _type="EclipseCommand" commandID="" date="Fri Jan 10 14:08:40 EST 2020" starttimestamp="1576666505112" timestamp="2016815210" />
  <Command __id="222043" _type="ShellCommand" date="Fri Jan 10 14:11:16 EST 2020" starttimestamp="1576666505112" timestamp="2016971013" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="222044" _type="ShellCommand" date="Fri Jan 10 14:11:16 EST 2020" starttimestamp="1576666505112" timestamp="2016971441" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="222045" _type="ShellCommand" date="Fri Jan 10 14:11:16 EST 2020" starttimestamp="1576666505112" timestamp="2016971731" type="ECLIPSE_LOST_FOCUS" />
  <DocumentChange __id="221833" _type="Insert" date="Fri Jan 10 11:21:50 EST 2020" docASTNodeCount="5347" docActiveCodeLength="39504" docExpressionCount="3297" docLength="45623" length="7" offset="33854" starttimestamp="1576666505112" timestamp="2006805479">
    <text><![CDATA[
					]]></text>
  </DocumentChange>
  <DocumentChange __id="221840" _type="Replace" date="Fri Jan 10 11:22:03 EST 2020" docASTNodeCount="5353" docActiveCodeLength="39594" docExpressionCount="3302" docLength="45713" endLine="913" insertionLength="95" int_docASTNodeCount="5347" int_docActiveCodeLength="39499" int_docExpressionCount="3297" int_docLength="45618" length="5" offset="33856" startLine="913" starttimestamp="1576666505112" timestamp="2006818153">
    <deletedText><![CDATA[					]]></deletedText>
    <insertedText><![CDATA[					fillDirectAssignmentsOfVariableAliases(aDeclaringMethodSNode, aFormalParameter, retVal);
]]></insertedText>
  </DocumentChange>
  <DocumentChange __id="221847" _type="Replace" date="Fri Jan 10 11:22:12 EST 2020" docASTNodeCount="5353" docActiveCodeLength="39591" docExpressionCount="3302" docLength="45710" endLine="913" insertionLength="18" int_docASTNodeCount="5352" int_docActiveCodeLength="39573" int_docExpressionCount="3301" int_docLength="45692" length="21" offset="33900" startLine="913" starttimestamp="1576666505112" timestamp="2006827708">
    <deletedText><![CDATA[aDeclaringMethodSNode]]></deletedText>
    <insertedText><![CDATA[aCallerMethodSNode]]></insertedText>
  </DocumentChange>
  <DocumentChange __id="221854" _type="Replace" date="Fri Jan 10 11:22:25 EST 2020" docASTNodeCount="5353" docActiveCodeLength="39582" docExpressionCount="3302" docLength="45701" endLine="913" insertionLength="7" int_docASTNodeCount="5352" int_docActiveCodeLength="39575" int_docExpressionCount="3301" int_docLength="45694" length="16" offset="33920" startLine="913" starttimestamp="1576666505112" timestamp="2006840010">
    <deletedText><![CDATA[aFormalParameter]]></deletedText>
    <insertedText><![CDATA[anAlias]]></insertedText>
  </DocumentChange>
  <Command __id="221924" _type="DiffBasedFileOpenCommand" date="Fri Jan 10 11:22:59 EST 2020" docASTNodeCount="314" docActiveCodeLength="2264" docExpressionCount="187" docLength="2422" projectName="GraderBasics" starttimestamp="1576666505112" timestamp="2006874383">
    <filePath><![CDATA[D:\dewan_backup\Java\GraderBasics\src\gradingTools\shared\testcases\openmp\scannedTree\ADeclarationSNode.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package gradingTools.shared.testcases.openmp.scannedTree;¶¶import java.util.ArrayList;¶import java.util.HashSet;¶import java.util.List;¶import java.util.Set;¶¶public class ADeclarationSNode extends AnSNode implements DeclarationSNode {¶	String variableName;¶	¶	String typeName;¶	List<String> operators;¶	¶¶	String variableIdentifier;¶	String typeIdentifier;¶	Set<AssignmentSNode> assignmentsToDeclaredVariable = new HashSet();¶	Set<AssignmentSNode> assignmentsEffectingDeclaredIdentifier;¶¶	¶	¶	public ADeclarationSNode(int aLineNumber, String aTypeName, String aVariableName) {¶		super(aLineNumber);¶		typeName = aTypeName;¶		variableName = aVariableName;¶		operators = OMPSNodeUtils.operatorsIn(typeName);¶		operators.addAll(OMPSNodeUtils.operatorsIn(typeName));¶		variableIdentifier = OMPSNodeUtils.identifiersIn(variableName).get(0);¶		typeIdentifier =  OMPSNodeUtils.identifiersIn(typeName).get(0);¶	}¶	@Override¶	public String getTypeName() {¶		return typeName;¶	}¶	@Override¶	public void setTypeName(String typeName) {¶		this.typeName = typeName;¶	}¶	@Override¶	public String getVariableName() {¶		return variableName;¶	}¶	@Override¶	public void setParent(SNode anSNode) {¶		super.setParent(anSNode);¶		if (!anSNode.getVariableDeclarations().contains(this)) {¶		anSNode.getVariableDeclarations().add(this);¶//		anSNode.getLocalVariables().add(variableName);¶		anSNode.getLocalVariableIdentifiers().add(variableIdentifier);¶		}¶¶	}¶	public String toString() {¶		return typeName + " " + variableName;¶	}¶	@Override¶	public String getVariableIdentifier() {¶		return variableIdentifier;¶	}¶	¶	@Override¶	public String getTypeIdentifier() {¶		return typeIdentifier;¶	}¶	@Override¶	public List<String> getOperators() {¶		return operators;¶	}¶	@Override¶	public Set<AssignmentSNode> getAssignmentsToDeclaredVariable() {¶		return assignmentsToDeclaredVariable;¶	}¶//	@Override¶//¶//	public void setVariableName(String variableName) {¶//		this.variableName = variableName;¶//	}¶	@Override¶	public Set<AssignmentSNode> getAssignmentsEffectingDeclaredIdentifier() {¶		return assignmentsEffectingDeclaredIdentifier;¶	}¶	@Override¶	public void setAssignmentsEffectingDeclaredIdentifier(Set<AssignmentSNode> assignmentsEffectingDeclaredIdentifier) {¶		this.assignmentsEffectingDeclaredIdentifier = assignmentsEffectingDeclaredIdentifier;¶	}¶}¶")]]]></diff>
  </Command>
  <Command __id="221930" _type="DiffBasedFileOpenCommand" date="Fri Jan 10 11:23:05 EST 2020" docASTNodeCount="5353" docActiveCodeLength="39582" docExpressionCount="3302" docLength="45701" projectName="GraderBasics" starttimestamp="1576666505112" timestamp="2006880713">
    <filePath><![CDATA[D:\dewan_backup\Java\GraderBasics\src\gradingTools\shared\testcases\openmp\scannedTree\OMPSNodeUtils.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package gradingTools.shared.testcases.openmp.scannedTree;¶¶import java.util.ArrayList;¶import java.util.Arrays;¶import java.util.HashMap;¶import java.util.HashSet;¶import java.util.List;¶import java.util.Map;¶import java.util.Set;¶import java.util.Stack;¶import java.util.regex.Matcher;¶import java.util.regex.Pattern;¶¶import org.apache.commons.lang.StringUtils;¶¶import grader.basics.project.source.ABasicTextManager;¶import gradingTools.shared.testcases.openmp.OpenMPKeywordEnum;¶import gradingTools.shared.testcases.openmp.OpenMPParallelPragma;¶import gradingTools.shared.testcases.openmp.OpenMPUtils;¶import gradingTools.shared.testcases.openmp.scannedTree.ADeclarationSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.ADeclaringAssignmentSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.AForSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.ATextSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.AnAssignmentSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.AnOMPCriticalSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.AnOMPForSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.AnOMPParallelSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.AnOMPSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.AnSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.AssignmentSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.DeclarationSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.DeclaringAssignmentSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.ForSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.OMPForSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.OMPSNode;¶import gradingTools.shared.testcases.openmp.scannedTree.SNode;¶¶public class OMPSNodeUtils extends OpenMPUtils {¶¶	public static RootOfFileSNode getSNode(String aFileName, StringBuffer aFileBuffer) {¶		String[] aFileLines = aFileBuffer.toString().split("\n");¶		return getSNode(aFileName, aFileLines);¶	}¶¶	public static AssignmentSNode getAssignmentSNode(int aLineNumber, String aString) {¶		if (aString == null) {¶			return null;¶		}¶		String[] aTokens = aString.split("=");¶		if (aTokens.length == 1) {¶			return new AnAssignmentSNode(aLineNumber, aTokens[0], null);¶		} else {¶		return new AnAssignmentSNode(aLineNumber, aTokens[0], aTokens[1]);¶		}¶	}¶¶	public static DeclarationSNode getDeclarationSNode(int aLineNumber, String aString) {¶		String[] aTokens = aString.split(" ");¶		return new ADeclarationSNode(aLineNumber, aTokens[0], aTokens[1]);¶	}¶¶	public static DeclaringAssignmentSNode getDeclaringAssignmentSNode(int aLineNumber, String aString) {¶		String[] anLHSAndRHS = aString.split("=");¶		String[] aTypeAndVariable = anLHSAndRHS[0].split(" ");¶		return new ADeclaringAssignmentSNode(aLineNumber, aTypeAndVariable[0], aTypeAndVariable[1], anLHSAndRHS[1]);¶	}¶	public static ConstDeclarationSNode getConstDeclarationSNode(int aLineNumber, String aString) {¶		String anAssignmentString = aString.substring(CONST.length()).trim();¶		String[] anLHSAndRHS = anAssignmentString.split("=");¶		String[] aTypeAndVariable = anLHSAndRHS[0].split(" ");¶		return new AConstDeclarationSNode(aLineNumber, aTypeAndVariable[0], aTypeAndVariable[1], anLHSAndRHS[1]);¶	}¶¶	public static boolean isDeclaringAssignment(String aFileLine) {¶		return startsWithTypeName(aFileLine) && aFileLine.contains("=");¶	}¶	public static boolean isConstDeclaration(String aFileLine) {¶		return aFileLine.startsWith(CONST);¶	}¶	public static boolean isMethodDeclaration(String aFileLine) {¶		return startsWithTypeName(aFileLine) && ¶				aFileLine.contains("(") &&¶				!aFileLine.contains("=");¶	}¶	public static boolean isExternalMethodDeclaration(String aFileLine) {¶		return isMethodDeclaration(aFileLine) && aFileLine.endsWith(";");¶	}¶¶¶	public static boolean isVariableDeclaration(String aFileLine) {¶¶		return startsWithTypeName(aFileLine) && !aFileLine.contains("(");¶	}¶¶	public static boolean isAssignment(String aFileLine) {¶		return aFileLine.contains("=") && !aFileLine.contains("==");¶	}¶¶	public static boolean isForNode(String aFileLine) {¶		return aFileLine.startsWith("for");¶	}¶¶	public static ForSNode getForSNode(int aLineNumber, String aFileLine) {¶¶		int aLeftParenIndex = aFileLine.indexOf("(");¶		int aRightParenIndex = aFileLine.indexOf(")");¶		if (aLeftParenIndex < 0 || aRightParenIndex < 0) {¶			return null;¶		}¶		String aHeaderString = aFileLine.substring(aLeftParenIndex + 1, aRightParenIndex);¶		String[] aForComponents = aHeaderString.split(";");¶		AssignmentSNode anAssignmentSNode = null;¶		String aForInitializaton = aForComponents[0];¶		if (!aForInitializaton.isEmpty() && aForInitializaton.contains("=")) {¶			if (isDeclaringAssignment(aForInitializaton)) {¶				anAssignmentSNode = getDeclaringAssignmentSNode(aLineNumber, aForInitializaton);¶			} else {¶				anAssignmentSNode = getAssignmentSNode(aLineNumber, aForInitializaton);¶			}¶¶		}		¶		return new AForSNode(aLineNumber, anAssignmentSNode, aForComponents[1], getAssignmentSNode(aLineNumber, aForComponents[2]));¶	}¶	static String[] emptyArray = {};¶	public static MethodSNode getMethodSNode(int aLineNumber, String aFileLine, boolean isInternal) {¶¶		int aLeftParenIndex = aFileLine.indexOf("(");¶		int aRightParenIndex = aFileLine.indexOf(")");¶		if (aLeftParenIndex < 0 || aRightParenIndex < 0) {¶			return null;¶		}¶		String aMethodNameAndType = aFileLine.substring(0, aLeftParenIndex);¶		String[] aMethodNameAndTypeTokens = aMethodNameAndType.split("\\s+"); ¶		¶		String aMethodParameters = aFileLine.substring(aLeftParenIndex +1 , aRightParenIndex);¶		String[] aMethodParameterTokens = aMethodParameters.isEmpty()?emptyArray:¶		 aMethodParameters.split(",");¶		¶//		String[] aMethodParameterTypes = new String[aMethodParameterTokens.length];¶//		String[] aMethodParameterNames = new String[aMethodParameterTokens.length];¶		List<DeclarationSNode> aDeclarationSNodeList = new ArrayList();¶		for (int i = 0; i < aMethodParameterTokens.length; i++ ) {¶			String[] aTypeAndName = aMethodParameterTokens[i].trim().split("\\s+");¶			if (aTypeAndName.length < 2) {¶				continue;¶			}¶			aDeclarationSNodeList.add(new ADeclarationSNode(aLineNumber, aTypeAndName[0].trim(), aTypeAndName[1].trim()));¶//			aMethodParameterTypes[i] = aTypeAndName[0].trim();¶//			aMethodParameterNames[i] = aTypeAndName[1].trim();¶		}¶		if (isInternal)¶//		return new AMethodSNode(aLineNumber, aMethodNameAndTypeTokens[0], aMethodNameAndTypeTokens[1], aMethodParameterTypes,aMethodParameterNames );¶			return new AMethodSNode(aLineNumber, aMethodNameAndTypeTokens[0], aMethodNameAndTypeTokens[1], aDeclarationSNodeList );¶		else¶			return new AnExternalMethodSNode(aLineNumber, aMethodNameAndTypeTokens[0], aMethodNameAndTypeTokens[1], aDeclarationSNodeList );¶	}¶¶	public static void setReductionData(OMPForSNode lastChild, String aStoredToken, int aLeftParenIndex,¶			int aRightParenIndex) {¶		int aColonIndex = aStoredToken.indexOf(":");¶		if (aLeftParenIndex != -1 && aRightParenIndex != -1 && aColonIndex != -1) {¶			String anOperationString = aStoredToken.substring(aLeftParenIndex + 1, aColonIndex).trim();¶			String aVariableString = aStoredToken.substring(aColonIndex + 1, aRightParenIndex).trim();¶			((OMPForSNode) lastChild).setReductionVariable(aVariableString);¶			((OMPForSNode) lastChild).setReductionOperation(anOperationString);¶		}¶	}¶¶	public static void setSharedOrPrivateData(OMPSNode lastChild, String aStoredToken, int aLeftParenIndex,¶			int aRightParenIndex, boolean isShared) {¶//		int aColonIndex = aStoredToken.indexOf(":");¶		if (aLeftParenIndex != -1 && aRightParenIndex != -1) {¶			String aVariableDeclarations = aStoredToken.substring(aLeftParenIndex + 1, aRightParenIndex);¶			String[] aVariables = aVariableDeclarations.split(",");¶			if (isShared) {¶				lastChild.setSharedVariables(aVariables);¶			} else {¶				lastChild.setPrivateVariables(aVariables);¶			}¶		}¶	}¶¶	public static RootOfFileSNode getSNode(String aFileName, String[] aFileLines) {¶		Stack<SNode> anSNodes = new Stack();¶¶		RootOfFileSNode retVal = new ARootOfFileSNode(aFileName);¶		anSNodes.add(retVal);¶		SNode previousHeaderNode = null;¶		for (int i = 0; i < aFileLines.length; i++) {¶			String aFileLine = aFileLines[i].trim();¶			if (!isCodeLine(aFileLine)) {¶				continue;¶			}¶			if (isForNode(aFileLine)) {¶				ForSNode aForSNode = getForSNode(i, aFileLine);¶				SNode aParent = previousHeaderNode != null?previousHeaderNode:anSNodes.peek();¶				aForSNode.setParent(anSNodes.peek());¶				aForSNode.setParent(aParent);¶¶//				anSNodes.push(aForSNode);¶				previousHeaderNode = aForSNode;¶				if (aFileLine.endsWith(")")) {¶					continue;¶				}¶			}¶			if (isExternalMethodDeclaration(aFileLine)) {¶				MethodSNode aMethodSNode = getMethodSNode(i, aFileLine, false);¶				aMethodSNode.setParent(anSNodes.peek());¶//				anSNodes.push(aForSNode);¶				previousHeaderNode = aMethodSNode;¶				if (aFileLine.endsWith(")")) {¶					continue;¶				}¶			}¶			if (isMethodDeclaration(aFileLine)) {¶				MethodSNode aMethodSNode = getMethodSNode(i, aFileLine, true);¶				aMethodSNode.setParent(anSNodes.peek());¶//				anSNodes.push(aForSNode);¶				previousHeaderNode = aMethodSNode;¶				if (aFileLine.endsWith(")")) {¶					continue;¶				}¶			}¶			if (isPragmaStart(aFileLine)) {¶				OMPSNode anOMPSNode = getOMPSNode(i, anSNodes.peek(), aFileLine);¶//				anSNodes.push(anOMPSNode);¶				previousHeaderNode = anOMPSNode;¶				continue;¶			}¶			if (isBlockStart(aFileLine)) {¶				SNode aBlockSNode = new ABlockSNode(i);¶				if (previousHeaderNode != null) {¶					aBlockSNode.setParent(previousHeaderNode);¶				} else {¶					aBlockSNode.setParent(anSNodes.peek());¶				}¶				anSNodes.push(aBlockSNode);¶				previousHeaderNode = null;¶				continue;¶			}¶//			} else ¶			if (isBlockEnd(aFileLine)) {¶				anSNodes.pop();¶				continue;¶			}¶			SNode aNewLeafNode = null;¶			if (isConstDeclaration(aFileLine)) {¶				aNewLeafNode = getConstDeclarationSNode(i, aFileLine);¶¶			} else if (isDeclaringAssignment(aFileLine)) {¶				aNewLeafNode = getDeclaringAssignmentSNode(i, aFileLine);¶¶			} else if (isAssignment(aFileLine)) {¶				aNewLeafNode = getAssignmentSNode(i, aFileLine);¶			} else if (isVariableDeclaration(aFileLine)) {¶				aNewLeafNode = getDeclarationSNode(i, aFileLine);¶			} else {¶				List<MethodCall> aCalls = callsIn(i, aFileLine, null); // parent will be assigned below¶				if (aCalls != null && aCalls.size() == 1) {¶					aNewLeafNode = aCalls.get(0);¶				} else {¶					aNewLeafNode = new ATextSNode(i, aFileLine);¶				}¶			}¶//			else {¶//				aNewLeafNode = new ATextSNode(i, aFileLine);¶//			}¶			if (previousHeaderNode != null) {¶				aNewLeafNode.setParent(previousHeaderNode);¶			} else {¶				aNewLeafNode.setParent(anSNodes.peek());¶			}¶¶		}¶¶		return retVal;¶	}¶¶	public static OMPSNode getOMPSNode(int aLineIndex, SNode aParentNode, String aFileLine) {¶		String[] aTokens = aFileLine.split("\\s+");¶		if (aTokens.length <= 2) {¶			return null;¶		}¶		if (!aTokens[1].equals("omp")) {¶			return null;¶		}¶		if (aTokens.length < 3) {¶			return null;¶		}¶		String aFirstToken = aTokens[2];¶		OpenMPKeywordEnum anOpenMPKeyword = stringToOpenMPKeyword.get(aFirstToken);¶//		List<OpenMPPragma> retVal = new ArrayList();¶		OMPSNode lastChild = null;¶		int aStartIndex = 2;¶		OMPSNode aNewNode = null;¶		OMPForSNode aForChild = null;¶		switch (anOpenMPKeyword) {¶		case PARALLEL:¶			aNewNode = new AnOMPParallelSNode(aLineIndex);¶¶			if (aTokens.length > 3 && aTokens[3].equals("for")) {¶				aForChild = new AnOMPForSNode(aLineIndex);¶				aForChild.setParent(aNewNode);¶¶				aStartIndex++;¶			}¶			break;¶		case FOR:¶			aNewNode = new AnOMPForSNode(aLineIndex);¶			;¶			break;¶		case CRITICAL:¶			aNewNode = new AnOMPCriticalSNode(aLineIndex);¶//			retVal.add (lastChild);¶			break;¶		default:¶			aNewNode = new AnOMPSNode(aLineIndex);¶¶		}¶¶		if (lastChild != null) {¶			aNewNode.setParent(lastChild);¶		} else {¶			aNewNode.setParent(aParentNode);¶		}¶		lastChild = aForChild == null ? aNewNode : aForChild;¶¶		for (int i = aStartIndex; i < aTokens.length; i++) {¶			String aStoredToken = aTokens[i].trim();¶			if (aStoredToken.isEmpty()) {¶				continue;¶			}¶			if (aStoredToken.startsWith("reduction") || aStoredToken.startsWith("shared")¶					|| aStoredToken.startsWith("private")) {¶				// combine all tokens until ")" into one for normalization¶				while (!aStoredToken.endsWith(")")) {¶					i++;¶					if (i >= aTokens.length) {¶						break;¶					}¶					String aNewToken = aTokens[i].trim();¶					aStoredToken += aNewToken;¶				}¶				int aLeftParenIndex = aStoredToken.indexOf("(");¶				int aRightParenIndex = aStoredToken.indexOf(")");¶				if (aStoredToken.startsWith("reduction")) {¶					setReductionData((OMPForSNode) lastChild, aStoredToken, aLeftParenIndex, aRightParenIndex);¶				} else if (aStoredToken.startsWith("private")) {¶					setSharedOrPrivateData((OMPSNode) lastChild, aStoredToken, aLeftParenIndex, aRightParenIndex,¶							false);¶¶				} else if (aStoredToken.startsWith("shared")) {¶					setSharedOrPrivateData(lastChild, aStoredToken, aLeftParenIndex, aRightParenIndex, true);¶¶				}¶¶			}¶¶			lastChild.getOpenMPTokens().add(aStoredToken);¶		}¶¶		return lastChild;¶¶	}¶¶	public static boolean hasParallelAncestor(SNode anSNode) {¶		if (anSNode == null) {¶			return false;¶		}¶		if (anSNode instanceof OMPParallelSNode) {¶			return true;¶		}¶		return hasParallelAncestor(anSNode.getParent());¶	}¶	public static boolean hasCriticalAncestor(SNode anSNode) {¶		if (anSNode == null) {¶			return false;¶		}¶		if (anSNode instanceof OMPCriticalSNode) {¶			return true;¶		}¶		return hasCriticalAncestor(anSNode.getParent());¶	}¶¶¶	public static Boolean isDeclaredShared(OMPSNode anOMPSNode, String anLHS) {¶		if (Arrays.asList(anOMPSNode.getSharedVariables()).contains(anLHS)) {¶			return true;¶		}¶		if (Arrays.asList(anOMPSNode.getPrivateVariables()).contains(anLHS)) {¶			return false;¶		}¶		return null;¶¶	}¶¶	public static boolean isSharedVariable(SNode anSNode, String anLHS) {¶		if (anSNode == null) {¶			return false;¶		}¶		if (anSNode.getLocalVariableIdentifiers().contains(anLHS)) {¶			if (!(anSNode instanceof OMPSNode)) { // no shared and private declarations¶				return !hasParallelAncestor(anSNode); // shared if not inParallel¶			}¶			OMPSNode anOMPSNode = (OMPSNode) anSNode;¶			return (Arrays.asList(anOMPSNode.getSharedVariables()).contains(anLHS)); // private unless declared shared¶		}¶		if (anSNode instanceof OMPSNode) {¶			OMPSNode anOMPSNode = (OMPSNode) anSNode;¶			// the variable is global to this scope, check if it has have been made shared¶			// or private by this scope¶			Boolean isDeclaredShared = isDeclaredShared(anOMPSNode, anLHS);¶			if (isDeclaredShared != null) {¶				return isDeclaredShared;¶			}¶		}¶		// check the parent¶		return isSharedVariable(anSNode.getParent(), anLHS);¶	}¶¶	public static List<SNode> getAllLeafNodes(SNode aTopNode) {¶		List<SNode> retVal = new ArrayList();¶		addLeafNodes(aTopNode, retVal);¶		return retVal;¶	}¶¶	public static void addLeafNodes(SNode aTopNode, List<SNode> retVal) {¶		for (SNode aChild : aTopNode.getChildren()) {¶			if (aChild.isLeaf()) {¶				retVal.add(aChild);¶			} else {¶				addLeafNodes(aChild, retVal);¶			}¶		}¶	}¶¶	public static List<SNode> getNonParallelLeafNodes(SNode aTopNode) {¶		List<SNode> retVal = new ArrayList();¶		addNonParallelLeafNodes(aTopNode, retVal);¶		return retVal;¶	}¶¶	public static void addNonParallelLeafNodes(SNode aTopNode, List<SNode> retVal) {¶		if (aTopNode.isInParallel()) {¶			return;¶		}¶		for (SNode aChild : aTopNode.getChildren()) {¶			if (aChild.isLeaf()) {¶				retVal.add(aChild);¶			} else {¶				addLeafNodes(aChild, retVal);¶			}¶		}¶	}¶	static String callRegex = "([a-zA-Z_$][a-zA-Z_$0-9]*)\\(.*?\\)";¶	static Pattern callPattern = Pattern.compile(callRegex);¶¶	static String identifierRegex = "[a-zA-Z_$][a-zA-Z_$0-9]*";¶	static Pattern identifierPattern = Pattern.compile(identifierRegex);¶	public static List<String> identifiersIn(String aString) {¶		if (aString == null)¶			return null;¶//		Pattern mypattern = Pattern.compile("[a-zA-Z_$][a-zA-Z_$0-9]*");¶//		Matcher mymatcher = mypattern.matcher(aString);¶		Matcher mymatcher = identifierPattern.matcher(aString);¶		List<String> retVal = new ArrayList();¶		while (mymatcher.find()) {¶			String find = mymatcher.group(0);¶			retVal.add(find);¶		}¶		return retVal;¶	}¶	public static List<MethodCall> callsIn(int aLineNumber, String aString, SNode aParent) {¶		if (aString == null)¶			return emptyList;¶		if (isMethodDeclaration(aString)) {¶			return emptyList;¶		}¶//		Pattern mypattern = Pattern.compile("[a-zA-Z_$][a-zA-Z_$0-9]*");¶//		Matcher mymatcher = mypattern.matcher(aString);¶		Matcher mymatcher = callPattern.matcher(aString);¶		List<MethodCall> retVal = new ArrayList();¶		while (mymatcher.find()) {¶			String find = mymatcher.group(0);¶			int aLeftParenIndex = find.indexOf("(");¶			int aRightParenIndex = find.indexOf(")");¶			String aMethodName = find.substring(0, aLeftParenIndex).trim();¶			String aParameters = find.substring(aLeftParenIndex + 1, aRightParenIndex);¶			List<String> aParameterList = new ArrayList();¶			String[] aParameterTokens = aParameters.split(",");¶			for (String aParameter:aParameterTokens) {¶				String aParameterTrimmed = aParameter.trim();¶				if (!aParameterTrimmed.isEmpty())¶				aParameterList.add(aParameterTrimmed);¶			}¶			retVal.add(new AMethodCall(aLineNumber, aMethodName, aParameterList, aParent));¶¶//			aCallStrings.add(find);¶		}¶		return retVal;¶	}¶	static String numberRegex = "(\\d+\\.\\d+)|(\\d+)";¶	static Pattern numberPattern = Pattern.compile(numberRegex);¶	public static List<String> numbersIn(String aString) {¶		if (aString == null)¶			return null;¶//		String regex = "(\\d+\\.\\d+)|(\\d+)";¶//¶//		Matcher m = Pattern.compile(regex).matcher(aString);¶		Matcher m =numberPattern.matcher(aString);¶¶¶		List<String> retVal = new ArrayList();¶¶		while (m.find()) {¶			retVal.add(m.group());¶		}¶		return retVal;¶	}¶¶	public static String subscriptIn(String aString) {¶		if (aString == null)¶			return null;¶		return StringUtils.substringBetween(aString, "[", "]");¶	}¶	static String[] emptyStringArray = {};¶	static List emptyList = new ArrayList();¶¶	public static String[] subscriptsIn(String aString) {¶		if (aString == null)¶			return emptyStringArray;¶		return StringUtils.substringsBetween(aString, "[", "]");¶	}¶	static  String operatorRegex = "([+-/*///^])|([/(/)])";¶	static Pattern operatorPattern = Pattern.compile(operatorRegex);¶¶	public static List<String> operatorsIn(String aString) {¶		if (aString == null)¶			return null;¶//		String operatorRegex = "([+-/*///^])|([/(/)])";¶//¶//		Matcher m = Pattern.compile(operatorRegex).matcher(aString);¶		¶		Matcher m = operatorPattern.matcher(aString);¶¶¶		List<String> retVal = new ArrayList();¶¶		while (m.find()) {¶			retVal.add(m.group());¶		}¶		return retVal;¶	}¶	¶	public static int numberOfNestingFors (SNode anSNode) {¶		if (anSNode == null) {¶			return 0;¶		}¶		int retVal = anSNode.getNumberOfNestingFors();¶		if ( retVal >= 0) {¶			return retVal;¶		}¶		retVal = numberOfNestingFors (anSNode.getParent()) ;¶¶		if (anSNode instanceof ForSNode) {¶			retVal++;¶		} else if (anSNode instanceof MethodSNode) {¶			List<MethodCall> aMethodCalls = ((MethodSNode) anSNode).getCalls();¶			int aMaxNestingLevel = 0;¶			for (MethodCall aMethodCall:aMethodCalls) {¶				MethodSNode aCallerMethodSNode = getDeclarationOfCalledMethod(anSNode, aMethodCall);¶				int aCallerNumberOfNestingFors = numberOfNestingFors(aCallerMethodSNode);¶				aMaxNestingLevel = Math.max(aCallerNumberOfNestingFors, aMaxNestingLevel);				¶			}¶			return retVal + aMaxNestingLevel;¶		}¶		return retVal;¶	}¶	public static boolean hasOperator (SNode anSNode, String anOperator) {¶		boolean retVal = false;¶		if (anSNode instanceof AssignmentSNode) {¶			AssignmentSNode anAssignmentSNode = (AssignmentSNode) anSNode;¶			 retVal = (anAssignmentSNode.getLhsOperators().contains(anOperator) || ¶					anAssignmentSNode.getRhsOperators().contains(anOperator)) ;¶			if (retVal) {¶				return retVal;¶			} else {¶				List<MethodCall> aMethodCalls = anAssignmentSNode.getRhsCalls();¶				for (MethodCall aMethodCall:aMethodCalls) {¶					MethodSNode aMethodSNode = getDeclarationOfCalledMethod(anSNode, aMethodCall);¶					retVal = hasOperator(aMethodSNode, anOperator);¶					if (retVal) {¶						return retVal;¶					}¶					¶				}¶				return false;¶			}¶			¶		}¶		for (SNode aChild:anSNode.getChildren()) {¶			retVal = hasOperator(aChild, anOperator);¶			if (retVal) {¶				return retVal;¶			}¶		}¶		return false;¶	}¶	public static boolean hasMethodCall (SNode anSNode, String anOperator) {¶		boolean retVal = false;¶		if (anSNode instanceof AssignmentSNode) {¶			AssignmentSNode anAssignmentSNode = (AssignmentSNode) anSNode;¶			 retVal = (anAssignmentSNode.getLhsOperators().contains(anOperator) || ¶					anAssignmentSNode.getRhsOperators().contains(anOperator)) ;¶			if (retVal) {¶				return retVal;¶			} else {¶				List<MethodCall> aMethodCalls = anAssignmentSNode.getRhsCalls();¶				for (MethodCall aMethodCall:aMethodCalls) {¶					MethodSNode aMethodSNode = getDeclarationOfCalledMethod(anSNode, aMethodCall);¶					retVal = hasOperator(aMethodSNode, anOperator);¶					if (retVal) {¶						return retVal;¶					}¶					¶				}¶				return false;¶			}¶			¶		}¶		for (SNode aChild:anSNode.getChildren()) {¶			retVal = hasOperator(aChild, anOperator);¶			if (retVal) {¶				return retVal;¶			}¶		}¶		return false;¶	}¶	public static boolean dependsOn (AssignmentSNode anAssignmentSNode, String aVariable, String aCallIdentifier) {¶		// This assignment does not change aVariable¶		if (!aVariable.equals(anAssignmentSNode.getLhsFirstIdentifier())) {¶			return false;¶		}¶		return dependsOn(anAssignmentSNode.getExpressionSNode(), aCallIdentifier);¶//		List<String> aCallIdentifiers = anAssignmentSNode.getRhsCallIdentifiers();¶//		boolean retVal = false;¶//		if (aCallIdentifiers != null && aCallIdentifiers.contains(aCallIdentifier)) {¶//			return true; // this assignment has aCallIdentifier in the rhs¶//		}¶//		// check if some referenced rhs variable depends on aCallIdentifier¶//		List<String> aReferencedVariableIdentifiers = anAssignmentSNode.getRhsVariableIdentifiers();¶//		SNode anAssignmentParent = anAssignmentSNode.getParent();¶//		if (anAssignmentParent == null) { // should never be trye¶//			return false;¶//		}¶//		int aLineNumber = anAssignmentSNode.getLineNumber();¶//		for (String aReferencedVariableIdentifier:aReferencedVariableIdentifiers ) {¶//			if (dependsOn (anAssignmentParent, aLineNumber, aReferencedVariableIdentifier, aCallIdentifier)) {¶//				return true;¶//			}¶//		}¶//		return false;¶	}¶	public static boolean dependsOn (ExpressionSNode anExpressionSNode, String aCallIdentifier) {¶		// This assignment does not change aVariable¶		¶		List<String> aCallIdentifiers = anExpressionSNode.getRhsCallIdentifiers();¶		boolean retVal = false;¶		if (aCallIdentifiers != null && aCallIdentifiers.contains(aCallIdentifier)) {¶			return true; // this assignment has aCallIdentifier in the rhs¶		}¶		// check if some referenced rhs variable depends on aCallIdentifier¶		List<String> aReferencedVariableIdentifiers = anExpressionSNode.getRhsVariableIdentifiers();¶		SNode anAssignmentParent = anExpressionSNode.getParent().getParent();¶		if (anAssignmentParent == null) { // should never be trye¶			return false;¶		}¶		int aLineNumber = anExpressionSNode.getLineNumber();¶		for (String aReferencedVariableIdentifier:aReferencedVariableIdentifiers ) {¶			if (dependsOn (anAssignmentParent, aLineNumber, aReferencedVariableIdentifier, aCallIdentifier)) {¶				return true;¶			}¶		}¶		return false;¶	}¶	public static Set<AssignmentSNode> assignmentsToSharedVariables(SNode anSNode) {¶		Set<AssignmentSNode> retVal =  new HashSet();¶		fillAssignmentsToShared(anSNode, retVal);¶		return retVal;¶		¶	}¶	public static Set<AssignmentSNode> assignmentsToSharedArrays(SNode anSNode) {¶		Set<AssignmentSNode> anAllSharedAssignments =  assignmentsToSharedVariables(anSNode);¶		Set<AssignmentSNode> aRetVal = new HashSet();¶		for (AssignmentSNode anAssignmentSNode:anAllSharedAssignments) {¶			if (anAssignmentSNode.getLhsSubscripts().length > 0) {¶				aRetVal.add(anAssignmentSNode);¶			}¶		}¶		return aRetVal;¶		¶	}¶	public static Set<AssignmentSNode> assignmentsToParallelCriticalSharedVariables(SNode anSNode) {¶		Set<AssignmentSNode> anAllSharedAssignments =  assignmentsToSharedVariables(anSNode);¶		Set<AssignmentSNode> aRetVal = new HashSet();¶		for (AssignmentSNode anAssignmentSNode:anAllSharedAssignments) {¶			if (anAssignmentSNode.isInParallel() &&¶					anAssignmentSNode.isInCritical()) {¶				aRetVal.add(anAssignmentSNode);¶			}¶		}¶		return aRetVal;¶		¶	}¶	public static Set<AssignmentSNode> assignmentsToNonParallelCriticalSharedVariables(SNode anSNode) {¶		Set<AssignmentSNode> anAllSharedAssignments =  assignmentsToSharedVariables(anSNode);¶		Set<AssignmentSNode> aRetVal = new HashSet();¶		for (AssignmentSNode anAssignmentSNode:anAllSharedAssignments) {¶			if (!anAssignmentSNode.isInParallel() &&¶					anAssignmentSNode.isInCritical()) {¶				aRetVal.add(anAssignmentSNode);¶			}¶		}¶		return aRetVal;¶		¶	}¶	public static Set<AssignmentSNode> assignmentsToParallelNonCriticalSharedVariables(SNode anSNode) {¶		Set<AssignmentSNode> anAllSharedAssignments =  assignmentsToSharedVariables(anSNode);¶		Set<AssignmentSNode> aRetVal = new HashSet();¶		for (AssignmentSNode anAssignmentSNode:anAllSharedAssignments) {¶			if (anAssignmentSNode.isInParallel() &&¶					!anAssignmentSNode.isInCritical()) {¶				aRetVal.add(anAssignmentSNode);¶			}¶		}¶		return aRetVal;¶		¶	}¶    public static void fillAssignmentsToShared(SNode anSNode, Set<AssignmentSNode> retVal) {¶    	if (anSNode instanceof AssignmentSNode) {¶			AssignmentSNode anAssignmentSNode = (AssignmentSNode) anSNode;¶			String anLHS = anAssignmentSNode.getLhsFirstIdentifier();¶			if (isSharedVariable(anSNode, anLHS)) {¶				retVal.add(anAssignmentSNode);¶				return;¶			}¶		}¶    	for (SNode aChild:anSNode.getChildren()) {¶    		fillAssignmentsToShared(aChild, retVal);¶    	}¶		¶	}¶    public static void fillInstancesOfNodeType(Class<? extends SNode> aNodeType, SNode anSNode, Set<SNode> retVal) {¶    	if (aNodeType.isAssignableFrom(anSNode.getClass())) {¶			¶				retVal.add(anSNode);¶				return;¶			}¶		¶    	for (SNode aChild:anSNode.getChildren()) {¶    		fillInstancesOfNodeType(aNodeType, aChild, retVal);¶    	}¶		¶	}¶    public static Set<AssignmentSNode>  assignmentSNodes(SNode anSNode) {¶    	Set retVal = new HashSet();    	¶    	fillInstancesOfNodeType(AssignmentSNode.class, anSNode, retVal );¶    	return retVal;¶	}¶   ¶    ¶    public static Set<OMPParallelSNode>  ompParallelSNodes(SNode anSNode) {¶    	Set retVal = new HashSet();    	¶    	fillInstancesOfNodeType(OMPParallelSNode.class, anSNode, retVal );¶    	return retVal;¶	}¶//    public static void fillOMPParallelSNodes(SNode anSNode, Set<OMPParallelSNode> retVal) {¶//    	if (anSNode instanceof OMPParallelSNode) {¶//    		retVal.add((OMPParallelSNode) anSNode);¶//		}¶//    	for (SNode aChild:anSNode.getChildren()) {¶//    		fillOMPParallelSNodes(aChild, retVal);¶//    	}		¶//	}¶    public static Set<ForSNode>  forSNodes(SNode anSNode) {¶    	Set retVal = new HashSet();    	¶    	fillInstancesOfNodeType(ForSNode.class, anSNode, retVal );¶    	return retVal;¶	}¶//    public static void fillForSNodes(SNode anSNode, Set<ForSNode> retVal) {¶//    	if (anSNode instanceof ForSNode) {¶//    		retVal.add((ForSNode) anSNode);¶//		}¶//    	for (SNode aChild:anSNode.getChildren()) {¶//    		fillForSNodes(aChild, retVal);¶//    	}		¶//	}¶    public static Set<OMPForSNode>  ompForSNodes(SNode anSNode) {¶    	Set retVal = new HashSet();    	¶    	fillInstancesOfNodeType(OMPForSNode.class, anSNode, retVal );¶    	return retVal;¶	}¶//    public static void fillOMPForSNodes(SNode anSNode, Set<OMPForSNode> retVal) {¶//    	if (anSNode instanceof OMPForSNode) {¶//    		retVal.add((OMPForSNode) anSNode);¶//		}¶//    	for (SNode aChild:anSNode.getChildren()) {¶//    		fillOMPForSNodes(aChild, retVal);¶//    	}		¶//	}¶    public static Set<OMPForSNode> ompReducingForNodes(SNode anSNode) {¶		Set<OMPForSNode> anAllOMPForSNodes =  ompForSNodes(anSNode);¶		Set<OMPForSNode> aRetVal = new HashSet();¶		for (OMPForSNode anOMPForSNode:anAllOMPForSNodes) {¶			if (anOMPForSNode.getReductionOperation() != null) {¶				aRetVal.add(anOMPForSNode);¶			}¶		}¶		return aRetVal;		¶	}¶    public static Set<AssignmentSNode> assignmentsToOMPReducingForNode(OMPForSNode anOMPForSNode) {¶    	String aReductionVariable = anOMPForSNode.getReductionVariable();¶    	return directAssignmentsOfVariableAndItsAliases(anOMPForSNode, aReductionVariable)	;¶    	¶    }¶	public static boolean dependsOn (SNode anSNode, int aVariableLineNumber, String aVariable, String aCallIdentifier) {¶		List<SNode> aListSNodes = anSNode.getChildren();¶		boolean retVal = false;¶		/*¶		 * Should probably ignore line number as it assumes straight line code¶		 */¶		for (int i = aVariableLineNumber; i >= 0; i--) {¶			SNode anSNodeChild = aListSNodes.get(i);¶			if (anSNodeChild instanceof AssignmentSNode) {¶				// does this statement in anSNode directly invoke aCallIdentifier ¶				if (dependsOn((AssignmentSNode) anSNodeChild, aVariable, aCallIdentifier))¶					return true;¶			} else if (!anSNode.isLeaf()) {¶					// child is overriding the variable so forget checking its assignment statements¶					if (anSNodeChild.getLocalVariableIdentifiers().contains(aVariable)) {¶						continue;¶					}¶					// some subblock of anSNode that has access to aVariable changes variable¶¶					if (dependsOn(anSNodeChild, anSNodeChild.getChildren().size() - 1, aVariable, aCallIdentifier)) {¶						return true;¶					}¶			}¶			¶		}¶		// none of the statements in anSNode or its descendents  have the required call¶		// is the variable a  method parameter ¶		if (anSNode instanceof MethodSNode) {¶			MethodSNode aMethodSNode = (MethodSNode) anSNode;¶			¶			int aParameterNumber = aMethodSNode.getLocalVariableIdentifiers().indexOf(aVariable);¶			if (aParameterNumber != -1) {¶				List <MethodCall> aCalls = aMethodSNode.getCalls();¶				for (MethodCall aCall:aCalls) {¶//					if (!aCall.getMethodActuals().contains(aVariable))¶//						continue;¶//					¶					MethodSNode aCallerSNode = getDeclarationOfCalledMethod(aMethodSNode, aCall);¶					if (dependsOn(aMethodSNode, aCallerSNode.getLineNumber(), aCallerSNode.getLocalVariableIdentifiers().get(aParameterNumber), aCallIdentifier));¶//				    if (aCallerDepends) {¶				    	return true;¶//				    }¶				}¶				return false;¶				// need to find all callers of method and see if any of the aliases for the variable in these¶				// calls depend on aCallIndentifier¶			}			¶			¶		} else if (anSNode.getLocalVariableIdentifiers().contains(aVariable)) {¶			// before going to the parent node, let us see if aVariable is declared here as a non  parameter ¶¶			return false; // no point going to parent¶		}¶		// not a local variable (parameter or declarated variable)¶		SNode anSNodeParent = anSNode.getParent() ;¶		if (anSNodeParent == null)  {¶			return false;¶		}¶		int anSNodeLineNumber = anSNodeParent.getChildren().indexOf(anSNode);¶		return dependsOn(anSNodeParent, anSNodeLineNumber, aVariable, aCallIdentifier);¶		¶	}¶	public static Set<AssignmentSNode> assignmentsOfVariableAliases (SNode anSNode,  String aVariable) {¶		Set<AssignmentSNode> retVal = new HashSet();¶		fillDirectAssignmentsOfVariableAliases(anSNode, aVariable, retVal);¶		return retVal;¶	}¶	public static void fillDirectAssignmentsOfVariableAliases (SNode anSNode,  String aVariable, Set<AssignmentSNode> retVal) {¶		if (anSNode instanceof MethodCall) {¶			MethodCall aMethodCall = (MethodCall) anSNode;¶			int aParameterNumber = aMethodCall.getMethodActualIdentifiers().indexOf(aVariable);¶			if (aParameterNumber < 0) {¶				return;¶			}¶			MethodSNode aDeclaringMethodSNode = getDeclarationOfCalledMethod(anSNode, aMethodCall);¶			String aFormalParameter = aDeclaringMethodSNode.getLocalVariableIdentifiers().get(aParameterNumber);¶//			Set<AssignmentSNode> aCallAssignments = ;¶			fillDirectAssignmentsOfVariableAliases(aDeclaringMethodSNode, aFormalParameter, retVal);¶		} else if (anSNode instanceof MethodSNode)	{¶			MethodSNode aMethodSNode = (MethodSNode) anSNode;¶			int aParameterNumber = aMethodSNode.getLocalVariableIdentifiers().indexOf(aVariable);¶			if (aParameterNumber < 0)¶				return;¶			List<MethodCall> aCalls = aMethodSNode.getCalls();¶			for (MethodCall a"), Diff(INSERT,"Method"), Diff(EQUAL,"Call:aCalls) {¶				"), Diff(DELETE,"aCall.get"), Diff(INSERT,"MethodSNode aCallerMethodSNode = getDeclarationOfCalledMethod(anSNode, aMethodCall);¶				if (aCallerMethodSNode != null) {¶					String anAlias = aCallerMethodSNode.getLocalVariableIdentifiers().get(aParameterNumber);¶					fillDirectAssignmentsOfVariableAliases(aCallerMethodSNode, anAlias, retVal);¶¶				}¶"), Diff(EQUAL,"¶			}¶		}¶		¶		else {¶			List<SNode> aChildren = anSNode.getChildren();¶			for (SNode aChild:aChildren) {¶				fillDirectAssignmentsOfVariableAliases(aChild, aVariable, retVal);¶			}¶		} 	¶		¶	}¶	¶	/*¶	 * will not consider assignments to variables in the RHS of these assignments¶	 */¶	public static Set<AssignmentSNode> directAssignmentsOfVariableAndItsAliases (SNode anSNode,  String aVariable) {¶		Set<AssignmentSNode> retVal = new HashSet();¶		fillDirectAssignmentsOfVariableAndItsAliases(anSNode, aVariable, retVal);¶		return retVal;¶	}¶	¶//	public static Set<AssignmentSNode> assignmentsEffectingVariableAndItsAliases (SNode anSNode,  String aVariable) {¶//		Set<AssignmentSNode> retVal = directAssignmentsOfVariableAndItsAliases(anSNode, aVariable);¶//		¶//	}¶	public static void fillDirectAssignmentsOfVariableAndItsAliases (SNode anSNode,  String aVariable, Set<AssignmentSNode> retVal) {¶		if (anSNode instanceof AssignmentSNode) {¶			AssignmentSNode anAssignmentSNode = (AssignmentSNode) anSNode;¶			if (anAssignmentSNode.getLhsFirstIdentifier().equals(aVariable)) {¶				retVal.add(anAssignmentSNode);¶			}¶		}¶		¶		else if (anSNode instanceof MethodCall) {¶			MethodCall aMethodCall = (MethodCall) anSNode;¶			int aParameterNumber = aMethodCall.getMethodActualIdentifiers().indexOf(aVariable);¶			if (aParameterNumber < 0) {¶				return;¶			}¶			MethodSNode aDeclaringMethodSNode = getDeclarationOfCalledMethod(anSNode, aMethodCall);¶			String aFormalParameter = aDeclaringMethodSNode.getLocalVariableIdentifiers().get(aParameterNumber);¶//			Set<AssignmentSNode> aCallAssignments = ;¶			fillDirectAssignmentsOfVariableAndItsAliases(aDeclaringMethodSNode, aFormalParameter, retVal);¶		} else {¶			List<SNode> aChildren = anSNode.getChildren();¶			for (SNode aChild:aChildren) {¶				fillDirectAssignmentsOfVariableAndItsAliases(aChild, aVariable, retVal);¶			}¶		}		¶		¶	}¶	¶	public static RootOfFileSNode getRootOfFileNode(SNode aCurrentSNode ) {¶		if (aCurrentSNode instanceof RootOfFileSNode) {¶			return (RootOfFileSNode) aCurrentSNode;¶		}¶		SNode aParentSNode = aCurrentSNode.getParent() ;¶		¶		if (aParentSNode == null) {¶			return null;¶		}¶		¶		return getRootOfFileNode(aParentSNode);¶		¶	}¶	public static boolean match (MethodSNode aMethodSNode, MethodCall aMethodCall) {¶		return aMethodSNode.getMethodName().equals(aMethodCall.getMethodName()) ¶				&& aMethodSNode.getLocalVariableIdentifiers().size() == aMethodCall.getMethodActuals().size();¶	}¶	public static DeclarationSNode getDeclarationOfVariableIdentifier(SNode aCurrentSNode, String anIdentifier) {¶		if (aCurrentSNode == null) {¶			return null;¶		}¶		¶		¶		int anIndex = aCurrentSNode.getLocalVariableIdentifiers().indexOf(anIdentifier);¶		if (anIndex < 0) {¶			return getDeclarationOfVariableIdentifier(aCurrentSNode.getParent(), anIdentifier);¶		}¶		DeclarationSNode retVal = aCurrentSNode.getVariableDeclarations().get(anIndex);¶//		retVal.getAssignmentsToDeclaredVariable().add(anAssignmentSNode);¶//		anAssignmentSNode.setLhsFirstIdentifierDeclaration(retVal);¶		return retVal;¶	}¶	¶	public static DeclarationSNode getDeclarationOfAssignedVariable(SNode aCurrentSNode, AssignmentSNode anAssignmentSNode) {¶		if (aCurrentSNode == null) {¶			return null;¶		}¶		if (anAssignmentSNode instanceof ADeclaringAssignmentSNode) {¶			return (ADeclaringAssignmentSNode) anAssignmentSNode;¶		}¶		int anIndex = aCurrentSNode.getLocalVariableIdentifiers().indexOf(anAssignmentSNode.getLhsFirstIdentifier());¶		if (anIndex < 0) {¶			return getDeclarationOfAssignedVariable(aCurrentSNode.getParent(), anAssignmentSNode);¶		}¶		DeclarationSNode retVal = aCurrentSNode.getVariableDeclarations().get(anIndex);¶//		retVal.getAssignmentsToDeclaredVariable().add(anAssignmentSNode);¶//		anAssignmentSNode.setLhsFirstIdentifierDeclaration(retVal);¶		return retVal;¶	}¶	¶	public static MethodSNode getDeclarationOfCalledMethod(SNode aCurrentSNode, MethodCall aMethodCall ) {¶		SNode aRootNode = getRootOfFileNode(aCurrentSNode);¶		for (SNode aChild:aRootNode.getChildren()) {¶			if (aChild instanceof MethodSNode) {¶				MethodSNode aMethodSNode = (MethodSNode) aChild;¶				if (match (aMethodSNode, aMethodCall)) {¶					return aMethodSNode;¶				}¶			}¶		}¶		return null; // this should never happen;¶	}¶	¶	public static RootOfProgramSNode getRootOfProgramSNode(String aSource) {¶		RootOfProgramSNode retVal = new ARootOfProgramSNode();¶		Map<String, StringBuffer> aFileNameToContents = ABasicTextManager.extractFileContents(aSource);¶		for (String aFileName:aFileNameToContents.keySet()) {¶			StringBuffer aFileContents = aFileNameToContents.get(aFileName);¶//			List<OpenMPPragma> anOpenMPPragmas = OpenMPUtils.getOpemMPPragmas(aFileContents);¶			RootOfFileSNode anSNode = OMPSNodeUtils.getSNode(aFileName, aFileContents);¶			retVal.getFileNameToSNode().put(aFileName, anSNode);¶			anSNode.setParent(retVal);¶//			System.out.println("file name:" + aFileName);¶//			System.out.println("pragmas:" + anSNode);¶		}¶		processExternalMethodSNodes(retVal);¶		setParentOfParameterDeclarations(retVal);¶		processIndirectAssignments(retVal);¶		return retVal;¶	}¶//	public static void processIndirectAssignments (S aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode) {¶//		for (SNode anSNode:aRootOfFileSNode.getChildren()) {¶//			-----¶//		}¶//	}¶	public static void setParentOfParameterDeclarations(RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode) {¶		for (SNode anSNode:aRootOfFileSNode.getChildren()) {¶			if (anSNode instanceof MethodSNode) {¶				setParentOfParameterDeclarations(aRootOfProgramSNode, aRootOfFileSNode, (MethodSNode) anSNode);¶			}¶		}¶	}¶	public static void setParentOfParameterDeclarations (RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode, MethodSNode aMethodSNode) {¶		List<DeclarationSNode> aDeclarations = aMethodSNode.getVariableDeclarations();¶		for (DeclarationSNode aDeclaration:aDeclarations) {¶			if (aDeclaration.getParent() == null) {¶				aDeclaration.setParent(aMethodSNode);¶			}¶		}¶	}¶	public static void setParentOfParameterDeclarations (RootOfProgramSNode aRootOfProgramSNode) {¶		for (String aFileName:aRootOfProgramSNode.getFileNameToSNode().keySet()) {¶			RootOfFileSNode aRootOfFileSNode = aRootOfProgramSNode.getFileNameToSNode().get(aFileName);¶			setParentOfParameterDeclarations(aRootOfProgramSNode, aRootOfFileSNode);¶			¶		}¶¶	}¶	public static void processExternalMethodSNodes (RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode) {¶		for (SNode anSNode:aRootOfFileSNode.getChildren()) {¶			if (anSNode instanceof ExternalMethodSNode) {¶				processExternalMethodSNode(aRootOfProgramSNode, aRootOfFileSNode, (ExternalMethodSNode) anSNode);¶			}¶		}¶	}¶¶	public static void processExternalMethodSNode (RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode, ExternalMethodSNode anExternalMethodSNode) {¶		MethodSNode aMethodSNode = aRootOfProgramSNode.getExternalToInternalMethod().get(anExternalMethodSNode.toString());¶		if (aMethodSNode == null) {¶			aMethodSNode = findMethodSNode(aRootOfProgramSNode, aRootOfFileSNode, anExternalMethodSNode);¶			if (aMethodSNode != null) {¶				aRootOfProgramSNode.getExternalToInternalMethod().put(anExternalMethodSNode.toString(),aMethodSNode );¶			}¶		}¶		if (aMethodSNode != null) {¶			anExternalMethodSNode.setActualMethodSNode(aMethodSNode);¶			aMethodSNode.getCalls().addAll(anExternalMethodSNode.getLocalCalls());¶		}¶	}¶	¶	public static MethodSNode findMethodSNode (RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode, ExternalMethodSNode anExternalMethodSNode) {¶//		MethodSNode foundMethodSNode = null;¶		for (String aFileName:aRootOfProgramSNode.getFileNameToSNode().keySet()) {¶			if (aFileName.equals(aRootOfFileSNode.getFileName()))¶				continue;¶			¶			RootOfFileSNode aSearchedRootOfFileSNode = aRootOfProgramSNode.getFileNameToSNode().get(aFileName);¶			 for (SNode anSNode:aSearchedRootOfFileSNode.getChildren()) {¶				if (anSNode instanceof MethodSNode && !(anSNode instanceof ExternalMethodSNode)) {¶					if (anSNode.toString().equals(anExternalMethodSNode.toString())) {¶						return (MethodSNode) anSNode;¶						¶					}¶//					processExternalMethodSNode(aRootOfProgramSNode, aRootOfFileSNode, (ExternalMethodSNode) anSNode);¶				}¶			}¶		}¶		return null;¶	}¶	public static void processExternalMethodSNodes (RootOfProgramSNode aRootOfProgramSNode) {¶		for (String aFileName:aRootOfProgramSNode.getFileNameToSNode().keySet()) {¶			RootOfFileSNode aRootOfFileSNode = aRootOfProgramSNode.getFileNameToSNode().get(aFileName);¶			processExternalMethodSNodes(aRootOfProgramSNode, aRootOfFileSNode);¶			aRootOfFileSNode.getOmp_get_num_threads_SNode().¶				setActualMethodSNode(aRootOfProgramSNode.getOmp_get_num_threads_SNode());¶			aRootOfFileSNode.getOmp_get_thread_num_SNode().¶				setActualMethodSNode(aRootOfProgramSNode.getOmp_get_thread_num_SNode());¶			aRootOfFileSNode.getOmp_get_wtime_SNode().¶			setActualMethodSNode(aRootOfProgramSNode.getOmp_get_wtime_SNode());¶		}¶¶	}¶	public static void processIndirectAssignments (SNode anSNode) {¶		if (anSNode instanceof ConstDeclarationSNode) {¶			return;¶		}¶		if (anSNode instanceof DeclarationSNode) {¶			DeclarationSNode aDeclarationSNode = (DeclarationSNode) anSNode;¶			Set<AssignmentSNode> anIndirectAssignments = aDeclarationSNode.getAssignmentsEffectingDeclaredIdentifier();¶			if (anIndirectAssignments != null) {¶				return; // already assigned¶			}¶			anIndirectAssignments = new HashSet<>();¶			aDeclarationSNode.setAssignmentsEffectingDeclaredIdentifier(anIndirectAssignments);¶			Set<AssignmentSNode> aDirectAssignments = aDeclarationSNode.getAssignmentsToDeclaredVariable();¶			anIndirectAssignments.addAll(aDirectAssignments);¶			Set<AssignmentSNode> anAliasAssignments = assignmentsOfVariableAliases(aDeclarationSNode.getParent(), aDeclarationSNode.getVariableName());¶			anIndirectAssignments.addAll(anAliasAssignments);¶			for (AssignmentSNode aDirectAssignment:aDirectAssignments) {¶				List<String> aVariableIdentifiers = aDirectAssignment.getRhsVariableIdentifiers();¶				¶				for (String aVariableIdentifier:aVariableIdentifiers) {¶					DeclarationSNode aDependeeDeclarationSNode = getDeclarationOfVariableIdentifier(aDirectAssignment, aVariableIdentifier);¶					if (aDependeeDeclarationSNode == null) {¶						System.err.println("Could not find declaration of:" + aVariableIdentifier + " referenced in:" + aDirectAssignment );¶						continue;¶					}¶					processIndirectAssignments(aDependeeDeclarationSNode);¶					Set<AssignmentSNode> aDependeeIndirectAssignments = aDeclarationSNode.getAssignmentsEffectingDeclaredIdentifier();¶					anIndirectAssignments.addAll(aDependeeIndirectAssignments);¶					¶				}¶			}¶		} else {¶			for (SNode aChild: anSNode.getChildren()) {¶				processIndirectAssignments(aChild);¶			}¶		}¶		¶	}¶	¶//	public static void fillIndirectAssignments (SNode anSNode, Set<AssignmentSNode> retVal ) {¶//		¶//	}¶	¶¶//	public static void main(String[] args) {¶//		List<MethodCall> aTokens = callsIn("foo(bar, hgf)/foo2()*foo3(b, a c,)");¶//		System.out.println(aTokens);¶//		¶//		¶////		List<String> aTokens = identifiersIn("a[i] + b*2/3");¶////		System.out.println(aTokens);¶////		aTokens = numbersIn("a[i] + b*2/3");¶////		System.out.println(aTokens);¶////		aTokens = operatorsIn("a[i] + b*2/3");¶////		System.out.println(aTokens);¶////¶////		System.out.println(StringUtils.substringBetween("a", "[", "]"));¶//	}¶¶}¶")]]]></diff>
    <snapshot><![CDATA[package gradingTools.shared.testcases.openmp.scannedTree;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Stack;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.apache.commons.lang.StringUtils;

import grader.basics.project.source.ABasicTextManager;
import gradingTools.shared.testcases.openmp.OpenMPKeywordEnum;
import gradingTools.shared.testcases.openmp.OpenMPParallelPragma;
import gradingTools.shared.testcases.openmp.OpenMPUtils;
import gradingTools.shared.testcases.openmp.scannedTree.ADeclarationSNode;
import gradingTools.shared.testcases.openmp.scannedTree.ADeclaringAssignmentSNode;
import gradingTools.shared.testcases.openmp.scannedTree.AForSNode;
import gradingTools.shared.testcases.openmp.scannedTree.ATextSNode;
import gradingTools.shared.testcases.openmp.scannedTree.AnAssignmentSNode;
import gradingTools.shared.testcases.openmp.scannedTree.AnOMPCriticalSNode;
import gradingTools.shared.testcases.openmp.scannedTree.AnOMPForSNode;
import gradingTools.shared.testcases.openmp.scannedTree.AnOMPParallelSNode;
import gradingTools.shared.testcases.openmp.scannedTree.AnOMPSNode;
import gradingTools.shared.testcases.openmp.scannedTree.AnSNode;
import gradingTools.shared.testcases.openmp.scannedTree.AssignmentSNode;
import gradingTools.shared.testcases.openmp.scannedTree.DeclarationSNode;
import gradingTools.shared.testcases.openmp.scannedTree.DeclaringAssignmentSNode;
import gradingTools.shared.testcases.openmp.scannedTree.ForSNode;
import gradingTools.shared.testcases.openmp.scannedTree.OMPForSNode;
import gradingTools.shared.testcases.openmp.scannedTree.OMPSNode;
import gradingTools.shared.testcases.openmp.scannedTree.SNode;

public class OMPSNodeUtils extends OpenMPUtils {

	public static RootOfFileSNode getSNode(String aFileName, StringBuffer aFileBuffer) {
		String[] aFileLines = aFileBuffer.toString().split("\n");
		return getSNode(aFileName, aFileLines);
	}

	public static AssignmentSNode getAssignmentSNode(int aLineNumber, String aString) {
		if (aString == null) {
			return null;
		}
		String[] aTokens = aString.split("=");
		if (aTokens.length == 1) {
			return new AnAssignmentSNode(aLineNumber, aTokens[0], null);
		} else {
		return new AnAssignmentSNode(aLineNumber, aTokens[0], aTokens[1]);
		}
	}

	public static DeclarationSNode getDeclarationSNode(int aLineNumber, String aString) {
		String[] aTokens = aString.split(" ");
		return new ADeclarationSNode(aLineNumber, aTokens[0], aTokens[1]);
	}

	public static DeclaringAssignmentSNode getDeclaringAssignmentSNode(int aLineNumber, String aString) {
		String[] anLHSAndRHS = aString.split("=");
		String[] aTypeAndVariable = anLHSAndRHS[0].split(" ");
		return new ADeclaringAssignmentSNode(aLineNumber, aTypeAndVariable[0], aTypeAndVariable[1], anLHSAndRHS[1]);
	}
	public static ConstDeclarationSNode getConstDeclarationSNode(int aLineNumber, String aString) {
		String anAssignmentString = aString.substring(CONST.length()).trim();
		String[] anLHSAndRHS = anAssignmentString.split("=");
		String[] aTypeAndVariable = anLHSAndRHS[0].split(" ");
		return new AConstDeclarationSNode(aLineNumber, aTypeAndVariable[0], aTypeAndVariable[1], anLHSAndRHS[1]);
	}

	public static boolean isDeclaringAssignment(String aFileLine) {
		return startsWithTypeName(aFileLine) && aFileLine.contains("=");
	}
	public static boolean isConstDeclaration(String aFileLine) {
		return aFileLine.startsWith(CONST);
	}
	public static boolean isMethodDeclaration(String aFileLine) {
		return startsWithTypeName(aFileLine) && 
				aFileLine.contains("(") &&
				!aFileLine.contains("=");
	}
	public static boolean isExternalMethodDeclaration(String aFileLine) {
		return isMethodDeclaration(aFileLine) && aFileLine.endsWith(";");
	}


	public static boolean isVariableDeclaration(String aFileLine) {

		return startsWithTypeName(aFileLine) && !aFileLine.contains("(");
	}

	public static boolean isAssignment(String aFileLine) {
		return aFileLine.contains("=") && !aFileLine.contains("==");
	}

	public static boolean isForNode(String aFileLine) {
		return aFileLine.startsWith("for");
	}

	public static ForSNode getForSNode(int aLineNumber, String aFileLine) {

		int aLeftParenIndex = aFileLine.indexOf("(");
		int aRightParenIndex = aFileLine.indexOf(")");
		if (aLeftParenIndex < 0 || aRightParenIndex < 0) {
			return null;
		}
		String aHeaderString = aFileLine.substring(aLeftParenIndex + 1, aRightParenIndex);
		String[] aForComponents = aHeaderString.split(";");
		AssignmentSNode anAssignmentSNode = null;
		String aForInitializaton = aForComponents[0];
		if (!aForInitializaton.isEmpty() && aForInitializaton.contains("=")) {
			if (isDeclaringAssignment(aForInitializaton)) {
				anAssignmentSNode = getDeclaringAssignmentSNode(aLineNumber, aForInitializaton);
			} else {
				anAssignmentSNode = getAssignmentSNode(aLineNumber, aForInitializaton);
			}

		}		
		return new AForSNode(aLineNumber, anAssignmentSNode, aForComponents[1], getAssignmentSNode(aLineNumber, aForComponents[2]));
	}
	static String[] emptyArray = {};
	public static MethodSNode getMethodSNode(int aLineNumber, String aFileLine, boolean isInternal) {

		int aLeftParenIndex = aFileLine.indexOf("(");
		int aRightParenIndex = aFileLine.indexOf(")");
		if (aLeftParenIndex < 0 || aRightParenIndex < 0) {
			return null;
		}
		String aMethodNameAndType = aFileLine.substring(0, aLeftParenIndex);
		String[] aMethodNameAndTypeTokens = aMethodNameAndType.split("\\s+"); 
		
		String aMethodParameters = aFileLine.substring(aLeftParenIndex +1 , aRightParenIndex);
		String[] aMethodParameterTokens = aMethodParameters.isEmpty()?emptyArray:
		 aMethodParameters.split(",");
		
//		String[] aMethodParameterTypes = new String[aMethodParameterTokens.length];
//		String[] aMethodParameterNames = new String[aMethodParameterTokens.length];
		List<DeclarationSNode> aDeclarationSNodeList = new ArrayList();
		for (int i = 0; i < aMethodParameterTokens.length; i++ ) {
			String[] aTypeAndName = aMethodParameterTokens[i].trim().split("\\s+");
			if (aTypeAndName.length < 2) {
				continue;
			}
			aDeclarationSNodeList.add(new ADeclarationSNode(aLineNumber, aTypeAndName[0].trim(), aTypeAndName[1].trim()));
//			aMethodParameterTypes[i] = aTypeAndName[0].trim();
//			aMethodParameterNames[i] = aTypeAndName[1].trim();
		}
		if (isInternal)
//		return new AMethodSNode(aLineNumber, aMethodNameAndTypeTokens[0], aMethodNameAndTypeTokens[1], aMethodParameterTypes,aMethodParameterNames );
			return new AMethodSNode(aLineNumber, aMethodNameAndTypeTokens[0], aMethodNameAndTypeTokens[1], aDeclarationSNodeList );
		else
			return new AnExternalMethodSNode(aLineNumber, aMethodNameAndTypeTokens[0], aMethodNameAndTypeTokens[1], aDeclarationSNodeList );
	}

	public static void setReductionData(OMPForSNode lastChild, String aStoredToken, int aLeftParenIndex,
			int aRightParenIndex) {
		int aColonIndex = aStoredToken.indexOf(":");
		if (aLeftParenIndex != -1 && aRightParenIndex != -1 && aColonIndex != -1) {
			String anOperationString = aStoredToken.substring(aLeftParenIndex + 1, aColonIndex).trim();
			String aVariableString = aStoredToken.substring(aColonIndex + 1, aRightParenIndex).trim();
			((OMPForSNode) lastChild).setReductionVariable(aVariableString);
			((OMPForSNode) lastChild).setReductionOperation(anOperationString);
		}
	}

	public static void setSharedOrPrivateData(OMPSNode lastChild, String aStoredToken, int aLeftParenIndex,
			int aRightParenIndex, boolean isShared) {
//		int aColonIndex = aStoredToken.indexOf(":");
		if (aLeftParenIndex != -1 && aRightParenIndex != -1) {
			String aVariableDeclarations = aStoredToken.substring(aLeftParenIndex + 1, aRightParenIndex);
			String[] aVariables = aVariableDeclarations.split(",");
			if (isShared) {
				lastChild.setSharedVariables(aVariables);
			} else {
				lastChild.setPrivateVariables(aVariables);
			}
		}
	}

	public static RootOfFileSNode getSNode(String aFileName, String[] aFileLines) {
		Stack<SNode> anSNodes = new Stack();

		RootOfFileSNode retVal = new ARootOfFileSNode(aFileName);
		anSNodes.add(retVal);
		SNode previousHeaderNode = null;
		for (int i = 0; i < aFileLines.length; i++) {
			String aFileLine = aFileLines[i].trim();
			if (!isCodeLine(aFileLine)) {
				continue;
			}
			if (isForNode(aFileLine)) {
				ForSNode aForSNode = getForSNode(i, aFileLine);
				SNode aParent = previousHeaderNode != null?previousHeaderNode:anSNodes.peek();
				aForSNode.setParent(anSNodes.peek());
				aForSNode.setParent(aParent);

//				anSNodes.push(aForSNode);
				previousHeaderNode = aForSNode;
				if (aFileLine.endsWith(")")) {
					continue;
				}
			}
			if (isExternalMethodDeclaration(aFileLine)) {
				MethodSNode aMethodSNode = getMethodSNode(i, aFileLine, false);
				aMethodSNode.setParent(anSNodes.peek());
//				anSNodes.push(aForSNode);
				previousHeaderNode = aMethodSNode;
				if (aFileLine.endsWith(")")) {
					continue;
				}
			}
			if (isMethodDeclaration(aFileLine)) {
				MethodSNode aMethodSNode = getMethodSNode(i, aFileLine, true);
				aMethodSNode.setParent(anSNodes.peek());
//				anSNodes.push(aForSNode);
				previousHeaderNode = aMethodSNode;
				if (aFileLine.endsWith(")")) {
					continue;
				}
			}
			if (isPragmaStart(aFileLine)) {
				OMPSNode anOMPSNode = getOMPSNode(i, anSNodes.peek(), aFileLine);
//				anSNodes.push(anOMPSNode);
				previousHeaderNode = anOMPSNode;
				continue;
			}
			if (isBlockStart(aFileLine)) {
				SNode aBlockSNode = new ABlockSNode(i);
				if (previousHeaderNode != null) {
					aBlockSNode.setParent(previousHeaderNode);
				} else {
					aBlockSNode.setParent(anSNodes.peek());
				}
				anSNodes.push(aBlockSNode);
				previousHeaderNode = null;
				continue;
			}
//			} else 
			if (isBlockEnd(aFileLine)) {
				anSNodes.pop();
				continue;
			}
			SNode aNewLeafNode = null;
			if (isConstDeclaration(aFileLine)) {
				aNewLeafNode = getConstDeclarationSNode(i, aFileLine);

			} else if (isDeclaringAssignment(aFileLine)) {
				aNewLeafNode = getDeclaringAssignmentSNode(i, aFileLine);

			} else if (isAssignment(aFileLine)) {
				aNewLeafNode = getAssignmentSNode(i, aFileLine);
			} else if (isVariableDeclaration(aFileLine)) {
				aNewLeafNode = getDeclarationSNode(i, aFileLine);
			} else {
				List<MethodCall> aCalls = callsIn(i, aFileLine, null); // parent will be assigned below
				if (aCalls != null && aCalls.size() == 1) {
					aNewLeafNode = aCalls.get(0);
				} else {
					aNewLeafNode = new ATextSNode(i, aFileLine);
				}
			}
//			else {
//				aNewLeafNode = new ATextSNode(i, aFileLine);
//			}
			if (previousHeaderNode != null) {
				aNewLeafNode.setParent(previousHeaderNode);
			} else {
				aNewLeafNode.setParent(anSNodes.peek());
			}

		}

		return retVal;
	}

	public static OMPSNode getOMPSNode(int aLineIndex, SNode aParentNode, String aFileLine) {
		String[] aTokens = aFileLine.split("\\s+");
		if (aTokens.length <= 2) {
			return null;
		}
		if (!aTokens[1].equals("omp")) {
			return null;
		}
		if (aTokens.length < 3) {
			return null;
		}
		String aFirstToken = aTokens[2];
		OpenMPKeywordEnum anOpenMPKeyword = stringToOpenMPKeyword.get(aFirstToken);
//		List<OpenMPPragma> retVal = new ArrayList();
		OMPSNode lastChild = null;
		int aStartIndex = 2;
		OMPSNode aNewNode = null;
		OMPForSNode aForChild = null;
		switch (anOpenMPKeyword) {
		case PARALLEL:
			aNewNode = new AnOMPParallelSNode(aLineIndex);

			if (aTokens.length > 3 && aTokens[3].equals("for")) {
				aForChild = new AnOMPForSNode(aLineIndex);
				aForChild.setParent(aNewNode);

				aStartIndex++;
			}
			break;
		case FOR:
			aNewNode = new AnOMPForSNode(aLineIndex);
			;
			break;
		case CRITICAL:
			aNewNode = new AnOMPCriticalSNode(aLineIndex);
//			retVal.add (lastChild);
			break;
		default:
			aNewNode = new AnOMPSNode(aLineIndex);

		}

		if (lastChild != null) {
			aNewNode.setParent(lastChild);
		} else {
			aNewNode.setParent(aParentNode);
		}
		lastChild = aForChild == null ? aNewNode : aForChild;

		for (int i = aStartIndex; i < aTokens.length; i++) {
			String aStoredToken = aTokens[i].trim();
			if (aStoredToken.isEmpty()) {
				continue;
			}
			if (aStoredToken.startsWith("reduction") || aStoredToken.startsWith("shared")
					|| aStoredToken.startsWith("private")) {
				// combine all tokens until ")" into one for normalization
				while (!aStoredToken.endsWith(")")) {
					i++;
					if (i >= aTokens.length) {
						break;
					}
					String aNewToken = aTokens[i].trim();
					aStoredToken += aNewToken;
				}
				int aLeftParenIndex = aStoredToken.indexOf("(");
				int aRightParenIndex = aStoredToken.indexOf(")");
				if (aStoredToken.startsWith("reduction")) {
					setReductionData((OMPForSNode) lastChild, aStoredToken, aLeftParenIndex, aRightParenIndex);
				} else if (aStoredToken.startsWith("private")) {
					setSharedOrPrivateData((OMPSNode) lastChild, aStoredToken, aLeftParenIndex, aRightParenIndex,
							false);

				} else if (aStoredToken.startsWith("shared")) {
					setSharedOrPrivateData(lastChild, aStoredToken, aLeftParenIndex, aRightParenIndex, true);

				}

			}

			lastChild.getOpenMPTokens().add(aStoredToken);
		}

		return lastChild;

	}

	public static boolean hasParallelAncestor(SNode anSNode) {
		if (anSNode == null) {
			return false;
		}
		if (anSNode instanceof OMPParallelSNode) {
			return true;
		}
		return hasParallelAncestor(anSNode.getParent());
	}
	public static boolean hasCriticalAncestor(SNode anSNode) {
		if (anSNode == null) {
			return false;
		}
		if (anSNode instanceof OMPCriticalSNode) {
			return true;
		}
		return hasCriticalAncestor(anSNode.getParent());
	}


	public static Boolean isDeclaredShared(OMPSNode anOMPSNode, String anLHS) {
		if (Arrays.asList(anOMPSNode.getSharedVariables()).contains(anLHS)) {
			return true;
		}
		if (Arrays.asList(anOMPSNode.getPrivateVariables()).contains(anLHS)) {
			return false;
		}
		return null;

	}

	public static boolean isSharedVariable(SNode anSNode, String anLHS) {
		if (anSNode == null) {
			return false;
		}
		if (anSNode.getLocalVariableIdentifiers().contains(anLHS)) {
			if (!(anSNode instanceof OMPSNode)) { // no shared and private declarations
				return !hasParallelAncestor(anSNode); // shared if not inParallel
			}
			OMPSNode anOMPSNode = (OMPSNode) anSNode;
			return (Arrays.asList(anOMPSNode.getSharedVariables()).contains(anLHS)); // private unless declared shared
		}
		if (anSNode instanceof OMPSNode) {
			OMPSNode anOMPSNode = (OMPSNode) anSNode;
			// the variable is global to this scope, check if it has have been made shared
			// or private by this scope
			Boolean isDeclaredShared = isDeclaredShared(anOMPSNode, anLHS);
			if (isDeclaredShared != null) {
				return isDeclaredShared;
			}
		}
		// check the parent
		return isSharedVariable(anSNode.getParent(), anLHS);
	}

	public static List<SNode> getAllLeafNodes(SNode aTopNode) {
		List<SNode> retVal = new ArrayList();
		addLeafNodes(aTopNode, retVal);
		return retVal;
	}

	public static void addLeafNodes(SNode aTopNode, List<SNode> retVal) {
		for (SNode aChild : aTopNode.getChildren()) {
			if (aChild.isLeaf()) {
				retVal.add(aChild);
			} else {
				addLeafNodes(aChild, retVal);
			}
		}
	}

	public static List<SNode> getNonParallelLeafNodes(SNode aTopNode) {
		List<SNode> retVal = new ArrayList();
		addNonParallelLeafNodes(aTopNode, retVal);
		return retVal;
	}

	public static void addNonParallelLeafNodes(SNode aTopNode, List<SNode> retVal) {
		if (aTopNode.isInParallel()) {
			return;
		}
		for (SNode aChild : aTopNode.getChildren()) {
			if (aChild.isLeaf()) {
				retVal.add(aChild);
			} else {
				addLeafNodes(aChild, retVal);
			}
		}
	}
	static String callRegex = "([a-zA-Z_$][a-zA-Z_$0-9]*)\\(.*?\\)";
	static Pattern callPattern = Pattern.compile(callRegex);

	static String identifierRegex = "[a-zA-Z_$][a-zA-Z_$0-9]*";
	static Pattern identifierPattern = Pattern.compile(identifierRegex);
	public static List<String> identifiersIn(String aString) {
		if (aString == null)
			return null;
//		Pattern mypattern = Pattern.compile("[a-zA-Z_$][a-zA-Z_$0-9]*");
//		Matcher mymatcher = mypattern.matcher(aString);
		Matcher mymatcher = identifierPattern.matcher(aString);
		List<String> retVal = new ArrayList();
		while (mymatcher.find()) {
			String find = mymatcher.group(0);
			retVal.add(find);
		}
		return retVal;
	}
	public static List<MethodCall> callsIn(int aLineNumber, String aString, SNode aParent) {
		if (aString == null)
			return emptyList;
		if (isMethodDeclaration(aString)) {
			return emptyList;
		}
//		Pattern mypattern = Pattern.compile("[a-zA-Z_$][a-zA-Z_$0-9]*");
//		Matcher mymatcher = mypattern.matcher(aString);
		Matcher mymatcher = callPattern.matcher(aString);
		List<MethodCall> retVal = new ArrayList();
		while (mymatcher.find()) {
			String find = mymatcher.group(0);
			int aLeftParenIndex = find.indexOf("(");
			int aRightParenIndex = find.indexOf(")");
			String aMethodName = find.substring(0, aLeftParenIndex).trim();
			String aParameters = find.substring(aLeftParenIndex + 1, aRightParenIndex);
			List<String> aParameterList = new ArrayList();
			String[] aParameterTokens = aParameters.split(",");
			for (String aParameter:aParameterTokens) {
				String aParameterTrimmed = aParameter.trim();
				if (!aParameterTrimmed.isEmpty())
				aParameterList.add(aParameterTrimmed);
			}
			retVal.add(new AMethodCall(aLineNumber, aMethodName, aParameterList, aParent));

//			aCallStrings.add(find);
		}
		return retVal;
	}
	static String numberRegex = "(\\d+\\.\\d+)|(\\d+)";
	static Pattern numberPattern = Pattern.compile(numberRegex);
	public static List<String> numbersIn(String aString) {
		if (aString == null)
			return null;
//		String regex = "(\\d+\\.\\d+)|(\\d+)";
//
//		Matcher m = Pattern.compile(regex).matcher(aString);
		Matcher m =numberPattern.matcher(aString);


		List<String> retVal = new ArrayList();

		while (m.find()) {
			retVal.add(m.group());
		}
		return retVal;
	}

	public static String subscriptIn(String aString) {
		if (aString == null)
			return null;
		return StringUtils.substringBetween(aString, "[", "]");
	}
	static String[] emptyStringArray = {};
	static List emptyList = new ArrayList();

	public static String[] subscriptsIn(String aString) {
		if (aString == null)
			return emptyStringArray;
		return StringUtils.substringsBetween(aString, "[", "]");
	}
	static  String operatorRegex = "([+-/*///^])|([/(/)])";
	static Pattern operatorPattern = Pattern.compile(operatorRegex);

	public static List<String> operatorsIn(String aString) {
		if (aString == null)
			return null;
//		String operatorRegex = "([+-/*///^])|([/(/)])";
//
//		Matcher m = Pattern.compile(operatorRegex).matcher(aString);
		
		Matcher m = operatorPattern.matcher(aString);


		List<String> retVal = new ArrayList();

		while (m.find()) {
			retVal.add(m.group());
		}
		return retVal;
	}
	
	public static int numberOfNestingFors (SNode anSNode) {
		if (anSNode == null) {
			return 0;
		}
		int retVal = anSNode.getNumberOfNestingFors();
		if ( retVal >= 0) {
			return retVal;
		}
		retVal = numberOfNestingFors (anSNode.getParent()) ;

		if (anSNode instanceof ForSNode) {
			retVal++;
		} else if (anSNode instanceof MethodSNode) {
			List<MethodCall> aMethodCalls = ((MethodSNode) anSNode).getCalls();
			int aMaxNestingLevel = 0;
			for (MethodCall aMethodCall:aMethodCalls) {
				MethodSNode aCallerMethodSNode = getDeclarationOfCalledMethod(anSNode, aMethodCall);
				int aCallerNumberOfNestingFors = numberOfNestingFors(aCallerMethodSNode);
				aMaxNestingLevel = Math.max(aCallerNumberOfNestingFors, aMaxNestingLevel);				
			}
			return retVal + aMaxNestingLevel;
		}
		return retVal;
	}
	public static boolean hasOperator (SNode anSNode, String anOperator) {
		boolean retVal = false;
		if (anSNode instanceof AssignmentSNode) {
			AssignmentSNode anAssignmentSNode = (AssignmentSNode) anSNode;
			 retVal = (anAssignmentSNode.getLhsOperators().contains(anOperator) || 
					anAssignmentSNode.getRhsOperators().contains(anOperator)) ;
			if (retVal) {
				return retVal;
			} else {
				List<MethodCall> aMethodCalls = anAssignmentSNode.getRhsCalls();
				for (MethodCall aMethodCall:aMethodCalls) {
					MethodSNode aMethodSNode = getDeclarationOfCalledMethod(anSNode, aMethodCall);
					retVal = hasOperator(aMethodSNode, anOperator);
					if (retVal) {
						return retVal;
					}
					
				}
				return false;
			}
			
		}
		for (SNode aChild:anSNode.getChildren()) {
			retVal = hasOperator(aChild, anOperator);
			if (retVal) {
				return retVal;
			}
		}
		return false;
	}
	public static boolean hasMethodCall (SNode anSNode, String anOperator) {
		boolean retVal = false;
		if (anSNode instanceof AssignmentSNode) {
			AssignmentSNode anAssignmentSNode = (AssignmentSNode) anSNode;
			 retVal = (anAssignmentSNode.getLhsOperators().contains(anOperator) || 
					anAssignmentSNode.getRhsOperators().contains(anOperator)) ;
			if (retVal) {
				return retVal;
			} else {
				List<MethodCall> aMethodCalls = anAssignmentSNode.getRhsCalls();
				for (MethodCall aMethodCall:aMethodCalls) {
					MethodSNode aMethodSNode = getDeclarationOfCalledMethod(anSNode, aMethodCall);
					retVal = hasOperator(aMethodSNode, anOperator);
					if (retVal) {
						return retVal;
					}
					
				}
				return false;
			}
			
		}
		for (SNode aChild:anSNode.getChildren()) {
			retVal = hasOperator(aChild, anOperator);
			if (retVal) {
				return retVal;
			}
		}
		return false;
	}
	public static boolean dependsOn (AssignmentSNode anAssignmentSNode, String aVariable, String aCallIdentifier) {
		// This assignment does not change aVariable
		if (!aVariable.equals(anAssignmentSNode.getLhsFirstIdentifier())) {
			return false;
		}
		return dependsOn(anAssignmentSNode.getExpressionSNode(), aCallIdentifier);
//		List<String> aCallIdentifiers = anAssignmentSNode.getRhsCallIdentifiers();
//		boolean retVal = false;
//		if (aCallIdentifiers != null && aCallIdentifiers.contains(aCallIdentifier)) {
//			return true; // this assignment has aCallIdentifier in the rhs
//		}
//		// check if some referenced rhs variable depends on aCallIdentifier
//		List<String> aReferencedVariableIdentifiers = anAssignmentSNode.getRhsVariableIdentifiers();
//		SNode anAssignmentParent = anAssignmentSNode.getParent();
//		if (anAssignmentParent == null) { // should never be trye
//			return false;
//		}
//		int aLineNumber = anAssignmentSNode.getLineNumber();
//		for (String aReferencedVariableIdentifier:aReferencedVariableIdentifiers ) {
//			if (dependsOn (anAssignmentParent, aLineNumber, aReferencedVariableIdentifier, aCallIdentifier)) {
//				return true;
//			}
//		}
//		return false;
	}
	public static boolean dependsOn (ExpressionSNode anExpressionSNode, String aCallIdentifier) {
		// This assignment does not change aVariable
		
		List<String> aCallIdentifiers = anExpressionSNode.getRhsCallIdentifiers();
		boolean retVal = false;
		if (aCallIdentifiers != null && aCallIdentifiers.contains(aCallIdentifier)) {
			return true; // this assignment has aCallIdentifier in the rhs
		}
		// check if some referenced rhs variable depends on aCallIdentifier
		List<String> aReferencedVariableIdentifiers = anExpressionSNode.getRhsVariableIdentifiers();
		SNode anAssignmentParent = anExpressionSNode.getParent().getParent();
		if (anAssignmentParent == null) { // should never be trye
			return false;
		}
		int aLineNumber = anExpressionSNode.getLineNumber();
		for (String aReferencedVariableIdentifier:aReferencedVariableIdentifiers ) {
			if (dependsOn (anAssignmentParent, aLineNumber, aReferencedVariableIdentifier, aCallIdentifier)) {
				return true;
			}
		}
		return false;
	}
	public static Set<AssignmentSNode> assignmentsToSharedVariables(SNode anSNode) {
		Set<AssignmentSNode> retVal =  new HashSet();
		fillAssignmentsToShared(anSNode, retVal);
		return retVal;
		
	}
	public static Set<AssignmentSNode> assignmentsToSharedArrays(SNode anSNode) {
		Set<AssignmentSNode> anAllSharedAssignments =  assignmentsToSharedVariables(anSNode);
		Set<AssignmentSNode> aRetVal = new HashSet();
		for (AssignmentSNode anAssignmentSNode:anAllSharedAssignments) {
			if (anAssignmentSNode.getLhsSubscripts().length > 0) {
				aRetVal.add(anAssignmentSNode);
			}
		}
		return aRetVal;
		
	}
	public static Set<AssignmentSNode> assignmentsToParallelCriticalSharedVariables(SNode anSNode) {
		Set<AssignmentSNode> anAllSharedAssignments =  assignmentsToSharedVariables(anSNode);
		Set<AssignmentSNode> aRetVal = new HashSet();
		for (AssignmentSNode anAssignmentSNode:anAllSharedAssignments) {
			if (anAssignmentSNode.isInParallel() &&
					anAssignmentSNode.isInCritical()) {
				aRetVal.add(anAssignmentSNode);
			}
		}
		return aRetVal;
		
	}
	public static Set<AssignmentSNode> assignmentsToNonParallelCriticalSharedVariables(SNode anSNode) {
		Set<AssignmentSNode> anAllSharedAssignments =  assignmentsToSharedVariables(anSNode);
		Set<AssignmentSNode> aRetVal = new HashSet();
		for (AssignmentSNode anAssignmentSNode:anAllSharedAssignments) {
			if (!anAssignmentSNode.isInParallel() &&
					anAssignmentSNode.isInCritical()) {
				aRetVal.add(anAssignmentSNode);
			}
		}
		return aRetVal;
		
	}
	public static Set<AssignmentSNode> assignmentsToParallelNonCriticalSharedVariables(SNode anSNode) {
		Set<AssignmentSNode> anAllSharedAssignments =  assignmentsToSharedVariables(anSNode);
		Set<AssignmentSNode> aRetVal = new HashSet();
		for (AssignmentSNode anAssignmentSNode:anAllSharedAssignments) {
			if (anAssignmentSNode.isInParallel() &&
					!anAssignmentSNode.isInCritical()) {
				aRetVal.add(anAssignmentSNode);
			}
		}
		return aRetVal;
		
	}
    public static void fillAssignmentsToShared(SNode anSNode, Set<AssignmentSNode> retVal) {
    	if (anSNode instanceof AssignmentSNode) {
			AssignmentSNode anAssignmentSNode = (AssignmentSNode) anSNode;
			String anLHS = anAssignmentSNode.getLhsFirstIdentifier();
			if (isSharedVariable(anSNode, anLHS)) {
				retVal.add(anAssignmentSNode);
				return;
			}
		}
    	for (SNode aChild:anSNode.getChildren()) {
    		fillAssignmentsToShared(aChild, retVal);
    	}
		
	}
    public static void fillInstancesOfNodeType(Class<? extends SNode> aNodeType, SNode anSNode, Set<SNode> retVal) {
    	if (aNodeType.isAssignableFrom(anSNode.getClass())) {
			
				retVal.add(anSNode);
				return;
			}
		
    	for (SNode aChild:anSNode.getChildren()) {
    		fillInstancesOfNodeType(aNodeType, aChild, retVal);
    	}
		
	}
    public static Set<AssignmentSNode>  assignmentSNodes(SNode anSNode) {
    	Set retVal = new HashSet();    	
    	fillInstancesOfNodeType(AssignmentSNode.class, anSNode, retVal );
    	return retVal;
	}
   
    
    public static Set<OMPParallelSNode>  ompParallelSNodes(SNode anSNode) {
    	Set retVal = new HashSet();    	
    	fillInstancesOfNodeType(OMPParallelSNode.class, anSNode, retVal );
    	return retVal;
	}
//    public static void fillOMPParallelSNodes(SNode anSNode, Set<OMPParallelSNode> retVal) {
//    	if (anSNode instanceof OMPParallelSNode) {
//    		retVal.add((OMPParallelSNode) anSNode);
//		}
//    	for (SNode aChild:anSNode.getChildren()) {
//    		fillOMPParallelSNodes(aChild, retVal);
//    	}		
//	}
    public static Set<ForSNode>  forSNodes(SNode anSNode) {
    	Set retVal = new HashSet();    	
    	fillInstancesOfNodeType(ForSNode.class, anSNode, retVal );
    	return retVal;
	}
//    public static void fillForSNodes(SNode anSNode, Set<ForSNode> retVal) {
//    	if (anSNode instanceof ForSNode) {
//    		retVal.add((ForSNode) anSNode);
//		}
//    	for (SNode aChild:anSNode.getChildren()) {
//    		fillForSNodes(aChild, retVal);
//    	}		
//	}
    public static Set<OMPForSNode>  ompForSNodes(SNode anSNode) {
    	Set retVal = new HashSet();    	
    	fillInstancesOfNodeType(OMPForSNode.class, anSNode, retVal );
    	return retVal;
	}
//    public static void fillOMPForSNodes(SNode anSNode, Set<OMPForSNode> retVal) {
//    	if (anSNode instanceof OMPForSNode) {
//    		retVal.add((OMPForSNode) anSNode);
//		}
//    	for (SNode aChild:anSNode.getChildren()) {
//    		fillOMPForSNodes(aChild, retVal);
//    	}		
//	}
    public static Set<OMPForSNode> ompReducingForNodes(SNode anSNode) {
		Set<OMPForSNode> anAllOMPForSNodes =  ompForSNodes(anSNode);
		Set<OMPForSNode> aRetVal = new HashSet();
		for (OMPForSNode anOMPForSNode:anAllOMPForSNodes) {
			if (anOMPForSNode.getReductionOperation() != null) {
				aRetVal.add(anOMPForSNode);
			}
		}
		return aRetVal;		
	}
    public static Set<AssignmentSNode> assignmentsToOMPReducingForNode(OMPForSNode anOMPForSNode) {
    	String aReductionVariable = anOMPForSNode.getReductionVariable();
    	return directAssignmentsOfVariableAndItsAliases(anOMPForSNode, aReductionVariable)	;
    	
    }
	public static boolean dependsOn (SNode anSNode, int aVariableLineNumber, String aVariable, String aCallIdentifier) {
		List<SNode> aListSNodes = anSNode.getChildren();
		boolean retVal = false;
		/*
		 * Should probably ignore line number as it assumes straight line code
		 */
		for (int i = aVariableLineNumber; i >= 0; i--) {
			SNode anSNodeChild = aListSNodes.get(i);
			if (anSNodeChild instanceof AssignmentSNode) {
				// does this statement in anSNode directly invoke aCallIdentifier 
				if (dependsOn((AssignmentSNode) anSNodeChild, aVariable, aCallIdentifier))
					return true;
			} else if (!anSNode.isLeaf()) {
					// child is overriding the variable so forget checking its assignment statements
					if (anSNodeChild.getLocalVariableIdentifiers().contains(aVariable)) {
						continue;
					}
					// some subblock of anSNode that has access to aVariable changes variable

					if (dependsOn(anSNodeChild, anSNodeChild.getChildren().size() - 1, aVariable, aCallIdentifier)) {
						return true;
					}
			}
			
		}
		// none of the statements in anSNode or its descendents  have the required call
		// is the variable a  method parameter 
		if (anSNode instanceof MethodSNode) {
			MethodSNode aMethodSNode = (MethodSNode) anSNode;
			
			int aParameterNumber = aMethodSNode.getLocalVariableIdentifiers().indexOf(aVariable);
			if (aParameterNumber != -1) {
				List <MethodCall> aCalls = aMethodSNode.getCalls();
				for (MethodCall aCall:aCalls) {
//					if (!aCall.getMethodActuals().contains(aVariable))
//						continue;
//					
					MethodSNode aCallerSNode = getDeclarationOfCalledMethod(aMethodSNode, aCall);
					if (dependsOn(aMethodSNode, aCallerSNode.getLineNumber(), aCallerSNode.getLocalVariableIdentifiers().get(aParameterNumber), aCallIdentifier));
//				    if (aCallerDepends) {
				    	return true;
//				    }
				}
				return false;
				// need to find all callers of method and see if any of the aliases for the variable in these
				// calls depend on aCallIndentifier
			}			
			
		} else if (anSNode.getLocalVariableIdentifiers().contains(aVariable)) {
			// before going to the parent node, let us see if aVariable is declared here as a non  parameter 

			return false; // no point going to parent
		}
		// not a local variable (parameter or declarated variable)
		SNode anSNodeParent = anSNode.getParent() ;
		if (anSNodeParent == null)  {
			return false;
		}
		int anSNodeLineNumber = anSNodeParent.getChildren().indexOf(anSNode);
		return dependsOn(anSNodeParent, anSNodeLineNumber, aVariable, aCallIdentifier);
		
	}
	public static Set<AssignmentSNode> assignmentsOfVariableAliases (SNode anSNode,  String aVariable) {
		Set<AssignmentSNode> retVal = new HashSet();
		fillDirectAssignmentsOfVariableAliases(anSNode, aVariable, retVal);
		return retVal;
	}
	public static void fillDirectAssignmentsOfVariableAliases (SNode anSNode,  String aVariable, Set<AssignmentSNode> retVal) {
		if (anSNode instanceof MethodCall) {
			MethodCall aMethodCall = (MethodCall) anSNode;
			int aParameterNumber = aMethodCall.getMethodActualIdentifiers().indexOf(aVariable);
			if (aParameterNumber < 0) {
				return;
			}
			MethodSNode aDeclaringMethodSNode = getDeclarationOfCalledMethod(anSNode, aMethodCall);
			String aFormalParameter = aDeclaringMethodSNode.getLocalVariableIdentifiers().get(aParameterNumber);
//			Set<AssignmentSNode> aCallAssignments = ;
			fillDirectAssignmentsOfVariableAliases(aDeclaringMethodSNode, aFormalParameter, retVal);
		} else if (anSNode instanceof MethodSNode)	{
			MethodSNode aMethodSNode = (MethodSNode) anSNode;
			int aParameterNumber = aMethodSNode.getLocalVariableIdentifiers().indexOf(aVariable);
			if (aParameterNumber < 0)
				return;
			List<MethodCall> aCalls = aMethodSNode.getCalls();
			for (MethodCall aMethodCall:aCalls) {
				MethodSNode aCallerMethodSNode = getDeclarationOfCalledMethod(anSNode, aMethodCall);
				if (aCallerMethodSNode != null) {
					String anAlias = aCallerMethodSNode.getLocalVariableIdentifiers().get(aParameterNumber);
					fillDirectAssignmentsOfVariableAliases(aCallerMethodSNode, anAlias, retVal);

				}

			}
		}
		
		else {
			List<SNode> aChildren = anSNode.getChildren();
			for (SNode aChild:aChildren) {
				fillDirectAssignmentsOfVariableAliases(aChild, aVariable, retVal);
			}
		} 	
		
	}
	
	/*
	 * will not consider assignments to variables in the RHS of these assignments
	 */
	public static Set<AssignmentSNode> directAssignmentsOfVariableAndItsAliases (SNode anSNode,  String aVariable) {
		Set<AssignmentSNode> retVal = new HashSet();
		fillDirectAssignmentsOfVariableAndItsAliases(anSNode, aVariable, retVal);
		return retVal;
	}
	
//	public static Set<AssignmentSNode> assignmentsEffectingVariableAndItsAliases (SNode anSNode,  String aVariable) {
//		Set<AssignmentSNode> retVal = directAssignmentsOfVariableAndItsAliases(anSNode, aVariable);
//		
//	}
	public static void fillDirectAssignmentsOfVariableAndItsAliases (SNode anSNode,  String aVariable, Set<AssignmentSNode> retVal) {
		if (anSNode instanceof AssignmentSNode) {
			AssignmentSNode anAssignmentSNode = (AssignmentSNode) anSNode;
			if (anAssignmentSNode.getLhsFirstIdentifier().equals(aVariable)) {
				retVal.add(anAssignmentSNode);
			}
		}
		
		else if (anSNode instanceof MethodCall) {
			MethodCall aMethodCall = (MethodCall) anSNode;
			int aParameterNumber = aMethodCall.getMethodActualIdentifiers().indexOf(aVariable);
			if (aParameterNumber < 0) {
				return;
			}
			MethodSNode aDeclaringMethodSNode = getDeclarationOfCalledMethod(anSNode, aMethodCall);
			String aFormalParameter = aDeclaringMethodSNode.getLocalVariableIdentifiers().get(aParameterNumber);
//			Set<AssignmentSNode> aCallAssignments = ;
			fillDirectAssignmentsOfVariableAndItsAliases(aDeclaringMethodSNode, aFormalParameter, retVal);
		} else {
			List<SNode> aChildren = anSNode.getChildren();
			for (SNode aChild:aChildren) {
				fillDirectAssignmentsOfVariableAndItsAliases(aChild, aVariable, retVal);
			}
		}		
		
	}
	
	public static RootOfFileSNode getRootOfFileNode(SNode aCurrentSNode ) {
		if (aCurrentSNode instanceof RootOfFileSNode) {
			return (RootOfFileSNode) aCurrentSNode;
		}
		SNode aParentSNode = aCurrentSNode.getParent() ;
		
		if (aParentSNode == null) {
			return null;
		}
		
		return getRootOfFileNode(aParentSNode);
		
	}
	public static boolean match (MethodSNode aMethodSNode, MethodCall aMethodCall) {
		return aMethodSNode.getMethodName().equals(aMethodCall.getMethodName()) 
				&& aMethodSNode.getLocalVariableIdentifiers().size() == aMethodCall.getMethodActuals().size();
	}
	public static DeclarationSNode getDeclarationOfVariableIdentifier(SNode aCurrentSNode, String anIdentifier) {
		if (aCurrentSNode == null) {
			return null;
		}
		
		
		int anIndex = aCurrentSNode.getLocalVariableIdentifiers().indexOf(anIdentifier);
		if (anIndex < 0) {
			return getDeclarationOfVariableIdentifier(aCurrentSNode.getParent(), anIdentifier);
		}
		DeclarationSNode retVal = aCurrentSNode.getVariableDeclarations().get(anIndex);
//		retVal.getAssignmentsToDeclaredVariable().add(anAssignmentSNode);
//		anAssignmentSNode.setLhsFirstIdentifierDeclaration(retVal);
		return retVal;
	}
	
	public static DeclarationSNode getDeclarationOfAssignedVariable(SNode aCurrentSNode, AssignmentSNode anAssignmentSNode) {
		if (aCurrentSNode == null) {
			return null;
		}
		if (anAssignmentSNode instanceof ADeclaringAssignmentSNode) {
			return (ADeclaringAssignmentSNode) anAssignmentSNode;
		}
		int anIndex = aCurrentSNode.getLocalVariableIdentifiers().indexOf(anAssignmentSNode.getLhsFirstIdentifier());
		if (anIndex < 0) {
			return getDeclarationOfAssignedVariable(aCurrentSNode.getParent(), anAssignmentSNode);
		}
		DeclarationSNode retVal = aCurrentSNode.getVariableDeclarations().get(anIndex);
//		retVal.getAssignmentsToDeclaredVariable().add(anAssignmentSNode);
//		anAssignmentSNode.setLhsFirstIdentifierDeclaration(retVal);
		return retVal;
	}
	
	public static MethodSNode getDeclarationOfCalledMethod(SNode aCurrentSNode, MethodCall aMethodCall ) {
		SNode aRootNode = getRootOfFileNode(aCurrentSNode);
		for (SNode aChild:aRootNode.getChildren()) {
			if (aChild instanceof MethodSNode) {
				MethodSNode aMethodSNode = (MethodSNode) aChild;
				if (match (aMethodSNode, aMethodCall)) {
					return aMethodSNode;
				}
			}
		}
		return null; // this should never happen;
	}
	
	public static RootOfProgramSNode getRootOfProgramSNode(String aSource) {
		RootOfProgramSNode retVal = new ARootOfProgramSNode();
		Map<String, StringBuffer> aFileNameToContents = ABasicTextManager.extractFileContents(aSource);
		for (String aFileName:aFileNameToContents.keySet()) {
			StringBuffer aFileContents = aFileNameToContents.get(aFileName);
//			List<OpenMPPragma> anOpenMPPragmas = OpenMPUtils.getOpemMPPragmas(aFileContents);
			RootOfFileSNode anSNode = OMPSNodeUtils.getSNode(aFileName, aFileContents);
			retVal.getFileNameToSNode().put(aFileName, anSNode);
			anSNode.setParent(retVal);
//			System.out.println("file name:" + aFileName);
//			System.out.println("pragmas:" + anSNode);
		}
		processExternalMethodSNodes(retVal);
		setParentOfParameterDeclarations(retVal);
		processIndirectAssignments(retVal);
		return retVal;
	}
//	public static void processIndirectAssignments (S aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode) {
//		for (SNode anSNode:aRootOfFileSNode.getChildren()) {
//			-----
//		}
//	}
	public static void setParentOfParameterDeclarations(RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode) {
		for (SNode anSNode:aRootOfFileSNode.getChildren()) {
			if (anSNode instanceof MethodSNode) {
				setParentOfParameterDeclarations(aRootOfProgramSNode, aRootOfFileSNode, (MethodSNode) anSNode);
			}
		}
	}
	public static void setParentOfParameterDeclarations (RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode, MethodSNode aMethodSNode) {
		List<DeclarationSNode> aDeclarations = aMethodSNode.getVariableDeclarations();
		for (DeclarationSNode aDeclaration:aDeclarations) {
			if (aDeclaration.getParent() == null) {
				aDeclaration.setParent(aMethodSNode);
			}
		}
	}
	public static void setParentOfParameterDeclarations (RootOfProgramSNode aRootOfProgramSNode) {
		for (String aFileName:aRootOfProgramSNode.getFileNameToSNode().keySet()) {
			RootOfFileSNode aRootOfFileSNode = aRootOfProgramSNode.getFileNameToSNode().get(aFileName);
			setParentOfParameterDeclarations(aRootOfProgramSNode, aRootOfFileSNode);
			
		}

	}
	public static void processExternalMethodSNodes (RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode) {
		for (SNode anSNode:aRootOfFileSNode.getChildren()) {
			if (anSNode instanceof ExternalMethodSNode) {
				processExternalMethodSNode(aRootOfProgramSNode, aRootOfFileSNode, (ExternalMethodSNode) anSNode);
			}
		}
	}

	public static void processExternalMethodSNode (RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode, ExternalMethodSNode anExternalMethodSNode) {
		MethodSNode aMethodSNode = aRootOfProgramSNode.getExternalToInternalMethod().get(anExternalMethodSNode.toString());
		if (aMethodSNode == null) {
			aMethodSNode = findMethodSNode(aRootOfProgramSNode, aRootOfFileSNode, anExternalMethodSNode);
			if (aMethodSNode != null) {
				aRootOfProgramSNode.getExternalToInternalMethod().put(anExternalMethodSNode.toString(),aMethodSNode );
			}
		}
		if (aMethodSNode != null) {
			anExternalMethodSNode.setActualMethodSNode(aMethodSNode);
			aMethodSNode.getCalls().addAll(anExternalMethodSNode.getLocalCalls());
		}
	}
	
	public static MethodSNode findMethodSNode (RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode, ExternalMethodSNode anExternalMethodSNode) {
//		MethodSNode foundMethodSNode = null;
		for (String aFileName:aRootOfProgramSNode.getFileNameToSNode().keySet()) {
			if (aFileName.equals(aRootOfFileSNode.getFileName()))
				continue;
			
			RootOfFileSNode aSearchedRootOfFileSNode = aRootOfProgramSNode.getFileNameToSNode().get(aFileName);
			 for (SNode anSNode:aSearchedRootOfFileSNode.getChildren()) {
				if (anSNode instanceof MethodSNode && !(anSNode instanceof ExternalMethodSNode)) {
					if (anSNode.toString().equals(anExternalMethodSNode.toString())) {
						return (MethodSNode) anSNode;
						
					}
//					processExternalMethodSNode(aRootOfProgramSNode, aRootOfFileSNode, (ExternalMethodSNode) anSNode);
				}
			}
		}
		return null;
	}
	public static void processExternalMethodSNodes (RootOfProgramSNode aRootOfProgramSNode) {
		for (String aFileName:aRootOfProgramSNode.getFileNameToSNode().keySet()) {
			RootOfFileSNode aRootOfFileSNode = aRootOfProgramSNode.getFileNameToSNode().get(aFileName);
			processExternalMethodSNodes(aRootOfProgramSNode, aRootOfFileSNode);
			aRootOfFileSNode.getOmp_get_num_threads_SNode().
				setActualMethodSNode(aRootOfProgramSNode.getOmp_get_num_threads_SNode());
			aRootOfFileSNode.getOmp_get_thread_num_SNode().
				setActualMethodSNode(aRootOfProgramSNode.getOmp_get_thread_num_SNode());
			aRootOfFileSNode.getOmp_get_wtime_SNode().
			setActualMethodSNode(aRootOfProgramSNode.getOmp_get_wtime_SNode());
		}

	}
	public static void processIndirectAssignments (SNode anSNode) {
		if (anSNode instanceof ConstDeclarationSNode) {
			return;
		}
		if (anSNode instanceof DeclarationSNode) {
			DeclarationSNode aDeclarationSNode = (DeclarationSNode) anSNode;
			Set<AssignmentSNode> anIndirectAssignments = aDeclarationSNode.getAssignmentsEffectingDeclaredIdentifier();
			if (anIndirectAssignments != null) {
				return; // already assigned
			}
			anIndirectAssignments = new HashSet<>();
			aDeclarationSNode.setAssignmentsEffectingDeclaredIdentifier(anIndirectAssignments);
			Set<AssignmentSNode> aDirectAssignments = aDeclarationSNode.getAssignmentsToDeclaredVariable();
			anIndirectAssignments.addAll(aDirectAssignments);
			Set<AssignmentSNode> anAliasAssignments = assignmentsOfVariableAliases(aDeclarationSNode.getParent(), aDeclarationSNode.getVariableName());
			anIndirectAssignments.addAll(anAliasAssignments);
			for (AssignmentSNode aDirectAssignment:aDirectAssignments) {
				List<String> aVariableIdentifiers = aDirectAssignment.getRhsVariableIdentifiers();
				
				for (String aVariableIdentifier:aVariableIdentifiers) {
					DeclarationSNode aDependeeDeclarationSNode = getDeclarationOfVariableIdentifier(aDirectAssignment, aVariableIdentifier);
					if (aDependeeDeclarationSNode == null) {
						System.err.println("Could not find declaration of:" + aVariableIdentifier + " referenced in:" + aDirectAssignment );
						continue;
					}
					processIndirectAssignments(aDependeeDeclarationSNode);
					Set<AssignmentSNode> aDependeeIndirectAssignments = aDeclarationSNode.getAssignmentsEffectingDeclaredIdentifier();
					anIndirectAssignments.addAll(aDependeeIndirectAssignments);
					
				}
			}
		} else {
			for (SNode aChild: anSNode.getChildren()) {
				processIndirectAssignments(aChild);
			}
		}
		
	}
	
//	public static void fillIndirectAssignments (SNode anSNode, Set<AssignmentSNode> retVal ) {
//		
//	}
	

//	public static void main(String[] args) {
//		List<MethodCall> aTokens = callsIn("foo(bar, hgf)/foo2()*foo3(b, a c,)");
//		System.out.println(aTokens);
//		
//		
////		List<String> aTokens = identifiersIn("a[i] + b*2/3");
////		System.out.println(aTokens);
////		aTokens = numbersIn("a[i] + b*2/3");
////		System.out.println(aTokens);
////		aTokens = operatorsIn("a[i] + b*2/3");
////		System.out.println(aTokens);
////
////		System.out.println(StringUtils.substringBetween("a", "[", "]"));
//	}

}
]]></snapshot>
  </Command>
  <DocumentChange __id="221998" _type="Insert" date="Fri Jan 10 14:08:34 EST 2020" docASTNodeCount="5337" docActiveCodeLength="39440" docExpressionCount="3291" docLength="45703" length="2" offset="43939" starttimestamp="1576666505112" timestamp="2016809463">
    <text><![CDATA[//]]></text>
  </DocumentChange>
  <DocumentChange __id="221999" _type="Insert" date="Fri Jan 10 14:08:34 EST 2020" docASTNodeCount="5332" docActiveCodeLength="39388" docExpressionCount="3287" docLength="45705" length="2" offset="44085" starttimestamp="1576666505112" timestamp="2016809479">
    <text><![CDATA[//]]></text>
  </DocumentChange>
  <Command __id="222048" _type="RunCommand" date="Fri Jan 10 14:11:26 EST 2020" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="2016981138" type="Run" />
  <Command __id="222049" _type="RunCommand" date="Fri Jan 10 14:11:26 EST 2020" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="2016981203" type="Debug" />
  <Command __id="222050" _type="RunCommand" date="Fri Jan 10 14:11:26 EST 2020" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="2016981207" type="Run" />
  <Command __id="222051" _type="RunCommand" date="Fri Jan 10 14:11:26 EST 2020" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="2016981211" type="Debug" />
  <Command __id="222052" _type="RunCommand" date="Fri Jan 10 14:11:26 EST 2020" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="2016981214" type="Run" />
  <Command __id="222053" _type="EHExceptionCommand" date="Fri Jan 10 14:11:26 EST 2020" starttimestamp="1576666505112" timestamp="2016981602" type="Exception">
    <outputString><![CDATA[sum_sequential
Sum: 499500
Took: 0
thread:0 lastIndex:999
_____________________________
sum_parallel_for_reduction
Sum: 499500
Took: 0
thread:0 lastIndex:124
thread:1 lastIndex:249
thread:2 lastIndex:374
thread:3 lastIndex:499
thread:4 lastIndex:624
thread:5 lastIndex:749
thread:6 lastIndex:874
thread:7 lastIndex:999
_____________________________
sum_parallel_for_local_var
Sum: 499500
Took: 0
thread:0 lastIndex:124
thread:1 lastIndex:249
thread:2 lastIndex:374
thread:3 lastIndex:499
thread:4 lastIndex:624
thread:5 lastIndex:749
thread:6 lastIndex:874
thread:7 lastIndex:999
_____________________________
sum_parallel
Sum: 499500
Took: 0
_____________________________
]]></outputString>
  </Command>
  <Command __id="222054" _type="DiffBasedFileOpenCommand" date="Fri Jan 10 14:11:36 EST 2020" docASTNodeCount="1" docActiveCodeLength="1642" docExpressionCount="0" docLength="1924" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="2016991786">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\my_sum_main.cpp]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"#include <iostream>¶#include <omp.h>¶¶using namespace std;¶//need to declare headers of external functions called¶void sum_sequential(double* array, int size);¶void sum_parallel_for_reduction(double* array, int size);¶void sum_parallel(double* array, int size);¶void sum_parallel_for_local_var(double* array, int size);¶¶// if this main is used to call functions to do other computations¶// then those headers should also be declared here¶¶const int SIZE = 1000;¶void initArray (double* array, int size ) {¶	for(int i = 0; i < size; i++)¶			array[i]=i;¶}¶/**¶ * Called by each of the summing alternatives¶ */¶void printSumWithTimes (int sum, int start, int end) {¶	cout << "Sum: " << sum << endl;¶	cout << "Took: " << end - start << endl;¶}¶void printNumThreads() {¶	cout << "threads:" << omp_get_num_threads() << endl;¶}¶/**¶ * an array to learn how much concurrency occcurred¶ */¶int MAX_THREADS = 100;¶double* threadsLastIndex = new double[MAX_THREADS];¶int numThreads;¶¶¶void recordThreadIndex(int index) {¶	int thread =  omp_get_thread_num();¶	if (thread >= MAX_THREADS) {¶		return;¶	}¶	threadsLastIndex[thread] = index;¶	numThreads = omp_get_num_threads();¶}¶void initThreadRecording() {¶	numThreads = 0;¶	for (int i = 0; i < MAX_THREADS; i++) {¶		threadsLastIndex[i] = -1;¶	}¶}¶¶void printThreadLastIndex() {¶	for (int i = 0; i < numThreads; i++) {¶		cout << "thread:" << i << " lastIndex:" << threadsLastIndex[i] << endl;¶	}¶	cout << "_____________________________" << endl;¶}¶¶¶int main()¶{¶	double* array = new double[SIZE];¶	initArray(array, SIZE);¶	initThreadRecording();¶	sum_sequential(array, SIZE);¶	printThreadLastIndex();¶	initThreadRecording();¶	sum_parallel_for_reduction(array, SIZE);¶	printThreadLastIndex();¶	initThreadRecording();¶	sum_parallel_for_local_var(array, SIZE);¶	printThreadLastIndex();¶	initThreadRecording();¶	sum_parallel(array, SIZE);¶	printThreadLastIndex();¶	initThreadRecording();¶}¶")]]]></diff>
  </Command>
  <Command __id="222055" _type="MoveCaretCommand" caretOffset="1500" date="Fri Jan 10 14:11:37 EST 2020" docOffset="1500" starttimestamp="1576666505112" timestamp="2016992321" />
  <Command __id="222056" _type="DiffBasedFileOpenCommand" date="Fri Jan 10 14:11:53 EST 2020" docASTNodeCount="1" docActiveCodeLength="659" docExpressionCount="0" docLength="747" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="2017008726">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\my_sum_parallel_for_local_var.cpp]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"#include <iostream>¶#include <omp.h>¶¶using namespace std;¶¶void printSumWithTimes (int sum, int start, int end);¶void printNumThreads();¶void recordThreadIndex(int index);¶void sum_parallel_for_local_var(double* array, int size)¶{¶	cout << "sum_parallel_for_local_var\n";¶¶	double start = omp_get_wtime();¶¶	double sum = 0;¶¶	int a, b;¶//¶//	for (int i = 0; i < size; i++) {¶//			sum += array[i];¶//			recordThreadIndex(i);¶//	}¶¶    #pragma omp parallel shared (sum, start) private (a, b)¶	{¶		double local_sum = 0;¶¶		#pragma omp for¶		for(int i = 0; i < size; i++) {¶			local_sum += array[i];¶			recordThreadIndex(i);¶		}¶¶		#pragma omp critical¶		sum += local_sum;¶	}¶¶	double end = omp_get_wtime();¶¶	printSumWithTimes(sum, start, end);¶	¶}¶")]]]></diff>
  </Command>
  <Command __id="222057" _type="MoveCaretCommand" caretOffset="621" date="Fri Jan 10 14:11:54 EST 2020" docOffset="621" starttimestamp="1576666505112" timestamp="2017009098" />
  <Command __id="222058" _type="DiffBasedFileOpenCommand" date="Fri Jan 10 14:12:54 EST 2020" docASTNodeCount="1" docActiveCodeLength="602" docExpressionCount="0" docLength="709" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="2017069579">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\my_sum_parallel_for_reduction.cpp]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"#include <iostream>¶#include <omp.h>¶¶using namespace std;¶¶//const int SIZE = 1000;¶void printSumWithTimes(int sum, int start, int end);¶void printNumThreads();¶void recordThreadIndex(int index);¶"), Diff(INSERT,"void add(double *p, int anIncrement) {¶	*p += anIncrement;¶}¶"), Diff(EQUAL,"void sum_parallel_for_reduction(double* array, int size) {¶	cout << "sum_parallel_for_reduction\n";¶¶	double start = omp_get_wtime();¶¶	double sum = 0;¶    #pragma omp  parallel for reduction ( + : sum )¶//    #pragma omp  for reduction ( + : sum )¶¶//	#pragma omp  for¶¶	for (int i = 0; i < size; i++) {¶"), Diff(INSERT,"//"), Diff(EQUAL,"		sum += array[i];¶"), Diff(INSERT,"		add(& sum, array[i] );"), Diff(EQUAL,"¶		recordThreadIndex(i);¶	}¶¶	double end = omp_get_wtime();¶¶	printSumWithTimes(sum, start, end);¶¶}¶")]]]></diff>
    <snapshot><![CDATA[#include <iostream>
#include <omp.h>

using namespace std;

//const int SIZE = 1000;
void printSumWithTimes(int sum, int start, int end);
void printNumThreads();
void recordThreadIndex(int index);
void add(double *p, int anIncrement) {
	*p += anIncrement;
}
void sum_parallel_for_reduction(double* array, int size) {
	cout << "sum_parallel_for_reduction\n";

	double start = omp_get_wtime();

	double sum = 0;
    #pragma omp  parallel for reduction ( + : sum )
//    #pragma omp  for reduction ( + : sum )

//	#pragma omp  for

	for (int i = 0; i < size; i++) {
//		sum += array[i];
		add(& sum, array[i] );
		recordThreadIndex(i);
	}

	double end = omp_get_wtime();

	printSumWithTimes(sum, start, end);

}
]]></snapshot>
  </Command>
  <Command __id="222059" _type="MoveCaretCommand" caretOffset="506" date="Fri Jan 10 14:12:54 EST 2020" docOffset="506" starttimestamp="1576666505112" timestamp="2017069881" />
  <Command __id="222060" _type="DiffBasedFileOpenCommand" date="Fri Jan 10 14:13:22 EST 2020" docASTNodeCount="1" docActiveCodeLength="795" docExpressionCount="0" docLength="795" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="2017097204">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\my_sum_parallel.cpp]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"#include <iostream>¶#include <omp.h>¶¶using namespace std;¶¶void printSumWithTimes(int sum, int start, int end);¶void printNumThreads();¶void recordThreadIndex(int index);¶void sum_parallel(double* array, int size) {¶	cout << "sum_parallel\n";¶¶	double start = omp_get_wtime();¶¶	double sum = 0;¶¶¶    #pragma omp critical¶	{¶	double sum = 0;¶	}¶    #pragma omp parallel¶	{¶		double local_sum = 0;¶¶		int rank = omp_get_thread_num();¶		int threads = omp_get_num_threads();¶¶		int start_index = (size/threads)*rank;¶		int end_index = (size/threads)*(rank+1);¶¶		if(rank==threads-1)¶			end_index=size;¶¶		for(int i = start_index; i < end_index; i++)¶			local_sum += array[i];¶¶		#pragma omp critical¶		sum += local_sum;¶	}¶¶	double end = omp_get_wtime();¶¶	printSumWithTimes(sum, start, end);¶¶¶}¶")]]]></diff>
  </Command>
  <Command __id="222061" _type="MoveCaretCommand" caretOffset="297" date="Fri Jan 10 14:13:22 EST 2020" docOffset="297" starttimestamp="1576666505112" timestamp="2017097628" />
  <Command __id="222063" _type="SelectTextCommand" caretOffset="280" date="Fri Jan 10 14:13:45 EST 2020" end="280" start="265" starttimestamp="1576666505112" timestamp="2017120711" />
</Events>
