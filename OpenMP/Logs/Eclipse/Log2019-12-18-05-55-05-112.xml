<Events startTimestamp="1576666505112" logVersion="1.0.0.201911281918">
  <Command __id="23357" _type="EclipseCommand" commandID="org.eclipse.ui.file.save" date="Fri Dec 20 08:54:26 EST 2019" starttimestamp="1576666505112" timestamp="183561304" />
  <DocumentChange __id="23414" _type="Insert" date="Fri Dec 20 08:57:09 EST 2019" docASTNodeCount="184" docActiveCodeLength="1396" docExpressionCount="142" docLength="1591" length="2" offset="929" starttimestamp="1576666505112" timestamp="183724722">
    <text><![CDATA[//]]></text>
  </DocumentChange>
  <DocumentChange __id="23415" _type="Insert" date="Fri Dec 20 08:57:09 EST 2019" docASTNodeCount="179" docActiveCodeLength="1337" docExpressionCount="138" docLength="1593" length="2" offset="959" starttimestamp="1576666505112" timestamp="183724724">
    <text><![CDATA[//]]></text>
  </DocumentChange>
  <Command __id="23426" _type="ShellCommand" date="Fri Dec 20 08:58:09 EST 2019" starttimestamp="1576666505112" timestamp="183784155" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="23428" _type="MoveCaretCommand" caretOffset="0" date="Fri Dec 20 08:58:41 EST 2019" docOffset="0" starttimestamp="1576666505112" timestamp="183816516" />
  <Command __id="23429" _type="MoveCaretCommand" caretOffset="394" date="Fri Dec 20 08:58:49 EST 2019" docOffset="394" starttimestamp="1576666505112" timestamp="183823914" />
  <Command __id="23430" _type="ShellCommand" date="Fri Dec 20 08:58:57 EST 2019" starttimestamp="1576666505112" timestamp="183832144" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="23431" _type="ShellCommand" date="Fri Dec 20 08:59:00 EST 2019" starttimestamp="1576666505112" timestamp="183835589" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="23432" _type="ShellCommand" date="Fri Dec 20 08:59:02 EST 2019" starttimestamp="1576666505112" timestamp="183837380" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="23427" _type="DiffBasedFileOpenCommand" date="Fri Dec 20 08:58:41 EST 2019" docASTNodeCount="1" docActiveCodeLength="496" docExpressionCount="0" docLength="520" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="183816195">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\sum_parallel_for_reduction.cpp]]></filePath>
    <diff><![CDATA[null]]></diff>
    <snapshot><![CDATA[#include <iostream>
#include <omp.h>

using namespace std;

//const int SIZE = 1000;
void printSumWithTimes(int sum, int start, int end);
void printNumThreads();
void recordThreadIndex(int index);
void sum_parallel_for_reduction(double* array, int size) {
	cout << "sum_parallel_for_reduction\n";

	double start = omp_get_wtime();

	double sum = 0;
    #pragma omp parallel for reduction(+:sum)

	for (int i = 0; i < size; i++)
		sum += array[i];

	double end = omp_get_wtime();

	printSumWithTimes(sum, start, end);

}
]]></snapshot>
  </Command>
  <Command __id="23433" _type="ShellCommand" date="Fri Dec 20 08:59:24 EST 2019" starttimestamp="1576666505112" timestamp="183859785" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="23435" _type="MoveCaretCommand" caretOffset="0" date="Fri Dec 20 08:59:32 EST 2019" docOffset="0" starttimestamp="1576666505112" timestamp="183867015" />
  <Command __id="23434" _type="DiffBasedFileOpenCommand" date="Fri Dec 20 08:59:31 EST 2019" docASTNodeCount="1" docActiveCodeLength="422" docExpressionCount="0" docLength="422" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="183866862">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\sum_parallel.cpp]]></filePath>
    <diff><![CDATA[null]]></diff>
    <snapshot><![CDATA[#include <iostream>
#include <omp.h>

using namespace std;

void printSumWithTimes(int sum, int start, int end);
void printNumThreads();
void recordThreadIndex(int index);
void sum_parallel(double* array, int size) {
	cout << "sum_parallel\n";

	double start = omp_get_wtime();

	double sum = 0;

	for (int i = 0; i < size; i++)
		sum += array[i];

	double end = omp_get_wtime();

	printSumWithTimes(sum, start, end);


}
]]></snapshot>
  </Command>
  <Command __id="23436" _type="MoveCaretCommand" caretOffset="296" date="Fri Dec 20 08:59:46 EST 2019" docOffset="296" starttimestamp="1576666505112" timestamp="183881637" />
  <Command __id="23438" _type="PasteCommand" date="Fri Dec 20 08:59:48 EST 2019" starttimestamp="1576666505112" timestamp="183883011" />
  <Command __id="23439" _type="MoveCaretCommand" caretOffset="296" date="Fri Dec 20 08:59:50 EST 2019" docOffset="296" starttimestamp="1576666505112" timestamp="183884925" />
  <Command __id="23441" _type="InsertStringCommand" date="Fri Dec 20 08:59:50 EST 2019" starttimestamp="1576666505112" timestamp="183885756" timestamp2="183885756">
    <data><![CDATA[	]]></data>
  </Command>
  <DocumentChange __id="23437" _type="Insert" date="Fri Dec 20 08:59:48 EST 2019" docASTNodeCount="1" docActiveCodeLength="443" docExpressionCount="0" docLength="443" length="21" offset="296" starttimestamp="1576666505112" timestamp="183883002">
    <text><![CDATA[#pragma omp parallel
]]></text>
  </DocumentChange>
  <DocumentChange __id="23440" _type="Insert" date="Fri Dec 20 08:59:50 EST 2019" docASTNodeCount="1" docActiveCodeLength="444" docExpressionCount="0" docLength="444" length="1" offset="296" starttimestamp="1576666505112" timestamp="183885744">
    <text><![CDATA[	]]></text>
  </DocumentChange>
  <Command __id="23442" _type="MoveCaretCommand" caretOffset="317" date="Fri Dec 20 08:59:52 EST 2019" docOffset="317" starttimestamp="1576666505112" timestamp="183887394" />
  <Command __id="23444" _type="EclipseCommand" commandID="org.eclipse.ui.edit.delete" date="Fri Dec 20 08:59:53 EST 2019" starttimestamp="1576666505112" timestamp="183888452" />
  <DocumentChange __id="23443" _type="Delete" date="Fri Dec 20 08:59:53 EST 2019" docASTNodeCount="1" docActiveCodeLength="443" docExpressionCount="0" docLength="443" endLine="15" length="1" offset="317" startLine="14" starttimestamp="1576666505112" timestamp="183888443">
    <text><![CDATA[
]]></text>
  </DocumentChange>
  <DocumentChange __id="23446" _type="Insert" date="Fri Dec 20 08:59:56 EST 2019" docASTNodeCount="1" docActiveCodeLength="445" docExpressionCount="0" docLength="445" length="2" offset="295" starttimestamp="1576666505112" timestamp="183891269">
    <text><![CDATA[
	]]></text>
  </DocumentChange>
  <Command __id="23445" _type="MoveCaretCommand" caretOffset="295" date="Fri Dec 20 08:59:55 EST 2019" docOffset="295" starttimestamp="1576666505112" timestamp="183890398" />
  <Command __id="23447" _type="InsertStringCommand" date="Fri Dec 20 08:59:56 EST 2019" starttimestamp="1576666505112" timestamp="183891276" timestamp2="183891276">
    <data><![CDATA[]]></data>
  </Command>
  <Command __id="23449" _type="EclipseCommand" commandID="org.eclipse.ui.file.save" date="Fri Dec 20 08:59:57 EST 2019" starttimestamp="1576666505112" timestamp="183892618" />
  <Command __id="23450" _type="ShellCommand" date="Fri Dec 20 09:00:01 EST 2019" starttimestamp="1576666505112" timestamp="183896216" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="23451" _type="ShellCommand" date="Fri Dec 20 09:00:46 EST 2019" starttimestamp="1576666505112" timestamp="183941831" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="23452" _type="ShellCommand" date="Fri Dec 20 09:01:11 EST 2019" starttimestamp="1576666505112" timestamp="183966137" type="ECLIPSE_LOST_FOCUS" />
  <DocumentChange __id="23506" _type="Insert" date="Fri Dec 20 09:02:15 EST 2019" docASTNodeCount="324" docActiveCodeLength="1992" docExpressionCount="214" docLength="1992" length="1" offset="983" starttimestamp="1576666505112" timestamp="184030588">
    <text><![CDATA[/]]></text>
  </DocumentChange>
  <Command __id="23546" _type="ShellCommand" date="Fri Dec 20 09:02:35 EST 2019" starttimestamp="1576666505112" timestamp="184050827" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="23547" _type="DiffBasedFileOpenCommand" date="Fri Dec 20 09:02:39 EST 2019" docASTNodeCount="1" docActiveCodeLength="496" docExpressionCount="0" docLength="520" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="184054593">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\sum_parallel_for_reduction.cpp]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"#include <iostream>¬∂#include <omp.h>¬∂¬∂using namespace std;¬∂¬∂//const int SIZE = 1000;¬∂void printSumWithTimes(int sum, int start, int end);¬∂void printNumThreads();¬∂void recordThreadIndex(int index);¬∂void sum_parallel_for_reduction(double* array, int size) {¬∂	cout << "sum_parallel_for_reduction\n";¬∂¬∂	double start = omp_get_wtime();¬∂¬∂	double sum = 0;¬∂    #pragma omp parallel for reduction(+:sum)¬∂¬∂	for (int i = 0; i < size; i++)¬∂		sum += array[i];¬∂¬∂	double end = omp_get_wtime();¬∂¬∂	printSumWithTimes(sum, start, end);¬∂¬∂}¬∂")]]]></diff>
  </Command>
  <Command __id="23549" _type="EclipseCommand" commandID="" date="Fri Dec 20 09:02:40 EST 2019" starttimestamp="1576666505112" timestamp="184055708" />
  <Command __id="23550" _type="EclipseCommand" commandID="" date="Fri Dec 20 09:02:40 EST 2019" starttimestamp="1576666505112" timestamp="184055819" />
  <Command __id="23552" _type="MoveCaretCommand" caretOffset="296" date="Fri Dec 20 09:03:08 EST 2019" docOffset="296" starttimestamp="1576666505112" timestamp="184083093" />
  <Command __id="23551" _type="DiffBasedFileOpenCommand" date="Fri Dec 20 09:03:08 EST 2019" docASTNodeCount="1" docActiveCodeLength="444" docExpressionCount="0" docLength="444" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="184082968">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\sum_parallel.cpp]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"#include <iostream>¬∂#include <omp.h>¬∂¬∂using namespace std;¬∂¬∂void printSumWithTimes(int sum, int start, int end);¬∂void printNumThreads();¬∂void recordThreadIndex(int index);¬∂void sum_parallel(double* array, int size) {¬∂	cout << "sum_parallel\n";¬∂¬∂	double start = omp_get_wtime();¬∂¬∂	double sum = 0;¬∂¬∂"), Diff(INSERT,"	#pragma omp parallel¬∂"), Diff(EQUAL,"	for (int i = 0; i < size; i++)¬∂		sum += array[i];¬∂¬∂	double end = omp_get_wtime();¬∂¬∂	printSumWithTimes(sum, start, end);¬∂¬∂¬∂}¬∂")]]]></diff>
    <snapshot><![CDATA[#include <iostream>
#include <omp.h>

using namespace std;

void printSumWithTimes(int sum, int start, int end);
void printNumThreads();
void recordThreadIndex(int index);
void sum_parallel(double* array, int size) {
	cout << "sum_parallel\n";

	double start = omp_get_wtime();

	double sum = 0;

	#pragma omp parallel
	for (int i = 0; i < size; i++)
		sum += array[i];

	double end = omp_get_wtime();

	printSumWithTimes(sum, start, end);


}
]]></snapshot>
  </Command>
  <Command __id="23553" _type="SelectTextCommand" caretOffset="370" date="Fri Dec 20 09:03:16 EST 2019" end="370" start="298" starttimestamp="1576666505112" timestamp="184091272" />
  <Command __id="23557" _type="EclipseCommand" commandID="org.eclipse.cdt.ui.edit.text.c.toggle.comment" date="Fri Dec 20 09:03:17 EST 2019" starttimestamp="1576666505112" timestamp="184092398" />
  <Command __id="23558" _type="MoveCaretCommand" caretOffset="375" date="Fri Dec 20 09:03:19 EST 2019" docOffset="375" starttimestamp="1576666505112" timestamp="184094177" />
  <Command __id="23560" _type="InsertStringCommand" date="Fri Dec 20 09:03:20 EST 2019" starttimestamp="1576666505112" timestamp="184094996" timestamp2="184094996">
    <data><![CDATA[]]></data>
  </Command>
  <Command __id="23562" _type="PasteCommand" date="Fri Dec 20 09:03:21 EST 2019" starttimestamp="1576666505112" timestamp="184095971" />
  <Command __id="23563" _type="MoveCaretCommand" caretOffset="376" date="Fri Dec 20 09:03:23 EST 2019" docOffset="376" starttimestamp="1576666505112" timestamp="184098865" />
  <Command __id="23565" _type="InsertStringCommand" date="Fri Dec 20 09:03:24 EST 2019" starttimestamp="1576666505112" timestamp="184099199" timestamp2="184099199">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="23567" _type="InsertStringCommand" date="Fri Dec 20 09:03:24 EST 2019" starttimestamp="1576666505112" timestamp="184099395" timestamp2="184099395">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="23569" _type="InsertStringCommand" date="Fri Dec 20 09:03:24 EST 2019" starttimestamp="1576666505112" timestamp="184099565" timestamp2="184099565">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="23571" _type="InsertStringCommand" date="Fri Dec 20 09:03:24 EST 2019" starttimestamp="1576666505112" timestamp="184099863" timestamp2="184099863">
    <data><![CDATA[ ]]></data>
  </Command>
  <DocumentChange __id="23554" _type="Insert" date="Fri Dec 20 09:03:17 EST 2019" docASTNodeCount="1" docActiveCodeLength="423" docExpressionCount="0" docLength="446" length="2" offset="297" starttimestamp="1576666505112" timestamp="184092385">
    <text><![CDATA[//]]></text>
  </DocumentChange>
  <DocumentChange __id="23555" _type="Insert" date="Fri Dec 20 09:03:17 EST 2019" docASTNodeCount="1" docActiveCodeLength="392" docExpressionCount="0" docLength="448" length="2" offset="321" starttimestamp="1576666505112" timestamp="184092388">
    <text><![CDATA[//]]></text>
  </DocumentChange>
  <DocumentChange __id="23556" _type="Insert" date="Fri Dec 20 09:03:17 EST 2019" docASTNodeCount="1" docActiveCodeLength="374" docExpressionCount="0" docLength="450" length="2" offset="355" starttimestamp="1576666505112" timestamp="184092389">
    <text><![CDATA[//]]></text>
  </DocumentChange>
  <DocumentChange __id="23559" _type="Insert" date="Fri Dec 20 09:03:20 EST 2019" docASTNodeCount="1" docActiveCodeLength="376" docExpressionCount="0" docLength="452" length="2" offset="375" starttimestamp="1576666505112" timestamp="184094989">
    <text><![CDATA[
	]]></text>
  </DocumentChange>
  <DocumentChange __id="23561" _type="Replace" date="Fri Dec 20 09:03:21 EST 2019" docASTNodeCount="1" docActiveCodeLength="550" docExpressionCount="0" docLength="626" endLine="18" insertionLength="175" int_docASTNodeCount="1" int_docActiveCodeLength="375" int_docExpressionCount="0" int_docLength="451" length="1" offset="376" startLine="18" starttimestamp="1576666505112" timestamp="184095953">
    <deletedText><![CDATA[	]]></deletedText>
    <insertedText><![CDATA[#pragma omp parallel
	{
		double local_sum = 0;
		
		#pragma omp for
		for(int i = 0; i < SIZE; i++)
			local_sum += array[i];
		
		#pragma omp critical
		sum += local_sum;
	}]]></insertedText>
  </DocumentChange>
  <DocumentChange __id="23564" _type="Insert" date="Fri Dec 20 09:03:24 EST 2019" docASTNodeCount="1" docActiveCodeLength="551" docExpressionCount="0" docLength="627" length="1" offset="376" starttimestamp="1576666505112" timestamp="184099181">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="23566" _type="Insert" date="Fri Dec 20 09:03:24 EST 2019" docASTNodeCount="1" docActiveCodeLength="552" docExpressionCount="0" docLength="628" length="1" offset="377" starttimestamp="1576666505112" timestamp="184099386">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="23568" _type="Insert" date="Fri Dec 20 09:03:24 EST 2019" docASTNodeCount="1" docActiveCodeLength="553" docExpressionCount="0" docLength="629" length="1" offset="378" starttimestamp="1576666505112" timestamp="184099549">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="23570" _type="Insert" date="Fri Dec 20 09:03:24 EST 2019" docASTNodeCount="1" docActiveCodeLength="554" docExpressionCount="0" docLength="630" length="1" offset="379" starttimestamp="1576666505112" timestamp="184099851">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="23574" _type="Replace" date="Fri Dec 20 09:03:40 EST 2019" docASTNodeCount="1" docActiveCodeLength="551" docExpressionCount="0" docLength="627" endLine="23" insertionLength="1" int_docASTNodeCount="1" int_docActiveCodeLength="550" int_docExpressionCount="0" int_docLength="626" length="4" offset="470" startLine="23" starttimestamp="1576666505112" timestamp="184115614">
    <deletedText><![CDATA[SIZE]]></deletedText>
    <insertedText><![CDATA[s]]></insertedText>
  </DocumentChange>
  <DocumentChange __id="23576" _type="Insert" date="Fri Dec 20 09:03:40 EST 2019" docASTNodeCount="1" docActiveCodeLength="552" docExpressionCount="0" docLength="628" length="1" offset="471" starttimestamp="1576666505112" timestamp="184115817">
    <text><![CDATA[i]]></text>
  </DocumentChange>
  <DocumentChange __id="23578" _type="Insert" date="Fri Dec 20 09:03:41 EST 2019" docASTNodeCount="1" docActiveCodeLength="553" docExpressionCount="0" docLength="629" length="1" offset="472" starttimestamp="1576666505112" timestamp="184116108">
    <text><![CDATA[z]]></text>
  </DocumentChange>
  <DocumentChange __id="23580" _type="Insert" date="Fri Dec 20 09:03:41 EST 2019" docASTNodeCount="1" docActiveCodeLength="554" docExpressionCount="0" docLength="630" length="1" offset="473" starttimestamp="1576666505112" timestamp="184116226">
    <text><![CDATA[z]]></text>
  </DocumentChange>
  <DocumentChange __id="23582" _type="Insert" date="Fri Dec 20 09:03:41 EST 2019" docASTNodeCount="1" docActiveCodeLength="555" docExpressionCount="0" docLength="631" length="1" offset="474" starttimestamp="1576666505112" timestamp="184116576">
    <text><![CDATA[e]]></text>
  </DocumentChange>
  <DocumentChange __id="23584" _type="Delete" date="Fri Dec 20 09:03:42 EST 2019" docASTNodeCount="1" docActiveCodeLength="554" docExpressionCount="0" docLength="630" endLine="23" length="1" offset="474" startLine="23" starttimestamp="1576666505112" timestamp="184117707">
    <text><![CDATA[e]]></text>
  </DocumentChange>
  <DocumentChange __id="23586" _type="Delete" date="Fri Dec 20 09:03:42 EST 2019" docASTNodeCount="1" docActiveCodeLength="553" docExpressionCount="0" docLength="629" endLine="23" length="1" offset="473" startLine="23" starttimestamp="1576666505112" timestamp="184117866">
    <text><![CDATA[z]]></text>
  </DocumentChange>
  <DocumentChange __id="23588" _type="Insert" date="Fri Dec 20 09:03:43 EST 2019" docASTNodeCount="1" docActiveCodeLength="554" docExpressionCount="0" docLength="630" length="1" offset="473" starttimestamp="1576666505112" timestamp="184118491">
    <text><![CDATA[e]]></text>
  </DocumentChange>
  <Command __id="23572" _type="MoveCaretCommand" caretOffset="471" date="Fri Dec 20 09:03:39 EST 2019" docOffset="471" starttimestamp="1576666505112" timestamp="184114690" />
  <Command __id="23573" _type="SelectTextCommand" caretOffset="474" date="Fri Dec 20 09:03:40 EST 2019" end="474" start="470" starttimestamp="1576666505112" timestamp="184114966" />
  <Command __id="23575" _type="InsertStringCommand" date="Fri Dec 20 09:03:40 EST 2019" starttimestamp="1576666505112" timestamp="184115622" timestamp2="184115622">
    <data><![CDATA[s]]></data>
  </Command>
  <Command __id="23577" _type="InsertStringCommand" date="Fri Dec 20 09:03:40 EST 2019" starttimestamp="1576666505112" timestamp="184115826" timestamp2="184115826">
    <data><![CDATA[i]]></data>
  </Command>
  <Command __id="23579" _type="InsertStringCommand" date="Fri Dec 20 09:03:41 EST 2019" starttimestamp="1576666505112" timestamp="184116120" timestamp2="184116120">
    <data><![CDATA[z]]></data>
  </Command>
  <Command __id="23581" _type="InsertStringCommand" date="Fri Dec 20 09:03:41 EST 2019" starttimestamp="1576666505112" timestamp="184116235" timestamp2="184116235">
    <data><![CDATA[z]]></data>
  </Command>
  <Command __id="23583" _type="InsertStringCommand" date="Fri Dec 20 09:03:41 EST 2019" starttimestamp="1576666505112" timestamp="184116589" timestamp2="184116589">
    <data><![CDATA[e]]></data>
  </Command>
  <Command __id="23585" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Fri Dec 20 09:03:42 EST 2019" starttimestamp="1576666505112" timestamp="184117712" />
  <Command __id="23587" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Fri Dec 20 09:03:42 EST 2019" starttimestamp="1576666505112" timestamp="184117872" />
  <Command __id="23589" _type="InsertStringCommand" date="Fri Dec 20 09:03:43 EST 2019" starttimestamp="1576666505112" timestamp="184118493" timestamp2="184118493">
    <data><![CDATA[e]]></data>
  </Command>
  <Command __id="23592" _type="EclipseCommand" commandID="org.eclipse.ui.file.save" date="Fri Dec 20 09:03:44 EST 2019" starttimestamp="1576666505112" timestamp="184119604" />
  <DocumentChange __id="23590" _type="Delete" date="Fri Dec 20 09:03:44 EST 2019" docASTNodeCount="1" docActiveCodeLength="552" docExpressionCount="0" docLength="628" endLine="25" length="2" offset="507" startLine="25" starttimestamp="1576666505112" timestamp="184119555">
    <text><![CDATA[		]]></text>
  </DocumentChange>
  <DocumentChange __id="23591" _type="Delete" date="Fri Dec 20 09:03:44 EST 2019" docASTNodeCount="1" docActiveCodeLength="550" docExpressionCount="0" docLength="626" endLine="21" length="2" offset="428" startLine="21" starttimestamp="1576666505112" timestamp="184119559">
    <text><![CDATA[		]]></text>
  </DocumentChange>
  <Command __id="23595" _type="DiffBasedFileOpenCommand" date="Fri Dec 20 09:03:59 EST 2019" docASTNodeCount="1" docActiveCodeLength="61671" docExpressionCount="0" docLength="61671" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="184134380">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\Debug\src\sum_parallel_for_local_var.o]]></filePath>
    <diff><![CDATA[null]]></diff>
    <snapshot><![CDATA[d‚Ä†     √´  1      .text           0  ‚Äù  (√®           P`.data                               @ P√Ä.bss                               ‚Ç¨ P√Ä.rdata              √Ñ              @ P@.xdata          0   √§              @ 0@.pdata          0     ¬†√®         @ 0@.ctors             D  √©         @ @√Ä/4              u  L  "√©      #   @ B/16             y  √Å#              @ B/30             0   :'  ‚Ç¨√™         @ B/45             √ò¬µ  j'  ‚Äù√™         @ B/58             √ì	  B√ù  ≈æ√™         @ B/70             (   √ß              @ B/81                 =√ß              @ P@/92                ]√ß  ¬®√™         @P@/117            ¬∏   m√ß  ¬≤√™         @ @BUH‚Ä∞√•H∆í√¨@H‚Ä∞M‚Ä∞UHÔøΩ    H‚Äπ    √®    √®    fH~√ÄH‚Ä∞E√®f√Ø√Ä√≤E√∏√áE√¥    ‚ÄπE√¥;E}6‚ÄπE√¥HÀúHÔøΩ√Ö    H‚ÄπEH√ê√≤ √≤M√∏√≤X√Å√≤E√∏‚ÄπE√¥‚Ä∞√Å√®    ∆íE√¥√´√Ç√®    fH~√ÄH‚Ä∞E√†√≤E√†√≤,√à√≤E√®√≤,√ê√≤E√∏√≤,√ÄA‚Ä∞√à‚Ä∞√Å√®    ÔøΩH∆í√Ñ@]√ÉUH‚Ä∞√•H∆í√¨ HÔøΩ    √®    ÔøΩH∆í√Ñ ]√ÉUH‚Ä∞√•H∆í√¨ ‚Ä∞M‚Ä∞U∆í}u!ÔøΩ}√ø√ø  uHÔøΩ    √®    HÔøΩ¬µ√ø√ø√ø√®    ÔøΩH∆í√Ñ ]√ÉUH‚Ä∞√•H∆í√¨ ¬∫√ø√ø  ¬π   √®¬≠√ø√ø√øÔøΩH∆í√Ñ ]√ÉÔøΩÔøΩÔøΩsum_parallel_for_local_var
     rP  2P  2P  2P      ¬∏       ¬∏   √ì      √ì          -  $         q       GNU C++ 5.1.0 -mtune=generic -march=x86-64 -mthreads -g3 -O0 -fmessage-length=0 -fopenmp ..\src\sum_parallel_for_local_var.cpp D:\dewan_backup\C\MyOpenMPTraining\Debug         -              std  ¬≠  __cxx11 √ö√ö√ò   @√à  ‚Äπ?  ÔøΩ√ö  ≈Ω√≤  ÔøΩ  ÔøΩ4  ‚ÄòR  ‚Äô{  ‚ÄúÀú  ‚Äù¬π  ‚Ä¢√ô  ‚Äì√±  ‚Äî  Àú6  ‚Ñ¢_  ≈°‚Äû  ‚Ä∫¬µ  ≈ì√í  ≈æ√≠  ¬†  ¬°-  ¬¢L  ¬§r  ¬ß‚Äî  ¬™¬º  ¬¨√°  ¬Æ  ¬∞   ¬±D  ¬≤b  ¬≥‚Ç¨  ¬¥≈∏  ¬µ¬Ω  ¬∂√ú  ¬∑  ¬∏*  ¬πN  ¬∫r  ¬ª‚Äì  ¬º√á  ¬Ω√•  ¬ø  √Å:  √ÇX  √É{  √Ñ≈∏  √Ö√É  √Ü√õ  √á√ø  √à#  √âH  √äl  √ã‚Ä°  √å¬°  √ç¬ø  √é√û  √è√Ω  √ê  ?  	m  
‚Äò  __debug 0char_traits<char> √©d  char_type √´√æ  int_type √¨s  	assign √≤_ZNSt11char_traitsIcE6assignERcRKc   
√†  
√¶   ¬Ω  eq √∂_ZNSt11char_traitsIcE2eqERKcS2_ √¨  X  
√¶  
√¶   lt √∫_ZNSt11char_traitsIcE2ltERKcS2_ √¨  ‚Äò  
√¶  
√¶   compare _ZNSt11char_traitsIcE7compareEPKcS2_y s  √õ  
√¥  
√¥  
d   length _ZNSt11char_traitsIcE6lengthEPKc d    
√¥   find 
_ZNSt11char_traitsIcE4findEPKcyRS1_ √¥  Z  
√¥  
d  
√¶   move _ZNSt11char_traitsIcE4moveEPcPKcy √∫  ÔøΩ  
√∫  
√¥  
d   copy _ZNSt11char_traitsIcE4copyEPcPKcy √∫  √†  
√∫  
√¥  
d   assign _ZNSt11char_traitsIcE6assignEPcyc √∫  %  
√∫  
d  
¬Ω   to_char_type _ZNSt11char_traitsIcE12to_char_typeERKi ¬Ω  l  
    √é  to_int_type  _ZNSt11char_traitsIcE11to_int_typeERKc √é  ¬∂  
√¶   eq_int_type $_ZNSt11char_traitsIcE11eq_int_typeERKiS2_ √¨    
   
    eof (_ZNSt11char_traitsIcE3eofEv √é  not_eof ,_ZNSt11char_traitsIcE7not_eofERKi √é  
     size_t √Ñ  5√é  6  7&  ptrdiff_t √Ö.  _Ios_Fmtflags ÔøΩ  9¬æ  _S_boolalpha _S_dec _S_fixed _S_hex _S_internal _S_left  _S_oct @_S_right ‚Ç¨_S_scientific  _S_showbase  _S_showpoint  _S_showpos  _S_skipws  _S_unitbuf   _S_uppercase  @_S_adjustfield ¬∞_S_basefield J_S_floatfield _S_ios_fmtflags_end     _Ios_Openmode ÔøΩ  m)  _S_app _S_ate _S_bin _S_in _S_out _S_trunc  _S_ios_openmode_end     _Ios_Iostate ÔøΩ  ‚Ä¢ÔøΩ  _S_goodbit  _S_badbit _S_eofbit _S_failbit _S_ios_iostate_end     _Ios_Seekdir ÔøΩ  ¬ª√ö  _S_beg  _S_cur _S_end _S_ios_seekdir_end     ios_base √∫  Init S‚Äπ	  _S_refcount [8  _S_synced_with_stdio \√¨  Init W_ZNSt8ios_base4InitC4Ev R	  X	  [   ~Init X_ZNSt8ios_base4InitD4Ev 	  [  s    fmtflags =Àú  boolalpha @¬±	  ‚Äπ	  dec C¬±	  fixed F¬±	  hex I¬±	  internal N¬±	  left R¬±	   oct U¬±	  @right Y¬±	  ‚Ç¨scientific \¬±	   showbase `¬±	   showpoint d¬±	   showpos g¬±	   skipws j¬±	   unitbuf m¬±	    uppercase q¬±	   @adjustfield t¬±	  ¬∞basefield w¬±	  Jfloatfield z¬±	  iostate ÀÜ)  badbit ≈í  √Æ
  eofbit ÔøΩ  failbit ‚Äù  goodbit ‚Äî   openmode ¬ß¬æ  app ¬™j  J  ate ¬≠j  binary ¬≤j  in ¬µj  out ¬∏j  trunc ¬ªj   seekdir √áÔøΩ  beg √ä√ò   ¬π  cur √ç√ò  end √ê√ò   	Ra  	Sc  	T?  	\r  	e‚Äò  	h¬±  	i√ä  basic_ostream<char, std::char_traits<char> > w  _CharT √æ  _Traits ¬£   ostream 
ÔøΩ+  cout =_ZSt4cout w   __ioinit J√®   __gnu_cxx √ù√¶  __cxx11 √û√û¬æ  √∏?  m  ‚Äò  __ops $,d  -‚Ä°  __numeric_traits_integer<int> 7Z  !    :L  !   ;L  !   ?Q  !   @L  "   s   __numeric_traits_integer<long unsigned int> 7√Ñ  !    :V  !   ;V  !   ?Q  !   @L  "   ¬π   __numeric_traits_integer<char> 7!  !    :+  !   ;+  !   ?Q  !   @L  "   √æ   __numeric_traits_integer<short int> 7∆í  !    :√¢  !   ;√¢  !   ?Q  !   @L  "      #__numeric_traits_integer<long long int> 7!    :√ß  !   ;√ß  !   ?Q  !   @L  "   .    $__builtin_va_list √æ  %char size_t #  %long long unsigned int %long long int wint_t jM  %short unsigned int wctype_t kM  %int %long int &√æ  &‚Äô  %wchar_t %unsigned int %sizetype %long unsigned int lconv X-m  'decimal_point .‚Ä†   'thousands_sep /‚Ä†  'grouping 0‚Ä†  'int_curr_symbol 1‚Ä†  'currency_symbol 2‚Ä†   'mon_decimal_point 3‚Ä†  ('mon_thousands_sep 4‚Ä†  0'mon_grouping 5‚Ä†  8'positive_sign 6‚Ä†  @'negative_sign 7‚Ä†  H'int_frac_digits 8√æ  P'frac_digits 9√æ  Q'p_cs_precedes :√æ  R'p_sep_by_space ;√æ  S'n_cs_precedes <√æ  T'n_sep_by_space =√æ  U'p_sign_posn >√æ  V'n_sign_posn ?√æ  W &√é  %unsigned char _iobuf 0   '_ptr !‚Ä†   '_cnt "s  '_base #‚Ä†  '_flag $s  '_file %s  '_charbuf &s   '_bufsiz 's  $'_tmpfname (‚Ä†  ( FILE *‚Äû  %short int (tm $∆í√à  )tm_sec ‚Äûs   )tm_min ‚Ä¶s  )tm_hour ‚Ä†s  )tm_mday ‚Ä°s  )tm_mon ÀÜs  )tm_year ‚Ä∞s  )tm_wday ≈†s  )tm_yday ‚Äπs  )tm_isdst ≈ís    *mbstate_t ¬®s  +btowc ¬´?  √≤  
s   +fgetwc |?    
   &  +fgetws ‚Ä¶≈í  4  
≈í  
s  
   +fputwc ~?  R  
‚Äô  
   +fputws ‚Ä†s  p  
p  
   &v  ‚Äô  +fwide ¬∫s  Àú  
  
s   ,fwprintf s  ¬π  
  
p  - ,fwscanf √≤s  √ô  
  
p  - +getwc ‚Ç¨?  √±  
   .getwchar ÔøΩ?  +mbrlen ¬¨  %  
%  
  
0   &+  √æ  &√à  +mbrtowc ¬≠  _  
≈í  
%  
  
0   +mbsinit ¬ªs  y  
y   &  √à  +mbsrtowcs ¬Æ  ¬Ø  
≈í  
¬Ø  
  
0   &%  +putwc ‚Äö?  √í  
‚Äô  
   +putwchar ∆í?  √≠  
‚Äô   /swprintf :s    
≈í  
p  - ,swscanf √ús  -  
p  
p  - +ungetwc ‚Äû?  L  
?  
   ,vfwprintf ,s  r  
  
p  
√¶   ,vfwscanf s  ‚Äî  
  
p  
√¶   /vswprintf /s  ¬º  
≈í  
p  
√¶   ,vswscanf √æs  √°  
p  
p  
√¶   ,vwprintf 3s    
p  
√¶   ,vwscanf s     
p  
√¶   +wcrtomb ¬Ø  D  
‚Ä†  
‚Äô  
0   +wcscat K≈í  b  
≈í  
p   +wcscmp Ms  ‚Ç¨  
p  
p   +wcscoll js  ≈∏  
p  
p   +wcscpy N≈í  ¬Ω  
≈í  
p   +wcscspn O  √ú  
p  
p   +wcsftime ‚Ä¢    
≈í  
  
p  
   &  $  +wcslen P  *  
p   +wcsncat R≈í  N  
≈í  
p  
   +wcsncmp Ss  r  
p  
p  
   +wcsncpy T≈í  ‚Äì  
≈í  
p  
   +wcsrtombs ¬∞  √Å  
‚Ä†  
√Å  
  
0   &p  +wcsspn X  √•  
p  
p   ,wcstod     
p  
   %double &≈í  ,wcstof 1  1  
p  
   %float +wcstok Z≈í  X  
≈í  
p   +wcstol z  {  
p  
  
s   +wcstoul !¬π  ≈∏  
p  
  
s   +wcsxfrm h  √É  
≈í  
p  
   +wctob ¬±s  √õ  
?   +wmemcmp ¬∂s  √ø  
p  
p  
   +wmemcpy ¬∑≈í  #  
≈í  
p  
   +wmemmove ¬π≈í  H  
≈í  
p  
   +wmemset ¬¥≈í  l  
≈í  
‚Äô  
   ,wprintf !s  ‚Ä°  
p  - ,wscanf √ßs  ¬°  
p  - +wcschr L≈í  ¬ø  
p  
‚Äô   +wcspbrk V≈í  √û  
p  
p   +wcsrchr W≈í  √Ω  
p  
‚Äô   +wcsstr Y≈í    
p  
p   +wmemchr ¬µ≈í  ?  
p  
‚Äô  
   +wcstold ^  ^  
p  
   %long double +wcstoll ¬º.  ‚Äò  
p  
  
s   +wcstoull ¬Ω  ¬∂  
p  
  
s   %signed char __gnu_debug 7√†  8Àú   0¬Ω  0  %bool &  &¬Ω  0l  1setlocale P‚Ä†  &  
s  
%   2localeconv Qm  _Atomic_word  s  s  √¨  ¬π  &√®  wctrans_t ¬¶‚Äô  1iswctype √ªs  ‚Äò  
?  
c   1towctrans ¬ß?  ¬±  
?  
a   1wctrans ¬®a  √ä  
%   1wctype ¬©c  √¢  
%     .  √ç   3sum_parallel_for_local_var 	_Z26sum_parallel_for_local_varPdi         ¬∏       ≈ì¬≥  4array 	¬≥  ‚Äò 4size 	s  ‚Äò5start   ‚ÄòX5sum   ‚Äòh5end   ‚ÄòP69       E       5i s  ‚Äòd  &  7__tcf_0 ¬∏              ≈ì8__static_initialization_and_destruction_0 √ì       <       ≈ìD  4__initialize_p s  ‚Äò 4__priority s  ‚Äò 7_GLOBAL__sub_I__Z26sum_parallel_for_local_varPdi              ≈ì9≈ì  	        :$  _ZN9__gnu_cxx24__numeric_traits_integerIiE5__minE ‚Ç¨‚Ç¨‚Ç¨‚Ç¨x;/  _ZN9__gnu_cxx24__numeric_traits_integerIiE5__maxE √ø√ø√ø<¬Ø  _ZN9__gnu_cxx24__numeric_traits_integerImE8__digitsE  <√∂  _ZN9__gnu_cxx24__numeric_traits_integerIcE5__maxE :M  _ZN9__gnu_cxx24__numeric_traits_integerIsE5__minE ‚Ç¨‚Ç¨~=X  _ZN9__gnu_cxx24__numeric_traits_integerIsE5__maxE √ø:¬Ø  _ZN9__gnu_cxx24__numeric_traits_integerIxE5__minE ‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨>¬∫  _ZN9__gnu_cxx24__numeric_traits_integerIxE5__maxE √ø√ø√ø√ø√ø√ø√ø %‚Ñ¢B  9:;  9 :;  : :;   :;   :;  :;   :;I  	.?:;n<  
 I  & I  .?:;nI<  .?:;nI<  . ?:;nI<  .?:;nI<  I:;  (   (   (   <  :;2   :;I?<  .?:;n2<d   I4  .?:;n2<d   :;I2   :;I?2<   :;I?2<  / I  / I  4 :;nI?<   4 :;I<  ! :;I?<  "/ I  #:;  $ I  %$ >  & I  ' :;I8  (:;  ) :;I8  * :;I  +.?:;I<  ,.:;I<  -   .. ?:;I<  /.:;I<  0 I  1.?:;I<  2. ?:;I<  3.?:;n@‚ÄìB  4 :;I  54 :;I  6  7. 4@‚ÄìB  8.4@‚ÄìB  94 G  :4 Gn  ;4 Gn  <4 Gn  =4 Gn  >4 Gn   ,                     -                            __STDC__ 1  __cplusplus 199711L  __STDC_HOSTED__ 1  __GNUC__ 5  __GNUC_MINOR__ 1  __GNUC_PATCHLEVEL__ 0  __VERSION__ "5.1.0"  __ATOMIC_RELAXED 0  __ATOMIC_SEQ_CST 5  __ATOMIC_ACQUIRE 2  __ATOMIC_RELEASE 3  __ATOMIC_ACQ_REL 4  __ATOMIC_CONSUME 1  __pic__ 1  __PIC__ 1  __FINITE_MATH_ONLY__ 0  __SIZEOF_INT__ 4  __SIZEOF_LONG__ 4  __SIZEOF_LONG_LONG__ 8  __SIZEOF_SHORT__ 2  __SIZEOF_FLOAT__ 4  __SIZEOF_DOUBLE__ 8  __SIZEOF_LONG_DOUBLE__ 16  __SIZEOF_SIZE_T__ 8  __CHAR_BIT__ 8  __BIGGEST_ALIGNMENT__ 16  __ORDER_LITTLE_ENDIAN__ 1234  __ORDER_BIG_ENDIAN__ 4321  __ORDER_PDP_ENDIAN__ 3412  __BYTE_ORDER__ __ORDER_LITTLE_ENDIAN__  __FLOAT_WORD_ORDER__ __ORDER_LITTLE_ENDIAN__  __SIZEOF_POINTER__ 8  __GNUG__ 5  __SIZE_TYPE__ long long unsigned int  __PTRDIFF_TYPE__ long long int  __WCHAR_TYPE__ short unsigned int  __WINT_TYPE__ short unsigned int  __INTMAX_TYPE__ long long int  __UINTMAX_TYPE__ long long unsigned int  __CHAR16_TYPE__ short unsigned int  __CHAR32_TYPE__ unsigned int  __SIG_ATOMIC_TYPE__ int  __INT8_TYPE__ signed char  __INT16_TYPE__ short int  __INT32_TYPE__ int  __INT64_TYPE__ long long int  __UINT8_TYPE__ unsigned char  __UINT16_TYPE__ short unsigned int  __UINT32_TYPE__ unsigned int  __UINT64_TYPE__ long long unsigned int  __INT_LEAST8_TYPE__ signed char  __INT_LEAST16_TYPE__ short int  __INT_LEAST32_TYPE__ int  __INT_LEAST64_TYPE__ long long int  __UINT_LEAST8_TYPE__ unsigned char  __UINT_LEAST16_TYPE__ short unsigned int  __UINT_LEAST32_TYPE__ unsigned int  __UINT_LEAST64_TYPE__ long long unsigned int  __INT_FAST8_TYPE__ signed char  __INT_FAST16_TYPE__ short int  __INT_FAST32_TYPE__ int  __INT_FAST64_TYPE__ long long int  __UINT_FAST8_TYPE__ unsigned char  __UINT_FAST16_TYPE__ short unsigned int  __UINT_FAST32_TYPE__ unsigned int  __UINT_FAST64_TYPE__ long long unsigned int  __INTPTR_TYPE__ long long int  __UINTPTR_TYPE__ long long unsigned int  __has_include(STR) __has_include__(STR)  __has_include_next(STR) __has_include_next__(STR)  __GXX_WEAK__ 1  __DEPRECATED 1  __GXX_RTTI 1  __cpp_rtti 199711  __cpp_binary_literals 201304  __cpp_runtime_arrays 198712  __EXCEPTIONS 1  __cpp_exceptions 199711  __GXX_ABI_VERSION 1008  __SCHAR_MAX__ 0x7f  __SHRT_MAX__ 0x7fff  __INT_MAX__ 0x7fffffff  __LONG_MAX__ 0x7fffffffL  __LONG_LONG_MAX__ 0x7fffffffffffffffLL  __WCHAR_MAX__ 0xffff  __WCHAR_MIN__ 0  __WINT_MAX__ 0xffff  __WINT_MIN__ 0  __PTRDIFF_MAX__ 0x7fffffffffffffffLL  __SIZE_MAX__ 0xffffffffffffffffULL  __GLIBCXX_TYPE_INT_N_0 __int128  __GLIBCXX_BITSIZE_INT_N_0 128  __INTMAX_MAX__ 0x7fffffffffffffffLL  __INTMAX_C(c) c ## LL  __UINTMAX_MAX__ 0xffffffffffffffffULL  __UINTMAX_C(c) c ## ULL  __SIG_ATOMIC_MAX__ 0x7fffffff  __SIG_ATOMIC_MIN__ (-__SIG_ATOMIC_MAX__ - 1)  __INT8_MAX__ 0x7f  __INT16_MAX__ 0x7fff  __INT32_MAX__ 0x7fffffff  __INT64_MAX__ 0x7fffffffffffffffLL  __UINT8_MAX__ 0xff  __UINT16_MAX__ 0xffff  __UINT32_MAX__ 0xffffffffU  __UINT64_MAX__ 0xffffffffffffffffULL  __INT_LEAST8_MAX__ 0x7f  __INT8_C(c) c  __INT_LEAST16_MAX__ 0x7fff  __INT16_C(c) c  __INT_LEAST32_MAX__ 0x7fffffff  __INT32_C(c) c  __INT_LEAST64_MAX__ 0x7fffffffffffffffLL  __INT64_C(c) c ## LL  __UINT_LEAST8_MAX__ 0xff  __UINT8_C(c) c  __UINT_LEAST16_MAX__ 0xffff  __UINT16_C(c) c  __UINT_LEAST32_MAX__ 0xffffffffU  __UINT32_C(c) c ## U  __UINT_LEAST64_MAX__ 0xffffffffffffffffULL  __UINT64_C(c) c ## ULL  __INT_FAST8_MAX__ 0x7f  __INT_FAST16_MAX__ 0x7fff  __INT_FAST32_MAX__ 0x7fffffff  __INT_FAST64_MAX__ 0x7fffffffffffffffLL  __UINT_FAST8_MAX__ 0xff  __UINT_FAST16_MAX__ 0xffff  __UINT_FAST32_MAX__ 0xffffffffU  __UINT_FAST64_MAX__ 0xffffffffffffffffULL  __INTPTR_MAX__ 0x7fffffffffffffffLL  __UINTPTR_MAX__ 0xffffffffffffffffULL  __GCC_IEC_559 2  __GCC_IEC_559_COMPLEX 2  __FLT_EVAL_METHOD__ 0  __DEC_EVAL_METHOD__ 2  __FLT_RADIX__ 2  __FLT_MANT_DIG__ 24  __FLT_DIG__ 6  __FLT_MIN_EXP__ (-125)  __FLT_MIN_10_EXP__ (-37)  __FLT_MAX_EXP__ 128  __FLT_MAX_10_EXP__ 38  __FLT_DECIMAL_DIG__ 9  __FLT_MAX__ 3.40282346638528859812e+38F  __FLT_MIN__ 1.17549435082228750797e-38F  __FLT_EPSILON__ 1.19209289550781250000e-7F  __FLT_DENORM_MIN__ 1.40129846432481707092e-45F  __FLT_HAS_DENORM__ 1  __FLT_HAS_INFINITY__ 1  __FLT_HAS_QUIET_NAN__ 1  __DBL_MANT_DIG__ 53  __DBL_DIG__ 15  __DBL_MIN_EXP__ (-1021)  __DBL_MIN_10_EXP__ (-307)  __DBL_MAX_EXP__ 1024  __DBL_MAX_10_EXP__ 308  __DBL_DECIMAL_DIG__ 17  __DBL_MAX__ double(1.79769313486231570815e+308L)  __DBL_MIN__ double(2.22507385850720138309e-308L)  __DBL_EPSILON__ double(2.22044604925031308085e-16L)  __DBL_DENORM_MIN__ double(4.94065645841246544177e-324L)  __DBL_HAS_DENORM__ 1  __DBL_HAS_INFINITY__ 1  __DBL_HAS_QUIET_NAN__ 1  __LDBL_MANT_DIG__ 64  __LDBL_DIG__ 18  __LDBL_MIN_EXP__ (-16381)  __LDBL_MIN_10_EXP__ (-4931)  __LDBL_MAX_EXP__ 16384  __LDBL_MAX_10_EXP__ 4932  __DECIMAL_DIG__ 21  __LDBL_MAX__ 1.18973149535723176502e+4932L  __LDBL_MIN__ 3.36210314311209350626e-4932L  __LDBL_EPSILON__ 1.08420217248550443401e-19L  __LDBL_DENORM_MIN__ 3.64519953188247460253e-4951L  __LDBL_HAS_DENORM__ 1  __LDBL_HAS_INFINITY__ 1  __LDBL_HAS_QUIET_NAN__ 1  __DEC32_MANT_DIG__ 7  __DEC32_MIN_EXP__ (-94)  __DEC32_MAX_EXP__ 97  __DEC32_MIN__ 1E-95DF  __DEC32_MAX__ 9.999999E96DF  __DEC32_EPSILON__ 1E-6DF  __DEC32_SUBNORMAL_MIN__ 0.000001E-95DF  __DEC64_MANT_DIG__ 16  __DEC64_MIN_EXP__ (-382)  __DEC64_MAX_EXP__ 385  __DEC64_MIN__ 1E-383DD  __DEC64_MAX__ 9.999999999999999E384DD  __DEC64_EPSILON__ 1E-15DD  __DEC64_SUBNORMAL_MIN__ 0.000000000000001E-383DD  __DEC128_MANT_DIG__ 34  __DEC128_MIN_EXP__ (-6142)  __DEC128_MAX_EXP__ 6145  __DEC128_MIN__ 1E-6143DL  __DEC128_MAX__ 9.999999999999999999999999999999999E6144DL  __DEC128_EPSILON__ 1E-33DL  __DEC128_SUBNORMAL_MIN__ 0.000000000000000000000000000000001E-6143DL  __REGISTER_PREFIX__   __USER_LABEL_PREFIX__   __GNUC_GNU_INLINE__ 1  __NO_INLINE__ 1  __WCHAR_UNSIGNED__ 1  __GCC_HAVE_SYNC_COMPARE_AND_SWAP_1 1  __GCC_HAVE_SYNC_COMPARE_AND_SWAP_2 1  __GCC_HAVE_SYNC_COMPARE_AND_SWAP_4 1  __GCC_HAVE_SYNC_COMPARE_AND_SWAP_8 1  __GCC_ATOMIC_BOOL_LOCK_FREE 2  __GCC_ATOMIC_CHAR_LOCK_FREE 2  __GCC_ATOMIC_CHAR16_T_LOCK_FREE 2  __GCC_ATOMIC_CHAR32_T_LOCK_FREE 2  __GCC_ATOMIC_WCHAR_T_LOCK_FREE 2  __GCC_ATOMIC_SHORT_LOCK_FREE 2  __GCC_ATOMIC_INT_LOCK_FREE 2  __GCC_ATOMIC_LONG_LOCK_FREE 2  __GCC_ATOMIC_LLONG_LOCK_FREE 2  __GCC_ATOMIC_TEST_AND_SET_TRUEVAL 1  __GCC_ATOMIC_POINTER_LOCK_FREE 2  __GCC_HAVE_DWARF2_CFI_ASM 1  __PRAGMA_REDEFINE_EXTNAME 1  _OPENMP 201307  __SIZEOF_INT128__ 16  __SIZEOF_WCHAR_T__ 2  __SIZEOF_WINT_T__ 2  __SIZEOF_PTRDIFF_T__ 8  __amd64 1  __amd64__ 1  __x86_64 1  __x86_64__ 1  __SIZEOF_FLOAT80__ 16  __SIZEOF_FLOAT128__ 16  __ATOMIC_HLE_ACQUIRE 65536  __ATOMIC_HLE_RELEASE 131072  __k8 1  __k8__ 1  __code_model_medium__ 1  __MMX__ 1  __SSE__ 1  __SSE2__ 1  __FXSR__ 1  __SSE_MATH__ 1  __SSE2_MATH__ 1  __SEH__ 1  __stdcall __attribute__((__stdcall__))  __fastcall __attribute__((__fastcall__))  __thiscall __attribute__((__thiscall__))  __cdecl __attribute__((__cdecl__))  _stdcall __attribute__((__stdcall__))  _fastcall __attribute__((__fastcall__))  _thiscall __attribute__((__thiscall__))  _cdecl __attribute__((__cdecl__))  __GXX_MERGED_TYPEINFO_NAMES 0  __GXX_TYPEINFO_EQUALITY_INLINE 0  __MSVCRT__ 1  __MINGW32__ 1  _WIN32 1  __WIN32 1  __WIN32__ 1  WIN32 1  __WINNT 1  __WINNT__ 1  WINNT 1  _INTEGRAL_MAX_BITS 64  __MINGW64__ 1  __WIN64 1  __WIN64__ 1  WIN64 1  _WIN64 1  __declspec(x) __attribute__((x))  __DECIMAL_BID_FORMAT__ 1  _MT 1  _REENTRANT 1  _REENTRANT  "_GLIBCXX_IOSTREAM 1 &_GLIBCXX_CXX_CONFIG_H 1 "__GLIBCXX__ 20150422 +_GLIBCXX_PURE __attribute__ ((__pure__)) /_GLIBCXX_CONST __attribute__ ((__const__)) 3_GLIBCXX_NORETURN __attribute__ ((__noreturn__)) @_GLIBCXX_HAVE_ATTRIBUTE_VISIBILITY 0 G_GLIBCXX_VISIBILITY(V) _GLIBCXX_PSEUDO_VISIBILITY(V) N_GLIBCXX_USE_DEPRECATED 1 T_GLIBCXX_DEPRECATED  Y_GLIBCXX_ABI_TAG_CXX11 __attribute ((__abi_tag__ ("cxx11"))) e_GLIBCXX_CONSTEXPR  f_GLIBCXX_USE_CONSTEXPR const n_GLIBCXX14_CONSTEXPR  y_GLIBCXX_NOEXCEPT  z_GLIBCXX_USE_NOEXCEPT throw() {_GLIBCXX_THROW(_EXC) throw(_EXC) ‚Ç¨_GLIBCXX_NOTHROW _GLIBCXX_USE_NOEXCEPT ‚Ä¶_GLIBCXX_THROW_OR_ABORT(_EXC) (throw (_EXC)) ‚Ä¢_GLIBCXX_EXTERN_TEMPLATE 1 √å_GLIBCXX_USE_DUAL_ABI 1 √î_GLIBCXX_USE_CXX11_ABI 1 √†_GLIBCXX_NAMESPACE_CXX11 __cxx11:: √°_GLIBCXX_BEGIN_NAMESPACE_CXX11 namespace __cxx11 { √¢_GLIBCXX_END_NAMESPACE_CXX11 } √£_GLIBCXX_DEFAULT_ABI_TAG _GLIBCXX_ABI_TAG_CXX11 √≠_GLIBCXX_INLINE_VERSION 0 ‚Äî_GLIBCXX_BEGIN_NAMESPACE_VERSION  Àú_GLIBCXX_END_NAMESPACE_VERSION  √¨_GLIBCXX_STD_A std √∞_GLIBCXX_STD_C std √¥_GLIBCXX_BEGIN_NAMESPACE_ALGO  √∏_GLIBCXX_END_NAMESPACE_ALGO  √º_GLIBCXX_BEGIN_NAMESPACE_CONTAINER  ‚Ç¨_GLIBCXX_END_NAMESPACE_CONTAINER  ‚Ä¶_GLIBCXX_LONG_DOUBLE_COMPAT ‚Äò_GLIBCXX_NAMESPACE_LDBL  ‚Äô_GLIBCXX_BEGIN_NAMESPACE_LDBL  ‚Äú_GLIBCXX_END_NAMESPACE_LDBL  ‚Äì_GLIBCXX_NAMESPACE_LDBL_OR_CXX11 _GLIBCXX_NAMESPACE_CXX11 ‚Äî_GLIBCXX_BEGIN_NAMESPACE_LDBL_OR_CXX11 _GLIBCXX_BEGIN_NAMESPACE_CXX11 Àú_GLIBCXX_END_NAMESPACE_LDBL_OR_CXX11 _GLIBCXX_END_NAMESPACE_CXX11 ¬°__glibcxx_assert(_Condition)  √è_GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(A)  √í_GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(A)  √ñ_GLIBCXX_BEGIN_EXTERN_C extern "C" { √ó_GLIBCXX_END_EXTERN_C } √¢_GLIBCXX_OS_DEFINES  '__GTHREAD_HIDE_WIN32API 1 ,NOMINMAX -NOMINMAX 1 2__USE_MINGW_ANSI_STDIO 3__USE_MINGW_ANSI_STDIO 1 8_GLIBCXX_PSEUDO_VISIBILITY_default  :_GLIBCXX_PSEUDO_VISIBILITY_hidden  <_GLIBCXX_PSEUDO_VISIBILITY(V) _GLIBCXX_PSEUDO_VISIBILITY_ ## V ?_GLIBCXX_HAVE_DOS_BASED_FILESYSTEM 1 D_GLIBCXX_NO_IOCTL 1 N_GLIBCXX_LLP64 1 T_GLIBCXX_THREAD_ATEXIT_WIN32 1 W_GTHREAD_USE_MUTEX_INIT_FUNC 1 √•_GLIBCXX_CPU_DEFINES 1 √±_GLIBCXX_WEAK_DEFINITION  √º_GLIBCXX_FAST_MATH 0 ∆í__N(msgid) (msgid) ‚Ä†min ‚Ä°max ≈Ω_GLIBCXX_HAVE_ACOSF 1 ‚Äò_GLIBCXX_HAVE_ACOSL 1 ‚Äù_GLIBCXX_HAVE_ASINF 1 ‚Äî_GLIBCXX_HAVE_ASINL 1 ÔøΩ_GLIBCXX_HAVE_ATAN2F 1 ¬†_GLIBCXX_HAVE_ATAN2L 1 ¬£_GLIBCXX_HAVE_ATANF 1 ¬¶_GLIBCXX_HAVE_ATANL 1 ¬Ø_GLIBCXX_HAVE_CEILF 1 ¬≤_GLIBCXX_HAVE_CEILL 1 ¬µ_GLIBCXX_HAVE_COMPLEX_H 1 ¬∏_GLIBCXX_HAVE_COSF 1 ¬ª_GLIBCXX_HAVE_COSHF 1 ¬æ_GLIBCXX_HAVE_COSHL 1 √Å_GLIBCXX_HAVE_COSL 1 √ä_GLIBCXX_HAVE_ECANCELED 1 √ç_GLIBCXX_HAVE_ECHILD 1 √ú_GLIBCXX_HAVE_ENOSPC 1 √®_GLIBCXX_HAVE_ENOTSUP 1 √´_GLIBCXX_HAVE_EOVERFLOW 1 √Æ_GLIBCXX_HAVE_EOWNERDEAD 1 √±_GLIBCXX_HAVE_EPERM 1 √¥_GLIBCXX_HAVE_EPROTO 1 √∫_GLIBCXX_HAVE_ETIMEDOUT 1 ‚Ç¨_GLIBCXX_HAVE_EWOULDBLOCK 1 ‚Ä†_GLIBCXX_HAVE_EXPF 1 ‚Ä∞_GLIBCXX_HAVE_EXPL 1 ≈í_GLIBCXX_HAVE_FABSF 1 ÔøΩ_GLIBCXX_HAVE_FABSL 1 ‚Äô_GLIBCXX_HAVE_FENV_H 1 ‚Ä¢_GLIBCXX_HAVE_FINITE 1 ≈æ_GLIBCXX_HAVE_FLOAT_H 1 ¬°_GLIBCXX_HAVE_FLOORF 1 ¬§_GLIBCXX_HAVE_FLOORL 1 ¬ß_GLIBCXX_HAVE_FMODF 1 ¬™_GLIBCXX_HAVE_FMODL 1 ¬≠_GLIBCXX_HAVE_FPCLASS 1 ¬≥_GLIBCXX_HAVE_FREXPF 1 ¬∂_GLIBCXX_HAVE_FREXPL 1 ¬π_GLIBCXX_HAVE_GETIPINFO 1 ¬º_GLIBCXX_HAVE_GETS 1 ¬ø_GLIBCXX_HAVE_HYPOT 1 √Ç_GLIBCXX_HAVE_HYPOTF 1 √Ö_GLIBCXX_HAVE_HYPOTL 1 √à_GLIBCXX_HAVE_ICONV 1 √ã_GLIBCXX_HAVE_IEEEFP_H 1 √é_GLIBCXX_HAVE_INT64_T 1 √î_GLIBCXX_HAVE_INT64_T_LONG_LONG 1 √ó_GLIBCXX_HAVE_INTTYPES_H 1 √£_GLIBCXX_HAVE_ISNAN 1 √¨_GLIBCXX_HAVE_ISWBLANK 1 √≤_GLIBCXX_HAVE_LDEXPF 1 √µ_GLIBCXX_HAVE_LDEXPL 1 ÔøΩ_GLIBCXX_HAVE_LOCALE_H 1 ÔøΩ_GLIBCXX_HAVE_LOG10F 1 ‚Äú_GLIBCXX_HAVE_LOG10L 1 ‚Äì_GLIBCXX_HAVE_LOGF 1 ‚Ñ¢_GLIBCXX_HAVE_LOGL 1 ¬¢_GLIBCXX_HAVE_MBSTATE_T 1 ¬•_GLIBCXX_HAVE_MEMORY_H 1 ¬®_GLIBCXX_HAVE_MODF 1 ¬´_GLIBCXX_HAVE_MODFF 1 ¬Æ_GLIBCXX_HAVE_MODFL 1 ¬∑_GLIBCXX_HAVE_POWF 1 ¬∫_GLIBCXX_HAVE_POWL 1 √Ü_GLIBCXX_HAVE_SINCOS 1 √â_GLIBCXX_HAVE_SINCOSF 1 √å_GLIBCXX_HAVE_SINCOSL 1 √è_GLIBCXX_HAVE_SINF 1 √í_GLIBCXX_HAVE_SINHF 1 √ï_GLIBCXX_HAVE_SINHL 1 √ò_GLIBCXX_HAVE_SINL 1 √û_GLIBCXX_HAVE_SQRTF 1 √°_GLIBCXX_HAVE_SQRTL 1 √§_GLIBCXX_HAVE_STDALIGN_H 1 √ß_GLIBCXX_HAVE_STDBOOL_H 1 √™_GLIBCXX_HAVE_STDINT_H 1 √≠_GLIBCXX_HAVE_STDLIB_H 1 √∂_GLIBCXX_HAVE_STRINGS_H 1 √π_GLIBCXX_HAVE_STRING_H 1 √º_GLIBCXX_HAVE_STRTOF 1 √ø_GLIBCXX_HAVE_STRTOLD 1 ‚Ä†_GLIBCXX_HAVE_SYMVER_SYMBOL_RENAMING_RUNTIME_SUPPORT 1 Àú_GLIBCXX_HAVE_SYS_PARAM_H 1 ¬§_GLIBCXX_HAVE_SYS_STAT_H 1 ¬™_GLIBCXX_HAVE_SYS_TIME_H 1 ¬≠_GLIBCXX_HAVE_SYS_TYPES_H 1 ¬∂_GLIBCXX_HAVE_S_ISREG 1 ¬π_GLIBCXX_HAVE_TANF 1 ¬º_GLIBCXX_HAVE_TANHF 1 ¬ø_GLIBCXX_HAVE_TANHL 1 √Ç_GLIBCXX_HAVE_TANL 1 √Ö_GLIBCXX_HAVE_TGMATH_H 1 √à_GLIBCXX_HAVE_TLS 1 √ã_GLIBCXX_HAVE_UNISTD_H 1 √ë_GLIBCXX_HAVE_VFWSCANF 1 √î_GLIBCXX_HAVE_VSWSCANF 1 √ó_GLIBCXX_HAVE_VWSCANF 1 √ö_GLIBCXX_HAVE_WCHAR_H 1 √ù_GLIBCXX_HAVE_WCSTOF 1 √†_GLIBCXX_HAVE_WCTYPE_H 1 ¬¢_GLIBCXX_HAVE__FINITEF 1 √í_GLIBCXX_HAVE__ISNANF 1 ¬¶	_GLIBCXX_ICONV_CONST  ¬™	LT_OBJDIR ".libs/" ¬∞	_GLIBCXX_PACKAGE_BUGREPORT "" ¬≥	_GLIBCXX_PACKAGE_NAME "package-unused" ¬∂	_GLIBCXX_PACKAGE_STRING "package-unused version-unused" ¬π	_GLIBCXX_PACKAGE_TARNAME "libstdc++" ¬º	_GLIBCXX_PACKAGE_URL "" ¬ø	_GLIBCXX_PACKAGE__GLIBCXX_VERSION "version-unused" √ë	STDC_HEADERS 1 √ó	_GLIBCXX_ATOMIC_BUILTINS 1 √û	_GLIBCXX_FULLY_DYNAMIC_STRING 1 √°	_GLIBCXX_HAS_GTHREADS 1 √§	_GLIBCXX_HOSTED 1 √µ	_GLIBCXX_STDIO_EOF -1 √∏	_GLIBCXX_STDIO_SEEK_CUR 1 √ª	_GLIBCXX_STDIO_SEEK_END 2 √æ	_GLIBCXX_SYMVER 1 ‚Äû
_GLIBCXX_SYMVER_GNU 1 ≈Ω
_GLIBCXX_USE_C99 1 ‚Äú
_GLIBCXX_USE_C99_COMPLEX 1 Àú
_GLIBCXX_USE_C99_COMPLEX_TR1 1 ≈ì
_GLIBCXX_USE_C99_CTYPE_TR1 1 ¬†
_GLIBCXX_USE_C99_FENV_TR1 1 ¬§
_GLIBCXX_USE_C99_INTTYPES_TR1 1 ¬®
_GLIBCXX_USE_C99_INTTYPES_WCHAR_T_TR1 1 ¬¨
_GLIBCXX_USE_C99_MATH 1 ¬∞
_GLIBCXX_USE_C99_MATH_TR1 1 ¬¥
_GLIBCXX_USE_C99_STDINT_TR1 1 ¬ª
_GLIBCXX_USE_CLOCK_MONOTONIC 1 ¬æ
_GLIBCXX_USE_CLOCK_REALTIME 1 √Ç
_GLIBCXX_USE_DECIMAL_FLOAT 1 √Ö
_GLIBCXX_USE_FLOAT128 1 √à
_GLIBCXX_USE_GETTIMEOFDAY 1 √é
_GLIBCXX_USE_INT128 1 √ë
_GLIBCXX_USE_LFS 1 √î
_GLIBCXX_USE_LONG_LONG 1 √ó
_GLIBCXX_USE_NANOSLEEP 1 √ù
_GLIBCXX_USE_PTHREADS_NUM_PROCESSORS_NP 1 √†
_GLIBCXX_USE_PTHREAD_RWLOCK_T 1 √ß
_GLIBCXX_USE_SCHED_YIELD 1 √≥
_GLIBCXX_USE_TMPNAM 1 √∂
_GLIBCXX_USE_WCHAR_T 1 √π
_GLIBCXX_VERBOSE 1 √º
_GLIBCXX_X86_RDRAND 1 √ø
_GTHREAD_USE_MUTEX_TIMEDLOCK 1 √°_GLIBCXX_HAVE_FINITEF 1 √¢finitef _finitef ¬±_GLIBCXX_HAVE_ISNANF 1 ¬≤isnanf _isnanf '"_GLIBCXX_OSTREAM 1 &"_GLIBCXX_IOS 1 &
"_GLIBCXX_IOSFWD 1 '#_STRINGFWD_H 1 (,_MEMORYFWD_H 1 ($_GLIBCXX_POSTYPES_H 1 (,_INC_WCHAR  	_INC_CRTDEFS  
_INC__MINGW_H  _INC_CRTDEFS_MACRO  
__STRINGIFY(x) #x __MINGW64_STRINGIFY(x) __STRINGIFY(x) __MINGW64_VERSION_MAJOR 4 __MINGW64_VERSION_MINOR 0 __MINGW64_VERSION_RC 0 __MINGW64_VERSION_STR __MINGW64_STRINGIFY(__MINGW64_VERSION_MAJOR) "." __MINGW64_STRINGIFY(__MINGW64_VERSION_MINOR) __MINGW64_VERSION_STATE "stable" $__MINGW32_MAJOR_VERSION 3 %__MINGW32_MINOR_VERSION 11 /_ 0_ 1 4__MINGW_USE_UNDERSCORE_PREFIX 0 6_ C__MINGW_IMP_SYMBOL(sym) __imp_ ##sym D__MINGW_IMP_LSYMBOL(sym) __imp_ ##sym E__MINGW_USYMBOL(sym) sym F__MINGW_LSYMBOL(sym) _ ##sym b_M_AMD64 100 c_M_X64 100 ≈†__MINGW_EXTENSION ÔøΩ__MINGW_EXTENSION __extension__ Àú__C89_NAMELESS __MINGW_EXTENSION ‚Ñ¢__C89_NAMELESSSTRUCTNAME  ≈°__C89_NAMELESSSTRUCTNAME1  ‚Ä∫__C89_NAMELESSSTRUCTNAME2  ≈ì__C89_NAMELESSSTRUCTNAME3  ÔøΩ__C89_NAMELESSSTRUCTNAME4  ≈æ__C89_NAMELESSSTRUCTNAME5  ≈∏__C89_NAMELESSUNIONNAME  ¬†__C89_NAMELESSUNIONNAME1  ¬°__C89_NAMELESSUNIONNAME2  ¬¢__C89_NAMELESSUNIONNAME3  ¬£__C89_NAMELESSUNIONNAME4  ¬§__C89_NAMELESSUNIONNAME5  ¬•__C89_NAMELESSUNIONNAME6  ¬¶__C89_NAMELESSUNIONNAME7  ¬ß__C89_NAMELESSUNIONNAME8  ¬´__GNU_EXTENSION __MINGW_EXTENSION ¬∞__MINGW_HAVE_ANSI_C99_PRINTF 1 ¬±__MINGW_HAVE_WIDE_C99_PRINTF 1 ¬≤__MINGW_HAVE_ANSI_C99_SCANF 1 ¬≥__MINGW_HAVE_WIDE_C99_SCANF 1 ¬∏__MINGW_POISON_NAME(__IFACE) __IFACE ##_layout_has_not_been_verified_and_its_declaration_is_most_likely_incorrect ¬æ__MSABI_LONG(x) x ## l √Ö__MINGW_GCC_VERSION (__GNUC__ * 10000 + __GNUC_MINOR__ * 100 + __GNUC_PATCHLEVEL__) √ç__MINGW_GNUC_PREREQ(major,minor) (__GNUC__ > (major) || (__GNUC__ == (major) && __GNUC_MINOR__ >= (minor))) √ò__MINGW_MSC_PREREQ(major,minor) 0 √§__MINGW_ATTRIB_DEPRECATED_STR(X)  √ß__MINGW_SEC_WARN_STR "This function or variable may be unsafe, use _CRT_SECURE_NO_WARNINGS to disable deprecation" √™__MINGW_MSVC2005_DEPREC_STR "This POSIX function is deprecated beginning in Visual C++ 2005, use _CRT_NONSTDC_NO_DEPRECATE to disable deprecation" √Æ__MINGW_ATTRIB_DEPRECATED_MSVC2005 __MINGW_ATTRIB_DEPRECATED_STR(__MINGW_MSVC2005_DEPREC_STR) √µ__MINGW_ATTRIB_DEPRECATED_SEC_WARN __MINGW_ATTRIB_DEPRECATED_STR(__MINGW_SEC_WARN_STR) √ª__MINGW_MS_PRINTF(__format,__args) __attribute__((__format__(ms_printf, __format,__args))) √æ__MINGW_MS_SCANF(__format,__args) __attribute__((__format__(ms_scanf, __format,__args))) ÔøΩ__MINGW_GNU_PRINTF(__format,__args) __attribute__((__format__(gnu_printf,__format,__args))) ‚Äû__MINGW_GNU_SCANF(__format,__args) __attribute__((__format__(gnu_scanf, __format,__args))) ‚Ä°__mingw_ovr ≈†__mingw_ovr inline __cdecl _INC_MINGW_SECAPI  _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES_MEMORY _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES  _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT !_CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_MEMORY "_CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES 0 #_CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES_MEMORY 0 $_CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES 0 %_CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT 0 &_CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_MEMORY 0 )__MINGW_CRT_NAME_CONCAT2(sym) ::sym ##_s E__CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_MEMORY_0_3_(__ret,__func,__type1,__attrib1,__arg1,__type2,__attrib2,__arg2,__type3,__attrib3,__arg3) _CRTIMP __ret __cdecl __func(__type1 * __attrib1 __arg1, __type2 __attrib2 __arg2, __type3 __attrib3 __arg3) __MINGW_ATTRIB_DEPRECATED_SEC_WARN; __LONG32 long "__stdcall $__stdcall  5__MINGW_IMPORT extern __attribute__ ((__dllimport__)) 8__USE_CRTIMP :__USE_CRTIMP 1 =_CRTIMP __attribute__ ((__dllimport__)) B__DECLSPEC_SUPPORTED  OUSE___UUIDOF 0 S_inline __inline W__CRT_INLINE inline d__MINGW_INTRIN_INLINE extern __inline__ __attribute__((__always_inline__,__gnu_inline__)) i__CRT__NO_INLINE j__CRT__NO_INLINE 1 o__UNUSED_PARAM(x)  ‚Ä†__restrict_arr  ‚Äò__MINGW_ATTRIB_NORETURN __attribute__ ((__noreturn__)) ‚Äô__MINGW_ATTRIB_CONST __attribute__ ((__const__)) ≈ì__MINGW_ATTRIB_MALLOC __attribute__ ((__malloc__)) ÔøΩ__MINGW_ATTRIB_PURE __attribute__ ((__pure__)) ¬™__MINGW_ATTRIB_NONNULL(arg) __attribute__ ((__nonnull__ (arg))) ¬∞__MINGW_ATTRIB_UNUSED __attribute__ ((__unused__)) ¬∂__MINGW_ATTRIB_USED __attribute__ ((__used__)) ¬∑__MINGW_ATTRIB_DEPRECATED __attribute__ ((__deprecated__)) √Å__MINGW_NOTHROW __attribute__ ((__nothrow__)) √â__MINGW_ATTRIB_NO_OPTIMIZE __attribute__((__optimize__ ("0"))) √è__MINGW_PRAGMA_PARAM(x) _Pragma (#x) √ñ__MINGW_BROKEN_INTERFACE(x) __MINGW_PRAGMA_PARAM(message ("Interface " _CRT_STRINGIZE(x) " has unverified layout.")) √ú__MSVCRT_VERSION__ 0x0700 √°_WIN32_WINNT 0x502 √•_INT128_DEFINED  √ß__int8 char √®__int16 short √©__int32 int √™__int64 long long √∏__ptr32  √π__ptr64  √ª__unaligned  √æ__w64  ÔøΩ__forceinline inline __attribute__((__always_inline__)) ÔøΩ__nothrow __declspec(nothrow) ‚Äú_INC_VADEFS  	¬≠MINGW_SDK_INIT  ¬µ __MINGW_HAS_DXSDK 1 MINGW_HAS_DDRAW_H 1 MINGW_DDRAW_VERSION 7 ¬∂!MINGW_DDK_H  MINGW_HAS_DDK_H 1 _CRT_PACKING _CRT_PACKING 8 __GNUC_VA_LIST  _VA_LIST_DEFINED  (_ADDRESSOF(v) (&reinterpret_cast<const char &>(v)) 0_crt_va_start(v,l) __builtin_va_start(v,l) 1_crt_va_arg(v,l) __builtin_va_arg(v,l) 2_crt_va_end(v) __builtin_va_end(v) 3_crt_va_copy(d,s) __builtin_va_copy(d,s) ‚Äì__CRT_STRINGIZE(_Value) #_Value ‚Äî_CRT_STRINGIZE(_Value) __CRT_STRINGIZE(_Value) ‚Ä∫__CRT_WIDE(_String) L ## _String ≈ì_CRT_WIDE(_String) __CRT_WIDE(_String) ¬†_W64  ¬ß_CRTIMP_NOIA64 _CRTIMP ¬¨_CRTIMP2 _CRTIMP ¬∞_CRTIMP_ALTERNATIVE _CRTIMP ¬±_CRT_ALTERNATIVE_IMPORTED  ¬µ_MRTIMP2 _CRTIMP ¬æ_DLL  √Ü_MCRTIMP _CRTIMP √ä_CRTIMP_PURE _CRTIMP √é_PGLOBAL  √í_AGLOBAL  √ï_SECURECRT_FILL_BUFFER_PATTERN 0xFD √ñ_CRT_DEPRECATE_TEXT(_Text) __declspec(deprecated) √ô_CRT_INSECURE_DEPRECATE_MEMORY(_Replacement)  √ù_CRT_INSECURE_DEPRECATE_GLOBALS(_Replacement)  √°_CRT_MANAGED_HEAP_DEPRECATE  √•_CRT_OBSOLETE(_NewItem)  √±_CONST_RETURN  √∂UNALIGNED __unaligned ‚Ç¨_CRT_ALIGN(x) __attribute__ ((__aligned__ (x))) ‚Ä°__CRTDECL __cdecl ≈†_ARGMAX 100 ÔøΩ_TRUNCATE ((size_t)-1) ‚Äò_CRT_UNUSED(x) (void)x ¬µ_CRT_glob ¬∂_CRT_glob _dowildcard √Ü__ANONYMOUS_DEFINED  √á_ANONYMOUS_UNION __MINGW_EXTENSION √à_ANONYMOUS_STRUCT __MINGW_EXTENSION √ä_UNION_NAME(x)  √ã_STRUCT_NAME(x)  √üDUMMYUNIONNAME  √†DUMMYUNIONNAME1  √°DUMMYUNIONNAME2  √¢DUMMYUNIONNAME3  √£DUMMYUNIONNAME4  √§DUMMYUNIONNAME5  √•DUMMYUNIONNAME6  √¶DUMMYUNIONNAME7  √ßDUMMYUNIONNAME8  √®DUMMYUNIONNAME9  √µDUMMYSTRUCTNAME  √∂DUMMYSTRUCTNAME1  √∑DUMMYSTRUCTNAME2  √∏DUMMYSTRUCTNAME3  √πDUMMYSTRUCTNAME4  √∫DUMMYSTRUCTNAME5  ‚Äö__CRT_UUID_DECL(type,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) extern "C++" { template<> inline const GUID &__mingw_uuidof<type>() { static const IID __uuid_inst = {l,w1,w2, {b1,b2,b3,b4,b5,b6,b7,b8}}; return __uuid_inst; } template<> inline const GUID &__mingw_uuidof<type*>() { return __mingw_uuidof<type>(); } } ÔøΩ__uuidof(type) __mingw_uuidof<__typeof(type)>() _CRT_PACKING _CRT_PACKING 8 _CRTNOALIAS  _CRTRESTRICT   _SIZE_T_DEFINED  !size_t *_SSIZE_T_DEFINED  +ssize_t 5_RSIZE_T_DEFINED  9_INTPTR_T_DEFINED  ;__intptr_t_defined  <intptr_t F_UINTPTR_T_DEFINED  H__uintptr_t_defined  Iuintptr_t S_PTRDIFF_T_DEFINED  U_PTRDIFF_T_  Vptrdiff_t `_WCHAR_T_DEFINED  g_WCTYPE_T_DEFINED  i_WINT_T  p_ERRCODE_DEFINED  u_TIME32_T_DEFINED  z_TIME64_T_DEFINED  ‚Ä†_TIME_T_DEFINED  ÔøΩ_CRT_SECURE_CPP_NOTHROW throw() √æ__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_0(__ret,__func,__dsttype,__dst)  √ø__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1(__ret,__func,__dsttype,__dst,__type1,__arg1)  ‚Ç¨__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2(__ret,__func,__dsttype,__dst,__type1,__arg1,__type2,__arg2)  ÔøΩ__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_3(__ret,__func,__dsttype,__dst,__type1,__arg1,__type2,__arg2,__type3,__arg3)  ‚Äö__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_4(__ret,__func,__dsttype,__dst,__type1,__arg1,__type2,__arg2,__type3,__arg3,__type4,__arg4)  ∆í__DEFINE_CPP_OVERLOAD_SECURE_FUNC_1_1(__ret,__func,__type0,__arg0,__dsttype,__dst,__type1,__arg1)  ‚Äû__DEFINE_CPP_OVERLOAD_SECURE_FUNC_1_2(__ret,__func,__type0,__arg0,__dsttype,__dst,__type1,__arg1,__type2,__arg2)  ‚Ä¶__DEFINE_CPP_OVERLOAD_SECURE_FUNC_1_3(__ret,__func,__type0,__arg0,__dsttype,__dst,__type1,__arg1,__type2,__arg2,__type3,__arg3)  ‚Ä†__DEFINE_CPP_OVERLOAD_SECURE_FUNC_2_0(__ret,__func,__type1,__arg1,__type2,__arg2,__dsttype,__dst)  ‚Ä°__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1_ARGLIST(__ret,__func,__vfunc,__dsttype,__dst,__type1,__arg1)  ÀÜ__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2_ARGLIST(__ret,__func,__vfunc,__dsttype,__dst,__type1,__arg1,__type2,__arg2)  ‚Ä∞__DEFINE_CPP_OVERLOAD_SECURE_FUNC_SPLITPATH(__ret,__func,__dsttype,__src)  ÔøΩ__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_0(__ret_type,__ret_policy,__decl_spec,__name,__dst_attr,__dst_type,__dst) __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_0_EX(__ret_type, __ret_policy, __decl_spec, __func_name, __func_name ##_s, __dst_attr, __dst_type, __dst) ÔøΩ__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1(__ret_type,__ret_policy,__decl_spec,__name,__dst_attr,__dst_type,__dst,__arg1_type,__arg1) __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2_EX(__ret_type, __ret_policy, __decl_spec, __func_name, __func_name ##_s, __dst_attr, __dst_type, __dst, __arg1_type, __arg1, __arg2_type, __arg2) ‚Äò__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2(__ret_type,__ret_policy,__decl_spec,__name,__dst_attr,__dst_type,__dst,__arg1_type,__arg1,__arg2_type,__arg2) __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2_EX(__ret_type, __ret_policy, __decl_spec, __func_name, __func_name ##_s, __dst_attr, __dst_type, __dst, __arg1_type, __arg1, __arg2_type, __arg2) ‚Äú__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_3(__ret_type,__ret_policy,__decl_spec,__name,__dst_attr,__dst_type,__dst,__arg1_type,__arg1,__arg2_type,__arg2,__arg3_type,__arg3) __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_3_EX(__ret_type, __ret_policy, __decl_spec, __func_name, __func_name ##_s, __dst_attr, __dst_type, __dst, __arg1_type, __arg1, __arg2_type, __arg2, __arg3_type, __arg3) ‚Ä¢__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_4(__ret_type,__ret_policy,__decl_spec,__name,__dst_attr,__dst_type,__dst,__arg1_type,__arg1,__arg2_type,__arg2,__arg3_type,__arg3,__arg4_type,__arg4) __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_4_EX(__ret_type, __ret_policy, __decl_spec, __func_name, __func_name ##_s, __dst_attr, __dst_type, __dst, __arg1_type, __arg1, __arg2_type, __arg2, __arg3_type, __arg3, __arg4_type, __arg4) ≈æ__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_0_EX(__ret_type,__ret_policy,__decl_spec,__name,__sec_name,__dst_attr,__dst_type,__dst)  ≈∏__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1_EX(__ret_type,__ret_policy,__decl_spec,__name,__sec_name,__dst_attr,__dst_type,__dst,__arg1_type,__arg1)  ¬†__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2_EX(__ret_type,__ret_policy,__decl_spec,__name,__sec_name,__dst_attr,__dst_type,__dst,__arg1_type,__arg1,__arg2_type,__arg2)  ¬°__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_3_EX(__ret_type,__ret_policy,__decl_spec,__name,__sec_name,__dst_attr,__dst_type,__dst,__arg1_type,__arg1,__arg2_type,__arg2,__arg3_type,__arg3)  ¬¢__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_4_EX(__ret_type,__ret_policy,__decl_spec,__name,__sec_name,__dst_attr,__dst_type,__dst,__arg1_type,__arg1,__arg2_type,__arg2,__arg3_type,__arg3,__arg4_type,__arg4)  ¬≤_TAGLC_ID_DEFINED  ¬ª_THREADLOCALEINFO  √ò__crt_typefix(ctype)  
"__USE_MINGW_STRTOX 1 WCHAR_MIN 0U WCHAR_MAX 0xffffU WEOF (wint_t)(0xFFFF) +_FILE_DEFINED  1_iob __iob_func() <_iob __iob_func() @stdin (&__iob_func()[0]) Astdout (&__iob_func()[1]) Bstderr (&__iob_func()[2]) C_STDSTREAM_DEFINED  H_FSIZE_T_DEFINED  z_wfinddata_t _wfinddata64i32_t {_wfinddatai64_t _wfinddata64_t }_wfindfirst _wfindfirst64i32 ~_wfindnext _wfindnext64i32 _wfindfirsti64 _wfindfirst64 ‚Ç¨_wfindnexti64 _wfindnext64 ∆í_WFINDDATA_T_DEFINED  ‚ÄπNULL 0LL ‚Äì_WConst_return _CONST_RETURN ‚Ñ¢_CRT_CTYPEDATA_DEFINED  ÔøΩ__PCTYPE_FUNC __pctype_func() ¬°__pctype_func() (* __MINGW_IMP_SYMBOL(_pctype)) ¬™_pctype (* __MINGW_IMP_SYMBOL(_pctype)) ¬±_CRT_WCTYPEDATA_DEFINED  ¬∏_wctype (* __MINGW_IMP_SYMBOL(_wctype)) ¬ø__pwctype_func() (* __MINGW_IMP_SYMBOL(_pwctype)) √á_pwctype (* __MINGW_IMP_SYMBOL(_pwctype)) √é_UPPER 0x1 √è_LOWER 0x2 √ê_DIGIT 0x4 √ë_SPACE 0x8 √ì_PUNCT 0x10 √î_CONTROL 0x20 √ï_BLANK 0x40 √ñ_HEX 0x80 √ò_LEADBYTE 0x8000 √ô_ALPHA (0x0100|_UPPER|_LOWER) √ú_WCTYPE_DEFINED  ≈†_WDIRECT_DEFINED  ‚Ä¢_WIO_DEFINED  ¬´_WLOCALE_DEFINED  ¬∞_WEXEC_DEFINED  ¬º_WSPAWN_DEFINED  √à_CRT_WSYSTEM_DEFINED  √ç_CRT_WCTYPE_NOINLINE √´_WCTYPE_INLINE_DEFINED  √∞_INO_T_DEFINED  √∏_DEV_T_DEFINED  √ø#_OFF_T_DEFINED  _OFF_T_  _OFF64_T_DEFINED  _FILE_OFFSET_BITS_SET_OFFT  ‚Ç¨$_fstat _fstat64i32 _fstati64 _fstat64 _stat _stat64i32 _stati64 _stat64 _wstat _wstat64i32 _wstati64 _wstat64 [__stat64 _stat64 \stat64 _stat64 ]fstat64 _fstat64 __STAT_DEFINED  ∆í_WSTAT_DEFINED  ÔøΩ_WCONIO_DEFINED  ¬´_WSTDIO_DEFINED  √å__mingw_ovr √é__mingw_ovr static __attribute__ ((__unused__)) __inline__ __cdecl √é_INC_SWPRINTF_INL  __mingw_ovr __mingw_ovr static __attribute__ ((__unused__)) __inline__ __cdecl √•_CRT_WPERROR_DEFINED  √™wpopen _wpopen √≤_CRT_GETPUTWCHAR_NOINLINE √µgetwchar() fgetwc(stdin) √∂putwchar(_c) fputwc((_c),stdout) √ºgetwc(_stm) fgetwc(_stm) √Ωputwc(_c,_stm) fputwc(_c,_stm) √æ_putwc_nolock(_c,_stm) _fputwc_nolock(_c,_stm) √ø_getwc_nolock(_c) _fgetwc_nolock(_c) ∆í_WSTDLIB_DEFINED  ¬ª_WSTDLIBP_DEFINED  √â_WSTRING_DEFINED  √µwcswcs wcsstr ‚Äö_TM_DEFINED  ‚Äò_WTIME_DEFINED  ≈ì_INC_WTIME_INL  √¶__MINGW_MBWC_CONVERT_DEFINED  ‚Äù%_INC_WCHAR_S  	‚Äì&0_GLIBCXX_CWCHAR 1 Dbtowc Efgetwc Ffgetws Gfputwc Hfputws Ifwide Jfwprintf Kfwscanf Lgetwc Mgetwchar Nmbrlen Ombrtowc Pmbsinit Qmbsrtowcs Rputwc Sputwchar Tswprintf Uswscanf Vungetwc Wvfwprintf Yvfwscanf [vswprintf ]vswscanf _vwprintf avwscanf cwcrtomb dwcscat ewcschr fwcscmp gwcscoll hwcscpy iwcscspn jwcsftime kwcslen lwcsncat mwcsncmp nwcsncpy owcspbrk pwcsrchr qwcsrtombs rwcsspn swcsstr twcstod vwcstof xwcstok ywcstol zwcstoul {wcsxfrm |wctob }wmemchr ~wmemcmp wmemcpy ‚Ç¨wmemmove ÔøΩwmemset ‚Äöwprintf ∆íwscanf √≠wcstold √Æwcstoll √Øwcstoull ''__EXCEPTION__  &(_GLIBCXX_ATOMIC_LOCK_FREE_H 1 (#_CHAR_TRAITS_H 1 ')9_STL_ALGOBASE_H 1 <*%_FUNCTEXCEPT_H 1 (+_EXCEPTION_DEFINES_H 1 (__try try )__catch(X) catch(X) *__throw_exception_again throw =,!_CPP_TYPE_TRAITS_H 1 √ø__INT_N(TYPE) template<> struct __is_integer<TYPE> { enum { __value = 1 }; typedef __true_type __type; }; template<> struct __is_integer<unsigned TYPE> { enum { __value = 1 }; typedef __true_type __type; }; ≈°__INT_N >-_EXT_TYPE_TRAITS 1 ?_EXT_NUMERIC_TRAITS 1 +__glibcxx_signed(_Tp) ((_Tp)(-1) < 0) ,__glibcxx_digits(_Tp) (sizeof(_Tp) * __CHAR_BIT__ - __glibcxx_signed(_Tp)) /__glibcxx_min(_Tp) (__glibcxx_signed(_Tp) ? (_Tp)1 << __glibcxx_digits(_Tp) : (_Tp)0) 2__glibcxx_max(_Tp) (__glibcxx_signed(_Tp) ? (((((_Tp)1 << (__glibcxx_digits(_Tp) - 1)) - 1) << 1) + 1) : ~(_Tp)0) O__glibcxx_signed P__glibcxx_digits Q__glibcxx_min R__glibcxx_max T__glibcxx_floating(_Tp,_Fval,_Dval,_LDval) (std::__are_same<_Tp, float>::__value ? _Fval : std::__are_same<_Tp, double>::__value ? _Dval : _LDval) X__glibcxx_max_digits10(_Tp) (2 + __glibcxx_floating(_Tp, __FLT_MANT_DIG__, __DBL_MANT_DIG__, __LDBL_MANT_DIG__) * 643L / 2136) \__glibcxx_digits10(_Tp) __glibcxx_floating(_Tp, __FLT_DIG__, __DBL_DIG__, __LDBL_DIG__) ___glibcxx_max_exponent10(_Tp) __glibcxx_floating(_Tp, __FLT_MAX_10_EXP__, __DBL_MAX_10_EXP__, __LDBL_MAX_10_EXP__) ‚Ä¶__glibcxx_floating ‚Ä†__glibcxx_max_digits10 ‚Ä°__glibcxx_digits10 ÀÜ__glibcxx_max_exponent10 @.9_STL_PAIR_H 1 ;/_MOVE_H 1 "0_CONCEPT_CHECK_H 1 /__glibcxx_function_requires(...)  0__glibcxx_class_requires(_a,_b)  1__glibcxx_class_requires2(_a,_b,_c)  2__glibcxx_class_requires3(_a,_b,_c,_d)  3__glibcxx_class_requires4(_a,_b,_c,_d,_e)  ‚Ä∫_GLIBCXX_MOVE(__val) (__val) ≈ì_GLIBCXX_FORWARD(_Tp,__val) (__val) A1<_STL_ITERATOR_BASE_TYPES_H 1 B2<_STL_ITERATOR_BASE_FUNCS_H 1 A_GLIBCXX_DEBUG_MACRO_SWITCH_H 1 =_GLIBCXX_DEBUG_ASSERT(_Condition)  >_GLIBCXX_DEBUG_PEDASSERT(_Condition)  ?_GLIBCXX_DEBUG_ONLY(_Statement) ; @__glibcxx_requires_cond(_Cond,_Msg)  A__glibcxx_requires_valid_range(_First,_Last)  B__glibcxx_requires_non_empty_range(_First,_Last)  C__glibcxx_requires_sorted(_First,_Last)  D__glibcxx_requires_sorted_pred(_First,_Last,_Pred)  E__glibcxx_requires_sorted_set(_First1,_Last1,_First2)  F__glibcxx_requires_sorted_set_pred(_First1,_Last1,_First2,_Pred)  G__glibcxx_requires_partitioned_lower(_First,_Last,_Value)  H__glibcxx_requires_partitioned_upper(_First,_Last,_Value)  I__glibcxx_requires_partitioned_lower_pred(_First,_Last,_Value,_Pred)  J__glibcxx_requires_partitioned_upper_pred(_First,_Last,_Value,_Pred)  K__glibcxx_requires_heap(_First,_Last)  L__glibcxx_requires_heap_pred(_First,_Last,_Pred)  M__glibcxx_requires_nonempty()  N__glibcxx_requires_string(_String)  O__glibcxx_requires_string_len(_String,_Len)  P__glibcxx_requires_subscript(_N)  C3=_STL_ITERATOR_H 1 B4_PTR_TRAITS_H 1 ≈°	_GLIBCXX_MAKE_MOVE_ITERATOR(_Iter) (_Iter) ‚Ä∫	_GLIBCXX_MAKE_MOVE_IF_NOEXCEPT_ITERATOR(_Iter) (_Iter) G_GLIBCXX_PREDEFINED_OPS_H 1 √ª_GLIBCXX_MOVE3(_Tp,_Up,_Vp) std::copy(_Tp, _Up, _Vp) ¬Ø_GLIBCXX_MOVE_BACKWARD3(_Tp,_Up,_Vp) std::copy_backward(_Tp, _Up, _Vp) ))5#_LOCALE_FWD_H 1 (6%_GLIBCXX_CXX_LOCALE_H 1 )*_INC_LOCALE  7_INC_STDIO  "BUFSIZ 512 _NFILE _NSTREAM_ _NSTREAM_ 512 _IOB_ENTRIES 20 EOF (-1) ,_P_tmpdir "\\" -_wP_tmpdir L"\\" 0L_tmpnam (sizeof(_P_tmpdir) + 12) 7SEEK_CUR 1 8SEEK_END 2 9SEEK_SET 0 ;STDIN_FILENO 0 <STDOUT_FILENO 1 =STDERR_FILENO 2 ?FILENAME_MAX 260 @FOPEN_MAX 20 A_SYS_OPEN 20 BTMP_MAX 32767 U_iob __iob_func() c_FPOS_T_DEFINED  d_FPOSOFF h_FPOSOFF(fp) ((long)(fp)) x_IOREAD 0x0001 y_IOWRT 0x0002 {_IOFBF 0x0000 |_IOLBF 0x0040 }_IONBF 0x0004 _IOMYBUF 0x0008 ‚Ç¨_IOEOF 0x0010 ÔøΩ_IOERR 0x0020 ‚Äö_IOSTRG 0x0040 ∆í_IORW 0x0080 ÀÜ_TWO_DIGIT_EXPONENT 0x1 √Ç__MINGW_PRINTF_FORMAT √É__MINGW_SCANF_FORMAT √Ñ__MINGW_PRINTF_FORMAT gnu_printf √Ö__MINGW_SCANF_FORMAT gnu_scanf √§__builtin_vsnprintf __mingw_vsnprintf √•__builtin_vsprintf __mingw_vsprintf √í_FILE_OFFSET_BITS_SET_FSEEKO  √û_FILE_OFFSET_BITS_SET_FTELLO  √≠_CRT_PERROR_DEFINED  √≥popen _popen √¥pclose _pclose √ª_CRT_DIRECTORY_DEFINED  √®_STDIO_DEFINED  √´_fgetc_nolock(_stream) (--(_stream)->_cnt >= 0 ? 0xff & *(_stream)->_ptr++ : _filbuf(_stream)) √¨_fputc_nolock(_c,_stream) (--(_stream)->_cnt >= 0 ? 0xff & (*(_stream)->_ptr++ = (char)(_c)) : _flsbuf((_c),(_stream))) √≠_getc_nolock(_stream) _fgetc_nolock(_stream) √Æ_putc_nolock(_c,_stream) _fputc_nolock(_c,_stream) √Ø_getchar_nolock() _getc_nolock(stdin) √∞_putchar_nolock(_c) _putc_nolock((_c),stdout) √±_getwchar_nolock() _getwc_nolock(stdin) √≤_putwchar_nolock(_c) _putwc_nolock((_c),stdout) ÔøΩP_tmpdir _P_tmpdir ‚ÄöSYS_OPEN _SYS_OPEN √Ü_P_WAIT 0 √á_P_NOWAIT 1 √à_OLD_P_OVERLAY 2 √â_P_NOWAITO 3 √ä_P_DETACH 4 √ã_P_OVERLAY 2 √ç_WAIT_CHILD 0 √é_WAIT_GRANDCHILD 1 √í_SPAWNV_DEFINED  √ü8_INC_STDIO_S  	7√°&!LC_ALL 0 "LC_COLLATE 1 #LC_CTYPE 2 $LC_MONETARY 3 %LC_NUMERIC 4 &LC_TIME 5 (LC_MIN LC_ALL )LC_MAX LC_TIME ,_LCONV_DEFINED  D_CONFIG_LOCALE_SWT  F_ENABLE_PER_THREAD_LOCALE 0x1 G_DISABLE_PER_THREAD_LOCALE 0x2 H_ENABLE_PER_THREAD_LOCALE_GLOBAL 0x10 I_DISABLE_PER_THREAD_LOCALE_GLOBAL 0x20 J_ENABLE_PER_THREAD_LOCALE_NEW 0x100 K_DISABLE_PER_THREAD_LOCALE_NEW 0x200 -_GLIBCXX_CLOCALE 1 0setlocale 1localeconv +_GLIBCXX_NUM_CATEGORIES 0 *9*:_INC_CTYPE  T_UPPER 0x1 U_LOWER 0x2 V_DIGIT 0x4 W_SPACE 0x8 Y_PUNCT 0x10 Z_CONTROL 0x20 [_BLANK 0x40 \_HEX 0x80 ^_LEADBYTE 0x8000 __ALPHA (0x0100|_UPPER|_LOWER) b_CTYPE_DEFINED  ¬ºMB_CUR_MAX ___mb_cur_max_func() √É__mb_cur_max (* __MINGW_IMP_SYMBOL(__mb_cur_max)) √Ü___mb_cur_max_func() (__mb_cur_max) √â__chvalidchk(a,b) (__PCTYPE_FUNC[(a)] & (b)) √ä_chvalidchk_l(_Char,_Flag,_Locale) (!_Locale ? __chvalidchk(_Char,_Flag) : ((_locale_t)_Locale)->locinfo->pctype[_Char] & (_Flag)) √ã_ischartype_l(_Char,_Flag,_Locale) (((_Locale)!=NULL && (((_locale_t)(_Locale))->locinfo->mb_cur_max) > 1) ? _isctype_l(_Char,(_Flag),_Locale) : _chvalidchk_l(_Char,_Flag,_Locale)) √å_isalpha_l(_Char,_Locale) _ischartype_l(_Char,_ALPHA,_Locale) √ç_isupper_l(_Char,_Locale) _ischartype_l(_Char,_UPPER,_Locale) √é_islower_l(_Char,_Locale) _ischartype_l(_Char,_LOWER,_Locale) √è_isdigit_l(_Char,_Locale) _ischartype_l(_Char,_DIGIT,_Locale) √ê_isxdigit_l(_Char,_Locale) _ischartype_l(_Char,_HEX,_Locale) √ë_isspace_l(_Char,_Locale) _ischartype_l(_Char,_SPACE,_Locale) √í_ispunct_l(_Char,_Locale) _ischartype_l(_Char,_PUNCT,_Locale) √ì_isalnum_l(_Char,_Locale) _ischartype_l(_Char,_ALPHA|_DIGIT,_Locale) √î_isprint_l(_Char,_Locale) _ischartype_l(_Char,_BLANK|_PUNCT|_ALPHA|_DIGIT,_Locale) √ï_isgraph_l(_Char,_Locale) _ischartype_l(_Char,_PUNCT|_ALPHA|_DIGIT,_Locale) √ñ_iscntrl_l(_Char,_Locale) _ischartype_l(_Char,_CONTROL,_Locale) √ó_tolower(_Char) ((_Char)-'A'+'a') √ò_toupper(_Char) ((_Char)-'a'+'A') √ô__isascii(_Char) ((unsigned)(_Char) < 0x80) √ö__toascii(_Char) ((_Char) & 0x7f) √ª__iscsymf(_c) (isalpha(_c) || ((_c)=='_')) √º__iscsym(_c) (isalnum(_c) || ((_c)=='_')) √Ω__iswcsymf(_c) (iswalpha(_c) || ((_c)=='_')) √æ__iswcsym(_c) (iswalnum(_c) || ((_c)=='_')) √ø_iscsymf_l(_c,_p) (_isalpha_l(_c,_p) || ((_c)=='_')) ‚Ç¨_iscsym_l(_c,_p) (_isalnum_l(_c,_p) || ((_c)=='_')) ÔøΩ_iswcsymf_l(_c,_p) (_iswalpha_l(_c,_p) || ((_c)=='_')) ‚Äö_iswcsym_l(_c,_p) (_iswalnum_l(_c,_p) || ((_c)=='_')) ≈íisascii __isascii ÔøΩtoascii __toascii ≈Ωiscsymf __iscsymf ÔøΩiscsym __iscsym -_GLIBCXX_CCTYPE 1 0isalnum 1isalpha 2iscntrl 3isdigit 4isgraph 5islower 6isprint 7ispunct 8isspace 9isupper :isxdigit ;tolower <toupper *#_IOS_BASE_H 1 ';_GLIBCXX_ATOMICITY_H 1 #<_GLIBCXX_GCC_GTHR_H  ≈í_GLIBCXX_GTHREAD_USE_WEAK ÔøΩ_GLIBCXX_GTHREAD_USE_WEAK 0 ‚Äù=_GLIBCXX_GCC_GTHR_POSIX_H   __GTHREADS 1 !__GTHREADS_CXX0X 1 "><WIN_PTHREADS_H  >?@
_INC_STDDEF  _CRT_ERRNO_DEFINED  errno (*_errno()) _threadid (__threadid()) 1_STDDEF_H  2_STDDEF_H_  4_ANSI_STDDEF_H  6__STDDEF_H__  ¬£__need_ptrdiff_t √∞__need_size_t √ë__need_wchar_t ≈†NULL ≈íNULL __null ‚Ñ¢__need_NULL ≈æoffsetof(TYPE,MEMBER) __builtin_offsetof (TYPE, MEMBER) ?A_INC_ERRNO  EPERM 1 ENOENT 2 ENOFILE ENOENT ESRCH 3 EINTR 4 EIO 5 ENXIO 6 E2BIG 7  ENOEXEC 8 !EBADF 9 "ECHILD 10 #EAGAIN 11 $ENOMEM 12 %EACCES 13 &EFAULT 14 'EBUSY 16 (EEXIST 17 )EXDEV 18 *ENODEV 19 +ENOTDIR 20 ,EISDIR 21 -ENFILE 23 .EMFILE 24 /ENOTTY 25 0EFBIG 27 1ENOSPC 28 2ESPIPE 29 3EROFS 30 4EMLINK 31 5EPIPE 32 6EDOM 33 7EDEADLK 36 8ENAMETOOLONG 38 9ENOLCK 39 :ENOSYS 40 ;ENOTEMPTY 41 ?_SECURECRT_ERRCODE_VALUES_DEFINED  @EINVAL 22 AERANGE 34 BEILSEQ 42 CSTRUNCATE 80 GEDEADLOCK EDEADLK LENOTSUP 129 REAFNOSUPPORT 102 VEADDRINUSE 100 ZEADDRNOTAVAIL 101 ^EISCONN 113 bENOBUFS 119 fECONNABORTED 106 jEALREADY 103 nECONNREFUSED 107 rECONNRESET 108 vEDESTADDRREQ 109 zEHOSTUNREACH 110 ~EMSGSIZE 115 ‚ÄöENETDOWN 116 ‚Ä†ENETRESET 117 ≈†ENETUNREACH 118 ≈ΩENOPROTOOPT 123 ‚ÄôENOTSOCK 128 ‚ÄìENOTCONN 126 ≈°ECANCELED 105 ≈æEINPROGRESS 112 ¬¢EOPNOTSUPP 130 ¬¶EWOULDBLOCK 140 ¬™EOWNERDEAD 133 ¬ÆEPROTO 134 ¬≤EPROTONOSUPPORT 135 ¬∑ETIMEDOUT 138 ¬ªELOOP 114 ¬øEPROTOTYPE 136 √ÉEOVERFLOW 132 @B_INC_TYPES  :_PID_T_  Cpid_t I_MODE_T_  X_TIMESPEC_DEFINED  e_SIGSET_T_  BC_INC_PROCESS  %_CRT_TERMINATE_DEFINED  3abort S_CRT_SYSTEM_DEFINED  ‚ÄòP_WAIT _P_WAIT ‚ÄôP_NOWAIT _P_NOWAIT ‚ÄúP_OVERLAY _P_OVERLAY ‚ÄùOLD_P_OVERLAY _OLD_P_OVERLAY ‚Ä¢P_NOWAITO _P_NOWAITO ‚ÄìP_DETACH _P_DETACH ‚ÄîWAIT_CHILD _WAIT_CHILD ÀúWAIT_GRANDCHILD _WAIT_GRANDCHILD ¬´_CRT_GETPID_DEFINED  CD_GCC_LIMITS_H_  "E_GCC_NEXT_LIMITS_H  D¬®F	_INC_LIMITS  PATH_MAX 260 CHAR_BIT 8 SCHAR_MIN (-128) SCHAR_MAX 127 UCHAR_MAX 0xff CHAR_MIN SCHAR_MIN CHAR_MAX SCHAR_MAX MB_LEN_MAX 5 SHRT_MIN (-32768)  SHRT_MAX 32767 !USHRT_MAX 0xffffU "INT_MIN (-2147483647 - 1) #INT_MAX 2147483647 $UINT_MAX 0xffffffffU %LONG_MIN (-2147483647L - 1) &LONG_MAX 2147483647L 'ULONG_MAX 0xffffffffUL (LLONG_MAX 9223372036854775807ll )LLONG_MIN (-9223372036854775807ll - 1) *ULLONG_MAX 0xffffffffffffffffull ,_I8_MIN (-127 - 1) -_I8_MAX 127 ._UI8_MAX 0xffu 0_I16_MIN (-32767 - 1) 1_I16_MAX 32767 2_UI16_MAX 0xffffu 4_I32_MIN (-2147483647 - 1) 5_I32_MAX 2147483647 6_UI32_MAX 0xffffffffu 9LONG_LONG_MAX :LONG_LONG_MAX 9223372036854775807ll ;LONG_LONG_MIN <LONG_LONG_MIN (-LONG_LONG_MAX-1) =ULONG_LONG_MAX >ULONG_LONG_MAX (2ull * LONG_LONG_MAX + 1ull) A_I64_MIN (-9223372036854775807ll - 1) B_I64_MAX 9223372036854775807ll C_UI64_MAX 0xffffffffffffffffull GSIZE_MAX _UI64_MAX OSSIZE_MAX _I64_MAX _GCC_NEXT_LIMITS_H <_LIMITS_H___  ?CHAR_BIT @CHAR_BIT __CHAR_BIT__ HSCHAR_MIN ISCHAR_MIN (-SCHAR_MAX - 1) JSCHAR_MAX KSCHAR_MAX __SCHAR_MAX__ NUCHAR_MAX RUCHAR_MAX (SCHAR_MAX * 2 + 1) `CHAR_MIN aCHAR_MIN SCHAR_MIN bCHAR_MAX cCHAR_MAX SCHAR_MAX gSHRT_MIN hSHRT_MIN (-SHRT_MAX - 1) iSHRT_MAX jSHRT_MAX __SHRT_MAX__ mUSHRT_MAX qUSHRT_MAX (SHRT_MAX * 2 + 1) uINT_MIN vINT_MIN (-INT_MAX - 1) wINT_MAX xINT_MAX __INT_MAX__ {UINT_MAX |UINT_MAX (INT_MAX * 2U + 1U) ‚Ç¨LONG_MIN ÔøΩLONG_MIN (-LONG_MAX - 1L) ‚ÄöLONG_MAX ∆íLONG_MAX __LONG_MAX__ ‚Ä†ULONG_MAX ‚Ä°ULONG_MAX (LONG_MAX * 2UL + 1UL) ‚ÄîLONG_LONG_MIN ÀúLONG_LONG_MIN (-LONG_LONG_MAX - 1LL) ‚Ñ¢LONG_LONG_MAX ≈°LONG_LONG_MAX __LONG_LONG_MAX__ ÔøΩULONG_LONG_MAX ≈æULONG_LONG_MAX (LONG_LONG_MAX * 2ULL + 1ULL) DG_INC_SIGNAL  
HWIN_PTHREADS_SIGNAL_H  pthread_sigmask(H,S1,S2) 0 _SIG_ATOMIC_T_DEFINED  NSIG 23 SIGINT 2 SIGILL 4 SIGABRT_COMPAT 6 SIGFPE 8 SIGSEGV 11 SIGTERM 15 SIGBREAK 21 SIGABRT 22 SIGABRT2 22 2SIG_DFL (__p_sig_fn_t)0 3SIG_IGN (__p_sig_fn_t)1 4SIG_GET (__p_sig_fn_t)2 5SIG_SGE (__p_sig_fn_t)3 6SIG_ACK (__p_sig_fn_t)4 7SIG_ERR (__p_sig_fn_t)-1 :_pxcptinfoptrs (*__pxcptinfoptrs()) FI_TIMEB_H_  3_TIMEB_DEFINED  Q_timeb __timeb64 |J_TIMEB_H_S  
IHK=WIN_PTHREADS_PTHREAD_COMPAT_H  AWINPTHREADS_INLINE inline BWINPTHREADS_ATTRIBUTE(X) __attribute__(X) CWINPTHREADS_SECTION(X) __section__(X) N__WINPTHREADS_VERSION_MAJOR 0 O__WINPTHREADS_VERSION_MINOR 5 P__WINPTHREADS_VERSION_PATCHLEVEL 0 S__WINPTHREADS_VERSION 0x00050000 \WINPTHREAD_API  bRWLS_PER_THREAD 8 qPTHREAD_CANCEL_DISABLE 0 rPTHREAD_CANCEL_ENABLE 0x01 tPTHREAD_CANCEL_DEFERRED 0 uPTHREAD_CANCEL_ASYNCHRONOUS 0x02 wPTHREAD_CREATE_JOINABLE 0 xPTHREAD_CREATE_DETACHED 0x04 zPTHREAD_EXPLICIT_SCHED 0 {PTHREAD_INHERIT_SCHED 0x08 }PTHREAD_SCOPE_PROCESS 0 ~PTHREAD_SCOPE_SYSTEM 0x10 ‚Ç¨PTHREAD_DEFAULT_ATTR (PTHREAD_CANCEL_ENABLE) ‚ÄöPTHREAD_CANCELED ((void *) (intptr_t) 0xDEADBEEF) ‚Äû_PTHREAD_NULL_THREAD ((pthread_t) 0) ‚Ä†PTHREAD_ONCE_INIT 0 ÀÜPTHREAD_DESTRUCTOR_ITERATIONS 256 ‚Ä∞PTHREAD_KEYS_MAX (1<<20) ‚ÄπPTHREAD_MUTEX_NORMAL 0 ≈íPTHREAD_MUTEX_ERRORCHECK 1 ÔøΩPTHREAD_MUTEX_RECURSIVE 2 ≈ΩPTHREAD_MUTEX_DEFAULT PTHREAD_MUTEX_NORMAL ÔøΩPTHREAD_MUTEX_SHARED 1 ‚ÄòPTHREAD_MUTEX_PRIVATE 0 ‚ÄúPTHREAD_PRIO_NONE 0 ‚ÄùPTHREAD_PRIO_INHERIT 8 ‚Ä¢PTHREAD_PRIO_PROTECT 16 ‚ÄìPTHREAD_PRIO_MULT 32 ‚ÄîPTHREAD_PROCESS_SHARED 1 ÀúPTHREAD_PROCESS_PRIVATE 0 ≈°PTHREAD_MUTEX_FAST_NP PTHREAD_MUTEX_NORMAL ‚Ä∫PTHREAD_MUTEX_TIMED_NP PTHREAD_MUTEX_FAST_NP ≈ìPTHREAD_MUTEX_ADAPTIVE_NP PTHREAD_MUTEX_FAST_NP ÔøΩPTHREAD_MUTEX_ERRORCHECK_NP PTHREAD_MUTEX_ERRORCHECK ≈æPTHREAD_MUTEX_RECURSIVE_NP PTHREAD_MUTEX_RECURSIVE ¬•PTHREAD_BARRIER_SERIAL_THREAD 1 ¬®MAX_READ_LOCKS (INT_MAX - 1) ¬´pthread_atfork(F1,F2,F3) 0 ¬Æpthread_mutex_getprioceiling(M,P) ENOTSUP ¬Øpthread_mutex_setprioceiling(M,P) ENOTSUP ¬∞pthread_getcpuclockid(T,C) ENOTSUP ¬±pthread_attr_getguardsize(A,S) ENOTSUP ¬≤pthread_attr_setgaurdsize(A,S) ENOTSUP √épthread_cleanup_push(F,A) { const _pthread_cleanup _pthread_cup = {(F), (A), *pthread_getclean()}; __sync_synchronize(); *pthread_getclean() = (_pthread_cleanup *) &_pthread_cup; __sync_synchronize() √ñpthread_cleanup_pop(E) (*pthread_getclean() = _pthread_cup.next, (E?_pthread_cup.func((pthread_once_t *)_pthread_cup.arg):0));} √©SCHED_OTHER 0 √™SCHED_FIFO 1 √´SCHED_RR 2 √¨SCHED_MIN SCHED_OTHER √≠SCHED_MAX SCHED_RR ‚ÄôPTHREAD_MUTEX_NORMAL 0 ‚ÄúPTHREAD_MUTEX_ERRORCHECK 1 ‚ÄùPTHREAD_MUTEX_RECURSIVE 2 ‚ÄìGENERIC_INITIALIZER ((void *) (size_t) -1) ‚ÄîGENERIC_ERRORCHECK_INITIALIZER ((void *) (size_t) -2) ÀúGENERIC_RECURSIVE_INITIALIZER ((void *) (size_t) -3) ‚Ñ¢GENERIC_NORMAL_INITIALIZER ((void *) (size_t) -1) ≈°PTHREAD_MUTEX_INITIALIZER (pthread_mutex_t)GENERIC_INITIALIZER ‚Ä∫PTHREAD_RECURSIVE_MUTEX_INITIALIZER (pthread_mutex_t)GENERIC_RECURSIVE_INITIALIZER ≈ìPTHREAD_ERRORCHECK_MUTEX_INITIALIZER (pthread_mutex_t)GENERIC_ERRORCHECK_INITIALIZER ÔøΩPTHREAD_NORMAL_MUTEX_INITIALIZER (pthread_mutex_t)GENERIC_NORMAL_INITIALIZER ≈æPTHREAD_DEFAULT_MUTEX_INITIALIZER PTHREAD_NORMAL_MUTEX_INITIALIZER ≈∏PTHREAD_COND_INITIALIZER (pthread_cond_t)GENERIC_INITIALIZER ¬†PTHREAD_RWLOCK_INITIALIZER (pthread_rwlock_t)GENERIC_INITIALIZER ¬°PTHREAD_SPINLOCK_INITIALIZER (pthread_spinlock_t)GENERIC_INITIALIZER ∆í__clockid_t_defined 1 ¬†SIG_BLOCK 0 ¬£SIG_UNBLOCK 1 ¬¶SIG_SETMASK 2 ¬©LWIN_PTHREADS_UNISTD_H  P_POSIX_THREADS Q_POSIX_THREADS 200112L d_POSIX_READER_WRITER_LOCKS e_POSIX_READER_WRITER_LOCKS 200112L r_POSIX_SPIN_LOCKS s_POSIX_SPIN_LOCKS 200112L ÔøΩ_POSIX_BARRIERS ‚Äö_POSIX_BARRIERS 200112L ‚Ä¢_POSIX_THREAD_SAFE_FUNCTIONS ‚Äì_POSIX_THREAD_SAFE_FUNCTIONS 200112L ¬§_POSIX_TIMEOUTS ¬•_POSIX_TIMEOUTS 200112L √Ä_POSIX_CLOCK_SELECTION √Å_POSIX_CLOCK_SELECTION 200112 √ë_POSIX_SEMAPHORES √í_POSIX_SEMAPHORES 200112 ¬´_POSIX_THREAD_DESTRUCTOR_ITERATIONS ¬¨_POSIX_THREAD_DESTRUCTOR_ITERATIONS PTHREAD_DESTRUCTOR_ITERATIONS ¬Æ_POSIX_THREAD_KEYS_MAX ¬Ø_POSIX_THREAD_KEYS_MAX PTHREAD_KEYS_MAX ¬±PTHREAD_THREADS_MAX ¬≤PTHREAD_THREADS_MAX 2019 ¬¥_POSIX_SEM_NSEMS_MAX ¬µ_POSIX_SEM_NSEMS_MAX 256 ¬∑SEM_NSEMS_MAX ¬∏SEM_NSEMS_MAX 1024 ¬©_GTHREAD_USE_MUTEX_INIT_FUNC ¬´_GTHREAD_USE_MUTEX_INIT_FUNC 1 $_GTHREAD_USE_MUTEX_INIT_FUNC 1 ;__GTHREAD_HAS_COND 1 =__GTHREAD_MUTEX_INIT PTHREAD_MUTEX_INITIALIZER >__GTHREAD_MUTEX_INIT_FUNCTION __gthread_mutex_init_function ?__GTHREAD_ONCE_INIT PTHREAD_ONCE_INIT A__GTHREAD_RECURSIVE_MUTEX_INIT PTHREAD_RECURSIVE_MUTEX_INITIALIZER G__GTHREAD_COND_INIT PTHREAD_COND_INITIALIZER H__GTHREAD_TIME_INIT {0,0} K__GTHREAD_MUTEX_INIT `__gthrw2(name,name2,type)  a__gthrw_(name) name e__gthrw(name) __gthrw2(__gthrw_ ## name,name,name) $_GLIBCXX_ATOMIC_WORD_H 1 o_GLIBCXX_READ_MEM_BARRIER __asm __volatile ("":::"memory") r_GLIBCXX_WRITE_MEM_BARRIER __asm __volatile ("":::"memory") )M#_LOCALE_CLASSES_H 1 (N"_GLIBCXX_STRING 1 )O,_ALLOCATOR_H 1 .P_GLIBCXX_CXX_ALLOCATOR_H 1 !_NEW_ALLOCATOR_H 1 !Q#_NEW  4__allocator_base __gnu_cxx::new_allocator ¬†__allocator_base ,R_OSTREAM_INSERT_H 1 $S _CXXABI_FORCED_H 1 0T9_STL_FUNCTION_H 1 √®U9_BACKWARD_BINDERS_H 1 3V_GLIBCXX_RANGE_ACCESS_H 1 4W#_BASIC_STRING_H 1 (X_EXT_ALLOC_TRAITS_H 1 5Y(_BASIC_STRING_TCC 1 √äZ#_LOCALE_CLASSES_TCC 1 ,["_GLIBCXX_STDEXCEPT 1 +\"_GLIBXX_STREAMBUF 1 √í]#_STREAMBUF_TCC 1 ,^_BASIC_IOS_H 1 %_#_LOCALE_FACETS_H 1 '	2_INC_WCTYPE  [_UPPER 0x1 \_LOWER 0x2 ]_DIGIT 0x4 ^_SPACE 0x8 `_PUNCT 0x10 a_CONTROL 0x20 b_BLANK 0x40 c_HEX 0x80 e_LEADBYTE 0x8000 f_ALPHA (0x0100|_UPPER|_LOWER) 6_GLIBCXX_CWCTYPE 1 9iswalnum :iswalpha <iswblank >iswcntrl ?iswctype @iswdigit Aiswgraph Biswlower Ciswprint Diswpunct Eiswspace Fiswupper Giswxdigit Htowctrans Itowlower Jtowupper Kwctrans Lwctype (9)`0a_STREAMBUF_ITERATOR_H 1 8_GLIBCXX_NUM_FACETS 28 9_GLIBCXX_NUM_CXX11_FACETS 16 ?_GLIBCXX_NUM_UNICODE_FACETS 2 √æb√õc_LOCALE_FACETS_TCC 1 ‚Äûd_BASIC_IOS_TCC 1 √æe#_OSTREAM_TCC 1 (f"_GLIBCXX_ISTREAM 1 ¬¶g#_ISTREAM_TCC 1 h_OMP_H 1 _LIBGOMP_OMP_LOCK_DEFINED 1 C__GOMP_NOTHROW throw ()  √è	   s	  √ª      ../src C:/TDM-GCC-64/lib/gcc/x86_64-w64-mingw32/5.1.0/include/c++ C:/TDM-GCC-64/lib/gcc/x86_64-w64-mingw32/5.1.0/include/c++/x86_64-w64-mingw32/bits C:/TDM-GCC-64/lib/gcc/x86_64-w64-mingw32/5.1.0/include/c++/debug C:/TDM-GCC-64/lib/gcc/x86_64-w64-mingw32/5.1.0/include/c++/bits C:/TDM-GCC-64/lib/gcc/x86_64-w64-mingw32/5.1.0/include/c++/ext C:/TDM-GCC-64/x86_64-w64-mingw32/include C:/TDM-GCC-64/x86_64-w64-mingw32/include/sdks C:/TDM-GCC-64/x86_64-w64-mingw32/include/sec_api C:/TDM-GCC-64/lib/gcc/x86_64-w64-mingw32/5.1.0/include C:/TDM-GCC-64/x86_64-w64-mingw32/include/sys C:/TDM-GCC-64/lib/gcc/x86_64-w64-mingw32/5.1.0/include-fixed C:/TDM-GCC-64/x86_64-w64-mingw32/include/sec_api/sys C:/TDM-GCC-64/lib/gcc/x86_64-w64-mingw32/5.1.0/include/c++/backward  sum_parallel_for_local_var.cpp   iostream   cwchar   c++config.h   debug.h   char_traits.h   clocale   ios_base.h   cwctype   iosfwd   <built-in>    predefined_ops.h   new_allocator.h   numeric_traits.h   crtdefs.h   locale.h   wchar.h   swprintf.inl   atomic_word.h   wctype.h   os_defines.h   cpu_defines.h   ostream   ios   stringfwd.h   memoryfwd.h   postypes.h   _mingw.h   _mingw_mac.h   _mingw_secapi.h   vadefs.h   _mingw_directx.h   _mingw_ddk.h   _mingw_print_push.h   _mingw_off_t.h   _mingw_stat64.h   wchar_s.h 	  _mingw_print_pop.h   exception   atomic_lockfree_defines.h   stl_algobase.h   functexcept.h   exception_defines.h   cpp_type_traits.h   type_traits.h   stl_pair.h   move.h   concept_check.h   stl_iterator_base_types.h   stl_iterator_base_funcs.h   stl_iterator.h   ptr_traits.h   localefwd.h   c++locale.h   stdio.h   stdio_s.h 	  cctype   ctype.h   atomicity.h   gthr.h   gthr-default.h   pthread.h   stddef.h 
  stddef.h   errno.h   types.h   process.h   limits.h   syslimits.h   limits.h   signal.h   pthread_signal.h   timeb.h   timeb_s.h   pthread_compat.h   pthread_unistd.h   locale_classes.h   string   allocator.h   c++allocator.h   new   ostream_insert.h   cxxabi_forced.h   stl_function.h   binders.h   range_access.h   basic_string.h   alloc_traits.h   basic_string.tcc   locale_classes.tcc   stdexcept   streambuf   streambuf.tcc   basic_ios.h   locale_facets.h   ctype_base.h   streambuf_iterator.h   ctype_inline.h   locale_facets.tcc   basic_ios.tcc   ostream.tcc   istream   istream.tcc   omp.h 
    	        	√•0√ò‚Äô t ∆í & ≈ìk√ò%0t‚ÄöP.√ñ f0ÔøΩPtt‚Äö __min __max __digits _Value __is_signed GCC: (tdm64-1) 5.1.0                               √ø√ø√ø√ø x ¬†      $               ¬∏       A‚Ä†C¬≥√Ü  $       ¬∏              A‚Ä†CV√Ü   $       √ì       <       A‚Ä†Cw√Ü   $                    A‚Ä†CY√Ü                (       )    #   *    t   +       *    ¬≠   ,    √É       √à   -    √≥       √∏   .      /        
       
              
       
              
       
            $   
    (   
    ,           
           ¬µ   
    √Ö        √â       %  "    0  "    ;  "    F  "    Q  "    ÔøΩ  "    ≈°  "    ¬•  "    ¬∞  "    ¬ª  "    √¨  "    √∑  "      "      "      "    N  "    Y  "    d  "    o  "    z  "    ¬∞  "    ¬ª  "    √Ü  "    √ë  "    √ú  "    3  
    ‚Ä¢  
    √Ç  
    √ø  
    v  
    ÔøΩ                
            ‚Ç¨	  
        0       &        
    D   &    H   
    l   &    p   
    ‚Äù   &    Àú   
    .file       √æ√ø  g    ‚Äö                 ¬°               ¬∞                                √í                         __tcf_0 ¬∏           √´   √ì                   .text          -               .data                            .bss                            .rdata                          .xdata         0                 .pdata         0                .ctors                             L         u  #                 X      	   y                    f      
   0                    u         √ò¬µ                   ‚Äö         √ì	                   ≈Ω         (                     ‚Ñ¢                              ¬§         ¬∏                    ¬±              √É               √ª               	                               9               Q           atexit               i           s  .debug_info .debug_abbrev .debug_aranges .debug_macro .debug_line .debug_str .rdata$zzz .rdata$.refptr._ZSt4cout .debug_frame sum_parallel_for_local_var.cpp _ZStL8__ioinit _Z26sum_parallel_for_local_varPdi .rdata$.refptr._ZSt4cout _Z41__static_initialization_and_destruction_0ii _GLOBAL__sub_I__Z26sum_parallel_for_local_varPdi .debug_info .debug_abbrev .debug_aranges .debug_macro .debug_line .debug_str .rdata$zzz .debug_frame .refptr._ZSt4cout _ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc omp_get_wtime _Z17recordThreadIndexi _Z17printSumWithTimesiii _ZNSt8ios_base4InitD1Ev _ZNSt8ios_base4InitC1Ev _ZSt4cout ]]></snapshot>
  </Command>
  <Command __id="23596" _type="DiffBasedFileOpenCommand" date="Fri Dec 20 09:04:04 EST 2019" docASTNodeCount="1" docActiveCodeLength="550" docExpressionCount="0" docLength="626" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="184139530">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\sum_parallel.cpp]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"#include <iostream>¬∂#include <omp.h>¬∂¬∂using namespace std;¬∂¬∂void printSumWithTimes(int sum, int start, int end);¬∂void printNumThreads();¬∂void recordThreadIndex(int index);¬∂void sum_parallel(double* array, int size) {¬∂	cout << "sum_parallel\n";¬∂¬∂	double start = omp_get_wtime();¬∂¬∂	double sum = 0;¬∂¬∂"), Diff(INSERT,"//"), Diff(EQUAL,"	#pragma omp parallel¬∂"), Diff(INSERT,"//"), Diff(EQUAL,"	for (int i = 0; i < size; i++)¬∂"), Diff(INSERT,"//"), Diff(EQUAL,"		sum += array[i];"), Diff(INSERT,"¬∂    #pragma omp parallel¬∂	{¬∂		double local_sum = 0;¬∂¬∂		#pragma omp for¬∂		for(int i = 0; i < size; i++)¬∂			local_sum += array[i];¬∂¬∂		#pragma omp critical¬∂		sum += local_sum;¬∂	}"), Diff(EQUAL,"¬∂¬∂	double end = omp_get_wtime();¬∂¬∂	printSumWithTimes(sum, start, end);¬∂¬∂¬∂}¬∂")]]]></diff>
    <snapshot><![CDATA[#include <iostream>
#include <omp.h>

using namespace std;

void printSumWithTimes(int sum, int start, int end);
void printNumThreads();
void recordThreadIndex(int index);
void sum_parallel(double* array, int size) {
	cout << "sum_parallel\n";

	double start = omp_get_wtime();

	double sum = 0;

//	#pragma omp parallel
//	for (int i = 0; i < size; i++)
//		sum += array[i];
    #pragma omp parallel
	{
		double local_sum = 0;

		#pragma omp for
		for(int i = 0; i < size; i++)
			local_sum += array[i];

		#pragma omp critical
		sum += local_sum;
	}

	double end = omp_get_wtime();

	printSumWithTimes(sum, start, end);


}
]]></snapshot>
  </Command>
  <Command __id="23593" _type="SelectTextCommand" caretOffset="551" date="Fri Dec 20 09:03:48 EST 2019" end="551" start="380" starttimestamp="1576666505112" timestamp="184123486" />
  <Command __id="23594" _type="CopyCommand" date="Fri Dec 20 09:03:49 EST 2019" starttimestamp="1576666505112" timestamp="184124179" />
  <Command __id="23597" _type="SelectTextCommand" caretOffset="551" date="Fri Dec 20 09:04:04 EST 2019" end="551" start="380" starttimestamp="1576666505112" timestamp="184139767" />
  <Command __id="23599" _type="MoveCaretCommand" caretOffset="0" date="Fri Dec 20 09:04:10 EST 2019" docOffset="0" starttimestamp="1576666505112" timestamp="184145879" />
  <Command __id="23598" _type="DiffBasedFileOpenCommand" date="Fri Dec 20 09:04:10 EST 2019" docASTNodeCount="1" docActiveCodeLength="482" docExpressionCount="0" docLength="482" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="184145724">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\sum_parallel_for_local_var.cpp]]></filePath>
    <diff><![CDATA[null]]></diff>
    <snapshot><![CDATA[#include <iostream>
#include <omp.h>

using namespace std;

void printSumWithTimes (int sum, int start, int end);
void printNumThreads();
void recordThreadIndex(int index);
void sum_parallel_for_local_var(double* array, int size)
{
	cout << "sum_parallel_for_local_var\n";

	double start = omp_get_wtime();

	double sum = 0;

	for (int i = 0; i < size; i++) {
			sum += array[i];
			recordThreadIndex(i);
	}

	double end = omp_get_wtime();

	printSumWithTimes(sum, start, end);
	
}
]]></snapshot>
  </Command>
  <Command __id="23600" _type="SelectTextCommand" caretOffset="309" date="Fri Dec 20 09:04:20 EST 2019" end="407" start="309" starttimestamp="1576666505112" timestamp="184155486" />
  <Command __id="23607" _type="EclipseCommand" commandID="org.eclipse.cdt.ui.edit.text.c.toggle.comment" date="Fri Dec 20 09:04:21 EST 2019" starttimestamp="1576666505112" timestamp="184156556" />
  <Command __id="23608" _type="MoveCaretCommand" caretOffset="419" date="Fri Dec 20 09:04:23 EST 2019" docOffset="419" starttimestamp="1576666505112" timestamp="184158259" />
  <Command __id="23610" _type="InsertStringCommand" date="Fri Dec 20 09:04:23 EST 2019" starttimestamp="1576666505112" timestamp="184158732" timestamp2="184158732">
    <data><![CDATA[]]></data>
  </Command>
  <Command __id="23612" _type="PasteCommand" date="Fri Dec 20 09:04:24 EST 2019" starttimestamp="1576666505112" timestamp="184159557" />
  <Command __id="23613" _type="MoveCaretCommand" caretOffset="420" date="Fri Dec 20 09:04:27 EST 2019" docOffset="420" starttimestamp="1576666505112" timestamp="184162206" />
  <Command __id="23615" _type="InsertStringCommand" date="Fri Dec 20 09:04:27 EST 2019" starttimestamp="1576666505112" timestamp="184162590" timestamp2="184162590">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="23617" _type="InsertStringCommand" date="Fri Dec 20 09:04:27 EST 2019" starttimestamp="1576666505112" timestamp="184162807" timestamp2="184162807">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="23619" _type="InsertStringCommand" date="Fri Dec 20 09:04:28 EST 2019" starttimestamp="1576666505112" timestamp="184162987" timestamp2="184162987">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="23621" _type="InsertStringCommand" date="Fri Dec 20 09:04:28 EST 2019" starttimestamp="1576666505112" timestamp="184163176" timestamp2="184163176">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="23622" _type="SelectTextCommand" caretOffset="413" date="Fri Dec 20 09:04:32 EST 2019" end="413" start="393" starttimestamp="1576666505112" timestamp="184167008" />
  <Command __id="23623" _type="CopyCommand" date="Fri Dec 20 09:04:32 EST 2019" starttimestamp="1576666505112" timestamp="184167754" />
  <DocumentChange __id="23601" _type="Insert" date="Fri Dec 20 09:04:21 EST 2019" docASTNodeCount="1" docActiveCodeLength="466" docExpressionCount="0" docLength="484" length="2" offset="308" starttimestamp="1576666505112" timestamp="184156538">
    <text><![CDATA[//]]></text>
  </DocumentChange>
  <DocumentChange __id="23602" _type="Insert" date="Fri Dec 20 09:04:21 EST 2019" docASTNodeCount="1" docActiveCodeLength="466" docExpressionCount="0" docLength="486" length="2" offset="327" starttimestamp="1576666505112" timestamp="184156539">
    <text><![CDATA[//]]></text>
  </DocumentChange>
  <DocumentChange __id="23603" _type="Insert" date="Fri Dec 20 09:04:21 EST 2019" docASTNodeCount="1" docActiveCodeLength="433" docExpressionCount="0" docLength="488" length="2" offset="330" starttimestamp="1576666505112" timestamp="184156540">
    <text><![CDATA[//]]></text>
  </DocumentChange>
  <DocumentChange __id="23604" _type="Insert" date="Fri Dec 20 09:04:21 EST 2019" docASTNodeCount="1" docActiveCodeLength="414" docExpressionCount="0" docLength="490" length="2" offset="366" starttimestamp="1576666505112" timestamp="184156542">
    <text><![CDATA[//]]></text>
  </DocumentChange>
  <DocumentChange __id="23605" _type="Insert" date="Fri Dec 20 09:04:21 EST 2019" docASTNodeCount="1" docActiveCodeLength="390" docExpressionCount="0" docLength="492" length="2" offset="388" starttimestamp="1576666505112" timestamp="184156543">
    <text><![CDATA[//]]></text>
  </DocumentChange>
  <DocumentChange __id="23606" _type="Insert" date="Fri Dec 20 09:04:21 EST 2019" docASTNodeCount="1" docActiveCodeLength="388" docExpressionCount="0" docLength="494" length="2" offset="415" starttimestamp="1576666505112" timestamp="184156544">
    <text><![CDATA[//]]></text>
  </DocumentChange>
  <DocumentChange __id="23609" _type="Insert" date="Fri Dec 20 09:04:23 EST 2019" docASTNodeCount="1" docActiveCodeLength="390" docExpressionCount="0" docLength="496" length="2" offset="419" starttimestamp="1576666505112" timestamp="184158725">
    <text><![CDATA[
	]]></text>
  </DocumentChange>
  <DocumentChange __id="23611" _type="Replace" date="Fri Dec 20 09:04:24 EST 2019" docASTNodeCount="1" docActiveCodeLength="560" docExpressionCount="0" docLength="666" endLine="20" insertionLength="171" int_docASTNodeCount="1" int_docActiveCodeLength="389" int_docExpressionCount="0" int_docLength="495" length="1" offset="420" startLine="20" starttimestamp="1576666505112" timestamp="184159538">
    <deletedText><![CDATA[	]]></deletedText>
    <insertedText><![CDATA[#pragma omp parallel
	{
		double local_sum = 0;

		#pragma omp for
		for(int i = 0; i < size; i++)
			local_sum += array[i];

		#pragma omp critical
		sum += local_sum;
	}]]></insertedText>
  </DocumentChange>
  <DocumentChange __id="23614" _type="Insert" date="Fri Dec 20 09:04:27 EST 2019" docASTNodeCount="1" docActiveCodeLength="561" docExpressionCount="0" docLength="667" length="1" offset="420" starttimestamp="1576666505112" timestamp="184162579">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="23616" _type="Insert" date="Fri Dec 20 09:04:27 EST 2019" docASTNodeCount="1" docActiveCodeLength="562" docExpressionCount="0" docLength="668" length="1" offset="421" starttimestamp="1576666505112" timestamp="184162797">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="23618" _type="Insert" date="Fri Dec 20 09:04:28 EST 2019" docASTNodeCount="1" docActiveCodeLength="563" docExpressionCount="0" docLength="669" length="1" offset="422" starttimestamp="1576666505112" timestamp="184162976">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="23620" _type="Insert" date="Fri Dec 20 09:04:28 EST 2019" docASTNodeCount="1" docActiveCodeLength="564" docExpressionCount="0" docLength="670" length="1" offset="423" starttimestamp="1576666505112" timestamp="184163163">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="23625" _type="Insert" date="Fri Dec 20 09:04:36 EST 2019" docASTNodeCount="1" docActiveCodeLength="565" docExpressionCount="0" docLength="671" length="1" offset="522" starttimestamp="1576666505112" timestamp="184171850">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <Command __id="23624" _type="MoveCaretCommand" caretOffset="522" date="Fri Dec 20 09:04:36 EST 2019" docOffset="522" starttimestamp="1576666505112" timestamp="184171229" />
  <Command __id="23626" _type="InsertStringCommand" date="Fri Dec 20 09:04:36 EST 2019" starttimestamp="1576666505112" timestamp="184171856" timestamp2="184171856">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="23628" _type="InsertStringCommand" date="Fri Dec 20 09:04:38 EST 2019" starttimestamp="1576666505112" timestamp="184172912" timestamp2="184172912">
    <data><![CDATA[{]]></data>
  </Command>
  <DocumentChange __id="23627" _type="Insert" date="Fri Dec 20 09:04:38 EST 2019" docASTNodeCount="1" docActiveCodeLength="566" docExpressionCount="0" docLength="672" length="1" offset="523" starttimestamp="1576666505112" timestamp="184172900">
    <text><![CDATA[{]]></text>
  </DocumentChange>
  <DocumentChange __id="23630" _type="Insert" date="Fri Dec 20 09:04:40 EST 2019" docASTNodeCount="1" docActiveCodeLength="570" docExpressionCount="0" docLength="676" length="4" offset="550" starttimestamp="1576666505112" timestamp="184174888">
    <text><![CDATA[
			]]></text>
  </DocumentChange>
  <Command __id="23629" _type="MoveCaretCommand" caretOffset="550" date="Fri Dec 20 09:04:39 EST 2019" docOffset="550" starttimestamp="1576666505112" timestamp="184174445" />
  <Command __id="23631" _type="InsertStringCommand" date="Fri Dec 20 09:04:40 EST 2019" starttimestamp="1576666505112" timestamp="184174894" timestamp2="184174894">
    <data><![CDATA[]]></data>
  </Command>
  <Command __id="23633" _type="InsertStringCommand" date="Fri Dec 20 09:04:41 EST 2019" starttimestamp="1576666505112" timestamp="184176080" timestamp2="184176080">
    <data><![CDATA[}]]></data>
  </Command>
  <DocumentChange __id="23632" _type="Replace" date="Fri Dec 20 09:04:41 EST 2019" docASTNodeCount="1" docActiveCodeLength="570" docExpressionCount="0" docLength="676" endLine="27" insertionLength="3" int_docASTNodeCount="1" int_docActiveCodeLength="567" int_docExpressionCount="0" int_docLength="673" length="3" offset="551" startLine="27" starttimestamp="1576666505112" timestamp="184176058">
    <deletedText><![CDATA[			]]></deletedText>
    <insertedText><![CDATA[		}]]></insertedText>
  </DocumentChange>
  <DocumentChange __id="23635" _type="Insert" date="Fri Dec 20 09:04:43 EST 2019" docASTNodeCount="1" docActiveCodeLength="574" docExpressionCount="0" docLength="680" length="4" offset="550" starttimestamp="1576666505112" timestamp="184178657">
    <text><![CDATA[
			]]></text>
  </DocumentChange>
  <DocumentChange __id="23637" _type="Replace" date="Fri Dec 20 09:04:44 EST 2019" docASTNodeCount="1" docActiveCodeLength="594" docExpressionCount="0" docLength="700" endLine="27" insertionLength="23" int_docASTNodeCount="1" int_docActiveCodeLength="571" int_docExpressionCount="0" int_docLength="677" length="3" offset="551" startLine="27" starttimestamp="1576666505112" timestamp="184179475">
    <deletedText><![CDATA[			]]></deletedText>
    <insertedText><![CDATA[			recordThreadIndex(i)]]></insertedText>
  </DocumentChange>
  <Command __id="23634" _type="MoveCaretCommand" caretOffset="550" date="Fri Dec 20 09:04:43 EST 2019" docOffset="550" starttimestamp="1576666505112" timestamp="184178204" />
  <Command __id="23636" _type="InsertStringCommand" date="Fri Dec 20 09:04:43 EST 2019" starttimestamp="1576666505112" timestamp="184178665" timestamp2="184178665">
    <data><![CDATA[]]></data>
  </Command>
  <Command __id="23638" _type="PasteCommand" date="Fri Dec 20 09:04:44 EST 2019" starttimestamp="1576666505112" timestamp="184179482" />
  <Command __id="23640" _type="InsertStringCommand" date="Fri Dec 20 09:04:47 EST 2019" starttimestamp="1576666505112" timestamp="184182535" timestamp2="184182535">
    <data><![CDATA[;]]></data>
  </Command>
  <DocumentChange __id="23639" _type="Insert" date="Fri Dec 20 09:04:47 EST 2019" docASTNodeCount="1" docActiveCodeLength="595" docExpressionCount="0" docLength="701" length="1" offset="574" starttimestamp="1576666505112" timestamp="184182528">
    <text><![CDATA[;]]></text>
  </DocumentChange>
  <Command __id="23641" _type="MoveCaretCommand" caretOffset="308" date="Fri Dec 20 09:05:01 EST 2019" docOffset="308" starttimestamp="1576666505112" timestamp="184195967" />
  <Command __id="23643" _type="EclipseCommand" commandID="org.eclipse.cdt.ui.edit.text.c.toggle.comment" date="Fri Dec 20 09:05:02 EST 2019" starttimestamp="1576666505112" timestamp="184197121" />
  <DocumentChange __id="23642" _type="Delete" date="Fri Dec 20 09:05:02 EST 2019" docASTNodeCount="1" docActiveCodeLength="611" docExpressionCount="0" docLength="699" endLine="14" length="2" offset="308" startLine="14" starttimestamp="1576666505112" timestamp="184197105">
    <text><![CDATA[//]]></text>
  </DocumentChange>
  <Command __id="23644" _type="EclipseCommand" commandID="org.eclipse.ui.file.save" date="Fri Dec 20 09:05:03 EST 2019" starttimestamp="1576666505112" timestamp="184198253" />
  <Command __id="23646" _type="SelectTextCommand" caretOffset="551" date="Fri Dec 20 09:05:21 EST 2019" end="551" start="380" starttimestamp="1576666505112" timestamp="184215892" />
  <DocumentChange __id="23677" _type="Replace" date="Fri Dec 20 09:05:56 EST 2019" docASTNodeCount="1" docActiveCodeLength="454" docExpressionCount="0" docLength="454" endLine="17" insertionLength="24" int_docASTNodeCount="1" int_docActiveCodeLength="430" int_docExpressionCount="0" int_docLength="430" length="6" offset="352" startLine="17" starttimestamp="1576666505112" timestamp="184251585">
    <deletedText><![CDATA[record]]></deletedText>
    <insertedText><![CDATA[recordThreadIndex(index)]]></insertedText>
  </DocumentChange>
  <DocumentChange __id="23683" _type="Replace" date="Fri Dec 20 09:06:00 EST 2019" docASTNodeCount="1" docActiveCodeLength="450" docExpressionCount="0" docLength="450" endLine="17" insertionLength="1" int_docASTNodeCount="1" int_docActiveCodeLength="449" int_docExpressionCount="0" int_docLength="449" length="5" offset="370" startLine="17" starttimestamp="1576666505112" timestamp="184254937">
    <deletedText><![CDATA[index]]></deletedText>
    <insertedText><![CDATA[i]]></insertedText>
  </DocumentChange>
  <DocumentChange __id="23686" _type="Insert" date="Fri Dec 20 09:06:01 EST 2019" docASTNodeCount="1" docActiveCodeLength="451" docExpressionCount="0" docLength="451" length="1" offset="372" starttimestamp="1576666505112" timestamp="184256847">
    <text><![CDATA[;]]></text>
  </DocumentChange>
  <Command __id="23694" _type="SelectTextCommand" caretOffset="298" date="Fri Dec 20 09:07:53 EST 2019" end="376" start="298" starttimestamp="1576666505112" timestamp="184368031" />
  <Command __id="23696" _type="MoveCaretCommand" caretOffset="552" date="Fri Dec 20 09:08:06 EST 2019" docOffset="552" starttimestamp="1576666505112" timestamp="184381340" />
  <Command __id="23695" _type="DiffBasedFileOpenCommand" date="Fri Dec 20 09:08:06 EST 2019" docASTNodeCount="1" docActiveCodeLength="550" docExpressionCount="0" docLength="626" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="184381171">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\sum_parallel.cpp]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"#include <iostream>¬∂#include <omp.h>¬∂¬∂using namespace std;¬∂¬∂void printSumWithTimes(int sum, int start, int end);¬∂void printNumThreads();¬∂void recordThreadIndex(int index);¬∂void sum_parallel(double* array, int size) {¬∂	cout << "sum_parallel\n";¬∂¬∂	double start = omp_get_wtime();¬∂¬∂	double sum = 0;¬∂¬∂//	#pragma omp parallel¬∂//	for (int i = 0; i < size; i++)¬∂//		sum += array[i];¬∂    #pragma omp parallel¬∂	{¬∂		double local_sum = 0;¬∂¬∂		#pragma omp for¬∂		for(int i = 0; i < size; i++)¬∂			local_sum += array[i];¬∂¬∂		#pragma omp critical¬∂		sum += local_sum;¬∂	}¬∂¬∂	double end = omp_get_wtime();¬∂¬∂	printSumWithTimes(sum, start, end);¬∂¬∂¬∂}¬∂")]]]></diff>
  </Command>
  <Command __id="23697" _type="SelectTextCommand" caretOffset="377" date="Fri Dec 20 09:08:15 EST 2019" end="551" start="377" starttimestamp="1576666505112" timestamp="184390699" />
  <Command __id="23698" _type="SelectTextCommand" caretOffset="377" date="Fri Dec 20 09:08:15 EST 2019" end="551" start="377" starttimestamp="1576666505112" timestamp="184390699" />
  <Command __id="23700" _type="PasteCommand" date="Fri Dec 20 09:08:16 EST 2019" starttimestamp="1576666505112" timestamp="184391832" />
  <Command __id="23701" _type="MoveCaretCommand" caretOffset="376" date="Fri Dec 20 09:08:21 EST 2019" docOffset="376" starttimestamp="1576666505112" timestamp="184396060" />
  <Command __id="23702" _type="MoveCaretCommand" caretOffset="376" date="Fri Dec 20 09:08:21 EST 2019" docOffset="376" starttimestamp="1576666505112" timestamp="184396060" />
  <Command __id="23704" _type="InsertStringCommand" date="Fri Dec 20 09:08:21 EST 2019" starttimestamp="1576666505112" timestamp="184396515" timestamp2="184396515">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="23705" _type="InsertStringCommand" date="Fri Dec 20 09:08:21 EST 2019" starttimestamp="1576666505112" timestamp="184396515" timestamp2="184396515">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="23707" _type="InsertStringCommand" date="Fri Dec 20 09:08:21 EST 2019" starttimestamp="1576666505112" timestamp="184396733" timestamp2="184396733">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="23708" _type="InsertStringCommand" date="Fri Dec 20 09:08:21 EST 2019" starttimestamp="1576666505112" timestamp="184396733" timestamp2="184396733">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="23710" _type="InsertStringCommand" date="Fri Dec 20 09:08:22 EST 2019" starttimestamp="1576666505112" timestamp="184396955" timestamp2="184396955">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="23711" _type="InsertStringCommand" date="Fri Dec 20 09:08:22 EST 2019" starttimestamp="1576666505112" timestamp="184396955" timestamp2="184396955">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="23713" _type="InsertStringCommand" date="Fri Dec 20 09:08:22 EST 2019" starttimestamp="1576666505112" timestamp="184397302" timestamp2="184397302">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="23714" _type="InsertStringCommand" date="Fri Dec 20 09:08:22 EST 2019" starttimestamp="1576666505112" timestamp="184397302" timestamp2="184397302">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="23715" _type="MoveCaretCommand" caretOffset="531" date="Fri Dec 20 09:08:29 EST 2019" docOffset="531" starttimestamp="1576666505112" timestamp="184403915" />
  <Command __id="23716" _type="MoveCaretCommand" caretOffset="531" date="Fri Dec 20 09:08:29 EST 2019" docOffset="531" starttimestamp="1576666505112" timestamp="184403916" />
  <Command __id="23717" _type="SelectTextCommand" caretOffset="533" date="Fri Dec 20 09:08:29 EST 2019" end="533" start="529" starttimestamp="1576666505112" timestamp="184404114" />
  <Command __id="23718" _type="SelectTextCommand" caretOffset="533" date="Fri Dec 20 09:08:29 EST 2019" end="533" start="529" starttimestamp="1576666505112" timestamp="184404114" />
  <Command __id="23720" _type="InsertStringCommand" date="Fri Dec 20 09:08:30 EST 2019" starttimestamp="1576666505112" timestamp="184404953" timestamp2="184404953">
    <data><![CDATA[s]]></data>
  </Command>
  <Command __id="23721" _type="InsertStringCommand" date="Fri Dec 20 09:08:30 EST 2019" starttimestamp="1576666505112" timestamp="184404953" timestamp2="184404953">
    <data><![CDATA[s]]></data>
  </Command>
  <Command __id="23723" _type="InsertStringCommand" date="Fri Dec 20 09:08:30 EST 2019" starttimestamp="1576666505112" timestamp="184405188" timestamp2="184405188">
    <data><![CDATA[i]]></data>
  </Command>
  <Command __id="23724" _type="InsertStringCommand" date="Fri Dec 20 09:08:30 EST 2019" starttimestamp="1576666505112" timestamp="184405188" timestamp2="184405188">
    <data><![CDATA[i]]></data>
  </Command>
  <Command __id="23726" _type="InsertStringCommand" date="Fri Dec 20 09:08:30 EST 2019" starttimestamp="1576666505112" timestamp="184405403" timestamp2="184405403">
    <data><![CDATA[z]]></data>
  </Command>
  <Command __id="23727" _type="InsertStringCommand" date="Fri Dec 20 09:08:30 EST 2019" starttimestamp="1576666505112" timestamp="184405403" timestamp2="184405403">
    <data><![CDATA[z]]></data>
  </Command>
  <Command __id="23729" _type="InsertStringCommand" date="Fri Dec 20 09:08:30 EST 2019" starttimestamp="1576666505112" timestamp="184405762" timestamp2="184405762">
    <data><![CDATA[e]]></data>
  </Command>
  <Command __id="23730" _type="InsertStringCommand" date="Fri Dec 20 09:08:30 EST 2019" starttimestamp="1576666505112" timestamp="184405762" timestamp2="184405762">
    <data><![CDATA[e]]></data>
  </Command>
  <Command __id="23731" _type="MoveCaretCommand" caretOffset="531" date="Fri Dec 20 09:08:32 EST 2019" docOffset="531" starttimestamp="1576666505112" timestamp="184407141" />
  <Command __id="23732" _type="MoveCaretCommand" caretOffset="531" date="Fri Dec 20 09:08:32 EST 2019" docOffset="531" starttimestamp="1576666505112" timestamp="184407142" />
  <Command __id="23733" _type="SelectTextCommand" caretOffset="533" date="Fri Dec 20 09:08:32 EST 2019" end="533" start="529" starttimestamp="1576666505112" timestamp="184407358" />
  <Command __id="23734" _type="SelectTextCommand" caretOffset="533" date="Fri Dec 20 09:08:32 EST 2019" end="533" start="529" starttimestamp="1576666505112" timestamp="184407358" />
  <Command __id="23735" _type="CopyCommand" date="Fri Dec 20 09:08:33 EST 2019" starttimestamp="1576666505112" timestamp="184408580" />
  <Command __id="23736" _type="MoveCaretCommand" caretOffset="571" date="Fri Dec 20 09:08:35 EST 2019" docOffset="571" starttimestamp="1576666505112" timestamp="184409946" />
  <Command __id="23737" _type="MoveCaretCommand" caretOffset="571" date="Fri Dec 20 09:08:35 EST 2019" docOffset="571" starttimestamp="1576666505112" timestamp="184409946" />
  <Command __id="23738" _type="SelectTextCommand" caretOffset="572" date="Fri Dec 20 09:08:35 EST 2019" end="572" start="568" starttimestamp="1576666505112" timestamp="184410177" />
  <Command __id="23739" _type="SelectTextCommand" caretOffset="572" date="Fri Dec 20 09:08:35 EST 2019" end="572" start="568" starttimestamp="1576666505112" timestamp="184410177" />
  <Command __id="23741" _type="PasteCommand" date="Fri Dec 20 09:08:35 EST 2019" starttimestamp="1576666505112" timestamp="184410796" />
  <DocumentChange __id="23699" _type="Replace" date="Fri Dec 20 09:08:16 EST 2019" docASTNodeCount="1" docActiveCodeLength="755" docExpressionCount="0" docLength="831" endLine="28" insertionLength="380" int_docASTNodeCount="1" int_docActiveCodeLength="375" int_docExpressionCount="0" int_docLength="451" length="175" offset="376" startLine="18" starttimestamp="1576666505112" timestamp="184391803">
    <deletedText><![CDATA[    #pragma omp parallel
	{
		double local_sum = 0;

		#pragma omp for
		for(int i = 0; i < size; i++)
			local_sum += array[i];

		#pragma omp critical
		sum += local_sum;
	}]]></deletedText>
    <insertedText><![CDATA[#pragma omp parallel
	{
		double local_sum = 0;
		
		int rank = omp_get_thread_num();
		int threads = omp_get_num_threads();
		
		int start_index = (SIZE/threads)*rank;
		int end_index = (SIZE/threads)*(rank+1);
		
		if(rank==threads-1)
			end_index=SIZE;
		
		for(int i = start_index; i < end_index; i++)
			local_sum += array[i];
		
		#pragma omp critical
		sum += local_sum;
	}]]></insertedText>
  </DocumentChange>
  <DocumentChange __id="23703" _type="Insert" date="Fri Dec 20 09:08:21 EST 2019" docASTNodeCount="1" docActiveCodeLength="756" docExpressionCount="0" docLength="832" length="1" offset="376" starttimestamp="1576666505112" timestamp="184396509">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="23706" _type="Insert" date="Fri Dec 20 09:08:21 EST 2019" docASTNodeCount="1" docActiveCodeLength="757" docExpressionCount="0" docLength="833" length="1" offset="377" starttimestamp="1576666505112" timestamp="184396729">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="23709" _type="Insert" date="Fri Dec 20 09:08:22 EST 2019" docASTNodeCount="1" docActiveCodeLength="758" docExpressionCount="0" docLength="834" length="1" offset="378" starttimestamp="1576666505112" timestamp="184396945">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="23712" _type="Insert" date="Fri Dec 20 09:08:22 EST 2019" docASTNodeCount="1" docActiveCodeLength="759" docExpressionCount="0" docLength="835" length="1" offset="379" starttimestamp="1576666505112" timestamp="184397297">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="23719" _type="Replace" date="Fri Dec 20 09:08:30 EST 2019" docASTNodeCount="1" docActiveCodeLength="756" docExpressionCount="0" docLength="832" endLine="25" insertionLength="1" int_docASTNodeCount="1" int_docActiveCodeLength="755" int_docExpressionCount="0" int_docLength="831" length="4" offset="529" startLine="25" starttimestamp="1576666505112" timestamp="184404947">
    <deletedText><![CDATA[SIZE]]></deletedText>
    <insertedText><![CDATA[s]]></insertedText>
  </DocumentChange>
  <DocumentChange __id="23722" _type="Insert" date="Fri Dec 20 09:08:30 EST 2019" docASTNodeCount="1" docActiveCodeLength="757" docExpressionCount="0" docLength="833" length="1" offset="530" starttimestamp="1576666505112" timestamp="184405185">
    <text><![CDATA[i]]></text>
  </DocumentChange>
  <DocumentChange __id="23725" _type="Insert" date="Fri Dec 20 09:08:30 EST 2019" docASTNodeCount="1" docActiveCodeLength="758" docExpressionCount="0" docLength="834" length="1" offset="531" starttimestamp="1576666505112" timestamp="184405395">
    <text><![CDATA[z]]></text>
  </DocumentChange>
  <DocumentChange __id="23728" _type="Insert" date="Fri Dec 20 09:08:30 EST 2019" docASTNodeCount="1" docActiveCodeLength="759" docExpressionCount="0" docLength="835" length="1" offset="532" starttimestamp="1576666505112" timestamp="184405755">
    <text><![CDATA[e]]></text>
  </DocumentChange>
  <DocumentChange __id="23740" _type="Replace" date="Fri Dec 20 09:08:35 EST 2019" docASTNodeCount="1" docActiveCodeLength="759" docExpressionCount="0" docLength="835" endLine="26" insertionLength="4" int_docASTNodeCount="1" int_docActiveCodeLength="755" int_docExpressionCount="0" int_docLength="831" length="4" offset="568" startLine="26" starttimestamp="1576666505112" timestamp="184410787">
    <deletedText><![CDATA[SIZE]]></deletedText>
    <insertedText><![CDATA[size]]></insertedText>
  </DocumentChange>
  <DocumentChange __id="23746" _type="Replace" date="Fri Dec 20 09:08:39 EST 2019" docASTNodeCount="1" docActiveCodeLength="759" docExpressionCount="0" docLength="835" endLine="29" insertionLength="4" int_docASTNodeCount="1" int_docActiveCodeLength="755" int_docExpressionCount="0" int_docLength="831" length="4" offset="630" startLine="29" starttimestamp="1576666505112" timestamp="184413982">
    <deletedText><![CDATA[SIZE]]></deletedText>
    <insertedText><![CDATA[size]]></insertedText>
  </DocumentChange>
  <DocumentChange __id="32635" _type="Replace" date="Sat Dec 21 23:58:13 EST 2019" docASTNodeCount="565" docActiveCodeLength="3670" docExpressionCount="335" docLength="4237" endLine="36" insertionLength="9" int_docASTNodeCount="564" int_docActiveCodeLength="3661" int_docExpressionCount="334" int_docLength="4228" length="5" offset="1231" startLine="36" starttimestamp="1576666505112" timestamp="324188789">
    <deletedText><![CDATA[aFile]]></deletedText>
    <insertedText><![CDATA[aFileLine]]></insertedText>
  </DocumentChange>
  <DocumentChange __id="32636" _type="Replace" date="Sat Dec 21 23:58:13 EST 2019" docASTNodeCount="565" docActiveCodeLength="3674" docExpressionCount="335" docLength="4241" endLine="34" insertionLength="9" int_docASTNodeCount="547" int_docActiveCodeLength="3665" int_docExpressionCount="324" int_docLength="4232" length="5" offset="1125" startLine="34" starttimestamp="1576666505112" timestamp="324188805">
    <deletedText><![CDATA[aFile]]></deletedText>
    <insertedText><![CDATA[aFileLine]]></insertedText>
  </DocumentChange>
  <Command __id="32678" _type="DiffBasedFileOpenCommand" date="Sat Dec 21 23:58:18 EST 2019" projectName="null" starttimestamp="1576666505112" timestamp="324193512">
    <filePath><![CDATA[null]]></filePath>
    <diff><![CDATA[null]]></diff>
  </Command>
  <Command __id="32683" _type="DiffBasedFileOpenCommand" date="Sat Dec 21 23:58:20 EST 2019" docASTNodeCount="565" docActiveCodeLength="3674" docExpressionCount="335" docLength="4241" projectName="GraderBasics" starttimestamp="1576666505112" timestamp="324195574">
    <filePath><![CDATA[D:\dewan_backup\Java\GraderBasics\src\gradingTools\shared\testcases\openmp\OpenMPUtils.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package gradingTools.shared.testcases.openmp;¬∂¬∂import java.util.ArrayList;¬∂import java.util.HashMap;¬∂import java.util.List;¬∂import java.util.Map;¬∂"), Diff(INSERT,"import java.util.Stack;¬∂"), Diff(EQUAL,"¬∂¬∂public class OpenMPUtils {¬∂//	protected static Map<String, OpenMPKeywordEnum> stringToOpenMPKeyword = new HashMap();¬∂	public static List<OpenMPPragma> getOpemMPPragmas(StringBuffer aFileBuffer) {¬∂		String[] aFileLines = aFileBuffer.toString().split("\n");¬∂		return getOpenMPPragmas(aFileLines);¬∂	}¬∂	¬∂	public static boolean isCodeLine(String aLine) {¬∂		return !aLine.isEmpty() && !aLine.startsWith("//");¬∂	}¬∂	public static boolean isBlockStart(String aLine) {¬∂		return "{".equals(aLine);¬∂	}¬∂	public static boolean isBlockEnd(String aLine) {¬∂		return "}".equals(aLine);¬∂	}¬∂	public static boolean is"), Diff(DELETE,"PragmaStart(String aLine) {¬∂		return aLine.startsWith("#pragma");¬∂	}¬∂	"), Diff(INSERT,"LoopStart(String aLine) {¬∂		return aLine.startsWith("for");¬∂	}¬∂	public static boolean endsWithLoopHeader(String aLine) {¬∂		return aLine.endsWith(")");¬∂	}¬∂	public static boolean isPragmaStart(String aLine) {¬∂		return aLine.startsWith("#pragma");¬∂	}¬∂	public static void addToStack(Stack<OpenMPPragma> anOpenMPPragmas, String aFileLine) {¬∂		for (OpenMPPragma anOpenMPPragma:anOpenMPPragmas) {¬∂			anOpenMPPragma.getAnnotatedText().add(aFileLine);¬∂		}¬∂	}¬∂	¬∂	public static void incrementStackTop (Stack<Integer> aNumOpenBracesStack) {¬∂		int aTopIndex = aNumOpenBracesStack.size() - 1;¬∂		Integer aCurrentValue = aNumOpenBracesStack.get(aTopIndex);¬∂		aNumOpenBracesStack.set(aTopIndex, aCurrentValue + 1);¬∂	}¬∂	public static void decrementStackTop (Stack<Integer> aNumOpenBracesStack) {¬∂		int aTopIndex = aNumOpenBracesStack.size() - 1;¬∂		Integer aCurrentValue = aNumOpenBracesStack.get(aTopIndex);¬∂		aNumOpenBracesStack.set(aTopIndex, aCurrentValue - 1);¬∂	}"), Diff(EQUAL,"¬∂¬∂	public static List<OpenMPPragma> getOpenMPPragmas(String[] aFileLines) {¬∂		List<OpenMPPragma> retVal = new ArrayList();¬∂		"), Diff(INSERT,"Stack<"), Diff(EQUAL,"OpenMPPragma"), Diff(INSERT,">"), Diff(EQUAL," anOpenMPPragma"), Diff(INSERT,"s"), Diff(EQUAL," = n"), Diff(DELETE,"ull"), Diff(INSERT,"ew Stack();¬∂		Stack<Integer> aNumOpenBracesStack = new Stack()"), Diff(EQUAL,";¬∂"), Diff(INSERT,"//"), Diff(EQUAL,"		int aNumOpenBraces = 0;¬∂		boolean a"), Diff(DELETE,"LastNonEmpty"), Diff(INSERT,"NextCode"), Diff(EQUAL,"Line"), Diff(DELETE,"Wa"), Diff(INSERT,"I"), Diff(EQUAL,"sAPragma"), Diff(INSERT,"Block"), Diff(EQUAL," = false;¬∂		for (int i = 0; i < aFileLines.length; i++) {¬∂			String aFileLine = aFileLines[i].trim();¬∂			if (!isCodeLine(aFileLine)) {¬∂				continue;¬∂			}¬∂			"), Diff(INSERT,"addToStack(anOpenMPPragmas, aFileLine); // if it is empty add to none¬∂			"), Diff(EQUAL,"if (isPragmaStart(aFileLine)) {¬∂				"), Diff(INSERT,"¬∂				OpenMPPragma "), Diff(EQUAL,"anOpenMPPragma = getOpemMPPragma(aFileLine, i);¬∂				if (anOpenMPPragma != null) {¬∂					"), Diff(INSERT,"anOpenMPPragmas.add(anOpenMPPragma);¬∂					aNumOpenBracesStack.add(0);¬∂					"), Diff(EQUAL,"retVal.add(anOpenMPPragma);"), Diff(INSERT,"					"), Diff(EQUAL,"¬∂					a"), Diff(DELETE,"LastNonEmpty"), Diff(INSERT,"NextCode"), Diff(EQUAL,"Line"), Diff(DELETE,"Wa"), Diff(INSERT,"I"), Diff(EQUAL,"sAPragma"), Diff(INSERT,"Block"), Diff(EQUAL," = true;¬∂					continue;¬∂				} ¬∂			}¬∂			if (anOpenMPPragma"), Diff(DELETE," == null"), Diff(INSERT,"s.isEmpty()"), Diff(EQUAL,") {¬∂				continue;¬∂			}	¬∂			if (a"), Diff(DELETE,"LastNonEmpty"), Diff(INSERT,"NextCode"), Diff(EQUAL,"Line"), Diff(DELETE,"Wa"), Diff(INSERT,"I"), Diff(EQUAL,"sAPragma"), Diff(DELETE,") {"), Diff(INSERT,"Block) {				"), Diff(EQUAL,"¬∂				anOpenMPPragma"), Diff(INSERT,"s.peek()"), Diff(EQUAL,".setAnnotatedTextStartLineNumber(i);"), Diff(INSERT,"				"), Diff(EQUAL,"¬∂				a"), Diff(DELETE,"LastNonEmpty"), Diff(INSERT,"NextCode"), Diff(EQUAL,"Line"), Diff(DELETE,"Wa"), Diff(INSERT,"I"), Diff(EQUAL,"sAPragma"), Diff(INSERT,"Block"), Diff(EQUAL," = false;¬∂			}¬∂"), Diff(INSERT,"//"), Diff(EQUAL,"			anOpenMPPragma"), Diff(INSERT,"s.peek()"), Diff(EQUAL,".getAnnotatedText().add(aFileLine);¬∂			if (isBlockStart(aFileLine)) {¬∂				"), Diff(INSERT,"incrementStackTop("), Diff(EQUAL,"aNumOpenBraces"), Diff(DELETE,"++"), Diff(INSERT,"Stack)"), Diff(EQUAL,";¬∂			} else if (isBlockEnd(aFileLine)) {¬∂				"), Diff(DELETE,"aNumOpenBraces--;"), Diff(INSERT,"decrementStackTop(aNumOpenBracesStack);¬∂¬∂			}¬∂			if (isLoopStart(aFileLine) && endsWithLoopHeader(aFileLine)) {¬∂				continue; // gather following block also"), Diff(EQUAL,"¬∂			}¬∂			if (aNumOpenBraces"), Diff(INSERT,"Stack.peek()"), Diff(EQUAL," == 0) {¬∂				"), Diff(INSERT,"¬∂				"), Diff(EQUAL,"anOpenMPPragma"), Diff(INSERT,"s.peek()"), Diff(EQUAL,".setAnnotatedTextEndLineNumber(i);¬∂				anOpenMPPragma"), Diff(DELETE," = null"), Diff(INSERT,"s.pop()"), Diff(EQUAL,";¬∂				continue;¬∂			}					¬∂		}¬∂		return retVal;¬∂	}¬∂	public static OpenMPPragma getOpemMPPragma(String aFileLine, int aLineIndex) {¬∂		String[] aTokens = aFileLine.split(" ");¬∂		if (aTokens.length <= 2) {¬∂			return null;¬∂		}¬∂		if (!aTokens[1].equals("omp")) {¬∂			return null;¬∂		}¬∂		for (int i = 2; i < aTokens.length; i ++) {¬∂			String aStoredToken = aTokens[i].trim().toLowerCase();¬∂			aTokens[i] = aStoredToken;¬∂		}¬∂		OpenMPPragma retVal = new AnOpenMPPragma(aTokens, aLineIndex);¬∂		return retVal;¬∂		¬∂		¬∂	}¬∂	static {¬∂//		stringToOpenMPKeyword.put("for", OpenMPKeywordEnum.FOR);¬∂//		stringToOpenMPKeyword.put("parallel", OpenMPKeywordEnum.PARALLEL);¬∂//		stringToOpenMPKeyword.put("reduce", OpenMPKeywordEnum.REDUCE);¬∂//		stringToOpenMPKeyword.put("shared", OpenMPKeywordEnum.SHARED);¬∂//		stringToOpenMPKeyword.put("private", OpenMPKeywordEnum.PRIVATE);¬∂¬∂¬∂¬∂¬∂	}¬∂	¬∂¬∂}¬∂")]]]></diff>
    <snapshot><![CDATA[package gradingTools.shared.testcases.openmp;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Stack;


public class OpenMPUtils {
//	protected static Map<String, OpenMPKeywordEnum> stringToOpenMPKeyword = new HashMap();
	public static List<OpenMPPragma> getOpemMPPragmas(StringBuffer aFileBuffer) {
		String[] aFileLines = aFileBuffer.toString().split("\n");
		return getOpenMPPragmas(aFileLines);
	}
	
	public static boolean isCodeLine(String aLine) {
		return !aLine.isEmpty() && !aLine.startsWith("//");
	}
	public static boolean isBlockStart(String aLine) {
		return "{".equals(aLine);
	}
	public static boolean isBlockEnd(String aLine) {
		return "}".equals(aLine);
	}
	public static boolean isLoopStart(String aLine) {
		return aLine.startsWith("for");
	}
	public static boolean endsWithLoopHeader(String aLine) {
		return aLine.endsWith(")");
	}
	public static boolean isPragmaStart(String aLine) {
		return aLine.startsWith("#pragma");
	}
	public static void addToStack(Stack<OpenMPPragma> anOpenMPPragmas, String aFileLine) {
		for (OpenMPPragma anOpenMPPragma:anOpenMPPragmas) {
			anOpenMPPragma.getAnnotatedText().add(aFileLine);
		}
	}
	
	public static void incrementStackTop (Stack<Integer> aNumOpenBracesStack) {
		int aTopIndex = aNumOpenBracesStack.size() - 1;
		Integer aCurrentValue = aNumOpenBracesStack.get(aTopIndex);
		aNumOpenBracesStack.set(aTopIndex, aCurrentValue + 1);
	}
	public static void decrementStackTop (Stack<Integer> aNumOpenBracesStack) {
		int aTopIndex = aNumOpenBracesStack.size() - 1;
		Integer aCurrentValue = aNumOpenBracesStack.get(aTopIndex);
		aNumOpenBracesStack.set(aTopIndex, aCurrentValue - 1);
	}

	public static List<OpenMPPragma> getOpenMPPragmas(String[] aFileLines) {
		List<OpenMPPragma> retVal = new ArrayList();
		Stack<OpenMPPragma> anOpenMPPragmas = new Stack();
		Stack<Integer> aNumOpenBracesStack = new Stack();
//		int aNumOpenBraces = 0;
		boolean aNextCodeLineIsAPragmaBlock = false;
		for (int i = 0; i < aFileLines.length; i++) {
			String aFileLine = aFileLines[i].trim();
			if (!isCodeLine(aFileLine)) {
				continue;
			}
			addToStack(anOpenMPPragmas, aFileLine); // if it is empty add to none
			if (isPragmaStart(aFileLine)) {
				
				OpenMPPragma anOpenMPPragma = getOpemMPPragma(aFileLine, i);
				if (anOpenMPPragma != null) {
					anOpenMPPragmas.add(anOpenMPPragma);
					aNumOpenBracesStack.add(0);
					retVal.add(anOpenMPPragma);					
					aNextCodeLineIsAPragmaBlock = true;
					continue;
				} 
			}
			if (anOpenMPPragmas.isEmpty()) {
				continue;
			}	
			if (aNextCodeLineIsAPragmaBlock) {				
				anOpenMPPragmas.peek().setAnnotatedTextStartLineNumber(i);				
				aNextCodeLineIsAPragmaBlock = false;
			}
//			anOpenMPPragmas.peek().getAnnotatedText().add(aFileLine);
			if (isBlockStart(aFileLine)) {
				incrementStackTop(aNumOpenBracesStack);
			} else if (isBlockEnd(aFileLine)) {
				decrementStackTop(aNumOpenBracesStack);

			}
			if (isLoopStart(aFileLine) && endsWithLoopHeader(aFileLine)) {
				continue; // gather following block also
			}
			if (aNumOpenBracesStack.peek() == 0) {
				
				anOpenMPPragmas.peek().setAnnotatedTextEndLineNumber(i);
				anOpenMPPragmas.pop();
				continue;
			}					
		}
		return retVal;
	}
	public static OpenMPPragma getOpemMPPragma(String aFileLine, int aLineIndex) {
		String[] aTokens = aFileLine.split(" ");
		if (aTokens.length <= 2) {
			return null;
		}
		if (!aTokens[1].equals("omp")) {
			return null;
		}
		for (int i = 2; i < aTokens.length; i ++) {
			String aStoredToken = aTokens[i].trim().toLowerCase();
			aTokens[i] = aStoredToken;
		}
		OpenMPPragma retVal = new AnOpenMPPragma(aTokens, aLineIndex);
		return retVal;
		
		
	}
	static {
//		stringToOpenMPKeyword.put("for", OpenMPKeywordEnum.FOR);
//		stringToOpenMPKeyword.put("parallel", OpenMPKeywordEnum.PARALLEL);
//		stringToOpenMPKeyword.put("reduce", OpenMPKeywordEnum.REDUCE);
//		stringToOpenMPKeyword.put("shared", OpenMPKeywordEnum.SHARED);
//		stringToOpenMPKeyword.put("private", OpenMPKeywordEnum.PRIVATE);




	}
	

}
]]></snapshot>
  </Command>
  <Command __id="32687" _type="DiffBasedFileOpenCommand" date="Sat Dec 21 23:58:22 EST 2019" projectName="null" starttimestamp="1576666505112" timestamp="324197320">
    <filePath><![CDATA[null]]></filePath>
    <diff><![CDATA[null]]></diff>
  </Command>
  <Command __id="32691" _type="DiffBasedFileOpenCommand" date="Sat Dec 21 23:58:24 EST 2019" docASTNodeCount="565" docActiveCodeLength="3674" docExpressionCount="335" docLength="4241" projectName="GraderBasics" starttimestamp="1576666505112" timestamp="324199179">
    <filePath><![CDATA[D:\dewan_backup\Java\GraderBasics\src\gradingTools\shared\testcases\openmp\OpenMPUtils.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package gradingTools.shared.testcases.openmp;¬∂¬∂import java.util.ArrayList;¬∂import java.util.HashMap;¬∂import java.util.List;¬∂import java.util.Map;¬∂import java.util.Stack;¬∂¬∂¬∂public class OpenMPUtils {¬∂//	protected static Map<String, OpenMPKeywordEnum> stringToOpenMPKeyword = new HashMap();¬∂	public static List<OpenMPPragma> getOpemMPPragmas(StringBuffer aFileBuffer) {¬∂		String[] aFileLines = aFileBuffer.toString().split("\n");¬∂		return getOpenMPPragmas(aFileLines);¬∂	}¬∂	¬∂	public static boolean isCodeLine(String aLine) {¬∂		return !aLine.isEmpty() && !aLine.startsWith("//");¬∂	}¬∂	public static boolean isBlockStart(String aLine) {¬∂		return "{".equals(aLine);¬∂	}¬∂	public static boolean isBlockEnd(String aLine) {¬∂		return "}".equals(aLine);¬∂	}¬∂	public static boolean isLoopStart(String aLine) {¬∂		return aLine.startsWith("for");¬∂	}¬∂	public static boolean endsWithLoopHeader(String aLine) {¬∂		return aLine.endsWith(")");¬∂	}¬∂	public static boolean isPragmaStart(String aLine) {¬∂		return aLine.startsWith("#pragma");¬∂	}¬∂	public static void addToStack(Stack<OpenMPPragma> anOpenMPPragmas, String aFileLine) {¬∂		for (OpenMPPragma anOpenMPPragma:anOpenMPPragmas) {¬∂			anOpenMPPragma.getAnnotatedText().add(aFileLine);¬∂		}¬∂	}¬∂	¬∂	public static void incrementStackTop (Stack<Integer> aNumOpenBracesStack) {¬∂		int aTopIndex = aNumOpenBracesStack.size() - 1;¬∂		Integer aCurrentValue = aNumOpenBracesStack.get(aTopIndex);¬∂		aNumOpenBracesStack.set(aTopIndex, aCurrentValue + 1);¬∂	}¬∂	public static void decrementStackTop (Stack<Integer> aNumOpenBracesStack) {¬∂		int aTopIndex = aNumOpenBracesStack.size() - 1;¬∂		Integer aCurrentValue = aNumOpenBracesStack.get(aTopIndex);¬∂		aNumOpenBracesStack.set(aTopIndex, aCurrentValue - 1);¬∂	}¬∂¬∂	public static List<OpenMPPragma> getOpenMPPragmas(String[] aFileLines) {¬∂		List<OpenMPPragma> retVal = new ArrayList();¬∂		Stack<OpenMPPragma> anOpenMPPragmas = new Stack();¬∂		Stack<Integer> aNumOpenBracesStack = new Stack();¬∂//		int aNumOpenBraces = 0;¬∂		boolean aNextCodeLineIsAPragmaBlock = false;¬∂		for (int i = 0; i < aFileLines.length; i++) {¬∂			String aFileLine = aFileLines[i].trim();¬∂			if (!isCodeLine(aFileLine)) {¬∂				continue;¬∂			}¬∂			addToStack(anOpenMPPragmas, aFileLine); // if it is empty add to none¬∂			if (isPragmaStart(aFileLine)) {¬∂				¬∂				OpenMPPragma anOpenMPPragma = getOpemMPPragma(aFileLine, i);¬∂				if (anOpenMPPragma != null) {¬∂					anOpenMPPragmas.add(anOpenMPPragma);¬∂					aNumOpenBracesStack.add(0);¬∂					retVal.add(anOpenMPPragma);					¬∂					aNextCodeLineIsAPragmaBlock = true;¬∂					continue;¬∂				} ¬∂			}¬∂			if (anOpenMPPragmas.isEmpty()) {¬∂				continue;¬∂			}	¬∂			if (aNextCodeLineIsAPragmaBlock) {				¬∂				anOpenMPPragmas.peek().setAnnotatedTextStartLineNumber(i);				¬∂				aNextCodeLineIsAPragmaBlock = false;¬∂			}¬∂//			anOpenMPPragmas.peek().getAnnotatedText().add(aFileLine);¬∂			if (isBlockStart(aFileLine)) {¬∂				incrementStackTop(aNumOpenBracesStack);¬∂			} else if (isBlockEnd(aFileLine)) {¬∂				decrementStackTop(aNumOpenBracesStack);¬∂¬∂			}¬∂			if (isLoopStart(aFileLine) && endsWithLoopHeader(aFileLine)) {¬∂				continue; // gather following block also¬∂			}¬∂			if (aNumOpenBracesStack.peek() == 0) {¬∂				¬∂				anOpenMPPragmas.peek().setAnnotatedTextEndLineNumber(i);¬∂				anOpenMPPragmas.pop();¬∂				continue;¬∂			}					¬∂		}¬∂		return retVal;¬∂	}¬∂	public static OpenMPPragma getOpemMPPragma(String aFileLine, int aLineIndex) {¬∂		String[] aTokens = aFileLine.split(" ");¬∂		if (aTokens.length <= 2) {¬∂			return null;¬∂		}¬∂		if (!aTokens[1].equals("omp")) {¬∂			return null;¬∂		}¬∂		for (int i = 2; i < aTokens.length; i ++) {¬∂			String aStoredToken = aTokens[i].trim().toLowerCase();¬∂			aTokens[i] = aStoredToken;¬∂		}¬∂		OpenMPPragma retVal = new AnOpenMPPragma(aTokens, aLineIndex);¬∂		return retVal;¬∂		¬∂		¬∂	}¬∂	static {¬∂//		stringToOpenMPKeyword.put("for", OpenMPKeywordEnum.FOR);¬∂//		stringToOpenMPKeyword.put("parallel", OpenMPKeywordEnum.PARALLEL);¬∂//		stringToOpenMPKeyword.put("reduce", OpenMPKeywordEnum.REDUCE);¬∂//		stringToOpenMPKeyword.put("shared", OpenMPKeywordEnum.SHARED);¬∂//		stringToOpenMPKeyword.put("private", OpenMPKeywordEnum.PRIVATE);¬∂¬∂¬∂¬∂¬∂	}¬∂	¬∂¬∂}¬∂")]]]></diff>
  </Command>
  <Command __id="33129" _type="EclipseCommand" commandID="org.eclipse.debug.ui.commands.Resume" date="Sun Dec 22 00:05:43 EST 2019" starttimestamp="1576666505112" timestamp="324638304" />
  <Command __id="33130" _type="RunCommand" date="Sun Dec 22 00:05:43 EST 2019" kind="StepInto" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="324638307" type="Run" />
  <Command __id="33131" _type="EHExceptionCommand" date="Sun Dec 22 00:05:43 EST 2019" starttimestamp="1576666505112" timestamp="324638358" type="Exception">
    <outputString><![CDATA[file name:sum_parallel_for_local_var.cp
pragmas:[20:[#pragma, omp, parallel]-->21:[{, double local_sum = 0;, #pragma omp for, for(int i = 0; i < size; i++) {, local_sum += array[i];], 24:[#pragma, omp, for]-->25:[for(int i = 0; i < size; i++) {], 30:[#pragma, omp, critical]-->31:[sum += local_sum;]]
]]></outputString>
  </Command>
  <Command __id="33133" _type="MoveCaretCommand" caretOffset="308" date="Sun Dec 22 00:06:34 EST 2019" docOffset="308" starttimestamp="1576666505112" timestamp="324689775" />
  <Command __id="33134" _type="ShellCommand" date="Sun Dec 22 00:15:01 EST 2019" starttimestamp="1576666505112" timestamp="325196810" type="ECLIPSE_LOST_FOCUS" />
  <DocumentChange __id="33520" _type="Delete" date="Sun Dec 22 00:25:52 EST 2019" docASTNodeCount="194" docActiveCodeLength="1531" docExpressionCount="104" docLength="1776" endLine="62" length="1" offset="1746" startLine="62" starttimestamp="1576666505112" timestamp="325847234">
    <text><![CDATA["]]></text>
  </DocumentChange>
  <Command __id="33583" _type="DiffBasedFileOpenCommand" date="Sun Dec 22 00:27:31 EST 2019" docASTNodeCount="565" docActiveCodeLength="3679" docExpressionCount="335" docLength="4258" projectName="GraderBasics" starttimestamp="1576666505112" timestamp="325946200">
    <filePath><![CDATA[D:\dewan_backup\Java\GraderBasics\src\gradingTools\shared\testcases\openmp\OpenMPUtils.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package gradingTools.shared.testcases.openmp;¬∂¬∂import java.util.ArrayList;¬∂import java.util.HashMap;¬∂import java.util.List;¬∂import java.util.Map;¬∂import java.util.Stack;¬∂¬∂¬∂public class OpenMPUtils {¬∂//	protected static Map<String, OpenMPKeywordEnum> stringToOpenMPKeyword = new HashMap();¬∂	public static List<OpenMPPragma> getOpemMPPragmas(StringBuffer aFileBuffer) {¬∂		String[] aFileLines = aFileBuffer.toString().split("\n");¬∂		return getOpenMPPragmas(aFileLines);¬∂	}¬∂	¬∂	public static boolean isCodeLine(String aLine) {¬∂		return !aLine.isEmpty() && !aLine.startsWith("//");¬∂	}¬∂	public static boolean isBlockStart(String aLine) {¬∂		return aLine.contains("{");¬∂	}¬∂	public static boolean isBlockEnd(String aLine) {¬∂		return aLine.contains("}");¬∂	}¬∂	public static boolean isLoopStart(String aLine) {¬∂		return aLine.startsWith("for");¬∂	}¬∂	public static boolean endsWithLoopHeader(String aLine) {¬∂		return aLine.endsWith(")");¬∂	}¬∂	public static boolean isPragmaStart(String aLine) {¬∂		return aLine.startsWith("#pragma");¬∂	}¬∂	public static void addToStack(Stack<OpenMPPragma> anOpenMPPragmas, String aFileLine) {¬∂		for (OpenMPPragma anOpenMPPragma:anOpenMPPragmas) {¬∂			anOpenMPPragma.getAnnotatedText().add(aFileLine);¬∂		}¬∂	}¬∂	¬∂	public static void incrementStackTop (Stack<Integer> aNumOpenBracesStack) {¬∂		int aTopIndex = aNumOpenBracesStack.size() - 1;¬∂		Integer aCurrentValue = aNumOpenBracesStack.get(aTopIndex);¬∂		aNumOpenBracesStack.set(aTopIndex, aCurrentValue + 1);¬∂	}¬∂	public static void decrementStackTop (Stack<Integer> aNumOpenBracesStack) {¬∂		int aTopIndex = aNumOpenBracesStack.size() - 1;¬∂		Integer aCurrentValue = aNumOpenBracesStack.get(aTopIndex);¬∂		aNumOpenBracesStack.set(aTopIndex, aCurrentValue - 1);¬∂	}¬∂¬∂	public static List<OpenMPPragma> getOpenMPPragmas(String[] aFileLines) {¬∂		List<OpenMPPragma> retVal = new ArrayList();¬∂		Stack<OpenMPPragma> anOpenMPPragmas = new Stack();¬∂		Stack<Integer> aNumOpenBracesStack = new Stack();¬∂//		int aNumOpenBraces = 0;¬∂		boolean aNextCodeLineIsAPragmaBlock = false;¬∂		for (int i = 0; i < aFileLines.length; i++) {¬∂			String aFileLine = aFileLines[i].trim();¬∂			if (!isCodeLine(aFileLine)) {¬∂				continue;¬∂			}¬∂			addToStack(anOpenMPPragmas, aFileLine); // if it is empty add to none¬∂			if (isPragmaStart(aFileLine)) {¬∂				¬∂				OpenMPPragma anOpenMPPragma = getOpemMPPragma(aFileLine, i);¬∂				if (anOpenMPPragma != null) {¬∂					anOpenMPPragmas.add(anOpenMPPragma);¬∂					aNumOpenBracesStack.add(0);¬∂					retVal.add(anOpenMPPragma);					¬∂					aNextCodeLineIsAPragmaBlock = true;¬∂					continue;¬∂				} ¬∂			}¬∂			if (anOpenMPPragmas.isEmpty()) {¬∂				continue;¬∂			}	¬∂			if (aNextCodeLineIsAPragmaBlock) {				¬∂				anOpenMPPragmas.peek().setAnnotatedTextStartLineNumber(i);				¬∂				aNextCodeLineIsAPragmaBlock = false;¬∂			}¬∂//			anOpenMPPragmas.peek().getAnnotatedText().add(aFileLine);¬∂			if (isBlockStart(aFileLine)) {¬∂				incrementStackTop(aNumOpenBracesStack);¬∂"), Diff(INSERT,"			}¬∂"), Diff(EQUAL,"//			} else ¬∂			if (isBlockEnd(aFileLine)) {¬∂				decrementStackTop(aNumOpenBracesStack);¬∂¬∂			}¬∂			if (isLoopStart(aFileLine) && endsWithLoopHeader(aFileLine)) {¬∂				continue; // gather following block also¬∂			}¬∂			if (aNumOpenBracesStack.peek() == 0) {¬∂				¬∂				anOpenMPPragmas.peek().setAnnotatedTextEndLineNumber(i);¬∂				anOpenMPPragmas.pop();¬∂				continue;¬∂			}					¬∂		}¬∂		return retVal;¬∂	}¬∂	public static OpenMPPragma getOpemMPPragma(String aFileLine, int aLineIndex) {¬∂		String[] aTokens = aFileLine.split(" ");¬∂		if (aTokens.length <= 2) {¬∂			return null;¬∂		}¬∂		if (!aTokens[1].equals("omp")) {¬∂			return null;¬∂		}¬∂		for (int i = 2; i < aTokens.length; i ++) {¬∂			String aStoredToken = aTokens[i].trim().toLowerCase();¬∂			aTokens[i] = aStoredToken;¬∂		}¬∂		OpenMPPragma retVal = new AnOpenMPPragma(aTokens, aLineIndex);¬∂		return retVal;¬∂		¬∂		¬∂	}¬∂	static {¬∂//		stringToOpenMPKeyword.put("for", OpenMPKeywordEnum.FOR);¬∂//		stringToOpenMPKeyword.put("parallel", OpenMPKeywordEnum.PARALLEL);¬∂//		stringToOpenMPKeyword.put("reduce", OpenMPKeywordEnum.REDUCE);¬∂//		stringToOpenMPKeyword.put("shared", OpenMPKeywordEnum.SHARED);¬∂//		stringToOpenMPKeyword.put("private", OpenMPKeywordEnum.PRIVATE);¬∂¬∂¬∂¬∂¬∂	}¬∂	¬∂¬∂}¬∂")]]]></diff>
    <snapshot><![CDATA[package gradingTools.shared.testcases.openmp;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Stack;


public class OpenMPUtils {
//	protected static Map<String, OpenMPKeywordEnum> stringToOpenMPKeyword = new HashMap();
	public static List<OpenMPPragma> getOpemMPPragmas(StringBuffer aFileBuffer) {
		String[] aFileLines = aFileBuffer.toString().split("\n");
		return getOpenMPPragmas(aFileLines);
	}
	
	public static boolean isCodeLine(String aLine) {
		return !aLine.isEmpty() && !aLine.startsWith("//");
	}
	public static boolean isBlockStart(String aLine) {
		return aLine.contains("{");
	}
	public static boolean isBlockEnd(String aLine) {
		return aLine.contains("}");
	}
	public static boolean isLoopStart(String aLine) {
		return aLine.startsWith("for");
	}
	public static boolean endsWithLoopHeader(String aLine) {
		return aLine.endsWith(")");
	}
	public static boolean isPragmaStart(String aLine) {
		return aLine.startsWith("#pragma");
	}
	public static void addToStack(Stack<OpenMPPragma> anOpenMPPragmas, String aFileLine) {
		for (OpenMPPragma anOpenMPPragma:anOpenMPPragmas) {
			anOpenMPPragma.getAnnotatedText().add(aFileLine);
		}
	}
	
	public static void incrementStackTop (Stack<Integer> aNumOpenBracesStack) {
		int aTopIndex = aNumOpenBracesStack.size() - 1;
		Integer aCurrentValue = aNumOpenBracesStack.get(aTopIndex);
		aNumOpenBracesStack.set(aTopIndex, aCurrentValue + 1);
	}
	public static void decrementStackTop (Stack<Integer> aNumOpenBracesStack) {
		int aTopIndex = aNumOpenBracesStack.size() - 1;
		Integer aCurrentValue = aNumOpenBracesStack.get(aTopIndex);
		aNumOpenBracesStack.set(aTopIndex, aCurrentValue - 1);
	}

	public static List<OpenMPPragma> getOpenMPPragmas(String[] aFileLines) {
		List<OpenMPPragma> retVal = new ArrayList();
		Stack<OpenMPPragma> anOpenMPPragmas = new Stack();
		Stack<Integer> aNumOpenBracesStack = new Stack();
//		int aNumOpenBraces = 0;
		boolean aNextCodeLineIsAPragmaBlock = false;
		for (int i = 0; i < aFileLines.length; i++) {
			String aFileLine = aFileLines[i].trim();
			if (!isCodeLine(aFileLine)) {
				continue;
			}
			addToStack(anOpenMPPragmas, aFileLine); // if it is empty add to none
			if (isPragmaStart(aFileLine)) {
				
				OpenMPPragma anOpenMPPragma = getOpemMPPragma(aFileLine, i);
				if (anOpenMPPragma != null) {
					anOpenMPPragmas.add(anOpenMPPragma);
					aNumOpenBracesStack.add(0);
					retVal.add(anOpenMPPragma);					
					aNextCodeLineIsAPragmaBlock = true;
					continue;
				} 
			}
			if (anOpenMPPragmas.isEmpty()) {
				continue;
			}	
			if (aNextCodeLineIsAPragmaBlock) {				
				anOpenMPPragmas.peek().setAnnotatedTextStartLineNumber(i);				
				aNextCodeLineIsAPragmaBlock = false;
			}
//			anOpenMPPragmas.peek().getAnnotatedText().add(aFileLine);
			if (isBlockStart(aFileLine)) {
				incrementStackTop(aNumOpenBracesStack);
			}
//			} else 
			if (isBlockEnd(aFileLine)) {
				decrementStackTop(aNumOpenBracesStack);

			}
			if (isLoopStart(aFileLine) && endsWithLoopHeader(aFileLine)) {
				continue; // gather following block also
			}
			if (aNumOpenBracesStack.peek() == 0) {
				
				anOpenMPPragmas.peek().setAnnotatedTextEndLineNumber(i);
				anOpenMPPragmas.pop();
				continue;
			}					
		}
		return retVal;
	}
	public static OpenMPPragma getOpemMPPragma(String aFileLine, int aLineIndex) {
		String[] aTokens = aFileLine.split(" ");
		if (aTokens.length <= 2) {
			return null;
		}
		if (!aTokens[1].equals("omp")) {
			return null;
		}
		for (int i = 2; i < aTokens.length; i ++) {
			String aStoredToken = aTokens[i].trim().toLowerCase();
			aTokens[i] = aStoredToken;
		}
		OpenMPPragma retVal = new AnOpenMPPragma(aTokens, aLineIndex);
		return retVal;
		
		
	}
	static {
//		stringToOpenMPKeyword.put("for", OpenMPKeywordEnum.FOR);
//		stringToOpenMPKeyword.put("parallel", OpenMPKeywordEnum.PARALLEL);
//		stringToOpenMPKeyword.put("reduce", OpenMPKeywordEnum.REDUCE);
//		stringToOpenMPKeyword.put("shared", OpenMPKeywordEnum.SHARED);
//		stringToOpenMPKeyword.put("private", OpenMPKeywordEnum.PRIVATE);




	}
	

}
]]></snapshot>
  </Command>
  <Command __id="33622" _type="RunCommand" date="Sun Dec 22 00:29:01 EST 2019" kind="StepInto" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="326036470" type="Run" />
  <Command __id="33623" _type="RunCommand" date="Sun Dec 22 00:29:01 EST 2019" kind="StepInto" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="326036482" type="Run" />
  <Command __id="33625" _type="MoveCaretCommand" caretOffset="308" date="Sun Dec 22 00:29:08 EST 2019" docOffset="308" starttimestamp="1576666505112" timestamp="326043736" />
  <Command __id="33626" _type="ShellCommand" date="Sun Dec 22 00:29:19 EST 2019" starttimestamp="1576666505112" timestamp="326054312" type="ECLIPSE_MINIMIZED" />
  <Command __id="33627" _type="ShellCommand" date="Sun Dec 22 00:29:19 EST 2019" starttimestamp="1576666505112" timestamp="326054322" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="33652" _type="EclipseCommand" commandID="org.eclipse.debug.ui.commands.StepInto" date="Sun Dec 22 00:29:52 EST 2019" starttimestamp="1576666505112" timestamp="326087175" />
  <Command __id="33653" _type="RunCommand" date="Sun Dec 22 00:29:52 EST 2019" kind="StepInto" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="326087182" type="Run" />
  <Command __id="33654" _type="EclipseCommand" commandID="org.eclipse.debug.ui.commands.StepOver" date="Sun Dec 22 00:29:53 EST 2019" starttimestamp="1576666505112" timestamp="326088105" />
  <Command __id="33655" _type="RunCommand" date="Sun Dec 22 00:29:53 EST 2019" kind="StepInto" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="326088116" type="Run" />
  <Command __id="33659" _type="DiffBasedFileOpenCommand" date="Sun Dec 22 00:30:17 EST 2019" docASTNodeCount="565" docActiveCodeLength="3679" docExpressionCount="335" docLength="4258" projectName="GraderBasics" starttimestamp="1576666505112" timestamp="326112554">
    <filePath><![CDATA[D:\dewan_backup\Java\GraderBasics\src\gradingTools\shared\testcases\openmp\OpenMPUtils.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package gradingTools.shared.testcases.openmp;¬∂¬∂import java.util.ArrayList;¬∂import java.util.HashMap;¬∂import java.util.List;¬∂import java.util.Map;¬∂import java.util.Stack;¬∂¬∂¬∂public class OpenMPUtils {¬∂//	protected static Map<String, OpenMPKeywordEnum> stringToOpenMPKeyword = new HashMap();¬∂	public static List<OpenMPPragma> getOpemMPPragmas(StringBuffer aFileBuffer) {¬∂		String[] aFileLines = aFileBuffer.toString().split("\n");¬∂		return getOpenMPPragmas(aFileLines);¬∂	}¬∂	¬∂	public static boolean isCodeLine(String aLine) {¬∂		return !aLine.isEmpty() && !aLine.startsWith("//");¬∂	}¬∂	public static boolean isBlockStart(String aLine) {¬∂		return aLine.contains("{");¬∂	}¬∂	public static boolean isBlockEnd(String aLine) {¬∂		return aLine.contains("}");¬∂	}¬∂	public static boolean isLoopStart(String aLine) {¬∂		return aLine.startsWith("for");¬∂	}¬∂	public static boolean endsWithLoopHeader(String aLine) {¬∂		return aLine.endsWith(")");¬∂	}¬∂	public static boolean isPragmaStart(String aLine) {¬∂		return aLine.startsWith("#pragma");¬∂	}¬∂	public static void addToStack(Stack<OpenMPPragma> anOpenMPPragmas, String aFileLine) {¬∂		for (OpenMPPragma anOpenMPPragma:anOpenMPPragmas) {¬∂			anOpenMPPragma.getAnnotatedText().add(aFileLine);¬∂		}¬∂	}¬∂	¬∂	public static void incrementStackTop (Stack<Integer> aNumOpenBracesStack) {¬∂		int aTopIndex = aNumOpenBracesStack.size() - 1;¬∂		Integer aCurrentValue = aNumOpenBracesStack.get(aTopIndex);¬∂		aNumOpenBracesStack.set(aTopIndex, aCurrentValue + 1);¬∂	}¬∂	public static void decrementStackTop (Stack<Integer> aNumOpenBracesStack) {¬∂		int aTopIndex = aNumOpenBracesStack.size() - 1;¬∂		Integer aCurrentValue = aNumOpenBracesStack.get(aTopIndex);¬∂		aNumOpenBracesStack.set(aTopIndex, aCurrentValue - 1);¬∂	}¬∂¬∂	public static List<OpenMPPragma> getOpenMPPragmas(String[] aFileLines) {¬∂		List<OpenMPPragma> retVal = new ArrayList();¬∂		Stack<OpenMPPragma> anOpenMPPragmas = new Stack();¬∂		Stack<Integer> aNumOpenBracesStack = new Stack();¬∂//		int aNumOpenBraces = 0;¬∂		boolean aNextCodeLineIsAPragmaBlock = false;¬∂		for (int i = 0; i < aFileLines.length; i++) {¬∂			String aFileLine = aFileLines[i].trim();¬∂			if (!isCodeLine(aFileLine)) {¬∂				continue;¬∂			}¬∂			addToStack(anOpenMPPragmas, aFileLine); // if it is empty add to none¬∂			if (isPragmaStart(aFileLine)) {¬∂				¬∂				OpenMPPragma anOpenMPPragma = getOpemMPPragma(aFileLine, i);¬∂				if (anOpenMPPragma != null) {¬∂					anOpenMPPragmas.add(anOpenMPPragma);¬∂					aNumOpenBracesStack.add(0);¬∂					retVal.add(anOpenMPPragma);					¬∂					aNextCodeLineIsAPragmaBlock = true;¬∂					continue;¬∂				} ¬∂			}¬∂			if (anOpenMPPragmas.isEmpty()) {¬∂				continue;¬∂			}	¬∂			if (aNextCodeLineIsAPragmaBlock) {				¬∂				anOpenMPPragmas.peek().setAnnotatedTextStartLineNumber(i);				¬∂				aNextCodeLineIsAPragmaBlock = false;¬∂			}¬∂//			anOpenMPPragmas.peek().getAnnotatedText().add(aFileLine);¬∂			if (isBlockStart(aFileLine)) {¬∂				incrementStackTop(aNumOpenBracesStack);¬∂			}¬∂//			} else ¬∂			if (isBlockEnd(aFileLine)) {¬∂				decrementStackTop(aNumOpenBracesStack);¬∂¬∂			}¬∂			if (isLoopStart(aFileLine) && endsWithLoopHeader(aFileLine)) {¬∂				continue; // gather following block also¬∂			}¬∂			if (aNumOpenBracesStack.peek() == 0) {¬∂				¬∂				anOpenMPPragmas.peek().setAnnotatedTextEndLineNumber(i);¬∂				anOpenMPPragmas.pop();¬∂				continue;¬∂			}					¬∂		}¬∂		return retVal;¬∂	}¬∂	public static OpenMPPragma getOpemMPPragma(String aFileLine, int aLineIndex) {¬∂		String[] aTokens = aFileLine.split(" ");¬∂		if (aTokens.length <= 2) {¬∂			return null;¬∂		}¬∂		if (!aTokens[1].equals("omp")) {¬∂			return null;¬∂		}¬∂		for (int i = 2; i < aTokens.length; i ++) {¬∂			String aStoredToken = aTokens[i].trim().toLowerCase();¬∂			aTokens[i] = aStoredToken;¬∂		}¬∂		OpenMPPragma retVal = new AnOpenMPPragma(aTokens, aLineIndex);¬∂		return retVal;¬∂		¬∂		¬∂	}¬∂	static {¬∂//		stringToOpenMPKeyword.put("for", OpenMPKeywordEnum.FOR);¬∂//		stringToOpenMPKeyword.put("parallel", OpenMPKeywordEnum.PARALLEL);¬∂//		stringToOpenMPKeyword.put("reduce", OpenMPKeywordEnum.REDUCE);¬∂//		stringToOpenMPKeyword.put("shared", OpenMPKeywordEnum.SHARED);¬∂//		stringToOpenMPKeyword.put("private", OpenMPKeywordEnum.PRIVATE);¬∂¬∂¬∂¬∂¬∂	}¬∂	¬∂¬∂}¬∂")]]]></diff>
  </Command>
  <Command __id="33749" _type="RunCommand" date="Sun Dec 22 00:31:04 EST 2019" kind="StepInto" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="326159856" type="Run" />
  <Command __id="33750" _type="RunCommand" date="Sun Dec 22 00:31:04 EST 2019" kind="StepInto" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="326159871" type="Run" />
  <Command __id="33755" _type="DiffBasedFileOpenCommand" date="Sun Dec 22 00:31:16 EST 2019" docASTNodeCount="565" docActiveCodeLength="3679" docExpressionCount="335" docLength="4258" projectName="GraderBasics" starttimestamp="1576666505112" timestamp="326171765">
    <filePath><![CDATA[D:\dewan_backup\Java\GraderBasics\src\gradingTools\shared\testcases\openmp\OpenMPUtils.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package gradingTools.shared.testcases.openmp;¬∂¬∂import java.util.ArrayList;¬∂import java.util.HashMap;¬∂import java.util.List;¬∂import java.util.Map;¬∂import java.util.Stack;¬∂¬∂¬∂public class OpenMPUtils {¬∂//	protected static Map<String, OpenMPKeywordEnum> stringToOpenMPKeyword = new HashMap();¬∂	public static List<OpenMPPragma> getOpemMPPragmas(StringBuffer aFileBuffer) {¬∂		String[] aFileLines = aFileBuffer.toString().split("\n");¬∂		return getOpenMPPragmas(aFileLines);¬∂	}¬∂	¬∂	public static boolean isCodeLine(String aLine) {¬∂		return !aLine.isEmpty() && !aLine.startsWith("//");¬∂	}¬∂	public static boolean isBlockStart(String aLine) {¬∂		return aLine.contains("{");¬∂	}¬∂	public static boolean isBlockEnd(String aLine) {¬∂		return aLine.contains("}");¬∂	}¬∂	public static boolean isLoopStart(String aLine) {¬∂		return aLine.startsWith("for");¬∂	}¬∂	public static boolean endsWithLoopHeader(String aLine) {¬∂		return aLine.endsWith(")");¬∂	}¬∂	public static boolean isPragmaStart(String aLine) {¬∂		return aLine.startsWith("#pragma");¬∂	}¬∂	public static void addToStack(Stack<OpenMPPragma> anOpenMPPragmas, String aFileLine) {¬∂		for (OpenMPPragma anOpenMPPragma:anOpenMPPragmas) {¬∂			anOpenMPPragma.getAnnotatedText().add(aFileLine);¬∂		}¬∂	}¬∂	¬∂	public static void incrementStackTop (Stack<Integer> aNumOpenBracesStack) {¬∂		int aTopIndex = aNumOpenBracesStack.size() - 1;¬∂		Integer aCurrentValue = aNumOpenBracesStack.get(aTopIndex);¬∂		aNumOpenBracesStack.set(aTopIndex, aCurrentValue + 1);¬∂	}¬∂	public static void decrementStackTop (Stack<Integer> aNumOpenBracesStack) {¬∂		int aTopIndex = aNumOpenBracesStack.size() - 1;¬∂		Integer aCurrentValue = aNumOpenBracesStack.get(aTopIndex);¬∂		aNumOpenBracesStack.set(aTopIndex, aCurrentValue - 1);¬∂	}¬∂¬∂	public static List<OpenMPPragma> getOpenMPPragmas(String[] aFileLines) {¬∂		List<OpenMPPragma> retVal = new ArrayList();¬∂		Stack<OpenMPPragma> anOpenMPPragmas = new Stack();¬∂		Stack<Integer> aNumOpenBracesStack = new Stack();¬∂//		int aNumOpenBraces = 0;¬∂		boolean aNextCodeLineIsAPragmaBlock = false;¬∂		for (int i = 0; i < aFileLines.length; i++) {¬∂			String aFileLine = aFileLines[i].trim();¬∂			if (!isCodeLine(aFileLine)) {¬∂				continue;¬∂			}¬∂			addToStack(anOpenMPPragmas, aFileLine); // if it is empty add to none¬∂			if (isPragmaStart(aFileLine)) {¬∂				¬∂				OpenMPPragma anOpenMPPragma = getOpemMPPragma(aFileLine, i);¬∂				if (anOpenMPPragma != null) {¬∂					anOpenMPPragmas.add(anOpenMPPragma);¬∂					aNumOpenBracesStack.add(0);¬∂					retVal.add(anOpenMPPragma);					¬∂					aNextCodeLineIsAPragmaBlock = true;¬∂					continue;¬∂				} ¬∂			}¬∂			if (anOpenMPPragmas.isEmpty()) {¬∂				continue;¬∂			}	¬∂			if (aNextCodeLineIsAPragmaBlock) {				¬∂				anOpenMPPragmas.peek().setAnnotatedTextStartLineNumber(i);				¬∂				aNextCodeLineIsAPragmaBlock = false;¬∂			}¬∂//			anOpenMPPragmas.peek().getAnnotatedText().add(aFileLine);¬∂			if (isBlockStart(aFileLine)) {¬∂				incrementStackTop(aNumOpenBracesStack);¬∂			}¬∂//			} else ¬∂			if (isBlockEnd(aFileLine)) {¬∂				decrementStackTop(aNumOpenBracesStack);¬∂¬∂			}¬∂			if (isLoopStart(aFileLine) && endsWithLoopHeader(aFileLine)) {¬∂				continue; // gather following block also¬∂			}¬∂			if (aNumOpenBracesStack.peek() == 0) {¬∂				¬∂				anOpenMPPragmas.peek().setAnnotatedTextEndLineNumber(i);¬∂				anOpenMPPragmas.pop();¬∂				continue;¬∂			}					¬∂		}¬∂		return retVal;¬∂	}¬∂	public static OpenMPPragma getOpemMPPragma(String aFileLine, int aLineIndex) {¬∂		String[] aTokens = aFileLine.split(" ");¬∂		if (aTokens.length <= 2) {¬∂			return null;¬∂		}¬∂		if (!aTokens[1].equals("omp")) {¬∂			return null;¬∂		}¬∂		for (int i = 2; i < aTokens.length; i ++) {¬∂			String aStoredToken = aTokens[i].trim().toLowerCase();¬∂			aTokens[i] = aStoredToken;¬∂		}¬∂		OpenMPPragma retVal = new AnOpenMPPragma(aTokens, aLineIndex);¬∂		return retVal;¬∂		¬∂		¬∂	}¬∂	static {¬∂//		stringToOpenMPKeyword.put("for", OpenMPKeywordEnum.FOR);¬∂//		stringToOpenMPKeyword.put("parallel", OpenMPKeywordEnum.PARALLEL);¬∂//		stringToOpenMPKeyword.put("reduce", OpenMPKeywordEnum.REDUCE);¬∂//		stringToOpenMPKeyword.put("shared", OpenMPKeywordEnum.SHARED);¬∂//		stringToOpenMPKeyword.put("private", OpenMPKeywordEnum.PRIVATE);¬∂¬∂¬∂¬∂¬∂	}¬∂	¬∂¬∂}¬∂")]]]></diff>
  </Command>
  <Command __id="33761" _type="ShellCommand" date="Sun Dec 22 00:35:22 EST 2019" starttimestamp="1576666505112" timestamp="326417578" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="33762" _type="MoveCaretCommand" caretOffset="3419" date="Sun Dec 22 00:35:22 EST 2019" docOffset="3419" starttimestamp="1576666505112" timestamp="326417693" />
  <Command __id="33765" _type="RunCommand" date="Sun Dec 22 00:37:18 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="326533554" type="Debug" />
  <Command __id="33766" _type="RunCommand" date="Sun Dec 22 00:37:18 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="326533554" type="Debug" />
  <Command __id="33767" _type="RunCommand" date="Sun Dec 22 00:37:18 EST 2019" kind="HitBreakPoint" projectName="PL_Java" starttimestamp="1576666505112" timestamp="326533554" type="Run" />
  <Command __id="33781" _type="RunCommand" date="Sun Dec 22 00:37:26 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="326541880" type="Run" />
  <Command __id="33782" _type="RunCommand" date="Sun Dec 22 00:37:27 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="326541919" type="Run" />
  <Command __id="33783" _type="EHExceptionCommand" date="Sun Dec 22 00:37:27 EST 2019" starttimestamp="1576666505112" timestamp="326541919" type="Exception">
    <outputString><![CDATA[I***(TestCaseResult) ### SequentialSumTestCase: 1.0
Returning first of multiple entry points:[MyOpenMPTraining.exe, OpenMPTraining.exe]
I***(BasicProcessRunner) Running command:D:\dewan_backup\C\MyOpenMPTraining\Debug\MyOpenMPTraining.exe
I***(BasicProcessRunner) Running in folder: D:\dewan_backup\C\MyOpenMPTraining\Debug
I***(BasicProcessRunner)  Process started: D:\dewan_backup\C\MyOpenMPTraining\Debug\MyOpenMPTraining.exe folder: D:\dewan_backup\C\MyOpenMPTraining\Debug entry point: null class path: D:\dewan_backup\Java\PLTeaching\PL_Java\bin;D:\dewan_backup\Java\lib\oeall22.jar;C:\Users\dewan\.p2\pool\plugins\org.junit_4.12.0.v201504281640\junit.jar;C:\Users\dewan\.p2\pool\plugins\org.hamcrest.core_1.3.0.v20180420-1519.jar;D:\dewan_backup\Java\GraderBasics\lib\commons-configuration-1.9.jar;D:\dewan_backup\Java\GraderBasics\lib\commons-lang-2.6.jar;D:\dewan_backup\Java\GraderBasics\lib\commons-logging-1.1.1.jar;G:\My Drive\Java\lib\Herrmes\lib\weka3_6.jar;D:\dewan_backup\Java\GraderBasics\target\classes;D:\dewan_backup\Java\DemoCourseLocalBasicChecks\bin
]]></outputString>
  </Command>
  <Command __id="33784" _type="RunCommand" date="Sun Dec 22 00:37:27 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="326541922" type="Run" />
  <Command __id="33785" _type="EHExceptionCommand" date="Sun Dec 22 00:37:27 EST 2019" starttimestamp="1576666505112" timestamp="326542021" type="Exception">
    <outputString><![CDATA[I***(ARunnerInputStreamProcessor) Provided Input:
I***(BasicRunningProject) 1576993047044:Received output from main: sum_sequential
I***(BasicRunningProject) 1576993047045:Processing line from main: sum_sequential
I***(BasicRunningProject) 1576993047045:Received output from main: Sum: 499500
I***(BasicRunningProject) 1576993047045:Processing line from main: Sum: 499500
I***(BasicRunningProject) 1576993047045:Received output from main: Took: 0
I***(BasicRunningProject) 1576993047045:Processing line from main: Took: 0
I***(BasicRunningProject) 1576993047046:Received output from main: thread:0 lastIndex:999
I***(BasicRunningProject) 1576993047046:Processing line from main: thread:0 lastIndex:999
I***(BasicRunningProject) 1576993047046:Received output from main: _____________________________
I***(BasicRunningProject) 1576993047046:Processing line from main: _____________________________
I***(BasicRunningProject) 1576993047046:Received output from main: sum_parallel_for_reduction
I***(BasicRunningProject) 1576993047047:Processing line from main: sum_parallel_for_reduction
I***(BasicRunningProject) 1576993047047:Received output from main: Sum: 499500
I***(BasicRunningProject) 1576993047047:Processing line from main: Sum: 499500
I***(BasicRunningProject) 1576993047047:Received output from main: Took: 0
I***(BasicRunningProject) 1576993047047:Processing line from main: Took: 0
I***(BasicRunningProject) 1576993047048:Received output from main: _____________________________
I***(BasicRunningProject) 1576993047048:Processing line from main: _____________________________
I***(BasicRunningProject) 1576993047048:Received output from main: sum_parallel_for_local_var
I***(BasicRunningProject) 1576993047048:Processing line from main: sum_parallel_for_local_var
I***(BasicRunningProject) 1576993047048:Received output from main: Sum: 499500
I***(BasicRunningProject) 1576993047048:Processing line from main: Sum: 499500
I***(BasicRunningProject) 1576993047048:Received output from main: Took: 0
I***(BasicRunningProject) 1576993047048:Processing line from main: Took: 0
I***(BasicRunningProject) 1576993047048:Received output from main: thread:0 lastIndex:999
I***(BasicRunningProject) 1576993047048:Processing line from main: thread:0 lastIndex:999
I***(BasicRunningProject) 1576993047048:Received output from main: _____________________________
I***(BasicRunningProject) 1576993047048:Processing line from main: _____________________________
I***(BasicRunningProject) 1576993047049:Received output from main: sum_parallel
I***(BasicRunningProject) 1576993047049:Processing line from main: sum_parallel
I***(BasicRunningProject) 1576993047049:Received output from main: Sum: 499500
I***(BasicRunningProject) 1576993047049:Processing line from main: Sum: 499500
I***(BasicRunningProject) 1576993047049:Received output from main: Took: 0
I***(BasicRunningProject) 1576993047049:Processing line from main: Took: 0
I***(BasicRunningProject) 1576993047049:Received output from main: _____________________________
I***(BasicRunningProject) 1576993047049:Processing line from main: _____________________________
I***(BasicProcessRunner)  Process finished; folder: D:\dewan_backup\C\MyOpenMPTraining\Debug entry point: null class path: D:\dewan_backup\Java\PLTeaching\PL_Java\bin;D:\dewan_backup\Java\lib\oeall22.jar;C:\Users\dewan\.p2\pool\plugins\org.junit_4.12.0.v201504281640\junit.jar;C:\Users\dewan\.p2\pool\plugins\org.hamcrest.core_1.3.0.v20180420-1519.jar;D:\dewan_backup\Java\GraderBasics\lib\commons-configuration-1.9.jar;D:\dewan_backup\Java\GraderBasics\lib\commons-lang-2.6.jar;D:\dewan_backup\Java\GraderBasics\lib\commons-logging-1.1.1.jar;G:\My Drive\Java\lib\Herrmes\lib\weka3_6.jar;D:\dewan_backup\Java\GraderBasics\target\classes;D:\dewan_backup\Java\DemoCourseLocalBasicChecks\bin
I***(BasicRunningProject) Thread[AWT-EventQueue-0,6,main] sleeping for ms:2000 waiting for pending output from threads 
]]></outputString>
  </Command>
  <Command __id="33789" _type="DiffBasedFileOpenCommand" date="Sun Dec 22 00:37:31 EST 2019" docASTNodeCount="565" docActiveCodeLength="3679" docExpressionCount="335" docLength="4258" projectName="GraderBasics" starttimestamp="1576666505112" timestamp="326545912">
    <filePath><![CDATA[D:\dewan_backup\Java\GraderBasics\src\gradingTools\shared\testcases\openmp\OpenMPUtils.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package gradingTools.shared.testcases.openmp;¬∂¬∂import java.util.ArrayList;¬∂import java.util.HashMap;¬∂import java.util.List;¬∂import java.util.Map;¬∂import java.util.Stack;¬∂¬∂¬∂public class OpenMPUtils {¬∂//	protected static Map<String, OpenMPKeywordEnum> stringToOpenMPKeyword = new HashMap();¬∂	public static List<OpenMPPragma> getOpemMPPragmas(StringBuffer aFileBuffer) {¬∂		String[] aFileLines = aFileBuffer.toString().split("\n");¬∂		return getOpenMPPragmas(aFileLines);¬∂	}¬∂	¬∂	public static boolean isCodeLine(String aLine) {¬∂		return !aLine.isEmpty() && !aLine.startsWith("//");¬∂	}¬∂	public static boolean isBlockStart(String aLine) {¬∂		return aLine.contains("{");¬∂	}¬∂	public static boolean isBlockEnd(String aLine) {¬∂		return aLine.contains("}");¬∂	}¬∂	public static boolean isLoopStart(String aLine) {¬∂		return aLine.startsWith("for");¬∂	}¬∂	public static boolean endsWithLoopHeader(String aLine) {¬∂		return aLine.endsWith(")");¬∂	}¬∂	public static boolean isPragmaStart(String aLine) {¬∂		return aLine.startsWith("#pragma");¬∂	}¬∂	public static void addToStack(Stack<OpenMPPragma> anOpenMPPragmas, String aFileLine) {¬∂		for (OpenMPPragma anOpenMPPragma:anOpenMPPragmas) {¬∂			anOpenMPPragma.getAnnotatedText().add(aFileLine);¬∂		}¬∂	}¬∂	¬∂	public static void incrementStackTop (Stack<Integer> aNumOpenBracesStack) {¬∂		int aTopIndex = aNumOpenBracesStack.size() - 1;¬∂		Integer aCurrentValue = aNumOpenBracesStack.get(aTopIndex);¬∂		aNumOpenBracesStack.set(aTopIndex, aCurrentValue + 1);¬∂	}¬∂	public static void decrementStackTop (Stack<Integer> aNumOpenBracesStack) {¬∂		int aTopIndex = aNumOpenBracesStack.size() - 1;¬∂		Integer aCurrentValue = aNumOpenBracesStack.get(aTopIndex);¬∂		aNumOpenBracesStack.set(aTopIndex, aCurrentValue - 1);¬∂	}¬∂¬∂	public static List<OpenMPPragma> getOpenMPPragmas(String[] aFileLines) {¬∂		List<OpenMPPragma> retVal = new ArrayList();¬∂		Stack<OpenMPPragma> anOpenMPPragmas = new Stack();¬∂		Stack<Integer> aNumOpenBracesStack = new Stack();¬∂//		int aNumOpenBraces = 0;¬∂		boolean aNextCodeLineIsAPragmaBlock = false;¬∂		for (int i = 0; i < aFileLines.length; i++) {¬∂			String aFileLine = aFileLines[i].trim();¬∂			if (!isCodeLine(aFileLine)) {¬∂				continue;¬∂			}¬∂			addToStack(anOpenMPPragmas, aFileLine); // if it is empty add to none¬∂			if (isPragmaStart(aFileLine)) {¬∂				¬∂				OpenMPPragma anOpenMPPragma = getOpemMPPragma(aFileLine, i);¬∂				if (anOpenMPPragma != null) {¬∂					anOpenMPPragmas.add(anOpenMPPragma);¬∂					aNumOpenBracesStack.add(0);¬∂					retVal.add(anOpenMPPragma);					¬∂					aNextCodeLineIsAPragmaBlock = true;¬∂					continue;¬∂				} ¬∂			}¬∂			if (anOpenMPPragmas.isEmpty()) {¬∂				continue;¬∂			}	¬∂			if (aNextCodeLineIsAPragmaBlock) {				¬∂				anOpenMPPragmas.peek().setAnnotatedTextStartLineNumber(i);				¬∂				aNextCodeLineIsAPragmaBlock = false;¬∂			}¬∂//			anOpenMPPragmas.peek().getAnnotatedText().add(aFileLine);¬∂			if (isBlockStart(aFileLine)) {¬∂				incrementStackTop(aNumOpenBracesStack);¬∂			}¬∂//			} else ¬∂			if (isBlockEnd(aFileLine)) {¬∂				decrementStackTop(aNumOpenBracesStack);¬∂¬∂			}¬∂			if (isLoopStart(aFileLine) && endsWithLoopHeader(aFileLine)) {¬∂				continue; // gather following block also¬∂			}¬∂			if (aNumOpenBracesStack.peek() == 0) {¬∂				¬∂				anOpenMPPragmas.peek().setAnnotatedTextEndLineNumber(i);¬∂				anOpenMPPragmas.pop();¬∂				continue;¬∂			}					¬∂		}¬∂		return retVal;¬∂	}¬∂	public static OpenMPPragma getOpemMPPragma(String aFileLine, int aLineIndex) {¬∂		String[] aTokens = aFileLine.split(" ");¬∂		if (aTokens.length <= 2) {¬∂			return null;¬∂		}¬∂		if (!aTokens[1].equals("omp")) {¬∂			return null;¬∂		}¬∂		for (int i = 2; i < aTokens.length; i ++) {¬∂			String aStoredToken = aTokens[i].trim().toLowerCase();¬∂			aTokens[i] = aStoredToken;¬∂		}¬∂		OpenMPPragma retVal = new AnOpenMPPragma(aTokens, aLineIndex);¬∂		return retVal;¬∂		¬∂		¬∂	}¬∂	static {¬∂//		stringToOpenMPKeyword.put("for", OpenMPKeywordEnum.FOR);¬∂//		stringToOpenMPKeyword.put("parallel", OpenMPKeywordEnum.PARALLEL);¬∂//		stringToOpenMPKeyword.put("reduce", OpenMPKeywordEnum.REDUCE);¬∂//		stringToOpenMPKeyword.put("shared", OpenMPKeywordEnum.SHARED);¬∂//		stringToOpenMPKeyword.put("private", OpenMPKeywordEnum.PRIVATE);¬∂¬∂¬∂¬∂¬∂	}¬∂	¬∂¬∂}¬∂")]]]></diff>
  </Command>
  <Command __id="33804" _type="EclipseCommand" commandID="org.eclipse.debug.ui.commands.Resume" date="Sun Dec 22 00:37:58 EST 2019" starttimestamp="1576666505112" timestamp="326573490" />
  <Command __id="33805" _type="RunCommand" date="Sun Dec 22 00:37:58 EST 2019" kind="StepInto" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="326573491" type="Run" />
  <DocumentChange __id="34838" _type="Insert" date="Sun Dec 22 04:10:40 EST 2019" docASTNodeCount="226" docActiveCodeLength="1702" docExpressionCount="116" docLength="1947" length="1" offset="645" starttimestamp="1576666505112" timestamp="339335009">
    <text><![CDATA[g]]></text>
  </DocumentChange>
  <Command __id="34839" _type="InsertStringCommand" date="Sun Dec 22 04:10:40 EST 2019" starttimestamp="1576666505112" timestamp="339335013" timestamp2="339335013">
    <data><![CDATA[g]]></data>
  </Command>
  <Command __id="34844" _type="DiffBasedFileOpenCommand" date="Sun Dec 22 04:10:50 EST 2019" projectName="null" starttimestamp="1576666505112" timestamp="339345231">
    <filePath><![CDATA[null]]></filePath>
    <diff><![CDATA[null]]></diff>
  </Command>
  <Command __id="34845" _type="MoveCaretCommand" caretOffset="48552" date="Sun Dec 22 04:10:50 EST 2019" docOffset="48688" starttimestamp="1576666505112" timestamp="339345365" />
  <Command __id="35210" _type="EclipseCommand" commandID="" date="Sun Dec 22 04:28:48 EST 2019" starttimestamp="1576666505112" timestamp="340422963" />
  <Command __id="35212" _type="MoveCaretCommand" caretOffset="0" date="Sun Dec 22 04:28:48 EST 2019" docOffset="0" starttimestamp="1576666505112" timestamp="340423291" />
  <Command __id="35213" _type="EclipseCommand" commandID="" date="Sun Dec 22 04:28:48 EST 2019" starttimestamp="1576666505112" timestamp="340423694" />
  <Command __id="35214" _type="MoveCaretCommand" caretOffset="387" date="Sun Dec 22 04:28:52 EST 2019" docOffset="387" starttimestamp="1576666505112" timestamp="340427674" />
  <Command __id="35216" _type="InsertStringCommand" date="Sun Dec 22 04:28:53 EST 2019" starttimestamp="1576666505112" timestamp="340428030" timestamp2="340428030">
    <data><![CDATA[ ]]></data>
  </Command>
  <DocumentChange __id="35201" _type="Insert" date="Sun Dec 22 04:25:32 EST 2019" docASTNodeCount="250" docActiveCodeLength="1847" docExpressionCount="125" docLength="2092" length="1" offset="790" starttimestamp="1576666505112" timestamp="340227406">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="35205" _type="Delete" date="Sun Dec 22 04:25:42 EST 2019" docASTNodeCount="239" docActiveCodeLength="1773" docExpressionCount="122" docLength="2018" endLine="21" length="74" offset="720" startLine="19" starttimestamp="1576666505112" timestamp="340237474">
    <text><![CDATA[protected boolean ompCritical = false;
	protected boolean ompParallel 
	]]></text>
  </DocumentChange>
  <DocumentChange __id="35208" _type="Delete" date="Sun Dec 22 04:25:47 EST 2019" docASTNodeCount="225" docActiveCodeLength="1686" docExpressionCount="116" docLength="1931" endLine="18" length="87" offset="630" startLine="17" starttimestamp="1576666505112" timestamp="340242649">
    <text><![CDATA[protected String reductionVariable = null;
	protected String reductionOperator = null;]]></text>
  </DocumentChange>
  <Command __id="35211" _type="DiffBasedFileOpenCommand" date="Sun Dec 22 04:28:48 EST 2019" docASTNodeCount="1" docActiveCodeLength="496" docExpressionCount="0" docLength="520" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="340423112">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\sum_parallel_for_reduction.cpp]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"#include <iostream>¬∂#include <omp.h>¬∂¬∂using namespace std;¬∂¬∂//const int SIZE = 1000;¬∂void printSumWithTimes(int sum, int start, int end);¬∂void printNumThreads();¬∂void recordThreadIndex(int index);¬∂void sum_parallel_for_reduction(double* array, int size) {¬∂	cout << "sum_parallel_for_reduction\n";¬∂¬∂	double start = omp_get_wtime();¬∂¬∂	double sum = 0;¬∂    #pragma omp parallel for reduction(+:sum)¬∂¬∂	for (int i = 0; i < size; i++)¬∂		sum += array[i];¬∂¬∂	double end = omp_get_wtime();¬∂¬∂	printSumWithTimes(sum, start, end);¬∂¬∂}¬∂")]]]></diff>
  </Command>
  <DocumentChange __id="35215" _type="Insert" date="Sun Dec 22 04:28:53 EST 2019" docASTNodeCount="1" docActiveCodeLength="497" docExpressionCount="0" docLength="521" length="1" offset="387" starttimestamp="1576666505112" timestamp="340428027">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <Command __id="35217" _type="EclipseCommand" commandID="org.eclipse.ui.file.save" date="Sun Dec 22 04:28:55 EST 2019" starttimestamp="1576666505112" timestamp="340430439" />
  <Command __id="35219" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Dec 22 04:28:58 EST 2019" starttimestamp="1576666505112" timestamp="340432959" />
  <DocumentChange __id="35218" _type="Delete" date="Sun Dec 22 04:28:58 EST 2019" docASTNodeCount="1" docActiveCodeLength="496" docExpressionCount="0" docLength="520" endLine="15" length="1" offset="387" startLine="15" starttimestamp="1576666505112" timestamp="340432954">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <Command __id="35220" _type="MoveCaretCommand" caretOffset="370" date="Sun Dec 22 04:29:01 EST 2019" docOffset="370" starttimestamp="1576666505112" timestamp="340435911" />
  <Command __id="35221" _type="SelectTextCommand" caretOffset="373" date="Sun Dec 22 04:29:01 EST 2019" end="373" start="365" starttimestamp="1576666505112" timestamp="340436161" />
  <DocumentChange __id="35222" _type="Delete" date="Sun Dec 22 04:29:04 EST 2019" docASTNodeCount="1" docActiveCodeLength="488" docExpressionCount="0" docLength="512" endLine="15" length="8" offset="365" startLine="15" starttimestamp="1576666505112" timestamp="340439697">
    <text><![CDATA[parallel]]></text>
  </DocumentChange>
  <Command __id="35223" _type="CutCommand" date="Sun Dec 22 04:29:04 EST 2019" starttimestamp="1576666505112" timestamp="340439705" />
  <Command __id="35225" _type="UndoCommand" date="Sun Dec 22 04:29:06 EST 2019" starttimestamp="1576666505112" timestamp="340441615" />
  <Command __id="35226" _type="MoveCaretCommand" caretOffset="372" date="Sun Dec 22 04:29:08 EST 2019" docOffset="372" starttimestamp="1576666505112" timestamp="340443190" />
  <Command __id="35227" _type="SelectTextCommand" caretOffset="373" date="Sun Dec 22 04:29:08 EST 2019" end="373" start="365" starttimestamp="1576666505112" timestamp="340443426" />
  <Command __id="35229" _type="CutCommand" date="Sun Dec 22 04:29:09 EST 2019" starttimestamp="1576666505112" timestamp="340444302" />
  <Command __id="35230" _type="MoveCaretCommand" caretOffset="386" date="Sun Dec 22 04:29:10 EST 2019" docOffset="386" starttimestamp="1576666505112" timestamp="340445861" />
  <Command __id="35232" _type="InsertStringCommand" date="Sun Dec 22 04:29:11 EST 2019" starttimestamp="1576666505112" timestamp="340446140" timestamp2="340446140">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="35234" _type="PasteCommand" date="Sun Dec 22 04:29:11 EST 2019" starttimestamp="1576666505112" timestamp="340446525" />
  <Command __id="35235" _type="EclipseCommand" commandID="org.eclipse.ui.file.save" date="Sun Dec 22 04:29:12 EST 2019" starttimestamp="1576666505112" timestamp="340447370" />
  <Command __id="35236" _type="MoveCaretCommand" caretOffset="389" date="Sun Dec 22 04:29:17 EST 2019" docOffset="389" starttimestamp="1576666505112" timestamp="340452497" />
  <Command __id="35237" _type="SelectTextCommand" caretOffset="395" date="Sun Dec 22 04:29:17 EST 2019" end="395" start="387" starttimestamp="1576666505112" timestamp="340452798" />
  <Command __id="35238" _type="SelectTextCommand" caretOffset="395" date="Sun Dec 22 04:29:18 EST 2019" end="395" start="387" starttimestamp="1576666505112" timestamp="340453703" />
  <Command __id="35239" _type="ShellCommand" date="Sun Dec 22 04:29:23 EST 2019" starttimestamp="1576666505112" timestamp="340458750" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="35240" _type="ShellCommand" date="Sun Dec 22 04:29:24 EST 2019" starttimestamp="1576666505112" timestamp="340458936" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="35241" _type="ShellCommand" date="Sun Dec 22 04:29:24 EST 2019" starttimestamp="1576666505112" timestamp="340459049" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="35242" _type="ShellCommand" date="Sun Dec 22 04:29:26 EST 2019" starttimestamp="1576666505112" timestamp="340461695" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="35243" _type="EclipseCommand" commandID="org.eclipse.cdt.debug.ui.localCShortcut.run" date="Sun Dec 22 04:29:26 EST 2019" starttimestamp="1576666505112" timestamp="340461710" />
  <Command __id="35244" _type="ShellCommand" date="Sun Dec 22 04:29:36 EST 2019" starttimestamp="1576666505112" timestamp="340471114" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="35245" _type="ShellCommand" date="Sun Dec 22 04:29:36 EST 2019" starttimestamp="1576666505112" timestamp="340471265" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="35246" _type="ShellCommand" date="Sun Dec 22 04:29:36 EST 2019" starttimestamp="1576666505112" timestamp="340471334" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="35247" _type="ShellCommand" date="Sun Dec 22 04:29:41 EST 2019" starttimestamp="1576666505112" timestamp="340476321" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="35248" _type="EclipseCommand" commandID="org.eclipse.cdt.debug.ui.localCShortcut.debug" date="Sun Dec 22 04:29:41 EST 2019" starttimestamp="1576666505112" timestamp="340476432" />
  <Command __id="35249" _type="ShellCommand" date="Sun Dec 22 04:29:43 EST 2019" starttimestamp="1576666505112" timestamp="340478870" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="35250" _type="ShellCommand" date="Sun Dec 22 04:29:48 EST 2019" starttimestamp="1576666505112" timestamp="340482962" type="ECLIPSE_GAINED_FOCUS" />
  <DocumentChange __id="35224" _type="Insert" date="Sun Dec 22 04:29:06 EST 2019" docASTNodeCount="1" docActiveCodeLength="496" docExpressionCount="0" docLength="520" length="8" offset="365" starttimestamp="1576666505112" timestamp="340441606">
    <text><![CDATA[parallel]]></text>
  </DocumentChange>
  <DocumentChange __id="35228" _type="Delete" date="Sun Dec 22 04:29:09 EST 2019" docASTNodeCount="1" docActiveCodeLength="488" docExpressionCount="0" docLength="512" endLine="15" length="8" offset="365" startLine="15" starttimestamp="1576666505112" timestamp="340444292">
    <text><![CDATA[parallel]]></text>
  </DocumentChange>
  <DocumentChange __id="35231" _type="Insert" date="Sun Dec 22 04:29:11 EST 2019" docASTNodeCount="1" docActiveCodeLength="489" docExpressionCount="0" docLength="513" length="1" offset="386" starttimestamp="1576666505112" timestamp="340446140">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="35233" _type="Insert" date="Sun Dec 22 04:29:11 EST 2019" docASTNodeCount="1" docActiveCodeLength="497" docExpressionCount="0" docLength="521" length="8" offset="387" starttimestamp="1576666505112" timestamp="340446525">
    <text><![CDATA[parallel]]></text>
  </DocumentChange>
  <Command __id="35251" _type="MoveCaretCommand" caretOffset="389" date="Sun Dec 22 04:29:53 EST 2019" docOffset="389" starttimestamp="1576666505112" timestamp="340488343" />
  <Command __id="35252" _type="SelectTextCommand" caretOffset="395" date="Sun Dec 22 04:29:53 EST 2019" end="395" start="387" starttimestamp="1576666505112" timestamp="340488593" />
  <Command __id="35254" _type="CutCommand" date="Sun Dec 22 04:29:55 EST 2019" starttimestamp="1576666505112" timestamp="340490013" />
  <Command __id="35255" _type="MoveCaretCommand" caretOffset="366" date="Sun Dec 22 04:29:57 EST 2019" docOffset="366" starttimestamp="1576666505112" timestamp="340491969" />
  <Command __id="35257" _type="PasteCommand" date="Sun Dec 22 04:29:58 EST 2019" starttimestamp="1576666505112" timestamp="340492895" />
  <Command __id="35259" _type="InsertStringCommand" date="Sun Dec 22 04:29:58 EST 2019" starttimestamp="1576666505112" timestamp="340493634" timestamp2="340493634">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="35261" _type="EclipseCommand" commandID="org.eclipse.ui.file.save" date="Sun Dec 22 04:29:59 EST 2019" starttimestamp="1576666505112" timestamp="340494350" />
  <Command __id="35262" _type="MoveCaretCommand" caretOffset="388" date="Sun Dec 22 04:30:05 EST 2019" docOffset="388" starttimestamp="1576666505112" timestamp="340500353" />
  <Command __id="35264" _type="InsertStringCommand" date="Sun Dec 22 04:30:05 EST 2019" starttimestamp="1576666505112" timestamp="340500647" timestamp2="340500647">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="35265" _type="EclipseCommand" commandID="org.eclipse.ui.file.save" date="Sun Dec 22 04:30:06 EST 2019" starttimestamp="1576666505112" timestamp="340501207" />
  <Command __id="35266" _type="ShellCommand" date="Sun Dec 22 04:30:11 EST 2019" starttimestamp="1576666505112" timestamp="340506226" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="35267" _type="ShellCommand" date="Sun Dec 22 04:30:11 EST 2019" starttimestamp="1576666505112" timestamp="340506327" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="35268" _type="ShellCommand" date="Sun Dec 22 04:30:11 EST 2019" starttimestamp="1576666505112" timestamp="340506399" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="35271" _type="RunCommand" date="Sun Dec 22 04:30:16 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="340511063" type="Run" />
  <Command __id="35272" _type="RunCommand" date="Sun Dec 22 04:30:16 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="340511080" type="Run" />
  <Command __id="35273" _type="RunCommand" date="Sun Dec 22 04:30:16 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="340511400" type="Run" />
  <Command __id="35274" _type="EclipseCommand" commandID="org.eclipse.debug.ui.commands.Resume" date="Sun Dec 22 04:30:23 EST 2019" starttimestamp="1576666505112" timestamp="340518052" />
  <Command __id="35275" _type="RunCommand" date="Sun Dec 22 04:30:23 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="340518090" type="Debug" />
  <Command __id="35276" _type="RunCommand" date="Sun Dec 22 04:30:23 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="340518092" type="Run" />
  <Command __id="35277" _type="RunCommand" date="Sun Dec 22 04:30:23 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="340518097" type="Debug" />
  <Command __id="35278" _type="RunCommand" date="Sun Dec 22 04:30:23 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="340518101" type="Run" />
  <Command __id="35279" _type="EHExceptionCommand" date="Sun Dec 22 04:30:23 EST 2019" starttimestamp="1576666505112" timestamp="340518188" type="Exception">
    <outputString><![CDATA[sum_sequential
Sum: 499500
Took: 0
thread:0 lastIndex:999
_____________________________
sum_parallel_for_reduction
Sum: 499500
Took: 0
_____________________________
sum_parallel_for_local_var
Sum: 499500
Took: 0
thread:0 lastIndex:124
thread:1 lastIndex:249
thread:2 lastIndex:374
thread:3 lastIndex:499
thread:4 lastIndex:624
thread:5 lastIndex:749
thread:6 lastIndex:874
thread:7 lastIndex:999
_____________________________
sum_parallel
Sum: 499500
Took: 0
_____________________________
]]></outputString>
  </Command>
  <Command __id="35280" _type="RunCommand" date="Sun Dec 22 04:30:23 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="340518605" type="Debug" />
  <Command __id="35281" _type="RunCommand" date="Sun Dec 22 04:30:23 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="340518606" type="Run" />
  <Command __id="35282" _type="RunCommand" date="Sun Dec 22 04:30:23 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="340518609" type="Debug" />
  <Command __id="35283" _type="RunCommand" date="Sun Dec 22 04:30:23 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="340518612" type="Run" />
  <DocumentChange __id="35253" _type="Delete" date="Sun Dec 22 04:29:55 EST 2019" docASTNodeCount="1" docActiveCodeLength="489" docExpressionCount="0" docLength="513" endLine="15" length="8" offset="387" startLine="15" starttimestamp="1576666505112" timestamp="340489977">
    <text><![CDATA[parallel]]></text>
  </DocumentChange>
  <DocumentChange __id="35256" _type="Insert" date="Sun Dec 22 04:29:57 EST 2019" docASTNodeCount="1" docActiveCodeLength="497" docExpressionCount="0" docLength="521" length="8" offset="366" starttimestamp="1576666505112" timestamp="340492880">
    <text><![CDATA[parallel]]></text>
  </DocumentChange>
  <DocumentChange __id="35258" _type="Insert" date="Sun Dec 22 04:29:58 EST 2019" docASTNodeCount="1" docActiveCodeLength="498" docExpressionCount="0" docLength="522" length="1" offset="374" starttimestamp="1576666505112" timestamp="340493631">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="35260" _type="Delete" date="Sun Dec 22 04:29:59 EST 2019" docASTNodeCount="1" docActiveCodeLength="497" docExpressionCount="0" docLength="521" endLine="15" length="1" offset="395" startLine="15" starttimestamp="1576666505112" timestamp="340494308">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="35263" _type="Insert" date="Sun Dec 22 04:30:05 EST 2019" docASTNodeCount="1" docActiveCodeLength="498" docExpressionCount="0" docLength="522" length="1" offset="388" starttimestamp="1576666505112" timestamp="340500645">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <Command __id="35284" _type="MoveCaretCommand" caretOffset="429" date="Sun Dec 22 04:30:53 EST 2019" docOffset="429" starttimestamp="1576666505112" timestamp="340547990" />
  <DocumentChange __id="35285" _type="Insert" date="Sun Dec 22 04:30:54 EST 2019" docASTNodeCount="1" docActiveCodeLength="499" docExpressionCount="0" docLength="523" length="1" offset="429" starttimestamp="1576666505112" timestamp="340549686">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <Command __id="35286" _type="InsertStringCommand" date="Sun Dec 22 04:30:54 EST 2019" starttimestamp="1576666505112" timestamp="340549690" timestamp2="340549690">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="35288" _type="InsertStringCommand" date="Sun Dec 22 04:30:56 EST 2019" starttimestamp="1576666505112" timestamp="340550895" timestamp2="340550895">
    <data><![CDATA[{]]></data>
  </Command>
  <DocumentChange __id="35287" _type="Insert" date="Sun Dec 22 04:30:56 EST 2019" docASTNodeCount="1" docActiveCodeLength="500" docExpressionCount="0" docLength="524" length="1" offset="430" starttimestamp="1576666505112" timestamp="340550891">
    <text><![CDATA[{]]></text>
  </DocumentChange>
  <DocumentChange __id="35290" _type="Insert" date="Sun Dec 22 04:31:00 EST 2019" docASTNodeCount="1" docActiveCodeLength="503" docExpressionCount="0" docLength="527" length="3" offset="450" starttimestamp="1576666505112" timestamp="340555116">
    <text><![CDATA[
		]]></text>
  </DocumentChange>
  <Command __id="35289" _type="MoveCaretCommand" caretOffset="450" date="Sun Dec 22 04:30:59 EST 2019" docOffset="450" starttimestamp="1576666505112" timestamp="340554566" />
  <Command __id="35291" _type="InsertStringCommand" date="Sun Dec 22 04:31:00 EST 2019" starttimestamp="1576666505112" timestamp="340555121" timestamp2="340555121">
    <data><![CDATA[]]></data>
  </Command>
  <Command __id="35293" _type="InsertStringCommand" date="Sun Dec 22 04:31:01 EST 2019" starttimestamp="1576666505112" timestamp="340556199" timestamp2="340556199">
    <data><![CDATA[}]]></data>
  </Command>
  <Command __id="35316" _type="DiffBasedFileOpenCommand" date="Sun Dec 22 04:31:46 EST 2019" docASTNodeCount="1" docActiveCodeLength="478" docExpressionCount="0" docLength="478" projectName="OpenMPTraining" starttimestamp="1576666505112" timestamp="340601121">
    <filePath><![CDATA[D:\dewan_backup\C\OpenMPTraining\OpenMPTrainingC++\src\sum_parallel_for_reduction.cpp]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"#include <iostream>¬∂#include <omp.h>¬∂¬∂using namespace std;¬∂¬∂void printSumWithTimes(int sum, int start, int end);¬∂void printNumThreads();¬∂void recordThreadIndex(int index);¬∂void sum_parallel_for_reduction(double* array, int size) {¬∂	cout << "sum_parallel_for_reduction\n";¬∂¬∂	double start = omp_get_wtime();¬∂¬∂	double sum = 0;¬∂¬∂	for (int i = 0; i < size; i++) {¬∂		sum += array[i];¬∂		recordThreadIndex(i);¬∂	}¬∂¬∂	double end = omp_get_wtime();¬∂¬∂	printSumWithTimes(sum, start, end);¬∂¬∂}¬∂")]]]></diff>
  </Command>
  <Command __id="35304" _type="MoveCaretCommand" caretOffset="356" date="Sun Dec 22 04:31:31 EST 2019" docOffset="356" starttimestamp="1576666505112" timestamp="340586367" />
  <Command __id="35306" _type="InsertStringCommand" date="Sun Dec 22 04:31:31 EST 2019" starttimestamp="1576666505112" timestamp="340586637" timestamp2="340586637">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="35307" _type="EclipseCommand" commandID="org.eclipse.ui.file.save" date="Sun Dec 22 04:31:32 EST 2019" starttimestamp="1576666505112" timestamp="340587127" />
  <Command __id="35309" _type="SelectTextCommand" caretOffset="376" date="Sun Dec 22 04:31:34 EST 2019" end="376" start="329" starttimestamp="1576666505112" timestamp="340589518" />
  <Command __id="35311" _type="MoveCaretCommand" caretOffset="357" date="Sun Dec 22 04:31:36 EST 2019" docOffset="357" starttimestamp="1576666505112" timestamp="340591300" />
  <Command __id="35313" _type="MoveCaretCommand" caretOffset="0" date="Sun Dec 22 04:31:37 EST 2019" docOffset="0" starttimestamp="1576666505112" timestamp="340592742" />
  <Command __id="35315" _type="SelectTextCommand" caretOffset="376" date="Sun Dec 22 04:31:44 EST 2019" end="376" start="329" starttimestamp="1576666505112" timestamp="340599420" />
  <Command __id="35317" _type="MoveCaretCommand" caretOffset="357" date="Sun Dec 22 04:31:46 EST 2019" docOffset="357" starttimestamp="1576666505112" timestamp="340601231" />
  <Command __id="35319" _type="MoveCaretCommand" caretOffset="453" date="Sun Dec 22 04:32:03 EST 2019" docOffset="453" starttimestamp="1576666505112" timestamp="340618166" />
  <Command __id="35320" _type="SelectTextCommand" caretOffset="453" date="Sun Dec 22 04:32:06 EST 2019" end="453" start="430" starttimestamp="1576666505112" timestamp="340621729" />
  <Command __id="35322" _type="PasteCommand" date="Sun Dec 22 04:32:07 EST 2019" starttimestamp="1576666505112" timestamp="340622339" />
  <Command __id="35318" _type="DiffBasedFileOpenCommand" date="Sun Dec 22 04:32:03 EST 2019" docASTNodeCount="1" docActiveCodeLength="503" docExpressionCount="0" docLength="527" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="340618007">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\sum_parallel_for_reduction.cpp]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"#include <iostream>¬∂#include <omp.h>¬∂¬∂using namespace std;¬∂¬∂//const int SIZE = 1000;¬∂void printSumWithTimes(int sum, int start, int end);¬∂void printNumThreads();¬∂void recordThreadIndex(int index);¬∂void sum_parallel_for_reduction(double* array, int size) {¬∂	cout << "sum_parallel_for_reduction\n";¬∂¬∂	double start = omp_get_wtime();¬∂¬∂	double sum = 0;¬∂    #pragma omp "), Diff(INSERT," "), Diff(EQUAL,"parallel for reduction"), Diff(INSERT," "), Diff(EQUAL,"(+:sum)¬∂¬∂	for (int i = 0; i < size; i++)"), Diff(INSERT," {"), Diff(EQUAL,"¬∂		sum += array[i];"), Diff(INSERT,"¬∂	}"), Diff(EQUAL,"¬∂¬∂	double end = omp_get_wtime();¬∂¬∂	printSumWithTimes(sum, start, end);¬∂¬∂}¬∂")]]]></diff>
    <snapshot><![CDATA[#include <iostream>
#include <omp.h>

using namespace std;

//const int SIZE = 1000;
void printSumWithTimes(int sum, int start, int end);
void printNumThreads();
void recordThreadIndex(int index);
void sum_parallel_for_reduction(double* array, int size) {
	cout << "sum_parallel_for_reduction\n";

	double start = omp_get_wtime();

	double sum = 0;
    #pragma omp  parallel for reduction (+:sum)

	for (int i = 0; i < size; i++) {
		sum += array[i];
	}

	double end = omp_get_wtime();

	printSumWithTimes(sum, start, end);

}
]]></snapshot>
  </Command>
  <DocumentChange __id="35321" _type="Replace" date="Sun Dec 22 04:32:07 EST 2019" docASTNodeCount="1" docActiveCodeLength="527" docExpressionCount="0" docLength="551" endLine="19" insertionLength="47" int_docASTNodeCount="1" int_docActiveCodeLength="480" int_docExpressionCount="0" int_docLength="504" length="23" offset="430" startLine="17" starttimestamp="1576666505112" timestamp="340622325">
    <deletedText><![CDATA[{
		sum += array[i];
	}]]></deletedText>
    <insertedText><![CDATA[{
		sum += array[i];
		recordThreadIndex(i);
	}]]></insertedText>
  </DocumentChange>
  <Command __id="35323" _type="EclipseCommand" commandID="org.eclipse.ui.file.save" date="Sun Dec 22 04:32:08 EST 2019" starttimestamp="1576666505112" timestamp="340623467" />
  <Command __id="35324" _type="DiffBasedFileOpenCommand" date="Sun Dec 22 04:32:10 EST 2019" docASTNodeCount="1" docActiveCodeLength="749" docExpressionCount="0" docLength="825" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="340625006">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\sum_parallel.cpp]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"#include <iostream>¬∂#include <omp.h>¬∂¬∂using namespace std;¬∂¬∂void printSumWithTimes(int sum, int start, int end);¬∂void printNumThreads();¬∂void recordThreadIndex(int index);¬∂void sum_parallel(double* array, int size) {¬∂	cout << "sum_parallel\n";¬∂¬∂	double start = omp_get_wtime();¬∂¬∂	double sum = 0;¬∂¬∂//	#pragma omp parallel¬∂//	for (int i = 0; i < size; i++)¬∂//		sum += array[i];¬∂    #pragma omp parallel¬∂	{¬∂		double local_sum = 0;¬∂¬∂		"), Diff(DELETE,"#pragma omp for"), Diff(INSERT,"int rank = omp_get_thread_num();¬∂		int threads = omp_get_num_threads();¬∂¬∂		int start_index = (size/threads)*rank;¬∂		int end_index = (size/threads)*(rank+1);¬∂¬∂		if(rank==threads-1)¬∂			end_index=size;¬∂"), Diff(EQUAL,"¬∂		for(int i = "), Diff(DELETE,"0; i < size"), Diff(INSERT,"start_index; i < end_index"), Diff(EQUAL,"; i++)¬∂			local_sum += array[i];¬∂¬∂		#pragma omp critical¬∂		sum += local_sum;¬∂	}¬∂¬∂	double end = omp_get_wtime();¬∂¬∂	printSumWithTimes(sum, start, end);¬∂¬∂¬∂}¬∂")]]]></diff>
    <snapshot><![CDATA[#include <iostream>
#include <omp.h>

using namespace std;

void printSumWithTimes(int sum, int start, int end);
void printNumThreads();
void recordThreadIndex(int index);
void sum_parallel(double* array, int size) {
	cout << "sum_parallel\n";

	double start = omp_get_wtime();

	double sum = 0;

//	#pragma omp parallel
//	for (int i = 0; i < size; i++)
//		sum += array[i];
    #pragma omp parallel
	{
		double local_sum = 0;

		int rank = omp_get_thread_num();
		int threads = omp_get_num_threads();

		int start_index = (size/threads)*rank;
		int end_index = (size/threads)*(rank+1);

		if(rank==threads-1)
			end_index=size;

		for(int i = start_index; i < end_index; i++)
			local_sum += array[i];

		#pragma omp critical
		sum += local_sum;
	}

	double end = omp_get_wtime();

	printSumWithTimes(sum, start, end);


}
]]></snapshot>
  </Command>
  <Command __id="35325" _type="MoveCaretCommand" caretOffset="0" date="Sun Dec 22 04:32:10 EST 2019" docOffset="0" starttimestamp="1576666505112" timestamp="340625138" />
  <Command __id="35326" _type="DiffBasedFileOpenCommand" date="Sun Dec 22 04:32:15 EST 2019" docASTNodeCount="1" docActiveCodeLength="611" docExpressionCount="0" docLength="699" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="340630267">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\sum_parallel_for_local_var.cpp]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"#include <iostream>¬∂#include <omp.h>¬∂¬∂using namespace std;¬∂¬∂void printSumWithTimes (int sum, int start, int end);¬∂void printNumThreads();¬∂void recordThreadIndex(int index);¬∂void sum_parallel_for_local_var(double* array, int size)¬∂{¬∂	cout << "sum_parallel_for_local_var\n";¬∂¬∂	double start = omp_get_wtime();¬∂¬∂	double sum = 0;¬∂//¬∂//	for (int i = 0; i < size; i++) {¬∂//			sum += array[i];¬∂//			recordThreadIndex(i);¬∂//	}¬∂    #pragma omp parallel¬∂	{¬∂		double local_sum = 0;¬∂¬∂		#pragma omp for¬∂		for(int i = 0; i < size; i++) {¬∂			local_sum += array[i];¬∂			recordThreadIndex(i);¬∂		}¬∂¬∂		#pragma omp critical¬∂		sum += local_sum;¬∂	}¬∂¬∂	double end = omp_get_wtime();¬∂¬∂	printSumWithTimes(sum, start, end);¬∂	¬∂}¬∂")]]]></diff>
  </Command>
  <Command __id="35327" _type="MoveCaretCommand" caretOffset="577" date="Sun Dec 22 04:32:15 EST 2019" docOffset="577" starttimestamp="1576666505112" timestamp="340630415" />
  <Command __id="35329" _type="MoveCaretCommand" caretOffset="0" date="Sun Dec 22 04:32:18 EST 2019" docOffset="0" starttimestamp="1576666505112" timestamp="340632919" />
  <Command __id="35328" _type="DiffBasedFileOpenCommand" date="Sun Dec 22 04:32:17 EST 2019" docASTNodeCount="1" docActiveCodeLength="453" docExpressionCount="0" docLength="453" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="340632744">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\sum_sequential.cpp]]></filePath>
    <diff><![CDATA[null]]></diff>
    <snapshot><![CDATA[#include <iostream>
#include <omp.h>

using namespace std;
void printSumWithTimes(int sum, int start, int end);
void printNumThreads();
void recordThreadIndex(int index);
void sum_sequential(double* array, int size) {

	cout << "sum_sequential\n";

	double start = omp_get_wtime();

	double sum = 0;

	for (int i = 0; i < size; i++) {
		sum += array[i];
		recordThreadIndex(i);
	}

	double end = omp_get_wtime();

	printSumWithTimes(sum, start, end);
}
]]></snapshot>
  </Command>
  <Command __id="35330" _type="MoveCaretCommand" caretOffset="312" date="Sun Dec 22 04:32:20 EST 2019" docOffset="312" starttimestamp="1576666505112" timestamp="340635054" />
  <Command __id="35331" _type="DiffBasedFileOpenCommand" date="Sun Dec 22 04:36:17 EST 2019" docASTNodeCount="1" docActiveCodeLength="527" docExpressionCount="0" docLength="551" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="340872680">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\sum_parallel_for_reduction.cpp]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"#include <iostream>¬∂#include <omp.h>¬∂¬∂using namespace std;¬∂¬∂//const int SIZE = 1000;¬∂void printSumWithTimes(int sum, int start, int end);¬∂void printNumThreads();¬∂void recordThreadIndex(int index);¬∂void sum_parallel_for_reduction(double* array, int size) {¬∂	cout << "sum_parallel_for_reduction\n";¬∂¬∂	double start = omp_get_wtime();¬∂¬∂	double sum = 0;¬∂    #pragma omp  parallel for reduction (+:sum)¬∂¬∂	for (int i = 0; i < size; i++) {¬∂		sum += array[i];¬∂	"), Diff(INSERT,"	recordThreadIndex(i);¬∂	"), Diff(EQUAL,"}¬∂¬∂	double end = omp_get_wtime();¬∂¬∂	printSumWithTimes(sum, start, end);¬∂¬∂}¬∂")]]]></diff>
    <snapshot><![CDATA[#include <iostream>
#include <omp.h>

using namespace std;

//const int SIZE = 1000;
void printSumWithTimes(int sum, int start, int end);
void printNumThreads();
void recordThreadIndex(int index);
void sum_parallel_for_reduction(double* array, int size) {
	cout << "sum_parallel_for_reduction\n";

	double start = omp_get_wtime();

	double sum = 0;
    #pragma omp  parallel for reduction (+:sum)

	for (int i = 0; i < size; i++) {
		sum += array[i];
		recordThreadIndex(i);
	}

	double end = omp_get_wtime();

	printSumWithTimes(sum, start, end);

}
]]></snapshot>
  </Command>
  <Command __id="35332" _type="MoveCaretCommand" caretOffset="477" date="Sun Dec 22 04:36:17 EST 2019" docOffset="477" starttimestamp="1576666505112" timestamp="340872771" />
  <Command __id="35337" _type="DiffBasedFileOpenCommand" date="Sun Dec 22 04:37:49 EST 2019" docASTNodeCount="1" docActiveCodeLength="478" docExpressionCount="0" docLength="478" projectName="OpenMPTraining" starttimestamp="1576666505112" timestamp="340964350">
    <filePath><![CDATA[D:\dewan_backup\C\OpenMPTraining\OpenMPTrainingC++\src\sum_parallel_for_reduction.cpp]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"#include <iostream>¬∂#include <omp.h>¬∂¬∂using namespace std;¬∂¬∂void printSumWithTimes(int sum, int start, int end);¬∂void printNumThreads();¬∂void recordThreadIndex(int index);¬∂void sum_parallel_for_reduction(double* array, int size) {¬∂	cout << "sum_parallel_for_reduction\n";¬∂¬∂	double start = omp_get_wtime();¬∂¬∂	double sum = 0;¬∂¬∂	for (int i = 0; i < size; i++) {¬∂		sum += array[i];¬∂		recordThreadIndex(i);¬∂	}¬∂¬∂	double end = omp_get_wtime();¬∂¬∂	printSumWithTimes(sum, start, end);¬∂¬∂}¬∂")]]]></diff>
  </Command>
  <Command __id="35338" _type="MoveCaretCommand" caretOffset="0" date="Sun Dec 22 04:37:49 EST 2019" docOffset="0" starttimestamp="1576666505112" timestamp="340964543" />
  <Command __id="35340" _type="MoveCaretCommand" caretOffset="0" date="Sun Dec 22 04:37:59 EST 2019" docOffset="0" starttimestamp="1576666505112" timestamp="340974706" />
  <Command __id="35339" _type="DiffBasedFileOpenCommand" date="Sun Dec 22 04:37:59 EST 2019" docASTNodeCount="1" docActiveCodeLength="527" docExpressionCount="0" docLength="551" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="340974579">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\sum_parallel_for_reduction.cpp]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"#include <iostream>¬∂#include <omp.h>¬∂¬∂using namespace std;¬∂¬∂//const int SIZE = 1000;¬∂void printSumWithTimes(int sum, int start, int end);¬∂void printNumThreads();¬∂void recordThreadIndex(int index);¬∂void sum_parallel_for_reduction(double* array, int size) {¬∂	cout << "sum_parallel_for_reduction\n";¬∂¬∂	double start = omp_get_wtime();¬∂¬∂	double sum = 0;¬∂    #pragma omp  parallel for reduction (+:sum)¬∂¬∂	for (int i = 0; i < size; i++) {¬∂		sum += array[i];¬∂		recordThreadIndex(i);¬∂	}¬∂¬∂	double end = omp_get_wtime();¬∂¬∂	printSumWithTimes(sum, start, end);¬∂¬∂}¬∂")]]]></diff>
  </Command>
  <Command __id="35341" _type="MoveCaretCommand" caretOffset="396" date="Sun Dec 22 04:38:10 EST 2019" docOffset="396" starttimestamp="1576666505112" timestamp="340985703" />
  <Command __id="35343" _type="EclipseCommand" commandID="org.eclipse.ui.edit.delete" date="Sun Dec 22 04:38:12 EST 2019" starttimestamp="1576666505112" timestamp="340987272" />
  <DocumentChange __id="35342" _type="Delete" date="Sun Dec 22 04:38:12 EST 2019" docASTNodeCount="1" docActiveCodeLength="526" docExpressionCount="0" docLength="550" endLine="16" length="1" offset="396" startLine="15" starttimestamp="1576666505112" timestamp="340987261">
    <text><![CDATA[
]]></text>
  </DocumentChange>
  <Command __id="35344" _type="MoveCaretCommand" caretOffset="437" date="Sun Dec 22 04:38:15 EST 2019" docOffset="437" starttimestamp="1576666505112" timestamp="340989962" />
  <Command __id="35345" _type="MoveCaretCommand" caretOffset="438" date="Sun Dec 22 04:38:15 EST 2019" docOffset="438" starttimestamp="1576666505112" timestamp="340990884" />
  <DocumentChange __id="35346" _type="Insert" date="Sun Dec 22 04:38:17 EST 2019" docASTNodeCount="1" docActiveCodeLength="527" docExpressionCount="0" docLength="551" length="1" offset="438" starttimestamp="1576666505112" timestamp="340991961">
    <text><![CDATA[\]]></text>
  </DocumentChange>
  <Command __id="35347" _type="InsertStringCommand" date="Sun Dec 22 04:38:17 EST 2019" starttimestamp="1576666505112" timestamp="340991964" timestamp2="340991964">
    <data><![CDATA[\]]></data>
  </Command>
  <DocumentChange __id="35348" _type="Insert" date="Sun Dec 22 04:38:17 EST 2019" docASTNodeCount="1" docActiveCodeLength="528" docExpressionCount="0" docLength="552" length="1" offset="439" starttimestamp="1576666505112" timestamp="340992887">
    <text><![CDATA[*]]></text>
  </DocumentChange>
  <Command __id="35349" _type="InsertStringCommand" date="Sun Dec 22 04:38:18 EST 2019" starttimestamp="1576666505112" timestamp="340992895" timestamp2="340992895">
    <data><![CDATA[*]]></data>
  </Command>
  <DocumentChange __id="35350" _type="Delete" date="Sun Dec 22 04:38:19 EST 2019" docASTNodeCount="1" docActiveCodeLength="527" docExpressionCount="0" docLength="551" endLine="17" length="1" offset="439" startLine="17" starttimestamp="1576666505112" timestamp="340994258">
    <text><![CDATA[*]]></text>
  </DocumentChange>
  <Command __id="35351" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Dec 22 04:38:19 EST 2019" starttimestamp="1576666505112" timestamp="340994260" />
  <DocumentChange __id="35352" _type="Delete" date="Sun Dec 22 04:38:19 EST 2019" docASTNodeCount="1" docActiveCodeLength="526" docExpressionCount="0" docLength="550" endLine="17" length="1" offset="438" startLine="17" starttimestamp="1576666505112" timestamp="340994504">
    <text><![CDATA[\]]></text>
  </DocumentChange>
  <Command __id="35353" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Dec 22 04:38:19 EST 2019" starttimestamp="1576666505112" timestamp="340994506" />
  <DocumentChange __id="35354" _type="Delete" date="Sun Dec 22 04:38:20 EST 2019" docASTNodeCount="1" docActiveCodeLength="525" docExpressionCount="0" docLength="549" endLine="17" length="1" offset="437" startLine="17" starttimestamp="1576666505112" timestamp="340995132">
    <text><![CDATA[+]]></text>
  </DocumentChange>
  <Command __id="35355" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Dec 22 04:38:20 EST 2019" starttimestamp="1576666505112" timestamp="340995138" />
  <Command __id="35357" _type="InsertStringCommand" date="Sun Dec 22 04:38:22 EST 2019" starttimestamp="1576666505112" timestamp="340997115" timestamp2="340997115">
    <data><![CDATA[*]]></data>
  </Command>
  <Command __id="35358" _type="EclipseCommand" commandID="org.eclipse.ui.file.save" date="Sun Dec 22 04:38:23 EST 2019" starttimestamp="1576666505112" timestamp="340998143" />
  <Command __id="35360" _type="RunCommand" date="Sun Dec 22 04:38:28 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="341003160" type="Run" />
  <Command __id="35361" _type="RunCommand" date="Sun Dec 22 04:38:28 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="341003161" type="Run" />
  <Command __id="35362" _type="RunCommand" date="Sun Dec 22 04:38:28 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="341003170" type="Debug" />
  <Command __id="35363" _type="RunCommand" date="Sun Dec 22 04:38:28 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="341003170" type="Run" />
  <Command __id="35364" _type="RunCommand" date="Sun Dec 22 04:38:28 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="341003170" type="Debug" />
  <Command __id="35365" _type="RunCommand" date="Sun Dec 22 04:38:28 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="341003170" type="Run" />
  <Command __id="35366" _type="EHExceptionCommand" date="Sun Dec 22 04:38:28 EST 2019" starttimestamp="1576666505112" timestamp="341003277" type="Exception">
    <outputString><![CDATA[sum_sequential
Sum: 499500
Took: 0
thread:0 lastIndex:999
_____________________________
sum_parallel_for_reduction
Sum: 0
Took: 0
thread:0 lastIndex:124
thread:1 lastIndex:249
thread:2 lastIndex:374
thread:3 lastIndex:499
thread:4 lastIndex:624
thread:5 lastIndex:749
thread:6 lastIndex:874
thread:7 lastIndex:999
_____________________________
sum_parallel_for_local_var
Sum: 499500
Took: 0
thread:0 lastIndex:124
thread:1 lastIndex:249
thread:2 lastIndex:374
thread:3 lastIndex:499
thread:4 lastIndex:624
thread:5 lastIndex:749
thread:6 lastIndex:874
thread:7 lastIndex:999
_____________________________
sum_parallel
Sum: 499500
Took: 0
_____________________________
]]></outputString>
  </Command>
  <DocumentChange __id="35356" _type="Insert" date="Sun Dec 22 04:38:22 EST 2019" docASTNodeCount="1" docActiveCodeLength="526" docExpressionCount="0" docLength="550" length="1" offset="437" starttimestamp="1576666505112" timestamp="340997112">
    <text><![CDATA[*]]></text>
  </DocumentChange>
  <Command __id="35367" _type="MoveCaretCommand" caretOffset="438" date="Sun Dec 22 04:38:58 EST 2019" docOffset="438" starttimestamp="1576666505112" timestamp="341033433" />
  <DocumentChange __id="35368" _type="Delete" date="Sun Dec 22 04:39:00 EST 2019" docASTNodeCount="1" docActiveCodeLength="525" docExpressionCount="0" docLength="549" endLine="17" length="1" offset="437" startLine="17" starttimestamp="1576666505112" timestamp="341035468">
    <text><![CDATA[*]]></text>
  </DocumentChange>
  <Command __id="35369" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Dec 22 04:39:00 EST 2019" starttimestamp="1576666505112" timestamp="341035468" />
  <Command __id="35371" _type="InsertStringCommand" date="Sun Dec 22 04:39:01 EST 2019" starttimestamp="1576666505112" timestamp="341036228" timestamp2="341036228">
    <data><![CDATA[+]]></data>
  </Command>
  <Command __id="35372" _type="EclipseCommand" commandID="org.eclipse.ui.file.save" date="Sun Dec 22 04:39:02 EST 2019" starttimestamp="1576666505112" timestamp="341037450" />
  <Command __id="35374" _type="RunCommand" date="Sun Dec 22 04:39:06 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="341041381" type="Run" />
  <Command __id="35375" _type="RunCommand" date="Sun Dec 22 04:39:06 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="341041381" type="Run" />
  <Command __id="35376" _type="RunCommand" date="Sun Dec 22 04:39:06 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="341041398" type="Debug" />
  <Command __id="35377" _type="RunCommand" date="Sun Dec 22 04:39:06 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="341041398" type="Run" />
  <Command __id="35378" _type="RunCommand" date="Sun Dec 22 04:39:06 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="341041398" type="Debug" />
  <Command __id="35379" _type="RunCommand" date="Sun Dec 22 04:39:06 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="341041398" type="Run" />
  <Command __id="35380" _type="EHExceptionCommand" date="Sun Dec 22 04:39:06 EST 2019" starttimestamp="1576666505112" timestamp="341041504" type="Exception">
    <outputString><![CDATA[sum_sequential
Sum: 499500
Took: 0
thread:0 lastIndex:999
_____________________________
sum_parallel_for_reduction
Sum: 499500
Took: 0
thread:0 lastIndex:124
thread:1 lastIndex:249
thread:2 lastIndex:374
thread:3 lastIndex:499
thread:4 lastIndex:624
thread:5 lastIndex:749
thread:6 lastIndex:874
thread:7 lastIndex:999
_____________________________
sum_parallel_for_local_var
Sum: 499500
Took: 0
thread:0 lastIndex:124
thread:1 lastIndex:249
thread:2 lastIndex:374
thread:3 lastIndex:499
thread:4 lastIndex:624
thread:5 lastIndex:749
thread:6 lastIndex:874
thread:7 lastIndex:999
_____________________________
sum_parallel
Sum: 499500
Took: 0
_____________________________
]]></outputString>
  </Command>
  <Command __id="35381" _type="ShellCommand" date="Sun Dec 22 04:40:37 EST 2019" starttimestamp="1576666505112" timestamp="341132734" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="35387" _type="DiffBasedFileOpenCommand" date="Sun Dec 22 04:41:36 EST 2019" docASTNodeCount="225" docActiveCodeLength="1686" docExpressionCount="116" docLength="1931" projectName="GraderBasics" starttimestamp="1576666505112" timestamp="341191411">
    <filePath><![CDATA[D:\dewan_backup\Java\GraderBasics\src\gradingTools\shared\testcases\openmp\AnOpenMPPragma.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package gradingTools.shared.testcases.openmp;¬∂¬∂import java.util.ArrayList;¬∂import java.util.Arrays;¬∂import java.util.List;¬∂¬∂public class AnOpenMPPragma implements OpenMPPragma {¬∂//	protected List<OpenMPKeywordEnum> openMPKeywords = new ArrayList();¬∂	protected String[] openMPTokens;¬∂¬∂	protected int lineNumber;¬∂	protected List<String> annotatedText = new ArrayList();¬∂	protected int annotatedTextStartLineNumber;¬∂	protected int annotatedTextEndLineNumber;¬∂	protected OpenMPPragma parent;¬∂	protected List<OpenMPPragma> children = new ArrayList();¬∂	protected List<String[]> variableDeclarations = new ArrayList();¬∂	¬∂	¬∂	¬∂	public AnOpenMPPragma(String[] openMPTokens, int lineNumber) {¬∂		super();¬∂		this.openMPTokens = openMPTokens;¬∂		this.lineNumber = lineNumber;¬∂		¬∂//		this.nextNonEmptyString = nextNonEmptyString;¬∂	}¬∂	@Override¬∂	public String[] getOpenMPTokens() {¬∂		return openMPTokens;¬∂	}¬∂	@Override¬∂	public int getLineNumber() {¬∂		return lineNumber;¬∂	}¬∂	@Override¬∂	public List<String> getAnnotatedText() {¬∂		return annotatedText;¬∂	}¬∂//	@Override¬∂//	public void setAnnotatedText(List<String> nextNonEmptyString) {¬∂//		this.annotatedText = nextNonEmptyString;¬∂//	}¬∂	@Override¬∂	public int getAnnotatedTextStartLineNumber() {¬∂		return annotatedTextStartLineNumber;¬∂	}¬∂	@Override¬∂	public void setAnnotatedTextStartLineNumber(int annotatedLineNumber) {¬∂		this.annotatedTextStartLineNumber = annotatedLineNumber;¬∂	}¬∂	¬∂	@Override¬∂	public int getAnnotatedTextEndLineNumber() {¬∂		return annotatedTextEndLineNumber;¬∂	}¬∂	@Override¬∂	public void setAnnotatedTextEndLineNumber(int annotatedTextEndLineNumber) {¬∂		this.annotatedTextEndLineNumber = annotatedTextEndLineNumber;¬∂	}¬∂	¬∂	public String toString() {¬∂		return lineNumber + ":" + Arrays.toString(openMPTokens) +¬∂				"--> (" + annotatedTextStartLineNumber + "," + annotatedTextEndLineNumber + "):" + annotatedText;¬∂	}¬∂¬∂}¬∂")]]]></diff>
  </Command>
  <Command __id="35388" _type="MoveCaretCommand" caretOffset="630" date="Sun Dec 22 04:41:36 EST 2019" docOffset="630" starttimestamp="1576666505112" timestamp="341191650" />
  <Command __id="35390" _type="MoveCaretCommand" caretOffset="547" date="Sun Dec 22 04:41:42 EST 2019" docOffset="547" starttimestamp="1576666505112" timestamp="341197330" />
  <Command __id="35389" _type="DiffBasedFileOpenCommand" date="Sun Dec 22 04:41:42 EST 2019" docASTNodeCount="1" docActiveCodeLength="526" docExpressionCount="0" docLength="550" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="341197186">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\sum_parallel_for_reduction.cpp]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"#include <iostream>¬∂#include <omp.h>¬∂¬∂using namespace std;¬∂¬∂//const int SIZE = 1000;¬∂void printSumWithTimes(int sum, int start, int end);¬∂void printNumThreads();¬∂void recordThreadIndex(int index);¬∂void sum_parallel_for_reduction(double* array, int size) {¬∂	cout << "sum_parallel_for_reduction\n";¬∂¬∂	double start = omp_get_wtime();¬∂¬∂	double sum = 0;¬∂    #pragma omp  parallel for reduction (+:sum)¬∂"), Diff(DELETE,"¬∂"), Diff(EQUAL,"	for (int i = 0; i < size; i++) {¬∂		sum += array[i];¬∂		recordThreadIndex(i);¬∂	}¬∂¬∂	double end = omp_get_wtime();¬∂¬∂	printSumWithTimes(sum, start, end);¬∂¬∂}¬∂")]]]></diff>
    <snapshot><![CDATA[#include <iostream>
#include <omp.h>

using namespace std;

//const int SIZE = 1000;
void printSumWithTimes(int sum, int start, int end);
void printNumThreads();
void recordThreadIndex(int index);
void sum_parallel_for_reduction(double* array, int size) {
	cout << "sum_parallel_for_reduction\n";

	double start = omp_get_wtime();

	double sum = 0;
    #pragma omp  parallel for reduction (+:sum)
	for (int i = 0; i < size; i++) {
		sum += array[i];
		recordThreadIndex(i);
	}

	double end = omp_get_wtime();

	printSumWithTimes(sum, start, end);

}
]]></snapshot>
  </Command>
  <Command __id="35391" _type="SelectTextCommand" caretOffset="396" date="Sun Dec 22 04:41:52 EST 2019" end="396" start="389" starttimestamp="1576666505112" timestamp="341207406" />
  <DocumentChange __id="35392" _type="Delete" date="Sun Dec 22 04:41:53 EST 2019" docASTNodeCount="1" docActiveCodeLength="519" docExpressionCount="0" docLength="543" endLine="15" length="7" offset="389" startLine="15" starttimestamp="1576666505112" timestamp="341208856">
    <text><![CDATA[(+:sum)]]></text>
  </DocumentChange>
  <Command __id="35393" _type="CutCommand" date="Sun Dec 22 04:41:53 EST 2019" starttimestamp="1576666505112" timestamp="341208874" />
  <Command __id="35395" _type="EclipseCommand" commandID="org.eclipse.ui.file.save" date="Sun Dec 22 04:41:55 EST 2019" starttimestamp="1576666505112" timestamp="341210095" />
  <Command __id="35396" _type="EclipseCommand" commandID="org.eclipse.debug.ui.commands.RunLast" date="Sun Dec 22 04:41:58 EST 2019" starttimestamp="1576666505112" timestamp="341213478" />
  <Command __id="35397" _type="ShellCommand" date="Sun Dec 22 04:41:59 EST 2019" starttimestamp="1576666505112" timestamp="341214054" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="35398" _type="ShellCommand" date="Sun Dec 22 04:42:00 EST 2019" starttimestamp="1576666505112" timestamp="341215732" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="35399" _type="RunCommand" date="Sun Dec 22 04:42:00 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="341215832" type="Run" />
  <Command __id="35400" _type="RunCommand" date="Sun Dec 22 04:42:00 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="341215832" type="Run" />
  <Command __id="35401" _type="RunCommand" date="Sun Dec 22 04:42:00 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="341215849" type="Debug" />
  <Command __id="35402" _type="RunCommand" date="Sun Dec 22 04:42:00 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="341215849" type="Run" />
  <Command __id="35403" _type="RunCommand" date="Sun Dec 22 04:42:00 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="341215849" type="Debug" />
  <Command __id="35404" _type="RunCommand" date="Sun Dec 22 04:42:00 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="341215849" type="Run" />
  <Command __id="35405" _type="EHExceptionCommand" date="Sun Dec 22 04:42:01 EST 2019" starttimestamp="1576666505112" timestamp="341215948" type="Exception">
    <outputString><![CDATA[sum_sequential
Sum: 499500
Took: 0
thread:0 lastIndex:999
_____________________________
sum_parallel_for_reduction
Sum: 499500
Took: 0
thread:0 lastIndex:124
thread:1 lastIndex:249
thread:2 lastIndex:374
thread:3 lastIndex:499
thread:4 lastIndex:624
thread:5 lastIndex:749
thread:6 lastIndex:874
thread:7 lastIndex:999
_____________________________
sum_parallel_for_local_var
Sum: 499500
Took: 0
thread:0 lastIndex:124
thread:1 lastIndex:249
thread:2 lastIndex:374
thread:3 lastIndex:499
thread:4 lastIndex:624
thread:5 lastIndex:749
thread:6 lastIndex:874
thread:7 lastIndex:999
_____________________________
sum_parallel
Sum: 499500
Took: 0
_____________________________
]]></outputString>
  </Command>
  <DocumentChange __id="35394" _type="Delete" date="Sun Dec 22 04:41:55 EST 2019" docASTNodeCount="1" docActiveCodeLength="518" docExpressionCount="0" docLength="542" endLine="15" length="1" offset="388" startLine="15" starttimestamp="1576666505112" timestamp="341210055">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <Command __id="35406" _type="MoveCaretCommand" caretOffset="388" date="Sun Dec 22 04:42:15 EST 2019" docOffset="388" starttimestamp="1576666505112" timestamp="341230004" />
  <DocumentChange __id="35407" _type="Insert" date="Sun Dec 22 04:42:16 EST 2019" docASTNodeCount="1" docActiveCodeLength="519" docExpressionCount="0" docLength="543" length="1" offset="388" starttimestamp="1576666505112" timestamp="341231278">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <Command __id="35408" _type="UndoCommand" date="Sun Dec 22 04:42:16 EST 2019" starttimestamp="1576666505112" timestamp="341231293" />
  <Command __id="35410" _type="UndoCommand" date="Sun Dec 22 04:42:18 EST 2019" starttimestamp="1576666505112" timestamp="341233345" />
  <Command __id="35411" _type="EclipseCommand" commandID="org.eclipse.ui.file.save" date="Sun Dec 22 04:42:19 EST 2019" starttimestamp="1576666505112" timestamp="341234557" />
  <Command __id="35412" _type="MoveCaretCommand" caretOffset="390" date="Sun Dec 22 04:42:36 EST 2019" docOffset="390" starttimestamp="1576666505112" timestamp="341251086" />
  <Command __id="35414" _type="InsertStringCommand" date="Sun Dec 22 04:42:36 EST 2019" starttimestamp="1576666505112" timestamp="341251568" timestamp2="341251568">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="35415" _type="MoveCaretCommand" caretOffset="392" date="Sun Dec 22 04:42:38 EST 2019" docOffset="392" starttimestamp="1576666505112" timestamp="341253089" />
  <Command __id="35417" _type="InsertStringCommand" date="Sun Dec 22 04:42:38 EST 2019" starttimestamp="1576666505112" timestamp="341253424" timestamp2="341253424">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="35418" _type="MoveCaretCommand" caretOffset="395" date="Sun Dec 22 04:42:39 EST 2019" docOffset="395" starttimestamp="1576666505112" timestamp="341254804" />
  <Command __id="35419" _type="MoveCaretCommand" caretOffset="394" date="Sun Dec 22 04:42:40 EST 2019" docOffset="394" starttimestamp="1576666505112" timestamp="341255652" />
  <Command __id="35421" _type="InsertStringCommand" date="Sun Dec 22 04:42:41 EST 2019" starttimestamp="1576666505112" timestamp="341255943" timestamp2="341255943">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="35422" _type="EclipseCommand" commandID="org.eclipse.ui.file.save" date="Sun Dec 22 04:42:42 EST 2019" starttimestamp="1576666505112" timestamp="341257229" />
  <DocumentChange __id="36142" _type="Insert" date="Sun Dec 22 04:53:13 EST 2019" docASTNodeCount="610" docActiveCodeLength="3965" docExpressionCount="367" docLength="4544" length="1" offset="3925" starttimestamp="1576666505112" timestamp="341887990">
    <text><![CDATA[b]]></text>
  </DocumentChange>
  <DocumentChange __id="36144" _type="Insert" date="Sun Dec 22 04:53:13 EST 2019" docASTNodeCount="610" docActiveCodeLength="3966" docExpressionCount="367" docLength="4545" length="1" offset="3926" starttimestamp="1576666505112" timestamp="341888277">
    <text><![CDATA[r]]></text>
  </DocumentChange>
  <DocumentChange __id="36146" _type="Insert" date="Sun Dec 22 04:53:13 EST 2019" docASTNodeCount="610" docActiveCodeLength="3967" docExpressionCount="367" docLength="4546" length="1" offset="3927" starttimestamp="1576666505112" timestamp="341888398">
    <text><![CDATA[e]]></text>
  </DocumentChange>
  <DocumentChange __id="36148" _type="Insert" date="Sun Dec 22 04:53:13 EST 2019" docASTNodeCount="610" docActiveCodeLength="3968" docExpressionCount="367" docLength="4547" length="1" offset="3928" starttimestamp="1576666505112" timestamp="341888584">
    <text><![CDATA[a]]></text>
  </DocumentChange>
  <DocumentChange __id="36150" _type="Insert" date="Sun Dec 22 04:53:13 EST 2019" docASTNodeCount="609" docActiveCodeLength="3969" docExpressionCount="366" docLength="4548" length="1" offset="3929" starttimestamp="1576666505112" timestamp="341888769">
    <text><![CDATA[k]]></text>
  </DocumentChange>
  <DocumentChange __id="36152" _type="Insert" date="Sun Dec 22 04:53:14 EST 2019" docASTNodeCount="609" docActiveCodeLength="3970" docExpressionCount="366" docLength="4549" length="1" offset="3930" starttimestamp="1576666505112" timestamp="341889691">
    <text><![CDATA[;]]></text>
  </DocumentChange>
  <DocumentChange __id="36155" _type="Insert" date="Sun Dec 22 04:53:26 EST 2019" docASTNodeCount="609" docActiveCodeLength="3977" docExpressionCount="366" docLength="4556" length="7" offset="4031" starttimestamp="1576666505112" timestamp="341901669">
    <text><![CDATA[
					]]></text>
  </DocumentChange>
  <DocumentChange __id="36158" _type="Delete" date="Sun Dec 22 04:53:30 EST 2019" docASTNodeCount="609" docActiveCodeLength="3975" docExpressionCount="366" docLength="4554" endLine="122" length="2" offset="4031" startLine="121" starttimestamp="1576666505112" timestamp="341905733">
    <text><![CDATA[
]]></text>
  </DocumentChange>
  <Command __id="36186" _type="EclipseCommand" commandID="" date="Sun Dec 22 04:53:45 EST 2019" starttimestamp="1576666505112" timestamp="341920326" />
  <Command __id="36187" _type="EclipseCommand" commandID="" date="Sun Dec 22 04:53:45 EST 2019" starttimestamp="1576666505112" timestamp="341920326" />
  <Command __id="36188" _type="EclipseCommand" commandID="" date="Sun Dec 22 04:53:45 EST 2019" starttimestamp="1576666505112" timestamp="341920335" />
  <Command __id="36189" _type="EclipseCommand" commandID="" date="Sun Dec 22 04:53:45 EST 2019" starttimestamp="1576666505112" timestamp="341920335" />
  <Command __id="36190" _type="EclipseCommand" commandID="" date="Sun Dec 22 04:53:45 EST 2019" starttimestamp="1576666505112" timestamp="341920337" />
  <Command __id="36191" _type="EclipseCommand" commandID="" date="Sun Dec 22 04:53:45 EST 2019" starttimestamp="1576666505112" timestamp="341920337" />
  <Command __id="36192" _type="EclipseCommand" commandID="" date="Sun Dec 22 04:53:45 EST 2019" starttimestamp="1576666505112" timestamp="341920352" />
  <Command __id="36193" _type="EclipseCommand" commandID="" date="Sun Dec 22 04:53:45 EST 2019" starttimestamp="1576666505112" timestamp="341920352" />
  <Command __id="36194" _type="EclipseCommand" commandID="" date="Sun Dec 22 04:53:45 EST 2019" starttimestamp="1576666505112" timestamp="341920357" />
  <Command __id="36195" _type="EclipseCommand" commandID="" date="Sun Dec 22 04:53:45 EST 2019" starttimestamp="1576666505112" timestamp="341920357" />
  <Command __id="36196" _type="EclipseCommand" commandID="" date="Sun Dec 22 04:53:45 EST 2019" starttimestamp="1576666505112" timestamp="341920365" />
  <Command __id="36198" _type="MoveCaretCommand" caretOffset="395" date="Sun Dec 22 04:53:47 EST 2019" docOffset="395" starttimestamp="1576666505112" timestamp="341922646" />
  <Command __id="36199" _type="EclipseCommand" commandID="" date="Sun Dec 22 04:53:48 EST 2019" starttimestamp="1576666505112" timestamp="341923640" />
  <Command __id="36200" _type="EclipseCommand" commandID="" date="Sun Dec 22 04:53:48 EST 2019" starttimestamp="1576666505112" timestamp="341923702" />
  <Command __id="36201" _type="MoveCaretCommand" caretOffset="398" date="Sun Dec 22 04:53:49 EST 2019" docOffset="398" starttimestamp="1576666505112" timestamp="341924749" />
  <Command __id="36203" _type="InsertStringCommand" date="Sun Dec 22 04:53:50 EST 2019" starttimestamp="1576666505112" timestamp="341924969" timestamp2="341924969">
    <data><![CDATA[ ]]></data>
  </Command>
  <DocumentChange __id="37693" _type="Insert" date="Sun Dec 22 05:20:18 EST 2019" docASTNodeCount="615" docActiveCodeLength="4045" docExpressionCount="369" docLength="4655" length="1" offset="3892" starttimestamp="1576666505112" timestamp="343513121">
    <text><![CDATA[;]]></text>
  </DocumentChange>
  <Command __id="37787" _type="EclipseCommand" commandID="org.eclipse.ui.navigate.backwardHistory" date="Sun Dec 22 05:22:29 EST 2019" starttimestamp="1576666505112" timestamp="343644320" />
  <Command __id="37789" _type="MoveCaretCommand" caretOffset="399" date="Sun Dec 22 05:22:33 EST 2019" docOffset="399" starttimestamp="1576666505112" timestamp="343647913" />
  <Command __id="37790" _type="ShellCommand" date="Sun Dec 22 05:22:40 EST 2019" starttimestamp="1576666505112" timestamp="343655773" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="37791" _type="RunCommand" date="Sun Dec 22 05:22:41 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="343656220" type="Run" />
  <Command __id="37792" _type="RunCommand" date="Sun Dec 22 05:22:41 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="343656252" type="Run" />
  <Command __id="37793" _type="RunCommand" date="Sun Dec 22 05:22:41 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="343656252" type="Run" />
  <Command __id="37794" _type="EHExceptionCommand" date="Sun Dec 22 05:22:41 EST 2019" starttimestamp="1576666505112" timestamp="343656267" type="Exception">
    <outputString><![CDATA[I***(TestCaseResult) ### SequentialSumTestCase: 1.0
Returning first of multiple entry points:[MyOpenMPTraining.exe, OpenMPTraining.exe]
I***(BasicProcessRunner) Running command:D:\dewan_backup\C\MyOpenMPTraining\Debug\MyOpenMPTraining.exe
I***(BasicProcessRunner) Running in folder: D:\dewan_backup\C\MyOpenMPTraining\Debug
I***(BasicProcessRunner)  Process started: D:\dewan_backup\C\MyOpenMPTraining\Debug\MyOpenMPTraining.exe folder: D:\dewan_backup\C\MyOpenMPTraining\Debug entry point: null class path: D:\dewan_backup\Java\PLTeaching\PL_Java\bin;D:\dewan_backup\Java\lib\oeall22.jar;C:\Users\dewan\.p2\pool\plugins\org.junit_4.12.0.v201504281640\junit.jar;C:\Users\dewan\.p2\pool\plugins\org.hamcrest.core_1.3.0.v20180420-1519.jar;D:\dewan_backup\Java\GraderBasics\lib\commons-configuration-1.9.jar;D:\dewan_backup\Java\GraderBasics\lib\commons-lang-2.6.jar;D:\dewan_backup\Java\GraderBasics\lib\commons-logging-1.1.1.jar;G:\My Drive\Java\lib\Herrmes\lib\weka3_6.jar;D:\dewan_backup\Java\GraderBasics\target\classes;D:\dewan_backup\Java\DemoCourseLocalBasicChecks\bin
I***(ARunnerInputStreamProcessor) Provided Input:
I***(BasicRunningProject) 1577010161364:Received output from main: sum_sequential
I***(BasicRunningProject) 1577010161364:Processing line from main: sum_sequential
I***(BasicRunningProject) 1577010161364:Received output from main: Sum: 499500
I***(BasicRunningProject) 1577010161364:Processing line from main: Sum: 499500
I***(BasicRunningProject) 1577010161364:Received output from main: Took: 0
I***(BasicRunningProject) 1577010161364:Processing line from main: Took: 0
I***(BasicRunningProject) 1577010161364:Received output from main: thread:0 lastIndex:999
I***(BasicRunningProject) 1577010161364:Processing line from main: thread:0 lastIndex:999
I***(BasicRunningProject) 1577010161364:Received output from main: _____________________________
I***(BasicRunningProject) 1577010161364:Processing line from main: _____________________________
I***(BasicRunningProject) 1577010161364:Received output from main: sum_parallel_for_reduction
I***(BasicRunningProject) 1577010161364:Processing line from main: sum_parallel_for_reduction
I***(BasicRunningProject) 1577010161364:Received output from main: Sum: 499500
I***(BasicRunningProject) 1577010161364:Processing line from main: Sum: 499500
I***(BasicRunningProject) 1577010161364:Received output from main: Took: 0
I***(BasicRunningProject) 1577010161364:Processing line from main: Took: 0
]]></outputString>
  </Command>
  <Command __id="37795" _type="EHExceptionCommand" date="Sun Dec 22 05:22:41 EST 2019" starttimestamp="1576666505112" timestamp="343656267" type="Exception">
    <outputString><![CDATA[I***(BasicRunningProject) 1577010161364:Received output from main: thread:0 lastIndex:124
I***(BasicRunningProject) 1577010161364:Processing line from main: thread:0 lastIndex:124
I***(BasicRunningProject) 1577010161364:Received output from main: thread:1 lastIndex:249
I***(BasicRunningProject) 1577010161364:Processing line from main: thread:1 lastIndex:249
I***(BasicRunningProject) 1577010161364:Received output from main: thread:2 lastIndex:374
I***(BasicRunningProject) 1577010161364:Processing line from main: thread:2 lastIndex:374
I***(BasicRunningProject) 1577010161364:Received output from main: thread:3 lastIndex:499
I***(BasicRunningProject) 1577010161364:Processing line from main: thread:3 lastIndex:499
I***(BasicRunningProject) 1577010161379:Received output from main: thread:4 lastIndex:624
I***(BasicRunningProject) 1577010161379:Processing line from main: thread:4 lastIndex:624
I***(BasicRunningProject) 1577010161379:Received output from main: thread:5 lastIndex:749
I***(BasicRunningProject) 1577010161379:Processing line from main: thread:5 lastIndex:749
I***(BasicRunningProject) 1577010161379:Received output from main: thread:6 lastIndex:874
I***(BasicRunningProject) 1577010161379:Processing line from main: thread:6 lastIndex:874
I***(BasicRunningProject) 1577010161379:Received output from main: thread:7 lastIndex:999
I***(BasicRunningProject) 1577010161379:Processing line from main: thread:7 lastIndex:999
I***(BasicRunningProject) 1577010161379:Received output from main: _____________________________
I***(BasicRunningProject) 1577010161379:Processing line from main: _____________________________
I***(BasicRunningProject) 1577010161379:Received output from main: sum_parallel_for_local_var
I***(BasicRunningProject) 1577010161379:Processing line from main: sum_parallel_for_local_var
I***(BasicRunningProject) 1577010161379:Received output from main: Sum: 499500
I***(BasicRunningProject) 1577010161379:Processing line from main: Sum: 499500
I***(BasicRunningProject) 1577010161379:Received output from main: Took: 0
I***(BasicRunningProject) 1577010161379:Processing line from main: Took: 0
I***(BasicRunningProject) 1577010161379:Received output from main: thread:0 lastIndex:124
I***(BasicRunningProject) 1577010161379:Processing line from main: thread:0 lastIndex:124
I***(BasicRunningProject) 1577010161379:Received output from main: thread:1 lastIndex:249
I***(BasicRunningProject) 1577010161379:Processing line from main: thread:1 lastIndex:249
I***(BasicRunningProject) 1577010161379:Received output from main: thread:2 lastIndex:374
I***(BasicRunningProject) 1577010161379:Processing line from main: thread:2 lastIndex:374
I***(BasicRunningProject) 1577010161379:Received output from main: thread:3 lastIndex:499
I***(BasicRunningProject) 1577010161379:Processing line from main: thread:3 lastIndex:499
I***(BasicRunningProject) 1577010161379:Received output from main: thread:4 lastIndex:624
I***(BasicRunningProject) 1577010161379:Processing line from main: thread:4 lastIndex:624
I***(BasicRunningProject) 1577010161379:Received output from main: thread:5 lastIndex:749
I***(BasicRunningProject) 1577010161379:Processing line from main: thread:5 lastIndex:749
I***(BasicRunningProject) 1577010161379:Received output from main: thread:6 lastIndex:874
I***(BasicRunningProject) 1577010161379:Processing line from main: thread:6 lastIndex:874
I***(BasicRunningProject) 1577010161379:Received output from main: thread:7 lastIndex:999
I***(BasicRunningProject) 1577010161379:Received output from main: _____________________________
I***(BasicRunningProject) 1577010161379:Received output from main: sum_parallel
I***(BasicRunningProject) 1577010161379:Received output from main: Sum: 499500
I***(BasicProcessRunner)  Process finished; folder: D:\dewan_backup\C\MyOpenMPTraining\Debug entry point: null class path: D:\dewan_backup\Java\PLTeaching\PL_Java\bin;D:\dewan_backup\Java\lib\oeall22.jar;C:\Users\dewan\.p2\pool\plugins\org.junit_4.12.0.v201504281640\junit.jar;C:\Users\dewan\.p2\pool\plugins\org.hamcrest.core_1.3.0.v20180420-1519.jar;D:\dewan_backup\Java\GraderBasics\lib\commons-configuration-1.9.jar;D:\dewan_backup\Java\GraderBasics\lib\commons-lang-2.6.jar;D:\dewan_backup\Java\GraderBasics\lib\commons-logging-1.1.1.jar;G:\My Drive\Java\lib\Herrmes\lib\weka3_6.jar;D:\dewan_backup\Java\GraderBasics\target\classes;D:\dewan_backup\Java\DemoCourseLocalBasicChecks\bin
I***(BasicRunningProject) 1577010161379:Processing line from main: thread:7 lastIndex:999
I***(BasicRunningProject) 1577010161379:Received output from main: Took: 0
I***(BasicRunningProject) 1577010161379:Processing line from main: _____________________________
I***(BasicRunningProject) 1577010161379:Processing line from main: sum_parallel
I***(BasicRunningProject) 1577010161379:Processing line from main: Sum: 499500
I***(BasicRunningProject) 1577010161379:Processing line from main: Took: 0
I***(BasicRunningProject) 1577010161379:Received output from main: _____________________________
I***(BasicRunningProject) 1577010161379:Processing line from main: _____________________________
I***(BasicRunningProject) Thread[AWT-EventQueue-0,6,main] sleeping for ms:2000 waiting for pending output from threads 
]]></outputString>
  </Command>
  <Command __id="37796" _type="EHExceptionCommand" date="Sun Dec 22 05:22:43 EST 2019" starttimestamp="1576666505112" timestamp="343658370" type="Exception">
    <outputString><![CDATA[line matcher for key:main
I***(ALinesMatcher) Matching pattern:.*sum_sequential.*?starting at:0
I***(ALinesMatcher) 0: Checking: sum_sequential

0: Matched  pattern .*sum_sequential.*?
I***(ALinesMatcher) Matching pattern:.*499500.*?starting at:1
I***(ALinesMatcher) 1: Checking: Sum: 499500

1: Matched  pattern .*499500.*?
I***(ALinesMatcher) Matching pattern:.*Took.*?starting at:2
I***(ALinesMatcher) 2: Checking: Took: 0

2: Matched  pattern .*Took.*?
I***(ALinesMatcher) Matching pattern:.*thread.*?starting at:3
I***(ALinesMatcher) 3: Checking: thread:0 lastIndex:999

3: Matched  pattern .*thread.*?
Matched Line sum_sequential
 for pattern [.*sum_sequential.*?, .*499500.*?, .*Took.*?, .*thread.*?]
Matched Line Sum: 499500
 for pattern [.*sum_sequential.*?, .*499500.*?, .*Took.*?, .*thread.*?]
Matched Line Took: 0
 for pattern [.*sum_sequential.*?, .*499500.*?, .*Took.*?, .*thread.*?]
Matched Line thread:0 lastIndex:999
 for pattern [.*sum_sequential.*?, .*499500.*?, .*Took.*?, .*thread.*?]
file name:sum_parallel_for_reduction.cp
pragmas:[15:[parallel, for, reduction(+:sum)]--> (16,19):[for (int i = 0; i < size; i++) {, sum += array[i];, recordThreadIndex(i);, }]]
file name:sum_parallel_for_local_var.cp
pragmas:[20:[parallel]--> (21,32):[{, double local_sum = 0;, #pragma omp for, for(int i = 0; i < size; i++) {, local_sum += array[i];, recordThreadIndex(i);, }, #pragma omp critical, sum += local_sum;, }], 24:[for]--> (25,28):[for(int i = 0; i < size; i++) {, local_sum += array[i];, recordThreadIndex(i);, }], 30:[critical]--> (31,31):[sum += local_sum;]]
file name:sum_main.cp
pragmas:[]
file name:sum_sequential.cp
pragmas:[]
file name:sum_parallel.cp
pragmas:[18:[parallel]--> (19,36):[{, double local_sum = 0;, int rank = omp_get_thread_num();, int threads = omp_get_num_threads();, int start_index = (size/threads)*rank;, int end_index = (size/threads)*(rank+1);, if(rank==threads-1), end_index=size;, for(int i = start_index; i < end_index; i++), local_sum += array[i];, #pragma omp critical, sum += local_sum;, }], 34:[critical]--> (35,35):[sum += local_sum;]]
I***(TestCaseResult) ### anonymous: 1.0
]]></outputString>
  </Command>
  <DocumentChange __id="38051" _type="Insert" date="Sun Dec 22 05:30:12 EST 2019" docASTNodeCount="230" docActiveCodeLength="1705" docExpressionCount="114" docLength="1987" length="1" offset="716" starttimestamp="1576666505112" timestamp="344107703">
    <text><![CDATA[o]]></text>
  </DocumentChange>
  <DocumentChange __id="38054" _type="Insert" date="Sun Dec 22 05:30:12 EST 2019" docASTNodeCount="230" docActiveCodeLength="1706" docExpressionCount="114" docLength="1988" length="1" offset="717" starttimestamp="1576666505112" timestamp="344107879">
    <text><![CDATA[p]]></text>
  </DocumentChange>
  <DocumentChange __id="38057" _type="Insert" date="Sun Dec 22 05:30:13 EST 2019" docASTNodeCount="230" docActiveCodeLength="1707" docExpressionCount="114" docLength="1989" length="1" offset="718" starttimestamp="1576666505112" timestamp="344108006">
    <text><![CDATA[e]]></text>
  </DocumentChange>
  <DocumentChange __id="38060" _type="Insert" date="Sun Dec 22 05:30:13 EST 2019" docASTNodeCount="230" docActiveCodeLength="1708" docExpressionCount="114" docLength="1990" length="1" offset="719" starttimestamp="1576666505112" timestamp="344108282">
    <text><![CDATA[r]]></text>
  </DocumentChange>
  <DocumentChange __id="38063" _type="Insert" date="Sun Dec 22 05:30:13 EST 2019" docASTNodeCount="230" docActiveCodeLength="1709" docExpressionCount="114" docLength="1991" length="1" offset="720" starttimestamp="1576666505112" timestamp="344108381">
    <text><![CDATA[a]]></text>
  </DocumentChange>
  <DocumentChange __id="38066" _type="Insert" date="Sun Dec 22 05:30:13 EST 2019" docASTNodeCount="230" docActiveCodeLength="1710" docExpressionCount="114" docLength="1992" length="1" offset="721" starttimestamp="1576666505112" timestamp="344108484">
    <text><![CDATA[t]]></text>
  </DocumentChange>
  <DocumentChange __id="38069" _type="Delete" date="Sun Dec 22 05:30:14 EST 2019" docASTNodeCount="230" docActiveCodeLength="1709" docExpressionCount="114" docLength="1991" endLine="18" length="1" offset="721" startLine="18" starttimestamp="1576666505112" timestamp="344109241">
    <text><![CDATA[t]]></text>
  </DocumentChange>
  <DocumentChange __id="38072" _type="Delete" date="Sun Dec 22 05:30:14 EST 2019" docASTNodeCount="230" docActiveCodeLength="1708" docExpressionCount="114" docLength="1990" endLine="18" length="1" offset="720" startLine="18" starttimestamp="1576666505112" timestamp="344109402">
    <text><![CDATA[a]]></text>
  </DocumentChange>
  <DocumentChange __id="38075" _type="Delete" date="Sun Dec 22 05:30:14 EST 2019" docASTNodeCount="230" docActiveCodeLength="1707" docExpressionCount="114" docLength="1989" endLine="18" length="1" offset="719" startLine="18" starttimestamp="1576666505112" timestamp="344109570">
    <text><![CDATA[r]]></text>
  </DocumentChange>
  <DocumentChange __id="38078" _type="Delete" date="Sun Dec 22 05:30:14 EST 2019" docASTNodeCount="230" docActiveCodeLength="1706" docExpressionCount="114" docLength="1988" endLine="18" length="1" offset="718" startLine="18" starttimestamp="1576666505112" timestamp="344109751">
    <text><![CDATA[e]]></text>
  </DocumentChange>
  <DocumentChange __id="38081" _type="Delete" date="Sun Dec 22 05:30:15 EST 2019" docASTNodeCount="230" docActiveCodeLength="1705" docExpressionCount="114" docLength="1987" endLine="18" length="1" offset="717" startLine="18" starttimestamp="1576666505112" timestamp="344109916">
    <text><![CDATA[p]]></text>
  </DocumentChange>
  <DocumentChange __id="38084" _type="Delete" date="Sun Dec 22 05:30:15 EST 2019" docASTNodeCount="230" docActiveCodeLength="1704" docExpressionCount="114" docLength="1986" endLine="18" length="1" offset="716" startLine="18" starttimestamp="1576666505112" timestamp="344110268">
    <text><![CDATA[o]]></text>
  </DocumentChange>
  <DocumentChange __id="38087" _type="Insert" date="Sun Dec 22 05:30:16 EST 2019" docASTNodeCount="230" docActiveCodeLength="1705" docExpressionCount="114" docLength="1987" length="1" offset="716" starttimestamp="1576666505112" timestamp="344110973">
    <text><![CDATA[O]]></text>
  </DocumentChange>
  <DocumentChange __id="38090" _type="Insert" date="Sun Dec 22 05:30:16 EST 2019" docASTNodeCount="230" docActiveCodeLength="1706" docExpressionCount="114" docLength="1988" length="1" offset="717" starttimestamp="1576666505112" timestamp="344111154">
    <text><![CDATA[p]]></text>
  </DocumentChange>
  <DocumentChange __id="38093" _type="Insert" date="Sun Dec 22 05:30:16 EST 2019" docASTNodeCount="230" docActiveCodeLength="1707" docExpressionCount="114" docLength="1989" length="1" offset="718" starttimestamp="1576666505112" timestamp="344111338">
    <text><![CDATA[e]]></text>
  </DocumentChange>
  <DocumentChange __id="38096" _type="Insert" date="Sun Dec 22 05:30:16 EST 2019" docASTNodeCount="230" docActiveCodeLength="1708" docExpressionCount="114" docLength="1990" length="1" offset="719" starttimestamp="1576666505112" timestamp="344111554">
    <text><![CDATA[r]]></text>
  </DocumentChange>
  <DocumentChange __id="38099" _type="Insert" date="Sun Dec 22 05:30:16 EST 2019" docASTNodeCount="230" docActiveCodeLength="1709" docExpressionCount="114" docLength="1991" length="1" offset="720" starttimestamp="1576666505112" timestamp="344111638">
    <text><![CDATA[a]]></text>
  </DocumentChange>
  <DocumentChange __id="38102" _type="Insert" date="Sun Dec 22 05:30:17 EST 2019" docASTNodeCount="230" docActiveCodeLength="1710" docExpressionCount="114" docLength="1992" length="1" offset="721" starttimestamp="1576666505112" timestamp="344111914">
    <text><![CDATA[t]]></text>
  </DocumentChange>
  <DocumentChange __id="38105" _type="Insert" date="Sun Dec 22 05:30:17 EST 2019" docASTNodeCount="230" docActiveCodeLength="1711" docExpressionCount="114" docLength="1993" length="1" offset="722" starttimestamp="1576666505112" timestamp="344112408">
    <text><![CDATA[i]]></text>
  </DocumentChange>
  <DocumentChange __id="38108" _type="Insert" date="Sun Dec 22 05:30:17 EST 2019" docASTNodeCount="230" docActiveCodeLength="1712" docExpressionCount="114" docLength="1994" length="1" offset="723" starttimestamp="1576666505112" timestamp="344112592">
    <text><![CDATA[o]]></text>
  </DocumentChange>
  <DocumentChange __id="38111" _type="Insert" date="Sun Dec 22 05:30:18 EST 2019" docASTNodeCount="230" docActiveCodeLength="1713" docExpressionCount="114" docLength="1995" length="1" offset="724" starttimestamp="1576666505112" timestamp="344113130">
    <text><![CDATA[n]]></text>
  </DocumentChange>
  <DocumentChange __id="38114" _type="Insert" date="Sun Dec 22 05:30:19 EST 2019" docASTNodeCount="230" docActiveCodeLength="1714" docExpressionCount="114" docLength="1996" length="1" offset="725" starttimestamp="1576666505112" timestamp="344114035">
    <text><![CDATA[;]]></text>
  </DocumentChange>
  <Command __id="38158" _type="DiffBasedFileOpenCommand" date="Sun Dec 22 05:31:59 EST 2019" docASTNodeCount="53" docActiveCodeLength="436" docExpressionCount="26" docLength="494" projectName="GraderBasics" starttimestamp="1576666505112" timestamp="344214381">
    <filePath><![CDATA[D:\dewan_backup\Java\GraderBasics\src\gradingTools\shared\testcases\openmp\OpenMPPragma.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package gradingTools.shared.testcases.openmp;¬∂¬∂import java.util.List;¬∂¬∂public interface OpenMPPragma {¬∂¬∂	List<String> getOpenMPTokens();¬∂¬∂	int getLineNumber();¬∂¬∂	List<String> getAnnotatedText();¬∂¬∂//	void setAnnotatedText(StringBuffer nextNonEmptyString);¬∂¬∂	int getAnnotatedTextStartLineNumber();¬∂¬∂	void setAnnotatedTextStartLineNumber(int annotatedLineNumber);¬∂¬∂	int getAnnotatedTextEndLineNumber();¬∂¬∂	void setAnnotatedTextEndLineNumber(int annotatedTextEndLineNumber);¬∂¬∂}")]]]></diff>
  </Command>
  <Command __id="38159" _type="SelectTextCommand" caretOffset="123" date="Sun Dec 22 05:31:59 EST 2019" end="123" start="111" starttimestamp="1576666505112" timestamp="344214470" />
  <DocumentChange __id="39817" _type="Insert" date="Sun Dec 22 11:34:19 EST 2019" docASTNodeCount="693" docActiveCodeLength="4592" docExpressionCount="428" docLength="5202" length="1" offset="4512" starttimestamp="1576666505112" timestamp="365954033">
    <text><![CDATA[a]]></text>
  </DocumentChange>
  <DocumentChange __id="39819" _type="Insert" date="Sun Dec 22 11:34:19 EST 2019" docASTNodeCount="693" docActiveCodeLength="4593" docExpressionCount="428" docLength="5203" length="1" offset="4513" starttimestamp="1576666505112" timestamp="365954687">
    <text><![CDATA[V]]></text>
  </DocumentChange>
  <DocumentChange __id="39821" _type="Insert" date="Sun Dec 22 11:34:19 EST 2019" docASTNodeCount="693" docActiveCodeLength="4594" docExpressionCount="428" docLength="5204" length="1" offset="4514" starttimestamp="1576666505112" timestamp="365954875">
    <text><![CDATA[a]]></text>
  </DocumentChange>
  <DocumentChange __id="39823" _type="Insert" date="Sun Dec 22 11:34:20 EST 2019" docASTNodeCount="693" docActiveCodeLength="4595" docExpressionCount="428" docLength="5205" length="1" offset="4515" starttimestamp="1576666505112" timestamp="365955144">
    <text><![CDATA[r]]></text>
  </DocumentChange>
  <DocumentChange __id="39825" _type="Insert" date="Sun Dec 22 11:34:20 EST 2019" docASTNodeCount="693" docActiveCodeLength="4596" docExpressionCount="428" docLength="5206" length="1" offset="4516" starttimestamp="1576666505112" timestamp="365955271">
    <text><![CDATA[i]]></text>
  </DocumentChange>
  <DocumentChange __id="39827" _type="Insert" date="Sun Dec 22 11:34:20 EST 2019" docASTNodeCount="693" docActiveCodeLength="4597" docExpressionCount="428" docLength="5207" length="1" offset="4517" starttimestamp="1576666505112" timestamp="365955404">
    <text><![CDATA[a]]></text>
  </DocumentChange>
  <DocumentChange __id="39829" _type="Insert" date="Sun Dec 22 11:34:20 EST 2019" docASTNodeCount="693" docActiveCodeLength="4598" docExpressionCount="428" docLength="5208" length="1" offset="4518" starttimestamp="1576666505112" timestamp="365955562">
    <text><![CDATA[b]]></text>
  </DocumentChange>
  <DocumentChange __id="39831" _type="Insert" date="Sun Dec 22 11:34:20 EST 2019" docASTNodeCount="693" docActiveCodeLength="4599" docExpressionCount="428" docLength="5209" length="1" offset="4519" starttimestamp="1576666505112" timestamp="365955841">
    <text><![CDATA[l]]></text>
  </DocumentChange>
  <DocumentChange __id="39833" _type="Insert" date="Sun Dec 22 11:34:21 EST 2019" docASTNodeCount="693" docActiveCodeLength="4600" docExpressionCount="428" docLength="5210" length="1" offset="4520" starttimestamp="1576666505112" timestamp="365955918">
    <text><![CDATA[e]]></text>
  </DocumentChange>
  <Command __id="39900" _type="EclipseCommand" commandID="org.eclipse.debug.ui.commands.Resume" date="Sun Dec 22 11:34:47 EST 2019" starttimestamp="1576666505112" timestamp="365982102" />
  <Command __id="39901" _type="RunCommand" date="Sun Dec 22 11:34:47 EST 2019" kind="StepInto" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="365982102" type="Run" />
  <Command __id="39902" _type="EHExceptionCommand" date="Sun Dec 22 11:34:47 EST 2019" starttimestamp="1576666505112" timestamp="365982247" type="Exception">
    <outputString><![CDATA[file name:sum_parallel_for_reduction.cp
pragmas:[15:[parallel, for, reduction(+:sum)]--> (16,19):[for (int i = 0; i < size; i++) {, sum += array[i];, recordThreadIndex(i);, }]]
file name:sum_parallel_for_local_var.cp
pragmas:[20:[parallel]--> (21,32):[{, double local_sum = 0;, #pragma omp for, for(int i = 0; i < size; i++) {, local_sum += array[i];, recordThreadIndex(i);, }, #pragma omp critical, sum += local_sum;, }], 24:[for]--> (25,28):[for(int i = 0; i < size; i++) {, local_sum += array[i];, recordThreadIndex(i);, }], 30:[critical]--> (31,31):[sum += local_sum;]]
file name:sum_main.cp
pragmas:[]
file name:sum_sequential.cp
pragmas:[]
file name:sum_parallel.cp
pragmas:[18:[parallel]--> (19,36):[{, double local_sum = 0;, int rank = omp_get_thread_num();, int threads = omp_get_num_threads();, int start_index = (size/threads)*rank;, int end_index = (size/threads)*(rank+1);, if(rank==threads-1), end_index=size;, for(int i = start_index; i < end_index; i++), local_sum += array[i];, #pragma omp critical, sum += local_sum;, }], 34:[critical]--> (35,35):[sum += local_sum;]]
I***(TestCaseResult) ### anonymous: 1.0
]]></outputString>
  </Command>
  <Command __id="39905" _type="DiffBasedFileOpenCommand" date="Sun Dec 22 11:37:42 EST 2019" docASTNodeCount="1" docActiveCodeLength="482" docExpressionCount="0" docLength="482" projectName="OpenMPTraining" starttimestamp="1576666505112" timestamp="366157549">
    <filePath><![CDATA[D:\dewan_backup\C\OpenMPTraining\OpenMPTrainingC++\src\sum_parallel_for_local_var.cpp]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"#include <iostream>¬∂#include <omp.h>¬∂¬∂using namespace std;¬∂¬∂void printSumWithTimes (int sum, int start, int end);¬∂void printNumThreads();¬∂void recordThreadIndex(int index);¬∂void sum_parallel_for_local_var(double* array, int size)¬∂{¬∂	cout << "sum_parallel_for_local_var\n";¬∂¬∂	double start = omp_get_wtime();¬∂¬∂	double sum = 0;¬∂¬∂	for (int i = 0; i < size; i++) {¬∂			sum += array[i];¬∂			recordThreadIndex(i);¬∂	}¬∂¬∂	double end = omp_get_wtime();¬∂¬∂	printSumWithTimes(sum, start, end);¬∂	¬∂}¬∂")]]]></diff>
  </Command>
  <Command __id="39906" _type="MoveCaretCommand" caretOffset="0" date="Sun Dec 22 11:37:42 EST 2019" docOffset="0" starttimestamp="1576666505112" timestamp="366157690" />
  <Command __id="39908" _type="MoveCaretCommand" caretOffset="0" date="Sun Dec 22 11:38:07 EST 2019" docOffset="0" starttimestamp="1576666505112" timestamp="366182444" />
  <Command __id="39907" _type="DiffBasedFileOpenCommand" date="Sun Dec 22 11:38:07 EST 2019" docASTNodeCount="1" docActiveCodeLength="611" docExpressionCount="0" docLength="699" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="366182266">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\sum_parallel_for_local_var.cpp]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"#include <iostream>¬∂#include <omp.h>¬∂¬∂using namespace std;¬∂¬∂void printSumWithTimes (int sum, int start, int end);¬∂void printNumThreads();¬∂void recordThreadIndex(int index);¬∂void sum_parallel_for_local_var(double* array, int size)¬∂{¬∂	cout << "sum_parallel_for_local_var\n";¬∂¬∂	double start = omp_get_wtime();¬∂¬∂	double sum = 0;¬∂//¬∂//	for (int i = 0; i < size; i++) {¬∂//			sum += array[i];¬∂//			recordThreadIndex(i);¬∂//	}¬∂    #pragma omp parallel¬∂	{¬∂		double local_sum = 0;¬∂¬∂		#pragma omp for¬∂		for(int i = 0; i < size; i++) {¬∂			local_sum += array[i];¬∂			recordThreadIndex(i);¬∂		}¬∂¬∂		#pragma omp critical¬∂		sum += local_sum;¬∂	}¬∂¬∂	double end = omp_get_wtime();¬∂¬∂	printSumWithTimes(sum, start, end);¬∂	¬∂}¬∂")]]]></diff>
  </Command>
  <Command __id="39909" _type="MoveCaretCommand" caretOffset="488" date="Sun Dec 22 11:38:13 EST 2019" docOffset="488" starttimestamp="1576666505112" timestamp="366188477" />
  <DocumentChange __id="39910" _type="Insert" date="Sun Dec 22 11:38:18 EST 2019" docASTNodeCount="1" docActiveCodeLength="612" docExpressionCount="0" docLength="700" length="1" offset="488" starttimestamp="1576666505112" timestamp="366193761">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <Command __id="39911" _type="InsertStringCommand" date="Sun Dec 22 11:38:18 EST 2019" starttimestamp="1576666505112" timestamp="366193763" timestamp2="366193763">
    <data><![CDATA[ ]]></data>
  </Command>
  <DocumentChange __id="39912" _type="Insert" date="Sun Dec 22 11:38:19 EST 2019" docASTNodeCount="1" docActiveCodeLength="613" docExpressionCount="0" docLength="701" length="1" offset="489" starttimestamp="1576666505112" timestamp="366194076">
    <text><![CDATA[r]]></text>
  </DocumentChange>
  <Command __id="39913" _type="InsertStringCommand" date="Sun Dec 22 11:38:19 EST 2019" starttimestamp="1576666505112" timestamp="366194083" timestamp2="366194083">
    <data><![CDATA[r]]></data>
  </Command>
  <DocumentChange __id="39914" _type="Insert" date="Sun Dec 22 11:38:19 EST 2019" docASTNodeCount="1" docActiveCodeLength="614" docExpressionCount="0" docLength="702" length="1" offset="490" starttimestamp="1576666505112" timestamp="366194299">
    <text><![CDATA[e]]></text>
  </DocumentChange>
  <Command __id="39915" _type="InsertStringCommand" date="Sun Dec 22 11:38:19 EST 2019" starttimestamp="1576666505112" timestamp="366194302" timestamp2="366194302">
    <data><![CDATA[e]]></data>
  </Command>
  <DocumentChange __id="39916" _type="Insert" date="Sun Dec 22 11:38:19 EST 2019" docASTNodeCount="1" docActiveCodeLength="615" docExpressionCount="0" docLength="703" length="1" offset="491" starttimestamp="1576666505112" timestamp="366194565">
    <text><![CDATA[d]]></text>
  </DocumentChange>
  <Command __id="39917" _type="InsertStringCommand" date="Sun Dec 22 11:38:19 EST 2019" starttimestamp="1576666505112" timestamp="366194565" timestamp2="366194565">
    <data><![CDATA[d]]></data>
  </Command>
  <DocumentChange __id="39918" _type="Insert" date="Sun Dec 22 11:38:19 EST 2019" docASTNodeCount="1" docActiveCodeLength="616" docExpressionCount="0" docLength="704" length="1" offset="492" starttimestamp="1576666505112" timestamp="366194795">
    <text><![CDATA[u]]></text>
  </DocumentChange>
  <Command __id="39919" _type="InsertStringCommand" date="Sun Dec 22 11:38:19 EST 2019" starttimestamp="1576666505112" timestamp="366194811" timestamp2="366194811">
    <data><![CDATA[u]]></data>
  </Command>
  <DocumentChange __id="39920" _type="Insert" date="Sun Dec 22 11:38:20 EST 2019" docASTNodeCount="1" docActiveCodeLength="617" docExpressionCount="0" docLength="705" length="1" offset="493" starttimestamp="1576666505112" timestamp="366194951">
    <text><![CDATA[c]]></text>
  </DocumentChange>
  <Command __id="39921" _type="InsertStringCommand" date="Sun Dec 22 11:38:20 EST 2019" starttimestamp="1576666505112" timestamp="366194967" timestamp2="366194967">
    <data><![CDATA[c]]></data>
  </Command>
  <DocumentChange __id="39922" _type="Insert" date="Sun Dec 22 11:38:20 EST 2019" docASTNodeCount="1" docActiveCodeLength="618" docExpressionCount="0" docLength="706" length="1" offset="494" starttimestamp="1576666505112" timestamp="366195282">
    <text><![CDATA[t]]></text>
  </DocumentChange>
  <Command __id="39923" _type="InsertStringCommand" date="Sun Dec 22 11:38:20 EST 2019" starttimestamp="1576666505112" timestamp="366195297" timestamp2="366195297">
    <data><![CDATA[t]]></data>
  </Command>
  <DocumentChange __id="39924" _type="Insert" date="Sun Dec 22 11:38:20 EST 2019" docASTNodeCount="1" docActiveCodeLength="619" docExpressionCount="0" docLength="707" length="1" offset="495" starttimestamp="1576666505112" timestamp="366195498">
    <text><![CDATA[i]]></text>
  </DocumentChange>
  <Command __id="39925" _type="InsertStringCommand" date="Sun Dec 22 11:38:20 EST 2019" starttimestamp="1576666505112" timestamp="366195507" timestamp2="366195507">
    <data><![CDATA[i]]></data>
  </Command>
  <DocumentChange __id="39926" _type="Insert" date="Sun Dec 22 11:38:20 EST 2019" docASTNodeCount="1" docActiveCodeLength="620" docExpressionCount="0" docLength="708" length="1" offset="496" starttimestamp="1576666505112" timestamp="366195674">
    <text><![CDATA[o]]></text>
  </DocumentChange>
  <Command __id="39927" _type="InsertStringCommand" date="Sun Dec 22 11:38:20 EST 2019" starttimestamp="1576666505112" timestamp="366195677" timestamp2="366195677">
    <data><![CDATA[o]]></data>
  </Command>
  <DocumentChange __id="39928" _type="Insert" date="Sun Dec 22 11:38:21 EST 2019" docASTNodeCount="1" docActiveCodeLength="621" docExpressionCount="0" docLength="709" length="1" offset="497" starttimestamp="1576666505112" timestamp="366195943">
    <text><![CDATA[n]]></text>
  </DocumentChange>
  <Command __id="39929" _type="InsertStringCommand" date="Sun Dec 22 11:38:21 EST 2019" starttimestamp="1576666505112" timestamp="366195945" timestamp2="366195945">
    <data><![CDATA[n]]></data>
  </Command>
  <DocumentChange __id="39930" _type="Insert" date="Sun Dec 22 11:38:21 EST 2019" docASTNodeCount="1" docActiveCodeLength="622" docExpressionCount="0" docLength="710" length="1" offset="498" starttimestamp="1576666505112" timestamp="366196524">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <Command __id="39931" _type="InsertStringCommand" date="Sun Dec 22 11:38:21 EST 2019" starttimestamp="1576666505112" timestamp="366196524" timestamp2="366196524">
    <data><![CDATA[ ]]></data>
  </Command>
  <DocumentChange __id="39932" _type="Insert" date="Sun Dec 22 11:38:22 EST 2019" docASTNodeCount="1" docActiveCodeLength="624" docExpressionCount="0" docLength="712" length="2" offset="499" starttimestamp="1576666505112" timestamp="366197699">
    <text><![CDATA[()]]></text>
  </DocumentChange>
  <Command __id="39933" _type="InsertStringCommand" date="Sun Dec 22 11:38:22 EST 2019" starttimestamp="1576666505112" timestamp="366197715" timestamp2="366197715">
    <data><![CDATA[(]]></data>
  </Command>
  <DocumentChange __id="39934" _type="Insert" date="Sun Dec 22 11:38:25 EST 2019" docASTNodeCount="1" docActiveCodeLength="625" docExpressionCount="0" docLength="713" length="1" offset="500" starttimestamp="1576666505112" timestamp="366200814">
    <text><![CDATA[+]]></text>
  </DocumentChange>
  <Command __id="39935" _type="InsertStringCommand" date="Sun Dec 22 11:38:25 EST 2019" starttimestamp="1576666505112" timestamp="366200814" timestamp2="366200814">
    <data><![CDATA[+]]></data>
  </Command>
  <DocumentChange __id="39936" _type="Insert" date="Sun Dec 22 11:38:29 EST 2019" docASTNodeCount="1" docActiveCodeLength="626" docExpressionCount="0" docLength="714" length="1" offset="501" starttimestamp="1576666505112" timestamp="366204038">
    <text><![CDATA[:]]></text>
  </DocumentChange>
  <Command __id="39937" _type="InsertStringCommand" date="Sun Dec 22 11:38:29 EST 2019" starttimestamp="1576666505112" timestamp="366204041" timestamp2="366204041">
    <data><![CDATA[:]]></data>
  </Command>
  <DocumentChange __id="39938" _type="Delete" date="Sun Dec 22 11:38:32 EST 2019" docASTNodeCount="1" docActiveCodeLength="624" docExpressionCount="0" docLength="712" endLine="24" length="2" offset="500" startLine="24" starttimestamp="1576666505112" timestamp="366207298">
    <text><![CDATA[+:]]></text>
  </DocumentChange>
  <Command __id="39939" _type="UndoCommand" date="Sun Dec 22 11:38:32 EST 2019" starttimestamp="1576666505112" timestamp="366207313" />
  <DocumentChange __id="39940" _type="Delete" date="Sun Dec 22 11:38:32 EST 2019" docASTNodeCount="1" docActiveCodeLength="622" docExpressionCount="0" docLength="710" endLine="24" length="2" offset="499" startLine="24" starttimestamp="1576666505112" timestamp="366207751">
    <text><![CDATA[()]]></text>
  </DocumentChange>
  <Command __id="39941" _type="UndoCommand" date="Sun Dec 22 11:38:32 EST 2019" starttimestamp="1576666505112" timestamp="366207847" />
  <Command __id="39943" _type="UndoCommand" date="Sun Dec 22 11:38:33 EST 2019" starttimestamp="1576666505112" timestamp="366208150" />
  <Command __id="39945" _type="RunCommand" date="Sun Dec 22 11:41:41 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="366396829" type="Debug" />
  <Command __id="39946" _type="RunCommand" date="Sun Dec 22 11:41:41 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="366396830" type="Debug" />
  <Command __id="39947" _type="RunCommand" date="Sun Dec 22 11:41:41 EST 2019" kind="HitBreakPoint" projectName="PL_Java" starttimestamp="1576666505112" timestamp="366396830" type="Run" />
  <DocumentChange __id="42550" _type="Insert" date="Sun Dec 22 22:35:54 EST 2019" docASTNodeCount="758" docActiveCodeLength="5250" docExpressionCount="472" docLength="5886" length="18" offset="2722" starttimestamp="1576666505112" timestamp="405649808">
    <text><![CDATA[
							
						}]]></text>
  </DocumentChange>
  <DocumentChange __id="42555" _type="Replace" date="Sun Dec 22 22:36:05 EST 2019" docASTNodeCount="765" docActiveCodeLength="5316" docExpressionCount="478" docLength="5952" endLine="71" insertionLength="73" int_docASTNodeCount="758" int_docActiveCodeLength="5243" int_docExpressionCount="472" int_docLength="5879" length="7" offset="2724" startLine="71" starttimestamp="1576666505112" timestamp="405660469">
    <deletedText><![CDATA[							]]></deletedText>
    <insertedText><![CDATA[							lastOpenMPPragma.getReductionVariableAssignments().add(aFileLine);]]></insertedText>
  </DocumentChange>
  <DocumentChange __id="42558" _type="Replace" date="Sun Dec 22 22:36:12 EST 2019" docASTNodeCount="765" docActiveCodeLength="5298" docExpressionCount="478" docLength="5934" endLine="71" insertionLength="1" int_docASTNodeCount="765" int_docActiveCodeLength="5297" int_docExpressionCount="478" int_docLength="5933" length="19" offset="2760" startLine="71" starttimestamp="1576666505112" timestamp="405667503">
    <deletedText><![CDATA[VariableAssignments]]></deletedText>
    <insertedText><![CDATA[O]]></insertedText>
  </DocumentChange>
  <DocumentChange __id="42560" _type="Insert" date="Sun Dec 22 22:36:12 EST 2019" docASTNodeCount="765" docActiveCodeLength="5299" docExpressionCount="478" docLength="5935" length="1" offset="2761" starttimestamp="1576666505112" timestamp="405667693">
    <text><![CDATA[p]]></text>
  </DocumentChange>
  <DocumentChange __id="42562" _type="Insert" date="Sun Dec 22 22:36:12 EST 2019" docASTNodeCount="765" docActiveCodeLength="5300" docExpressionCount="478" docLength="5936" length="1" offset="2762" starttimestamp="1576666505112" timestamp="405667812">
    <text><![CDATA[e]]></text>
  </DocumentChange>
  <DocumentChange __id="42564" _type="Insert" date="Sun Dec 22 22:36:13 EST 2019" docASTNodeCount="765" docActiveCodeLength="5301" docExpressionCount="478" docLength="5937" length="1" offset="2763" starttimestamp="1576666505112" timestamp="405668076">
    <text><![CDATA[r]]></text>
  </DocumentChange>
  <DocumentChange __id="42566" _type="Insert" date="Sun Dec 22 22:36:13 EST 2019" docASTNodeCount="765" docActiveCodeLength="5302" docExpressionCount="478" docLength="5938" length="1" offset="2764" starttimestamp="1576666505112" timestamp="405668193">
    <text><![CDATA[a]]></text>
  </DocumentChange>
  <DocumentChange __id="42568" _type="Insert" date="Sun Dec 22 22:36:13 EST 2019" docASTNodeCount="765" docActiveCodeLength="5303" docExpressionCount="478" docLength="5939" length="1" offset="2765" starttimestamp="1576666505112" timestamp="405668484">
    <text><![CDATA[t]]></text>
  </DocumentChange>
  <DocumentChange __id="42570" _type="Insert" date="Sun Dec 22 22:36:13 EST 2019" docASTNodeCount="765" docActiveCodeLength="5304" docExpressionCount="478" docLength="5940" length="1" offset="2766" starttimestamp="1576666505112" timestamp="405668673">
    <text><![CDATA[i]]></text>
  </DocumentChange>
  <DocumentChange __id="42572" _type="Insert" date="Sun Dec 22 22:36:14 EST 2019" docASTNodeCount="765" docActiveCodeLength="5305" docExpressionCount="478" docLength="5941" length="1" offset="2767" starttimestamp="1576666505112" timestamp="405669305">
    <text><![CDATA[o]]></text>
  </DocumentChange>
  <DocumentChange __id="42574" _type="Insert" date="Sun Dec 22 22:36:14 EST 2019" docASTNodeCount="765" docActiveCodeLength="5306" docExpressionCount="478" docLength="5942" length="1" offset="2768" starttimestamp="1576666505112" timestamp="405669606">
    <text><![CDATA[n]]></text>
  </DocumentChange>
  <DocumentChange __id="42581" _type="Replace" date="Sun Dec 22 22:36:18 EST 2019" docASTNodeCount="767" docActiveCodeLength="5312" docExpressionCount="480" docLength="5948" endLine="71" insertionLength="27" int_docASTNodeCount="765" int_docActiveCodeLength="5285" int_docExpressionCount="478" int_docLength="5921" length="21" offset="2748" startLine="71" starttimestamp="1576666505112" timestamp="405673874">
    <deletedText><![CDATA[getReductionOperation]]></deletedText>
    <insertedText><![CDATA[getReductionOperationUses()]]></insertedText>
  </DocumentChange>
  <DocumentChange __id="42584" _type="Delete" date="Sun Dec 22 22:36:21 EST 2019" docASTNodeCount="765" docActiveCodeLength="5311" docExpressionCount="478" docLength="5947" endLine="71" length="1" offset="2776" startLine="71" starttimestamp="1576666505112" timestamp="405676488">
    <text><![CDATA[)]]></text>
  </DocumentChange>
  <DocumentChange __id="42586" _type="Delete" date="Sun Dec 22 22:36:21 EST 2019" docASTNodeCount="765" docActiveCodeLength="5310" docExpressionCount="478" docLength="5946" endLine="71" length="1" offset="2775" startLine="71" starttimestamp="1576666505112" timestamp="405676658">
    <text><![CDATA[(]]></text>
  </DocumentChange>
  <DocumentChange __id="42588" _type="Delete" date="Sun Dec 22 22:36:21 EST 2019" docASTNodeCount="765" docActiveCodeLength="5309" docExpressionCount="478" docLength="5945" endLine="71" length="1" offset="2774" startLine="71" starttimestamp="1576666505112" timestamp="405676865">
    <text><![CDATA[)]]></text>
  </DocumentChange>
  <DocumentChange __id="42590" _type="Insert" date="Sun Dec 22 22:36:22 EST 2019" docASTNodeCount="765" docActiveCodeLength="5310" docExpressionCount="478" docLength="5946" length="1" offset="2774" starttimestamp="1576666505112" timestamp="405677839">
    <text><![CDATA[)]]></text>
  </DocumentChange>
  <DocumentChange __id="42628" _type="Delete" date="Sun Dec 22 22:36:28 EST 2019" docASTNodeCount="765" docActiveCodeLength="5308" docExpressionCount="478" docLength="5944" endLine="75" length="2" offset="2815" startLine="74" starttimestamp="1576666505112" timestamp="405683290">
    <text><![CDATA[
]]></text>
  </DocumentChange>
  <DocumentChange __id="42747" _type="Insert" date="Sun Dec 22 22:57:16 EST 2019" docASTNodeCount="765" docActiveCodeLength="5311" docExpressionCount="478" docLength="5947" length="3" offset="207" starttimestamp="1576666505112" timestamp="406931156">
    <text><![CDATA[
	]]></text>
  </DocumentChange>
  <Command __id="42750" _type="ShellCommand" date="Sun Dec 22 22:57:23 EST 2019" starttimestamp="1576666505112" timestamp="406938434" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="42751" _type="MoveCaretCommand" caretOffset="255" date="Sun Dec 22 22:57:23 EST 2019" docOffset="255" starttimestamp="1576666505112" timestamp="406938534" />
  <Command __id="42752" _type="DiffBasedFileOpenCommand" date="Sun Dec 22 22:57:38 EST 2019" docASTNodeCount="1" docActiveCodeLength="749" docExpressionCount="0" docLength="825" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="406953475">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\sum_parallel.cpp]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"#include <iostream>¬∂#include <omp.h>¬∂¬∂using namespace std;¬∂¬∂void printSumWithTimes(int sum, int start, int end);¬∂void printNumThreads();¬∂void recordThreadIndex(int index);¬∂void sum_parallel(double* array, int size) {¬∂	cout << "sum_parallel\n";¬∂¬∂	double start = omp_get_wtime();¬∂¬∂	double sum = 0;¬∂¬∂//	#pragma omp parallel¬∂//	for (int i = 0; i < size; i++)¬∂//		sum += array[i];¬∂    #pragma omp parallel¬∂	{¬∂		double local_sum = 0;¬∂¬∂		int rank = omp_get_thread_num();¬∂		int threads = omp_get_num_threads();¬∂¬∂		int start_index = (size/threads)*rank;¬∂		int end_index = (size/threads)*(rank+1);¬∂¬∂		if(rank==threads-1)¬∂			end_index=size;¬∂¬∂		for(int i = start_index; i < end_index; i++)¬∂			local_sum += array[i];¬∂¬∂		#pragma omp critical¬∂		sum += local_sum;¬∂	}¬∂¬∂	double end = omp_get_wtime();¬∂¬∂	printSumWithTimes(sum, start, end);¬∂¬∂¬∂}¬∂")]]]></diff>
  </Command>
  <Command __id="42753" _type="MoveCaretCommand" caretOffset="0" date="Sun Dec 22 22:57:38 EST 2019" docOffset="0" starttimestamp="1576666505112" timestamp="406953675" />
  <DocumentChange __id="43223" _type="Insert" date="Sun Dec 22 23:10:15 EST 2019" docASTNodeCount="349" docActiveCodeLength="2568" docExpressionCount="171" docLength="2850" length="1" offset="389" starttimestamp="1576666505112" timestamp="407710794">
    <text><![CDATA[c]]></text>
  </DocumentChange>
  <Command __id="55575" _type="DiffBasedFileOpenCommand" date="Mon Dec 23 06:31:07 EST 2019" docASTNodeCount="89" docActiveCodeLength="709" docExpressionCount="51" docLength="786" projectName="GraderBasics" starttimestamp="1576666505112" timestamp="434161994">
    <filePath><![CDATA[D:\dewan_backup\Java\GraderBasics\src\gradingTools\shared\testcases\openmp\AnOpenMPParallelPragma.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package gradingTools.shared.testcases.openmp;¬∂¬∂import java.util.ArrayList;¬∂import java.util.List;¬∂¬∂public class AnOpenMPParallelPragma extends AnOpenMPPragma implements OpenMPParallelPragma{¬∂	protected List<String> variableDeclarationsInParallel = new ArrayList();//separate subclass for this variable?¬∂¬∂	public AnOpenMPParallelPragma(int lineNumber) {¬∂		super(lineNumber);¬∂		// TODO Auto-generated constructor stub¬∂	}¬∂	@Override¬∂	public void addToAnnotatedText(String aFileLine) {¬∂		super.addToAnnotatedText(aFileLine);¬∂		¬∂		if (OpenMPUtils.startsWithTypeName(aFileLine)) {¬∂				getVariableDeclarationsInParallel().add(aFileLine);¬∂		}¬∂		 ¬∂	}¬∂	@Override¬∂	public List<String> getVariableDeclarationsInParallel() {¬∂		return variableDeclarationsInParallel;¬∂	}¬∂¬∂}¬∂")]]]></diff>
  </Command>
  <Command __id="55576" _type="MoveCaretCommand" caretOffset="592" date="Mon Dec 23 06:31:07 EST 2019" docOffset="592" starttimestamp="1576666505112" timestamp="434162169" />
  <Command __id="55578" _type="MoveCaretCommand" caretOffset="488" date="Mon Dec 23 06:32:28 EST 2019" docOffset="488" starttimestamp="1576666505112" timestamp="434243213" />
  <Command __id="55579" _type="ShellCommand" date="Mon Dec 23 06:32:50 EST 2019" starttimestamp="1576666505112" timestamp="434264942" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="55577" _type="DiffBasedFileOpenCommand" date="Mon Dec 23 06:32:28 EST 2019" docASTNodeCount="1" docActiveCodeLength="611" docExpressionCount="0" docLength="699" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="434243048">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\sum_parallel_for_local_var.cpp]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"#include <iostream>¬∂#include <omp.h>¬∂¬∂using namespace std;¬∂¬∂void printSumWithTimes (int sum, int start, int end);¬∂void printNumThreads();¬∂void recordThreadIndex(int index);¬∂void sum_parallel_for_local_var(double* array, int size)¬∂{¬∂	cout << "sum_parallel_for_local_var\n";¬∂¬∂	double start = omp_get_wtime();¬∂¬∂	double sum = 0;¬∂//¬∂//	for (int i = 0; i < size; i++) {¬∂//			sum += array[i];¬∂//			recordThreadIndex(i);¬∂//	}¬∂    #pragma omp parallel¬∂	{¬∂		double local_sum = 0;¬∂¬∂		#pragma omp for¬∂		for(int i = 0; i < size; i++) {¬∂			local_sum += array[i];¬∂			recordThreadIndex(i);¬∂		}¬∂¬∂		#pragma omp critical¬∂		sum += local_sum;¬∂	}¬∂¬∂	double end = omp_get_wtime();¬∂¬∂	printSumWithTimes(sum, start, end);¬∂	¬∂}¬∂")]]]></diff>
  </Command>
  <Command __id="55580" _type="ShellCommand" date="Mon Dec 23 06:45:42 EST 2019" starttimestamp="1576666505112" timestamp="435037280" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="55581" _type="DiffBasedFileOpenCommand" date="Mon Dec 23 06:46:51 EST 2019" docASTNodeCount="1" docActiveCodeLength="749" docExpressionCount="0" docLength="825" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="435106649">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\sum_parallel.cpp]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"#include <iostream>¬∂#include <omp.h>¬∂¬∂using namespace std;¬∂¬∂void printSumWithTimes(int sum, int start, int end);¬∂void printNumThreads();¬∂void recordThreadIndex(int index);¬∂void sum_parallel(double* array, int size) {¬∂	cout << "sum_parallel\n";¬∂¬∂	double start = omp_get_wtime();¬∂¬∂	double sum = 0;¬∂¬∂//	#pragma omp parallel¬∂//	for (int i = 0; i < size; i++)¬∂//		sum += array[i];¬∂    #pragma omp parallel¬∂	{¬∂		double local_sum = 0;¬∂¬∂		int rank = omp_get_thread_num();¬∂		int threads = omp_get_num_threads();¬∂¬∂		int start_index = (size/threads)*rank;¬∂		int end_index = (size/threads)*(rank+1);¬∂¬∂		if(rank==threads-1)¬∂			end_index=size;¬∂¬∂		for(int i = start_index; i < end_index; i++)¬∂			local_sum += array[i];¬∂¬∂		#pragma omp critical¬∂		sum += local_sum;¬∂	}¬∂¬∂	double end = omp_get_wtime();¬∂¬∂	printSumWithTimes(sum, start, end);¬∂¬∂¬∂}¬∂")]]]></diff>
  </Command>
  <Command __id="55582" _type="MoveCaretCommand" caretOffset="0" date="Mon Dec 23 06:46:51 EST 2019" docOffset="0" starttimestamp="1576666505112" timestamp="435106801" />
  <Command __id="55583" _type="DiffBasedFileOpenCommand" date="Mon Dec 23 06:48:48 EST 2019" docASTNodeCount="1" docActiveCodeLength="611" docExpressionCount="0" docLength="699" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="435223184">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\sum_parallel_for_local_var.cpp]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"#include <iostream>¬∂#include <omp.h>¬∂¬∂using namespace std;¬∂¬∂void printSumWithTimes (int sum, int start, int end);¬∂void printNumThreads();¬∂void recordThreadIndex(int index);¬∂void sum_parallel_for_local_var(double* array, int size)¬∂{¬∂	cout << "sum_parallel_for_local_var\n";¬∂¬∂	double start = omp_get_wtime();¬∂¬∂	double sum = 0;¬∂//¬∂//	for (int i = 0; i < size; i++) {¬∂//			sum += array[i];¬∂//			recordThreadIndex(i);¬∂//	}¬∂    #pragma omp parallel¬∂	{¬∂		double local_sum = 0;¬∂¬∂		#pragma omp for¬∂		for(int i = 0; i < size; i++) {¬∂			local_sum += array[i];¬∂			recordThreadIndex(i);¬∂		}¬∂¬∂		#pragma omp critical¬∂		sum += local_sum;¬∂	}¬∂¬∂	double end = omp_get_wtime();¬∂¬∂	printSumWithTimes(sum, start, end);¬∂	¬∂}¬∂")]]]></diff>
  </Command>
  <Command __id="55584" _type="MoveCaretCommand" caretOffset="488" date="Mon Dec 23 06:48:48 EST 2019" docOffset="488" starttimestamp="1576666505112" timestamp="435223309" />
  <DocumentChange __id="56403" _type="Insert" date="Mon Dec 23 07:15:49 EST 2019" docASTNodeCount="992" docActiveCodeLength="6711" docExpressionCount="620" docLength="8593" length="2" offset="428" starttimestamp="1576666505112" timestamp="436844803">
    <text><![CDATA[""]]></text>
  </DocumentChange>
  <Command __id="56404" _type="InsertStringCommand" date="Mon Dec 23 07:15:49 EST 2019" starttimestamp="1576666505112" timestamp="436844807" timestamp2="436844807">
    <data><![CDATA["]]></data>
  </Command>
  <Command __id="56405" _type="InsertStringCommand" date="Mon Dec 23 07:15:49 EST 2019" starttimestamp="1576666505112" timestamp="436844808" timestamp2="436844808">
    <data><![CDATA["]]></data>
  </Command>
  <Command __id="56407" _type="MoveCaretCommand" caretOffset="0" date="Mon Dec 23 07:15:53 EST 2019" docOffset="0" starttimestamp="1576666505112" timestamp="436847910" />
  <Command __id="56408" _type="EclipseCommand" commandID="" date="Mon Dec 23 07:15:53 EST 2019" starttimestamp="1576666505112" timestamp="436848680" />
  <Command __id="56409" _type="EclipseCommand" commandID="" date="Mon Dec 23 07:15:54 EST 2019" starttimestamp="1576666505112" timestamp="436849222" />
  <DocumentChange __id="56443" _type="Insert" date="Mon Dec 23 07:16:48 EST 2019" docASTNodeCount="992" docActiveCodeLength="6738" docExpressionCount="620" docLength="8620" length="1" offset="455" starttimestamp="1576666505112" timestamp="436903160">
    <text><![CDATA[p]]></text>
  </DocumentChange>
  <Command __id="56444" _type="InsertStringCommand" date="Mon Dec 23 07:16:48 EST 2019" starttimestamp="1576666505112" timestamp="436903160" timestamp2="436903160">
    <data><![CDATA[p]]></data>
  </Command>
  <Command __id="56445" _type="InsertStringCommand" date="Mon Dec 23 07:16:48 EST 2019" starttimestamp="1576666505112" timestamp="436903160" timestamp2="436903160">
    <data><![CDATA[p]]></data>
  </Command>
  <Command __id="56447" _type="SelectTextCommand" caretOffset="460" date="Mon Dec 23 07:18:03 EST 2019" end="460" start="442" starttimestamp="1576666505112" timestamp="436978179" />
  <DocumentChange __id="58635" _type="Insert" date="Mon Dec 23 07:39:55 EST 2019" docASTNodeCount="1070" docActiveCodeLength="7213" docExpressionCount="660" docLength="9095" length="1" offset="1633" starttimestamp="1576666505112" timestamp="438290086">
    <text><![CDATA[S]]></text>
  </DocumentChange>
  <DocumentChange __id="58638" _type="Insert" date="Mon Dec 23 07:39:55 EST 2019" docASTNodeCount="1070" docActiveCodeLength="7214" docExpressionCount="660" docLength="9096" length="1" offset="1634" starttimestamp="1576666505112" timestamp="438290551">
    <text><![CDATA[t]]></text>
  </DocumentChange>
  <DocumentChange __id="58641" _type="Insert" date="Mon Dec 23 07:39:55 EST 2019" docASTNodeCount="1070" docActiveCodeLength="7215" docExpressionCount="660" docLength="9097" length="1" offset="1635" starttimestamp="1576666505112" timestamp="438290674">
    <text><![CDATA[r]]></text>
  </DocumentChange>
  <DocumentChange __id="58644" _type="Insert" date="Mon Dec 23 07:39:55 EST 2019" docASTNodeCount="1070" docActiveCodeLength="7216" docExpressionCount="660" docLength="9098" length="1" offset="1636" starttimestamp="1576666505112" timestamp="438290862">
    <text><![CDATA[i]]></text>
  </DocumentChange>
  <DocumentChange __id="58647" _type="Insert" date="Mon Dec 23 07:39:56 EST 2019" docASTNodeCount="1070" docActiveCodeLength="7217" docExpressionCount="660" docLength="9099" length="1" offset="1637" starttimestamp="1576666505112" timestamp="438291058">
    <text><![CDATA[n]]></text>
  </DocumentChange>
  <DocumentChange __id="58650" _type="Insert" date="Mon Dec 23 07:39:56 EST 2019" docASTNodeCount="1070" docActiveCodeLength="7218" docExpressionCount="660" docLength="9100" length="1" offset="1638" starttimestamp="1576666505112" timestamp="438291512">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="58653" _type="Insert" date="Mon Dec 23 07:39:56 EST 2019" docASTNodeCount="1074" docActiveCodeLength="7219" docExpressionCount="662" docLength="9101" length="1" offset="1639" starttimestamp="1576666505112" timestamp="438291669">
    <text><![CDATA[a]]></text>
  </DocumentChange>
  <DocumentChange __id="58656" _type="Insert" date="Mon Dec 23 07:39:57 EST 2019" docASTNodeCount="1074" docActiveCodeLength="7220" docExpressionCount="662" docLength="9102" length="1" offset="1640" starttimestamp="1576666505112" timestamp="438292386">
    <text><![CDATA[F]]></text>
  </DocumentChange>
  <DocumentChange __id="58659" _type="Insert" date="Mon Dec 23 07:39:57 EST 2019" docASTNodeCount="1074" docActiveCodeLength="7221" docExpressionCount="662" docLength="9103" length="1" offset="1641" starttimestamp="1576666505112" timestamp="438292765">
    <text><![CDATA[i]]></text>
  </DocumentChange>
  <DocumentChange __id="58662" _type="Insert" date="Mon Dec 23 07:39:58 EST 2019" docASTNodeCount="1074" docActiveCodeLength="7222" docExpressionCount="662" docLength="9104" length="1" offset="1642" starttimestamp="1576666505112" timestamp="438293002">
    <text><![CDATA[l]]></text>
  </DocumentChange>
  <DocumentChange __id="58665" _type="Insert" date="Mon Dec 23 07:39:58 EST 2019" docASTNodeCount="1074" docActiveCodeLength="7223" docExpressionCount="662" docLength="9105" length="1" offset="1643" starttimestamp="1576666505112" timestamp="438293081">
    <text><![CDATA[e]]></text>
  </DocumentChange>
  <DocumentChange __id="58668" _type="Insert" date="Mon Dec 23 07:39:58 EST 2019" docASTNodeCount="1074" docActiveCodeLength="7224" docExpressionCount="662" docLength="9106" length="1" offset="1644" starttimestamp="1576666505112" timestamp="438293568">
    <text><![CDATA[L]]></text>
  </DocumentChange>
  <DocumentChange __id="58671" _type="Insert" date="Mon Dec 23 07:39:58 EST 2019" docASTNodeCount="1074" docActiveCodeLength="7225" docExpressionCount="662" docLength="9107" length="1" offset="1645" starttimestamp="1576666505112" timestamp="438293814">
    <text><![CDATA[i]]></text>
  </DocumentChange>
  <DocumentChange __id="58674" _type="Insert" date="Mon Dec 23 07:39:59 EST 2019" docASTNodeCount="1074" docActiveCodeLength="7226" docExpressionCount="662" docLength="9108" length="1" offset="1646" starttimestamp="1576666505112" timestamp="438294113">
    <text><![CDATA[n]]></text>
  </DocumentChange>
  <DocumentChange __id="58677" _type="Insert" date="Mon Dec 23 07:39:59 EST 2019" docASTNodeCount="1074" docActiveCodeLength="7227" docExpressionCount="662" docLength="9109" length="1" offset="1647" starttimestamp="1576666505112" timestamp="438294221">
    <text><![CDATA[e]]></text>
  </DocumentChange>
  <DocumentChange __id="58682" _type="Insert" date="Mon Dec 23 07:40:01 EST 2019" docASTNodeCount="1074" docActiveCodeLength="7228" docExpressionCount="662" docLength="9110" length="1" offset="1638" starttimestamp="1576666505112" timestamp="438296632">
    <text><![CDATA[g]]></text>
  </DocumentChange>
  <DocumentChange __id="58687" _type="Insert" date="Mon Dec 23 07:40:03 EST 2019" docASTNodeCount="1074" docActiveCodeLength="7229" docExpressionCount="662" docLength="9111" length="1" offset="1650" starttimestamp="1576666505112" timestamp="438298106">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="58690" _type="Insert" date="Mon Dec 23 07:40:03 EST 2019" docASTNodeCount="1074" docActiveCodeLength="7230" docExpressionCount="662" docLength="9112" length="1" offset="1651" starttimestamp="1576666505112" timestamp="438298808">
    <text><![CDATA[{]]></text>
  </DocumentChange>
  <DocumentChange __id="58693" _type="Insert" date="Mon Dec 23 07:40:04 EST 2019" docASTNodeCount="1074" docActiveCodeLength="7238" docExpressionCount="662" docLength="9120" length="8" offset="1652" starttimestamp="1576666505112" timestamp="438299088">
    <text><![CDATA[
		
	}]]></text>
  </DocumentChange>
  <Command __id="58720" _type="EclipseCommand" commandID="" date="Mon Dec 23 07:40:05 EST 2019" starttimestamp="1576666505112" timestamp="438300672" />
  <Command __id="58721" _type="EclipseCommand" commandID="" date="Mon Dec 23 07:40:05 EST 2019" starttimestamp="1576666505112" timestamp="438300673" />
  <Command __id="58722" _type="EclipseCommand" commandID="" date="Mon Dec 23 07:40:05 EST 2019" starttimestamp="1576666505112" timestamp="438300682" />
  <Command __id="58723" _type="EclipseCommand" commandID="" date="Mon Dec 23 07:40:05 EST 2019" starttimestamp="1576666505112" timestamp="438300682" />
  <Command __id="58724" _type="EclipseCommand" commandID="" date="Mon Dec 23 07:40:05 EST 2019" starttimestamp="1576666505112" timestamp="438300684" />
  <Command __id="58725" _type="EclipseCommand" commandID="" date="Mon Dec 23 07:40:05 EST 2019" starttimestamp="1576666505112" timestamp="438300684" />
  <Command __id="58726" _type="EclipseCommand" commandID="" date="Mon Dec 23 07:40:05 EST 2019" starttimestamp="1576666505112" timestamp="438300698" />
  <Command __id="58727" _type="EclipseCommand" commandID="" date="Mon Dec 23 07:40:05 EST 2019" starttimestamp="1576666505112" timestamp="438300699" />
  <Command __id="58728" _type="EclipseCommand" commandID="" date="Mon Dec 23 07:40:05 EST 2019" starttimestamp="1576666505112" timestamp="438300704" />
  <Command __id="58729" _type="EclipseCommand" commandID="" date="Mon Dec 23 07:40:05 EST 2019" starttimestamp="1576666505112" timestamp="438300704" />
  <Command __id="58730" _type="EclipseCommand" commandID="" date="Mon Dec 23 07:40:05 EST 2019" starttimestamp="1576666505112" timestamp="438300710" />
  <Command __id="60355" _type="DiffBasedFileOpenCommand" date="Mon Dec 23 07:47:38 EST 2019" docASTNodeCount="1140" docActiveCodeLength="7664" docExpressionCount="708" docLength="9546" projectName="GraderBasics" starttimestamp="1576666505112" timestamp="438753416">
    <filePath><![CDATA[D:\dewan_backup\Java\GraderBasics\src\gradingTools\shared\testcases\openmp\OpenMPUtils.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package gradingTools.shared.testcases.openmp;¬∂¬∂import java.util.ArrayList;¬∂import java.util.HashMap;¬∂import java.util.List;¬∂import java.util.Map;¬∂import java.util.Stack;¬∂¬∂¬∂public class OpenMPUtils {¬∂	¬∂	protected static Map<String, OpenMPKeywordEnum> stringToOpenMPKeyword = new HashMap();¬∂	protected static String[] typeNames = {"double", "float", "int", "short", "long"};¬∂	protected static String[] openMPCalls = {"omp_get_thread_num()", "omp_get_num_threads()"};¬∂	public static List<OpenMPPragma> getOpemMPPragmas(StringBuffer aFileBuffer) {¬∂		String[] aFileLines = aFileBuffer.toString().split("\n");¬∂		return getOpenMPPragmas(aFileLines);¬∂	}¬∂	¬∂	public static boolean isCodeLine(String aLine) {¬∂		return !aLine.isEmpty() && !aLine.startsWith("//");¬∂	}¬∂	public static boolean isBlockStart(String aLine) {¬∂		return aLine.contains("{");¬∂	}¬∂	public static boolean isBlockEnd(String aLine) {¬∂		return aLine.contains("}");¬∂	}¬∂	public static boolean isLoopStart(String aLine) {¬∂		return aLine.startsWith("for");¬∂	}¬∂	public static boolean endsWithLoopHeader(String aLine) {¬∂		return aLine.endsWith(")");¬∂	}¬∂	public static boolean isPragmaStart(String aLine) {¬∂		return aLine.startsWith("#pragma");¬∂	}¬∂	public static void addToStack(Stack<OpenMPPragma> anOpenMPPragmas, String aFileLine) {¬∂		List<String> anOpenMPCalls = getOMPCalls(aFileLine);¬∂		for (OpenMPPragma anOpenMPPragma:anOpenMPPragmas) {¬∂			anOpenMPPragma.addToAnnotatedText(aFileLine);¬∂			for (String anOpenMPCall:anOpenMPCalls) {¬∂				anOpenMPPragma.addOpenMPCall(anOpenMPCall);¬∂			}		¬∂		}¬∂	}¬∂	public static "), Diff(INSERT,"A"), Diff(EQUAL,"ForHeader getForHeader(String aFileLine, int aLineNumber) {¬∂		int aLeftParenIndex = aFileLine.indexOf("(");¬∂		int aRightParenIndex = aFileLine.indexOf(")");¬∂		if (aLeftParenIndex < 0 || aRightParenIndex < 0) {¬∂			return null;¬∂		}¬∂		String aHeaderString = aFileLine.substring(aLeftParenIndex + 1, aRightParenIndex);¬∂		String[] aForComponents = aHeaderString.split(";");¬∂		return "), Diff(INSERT,"new A"), Diff(EQUAL,"ForHeader(aForComponents[0], aForComponents[1], aForComponents[2], aLineNumber);¬∂	}¬∂	public static List<String> getOMPCalls(String aFileLine) {¬∂		List<String> retVal = new ArrayList();¬∂		for (String anOpenMPCall:openMPCalls) {¬∂			if (aFileLine.contains(anOpenMPCall)) {¬∂				retVal.add(anOpenMPCall);¬∂			}¬∂		}¬∂		return retVal;¬∂	}¬∂	¬∂	public static void incrementStackTop (Stack<Integer> aNumOpenBracesStack) {¬∂		int aTopIndex = aNumOpenBracesStack.size() - 1;¬∂		Integer aCurrentValue = aNumOpenBracesStack.get(aTopIndex);¬∂		aNumOpenBracesStack.set(aTopIndex, aCurrentValue + 1);¬∂	}¬∂	public static void decrementStackTop (Stack<Integer> aNumOpenBracesStack) {¬∂		int aTopIndex = aNumOpenBracesStack.size() - 1;¬∂		Integer aCurrentValue = aNumOpenBracesStack.get(aTopIndex);¬∂		aNumOpenBracesStack.set(aTopIndex, aCurrentValue - 1);¬∂	}¬∂	¬∂	public static boolean startsWithTypeName(String aLine) {¬∂		for (String aTypeName:typeNames) {¬∂			if (aLine.startsWith(aTypeName)) {¬∂				return true;¬∂			}¬∂		}¬∂		return false;¬∂	}¬∂¬∂	public static List<OpenMPPragma> getOpenMPPragmas(String[] aFileLines) {¬∂		List<OpenMPPragma> retVal = new ArrayList();¬∂		Stack<OpenMPPragma> anOpenMPPragmas = new Stack();¬∂		Stack<Integer> aNumOpenBracesStack = new Stack();¬∂//		OpenMPPragma lastOpenMPPragma = null;¬∂//		String lastReductionVariable = null;¬∂//		String lastReductionOperation = null;¬∂//		int aNumOpenBraces = 0;¬∂		boolean aNextCodeLineIsAPragmaBlock = false;¬∂		List<OpenMPPragma> newOpenMPPragmas = null;¬∂		for (int i = 0; i < aFileLines.length; i++) {¬∂			String aFileLine = aFileLines[i].trim();¬∂			if (!isCodeLine(aFileLine)) {¬∂				continue;¬∂			}¬∂			addToStack(anOpenMPPragmas, aFileLine); // if it is empty add to none¬∂//			if (lastReductionVariable != null) {¬∂//				if (aFileLine.startsWith(lastReductionVariable)) {¬∂//					lastOpenMPPragma.getReductionVariableAssignments().add(aFileLine);¬∂//					if (lastReductionOperation != null) { // can it ever be not null¬∂//						if (aFileLine.contains(lastReductionOperation)) {¬∂//							lastOpenMPPragma.getReductionOperationUses().add(aFileLine);¬∂//						}¬∂//					}¬∂//				}			¬∂//			}¬∂//			if (lastOpenMPPragma != null && lastOpenMPPragma.getFirstOpenMPKeyword() == OpenMPKeywordEnum.PARALLEL) {¬∂//				if (startsWithTypeName(aFileLine)) {¬∂//					lastOpenMPPragma.getVariableDeclarationsInParallel().add(aFileLine);¬∂//				}¬∂//			} ¬∂//			else if (lastOpenMPPragma != null && lastOpenMPPragma.getFirstOpenMPKeyword() == OpenMPKeywordEnum.CRITICAL) {¬∂//				String[] aTokens = aFileLine.split("\\s+");¬∂//				lastOpenMPPragma.setAssignedVariableInCritical(aTokens[0]);				¬∂//			}¬∂			if (isPragmaStart(aFileLine)) {¬∂				¬∂				newOpenMPPragmas = getOpenMPPragmas(aFileLine, i);¬∂				if (newOpenMPPragmas.size() != 0) {¬∂					for (OpenMPPragma anOpenMPPragma:newOpenMPPragmas) {¬∂						if (anOpenMPPragmas.size() > 0) {¬∂						    anOpenMPPragma.setParent(anOpenMPPragmas.peek());¬∂						}¬∂						anOpenMPPragmas.push(anOpenMPPragma);¬∂						aNumOpenBracesStack.push(0);¬∂						retVal.add(anOpenMPPragma);¬∂¬∂					}¬∂//					anOpenMPPragmas.addAll(newOpenMPPragmas);¬∂					aNumOpenBracesStack.add(0);¬∂//					retVal.add(lastOpenMPPragma);					¬∂					aNextCodeLineIsAPragmaBlock = true;¬∂//					String lastReductionOperation = lastOpenMPPragma.getReductionOperation();¬∂//					String lastReductionVariable = lastOpenMPPragma.getReductionVariable();¬∂					continue;¬∂				} ¬∂			}¬∂			if (anOpenMPPragmas.isEmpty()) {¬∂				continue;¬∂			}	¬∂			if (aNextCodeLineIsAPragmaBlock) {				¬∂				anOpenMPPragmas.peek().setAnnotatedTextStartLineNumber(i);				¬∂				aNextCodeLineIsAPragmaBlock = false;¬∂			}¬∂//			anOpenMPPragmas.peek().getAnnotatedText().add(aFileLine);¬∂			if (isBlockStart(aFileLine)) {¬∂				incrementStackTop(aNumOpenBracesStack);¬∂			}¬∂//			} else ¬∂			if (isBlockEnd(aFileLine)) {¬∂				decrementStackTop(aNumOpenBracesStack);¬∂¬∂			}¬∂			if (isLoopStart(aFileLine) && endsWithLoopHeader(aFileLine)) {¬∂				continue; // gather following block also¬∂			}¬∂			if (aNumOpenBracesStack.peek() == 0) {¬∂				¬∂				anOpenMPPragmas.peek().setAnnotatedTextEndLineNumber(i);¬∂				for (int j = 0; j < newOpenMPPragmas.size(); j++) {¬∂					anOpenMPPragmas.pop();¬∂					aNumOpenBracesStack.pop();¬∂				}¬∂//				lastOpenMPPragma = null;¬∂//				lastReductionVariable = null;¬∂//				lastReductionOperation = null;¬∂				continue;¬∂			}					¬∂		}¬∂		return retVal;¬∂	}¬∂	public static List<OpenMPPragma> getOpenMPPragmas(String aFileLine, int aLineIndex) {¬∂		String[] aTokens = aFileLine.split("\\s+");¬∂		if (aTokens.length <= 2) {¬∂			return null;¬∂		}¬∂		if (!aTokens[1].equals("omp")) {¬∂			return null;¬∂		}¬∂		if (aTokens.length < 3) {¬∂			return null;¬∂		}¬∂		String aFirstToken = aTokens[2];¬∂		OpenMPKeywordEnum anOpenMPKeyword = stringToOpenMPKeyword.get(aFirstToken);¬∂		List<OpenMPPragma> retVal = new ArrayList();¬∂		OpenMPPragma lastChild;¬∂		int aStartIndex = 2;¬∂		switch (anOpenMPKeyword) {¬∂		case PARALLEL:¬∂			lastChild = new AnOpenMPParallelPragma(aLineIndex);¬∂			¬∂//			lastChild.setFirstOpenMPKeyword(stringToOpenMPKeyword.get(aFirstToken));	¬∂¬∂			retVal.add(lastChild);¬∂			if (aTokens.length > 3 && aTokens[3].equals("for")) {¬∂				OpenMPPragma aForChild = new AnOpenMPForPragma(aLineIndex);¬∂				retVal.add(aForChild);¬∂				lastChild = aForChild;¬∂				aStartIndex++;¬∂			}¬∂			break;¬∂		case FOR:¬∂			lastChild = new AnOpenMPForPragma(aLineIndex);¬∂			retVal.add (lastChild);¬∂			break;¬∂		case CRITICAL:¬∂			lastChild = new AnOpenMPCriticalPragma(aLineIndex);¬∂			retVal.add (lastChild);¬∂			break;¬∂			default: ¬∂				lastChild = new AnOpenMPPragma(aLineIndex);¬∂				retVal.add(lastChild);¬∂			¬∂		}¬∂//		retVal.setFirstOpenMPKeyword(stringToOpenMPKeyword.get(aFirstToken));	¬∂//		OpenMPPragma retVal = new AnOpenMPPragma(aLineIndex);¬∂¬∂¬∂		for (int i = aStartIndex; i < aTokens.length; i ++) {¬∂			String aStoredToken = aTokens[i].trim();¬∂			if (aStoredToken.isEmpty()) {¬∂				continue;¬∂			}¬∂			if (aStoredToken.startsWith("reduction")) {¬∂				while (!aStoredToken.endsWith(")")) {¬∂					i++;¬∂					if (i >= aTokens.length) {¬∂						break;¬∂					}¬∂					String aNewToken = aTokens[i].trim();¬∂					aStoredToken += aNewToken; 					¬∂				}¬∂				int aLeftParenIndex = aStoredToken.indexOf("(");¬∂				int aRightParenIndex = aStoredToken.indexOf(")");¬∂				int aColonIndex = aStoredToken.indexOf(":");¬∂				if (aLeftParenIndex != -1 && aRightParenIndex != -1 && aColonIndex != -1) {¬∂					String anOperationString = aStoredToken.substring(aLeftParenIndex + 1, aColonIndex).trim();¬∂					String aVariableString = aStoredToken.substring(aColonIndex + 1, aRightParenIndex).trim();¬∂					((OpenMPForPragma) lastChild).setReductionVariable(aVariableString);¬∂					((OpenMPForPragma) lastChild).setReductionOperation(anOperationString);¬∂				}¬∂				¬∂			}¬∂//			aTokens[i] = aStoredToken;¬∂			lastChild.getOpenMPTokens().add(aStoredToken);¬∂		}¬∂//		String aFirstToken = retVal.getOpenMPTokens().get(0);¬∂//		retVal.setFirstOpenMPKeyword(stringToOpenMPKeyword.get(aFirstToken));		¬∂		return retVal;¬∂		¬∂		¬∂	}¬∂	static {¬∂		stringToOpenMPKeyword.put("for", OpenMPKeywordEnum.FOR);¬∂		stringToOpenMPKeyword.put("parallel", OpenMPKeywordEnum.PARALLEL);¬∂		stringToOpenMPKeyword.put("reduce", OpenMPKeywordEnum.REDUCE);¬∂		stringToOpenMPKeyword.put("shared", OpenMPKeywordEnum.SHARED);¬∂		stringToOpenMPKeyword.put("private", OpenMPKeywordEnum.PRIVATE);¬∂		stringToOpenMPKeyword.put("critical", OpenMPKeywordEnum.CRITICAL);¬∂¬∂¬∂¬∂¬∂¬∂	}¬∂	¬∂¬∂}¬∂")]]]></diff>
    <snapshot><![CDATA[package gradingTools.shared.testcases.openmp;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Stack;


public class OpenMPUtils {
	
	protected static Map<String, OpenMPKeywordEnum> stringToOpenMPKeyword = new HashMap();
	protected static String[] typeNames = {"double", "float", "int", "short", "long"};
	protected static String[] openMPCalls = {"omp_get_thread_num()", "omp_get_num_threads()"};
	public static List<OpenMPPragma> getOpemMPPragmas(StringBuffer aFileBuffer) {
		String[] aFileLines = aFileBuffer.toString().split("\n");
		return getOpenMPPragmas(aFileLines);
	}
	
	public static boolean isCodeLine(String aLine) {
		return !aLine.isEmpty() && !aLine.startsWith("//");
	}
	public static boolean isBlockStart(String aLine) {
		return aLine.contains("{");
	}
	public static boolean isBlockEnd(String aLine) {
		return aLine.contains("}");
	}
	public static boolean isLoopStart(String aLine) {
		return aLine.startsWith("for");
	}
	public static boolean endsWithLoopHeader(String aLine) {
		return aLine.endsWith(")");
	}
	public static boolean isPragmaStart(String aLine) {
		return aLine.startsWith("#pragma");
	}
	public static void addToStack(Stack<OpenMPPragma> anOpenMPPragmas, String aFileLine) {
		List<String> anOpenMPCalls = getOMPCalls(aFileLine);
		for (OpenMPPragma anOpenMPPragma:anOpenMPPragmas) {
			anOpenMPPragma.addToAnnotatedText(aFileLine);
			for (String anOpenMPCall:anOpenMPCalls) {
				anOpenMPPragma.addOpenMPCall(anOpenMPCall);
			}		
		}
	}
	public static AForHeader getForHeader(String aFileLine, int aLineNumber) {
		int aLeftParenIndex = aFileLine.indexOf("(");
		int aRightParenIndex = aFileLine.indexOf(")");
		if (aLeftParenIndex < 0 || aRightParenIndex < 0) {
			return null;
		}
		String aHeaderString = aFileLine.substring(aLeftParenIndex + 1, aRightParenIndex);
		String[] aForComponents = aHeaderString.split(";");
		return new AForHeader(aForComponents[0], aForComponents[1], aForComponents[2], aLineNumber);
	}
	public static List<String> getOMPCalls(String aFileLine) {
		List<String> retVal = new ArrayList();
		for (String anOpenMPCall:openMPCalls) {
			if (aFileLine.contains(anOpenMPCall)) {
				retVal.add(anOpenMPCall);
			}
		}
		return retVal;
	}
	
	public static void incrementStackTop (Stack<Integer> aNumOpenBracesStack) {
		int aTopIndex = aNumOpenBracesStack.size() - 1;
		Integer aCurrentValue = aNumOpenBracesStack.get(aTopIndex);
		aNumOpenBracesStack.set(aTopIndex, aCurrentValue + 1);
	}
	public static void decrementStackTop (Stack<Integer> aNumOpenBracesStack) {
		int aTopIndex = aNumOpenBracesStack.size() - 1;
		Integer aCurrentValue = aNumOpenBracesStack.get(aTopIndex);
		aNumOpenBracesStack.set(aTopIndex, aCurrentValue - 1);
	}
	
	public static boolean startsWithTypeName(String aLine) {
		for (String aTypeName:typeNames) {
			if (aLine.startsWith(aTypeName)) {
				return true;
			}
		}
		return false;
	}

	public static List<OpenMPPragma> getOpenMPPragmas(String[] aFileLines) {
		List<OpenMPPragma> retVal = new ArrayList();
		Stack<OpenMPPragma> anOpenMPPragmas = new Stack();
		Stack<Integer> aNumOpenBracesStack = new Stack();
//		OpenMPPragma lastOpenMPPragma = null;
//		String lastReductionVariable = null;
//		String lastReductionOperation = null;
//		int aNumOpenBraces = 0;
		boolean aNextCodeLineIsAPragmaBlock = false;
		List<OpenMPPragma> newOpenMPPragmas = null;
		for (int i = 0; i < aFileLines.length; i++) {
			String aFileLine = aFileLines[i].trim();
			if (!isCodeLine(aFileLine)) {
				continue;
			}
			addToStack(anOpenMPPragmas, aFileLine); // if it is empty add to none
//			if (lastReductionVariable != null) {
//				if (aFileLine.startsWith(lastReductionVariable)) {
//					lastOpenMPPragma.getReductionVariableAssignments().add(aFileLine);
//					if (lastReductionOperation != null) { // can it ever be not null
//						if (aFileLine.contains(lastReductionOperation)) {
//							lastOpenMPPragma.getReductionOperationUses().add(aFileLine);
//						}
//					}
//				}			
//			}
//			if (lastOpenMPPragma != null && lastOpenMPPragma.getFirstOpenMPKeyword() == OpenMPKeywordEnum.PARALLEL) {
//				if (startsWithTypeName(aFileLine)) {
//					lastOpenMPPragma.getVariableDeclarationsInParallel().add(aFileLine);
//				}
//			} 
//			else if (lastOpenMPPragma != null && lastOpenMPPragma.getFirstOpenMPKeyword() == OpenMPKeywordEnum.CRITICAL) {
//				String[] aTokens = aFileLine.split("\\s+");
//				lastOpenMPPragma.setAssignedVariableInCritical(aTokens[0]);				
//			}
			if (isPragmaStart(aFileLine)) {
				
				newOpenMPPragmas = getOpenMPPragmas(aFileLine, i);
				if (newOpenMPPragmas.size() != 0) {
					for (OpenMPPragma anOpenMPPragma:newOpenMPPragmas) {
						if (anOpenMPPragmas.size() > 0) {
						    anOpenMPPragma.setParent(anOpenMPPragmas.peek());
						}
						anOpenMPPragmas.push(anOpenMPPragma);
						aNumOpenBracesStack.push(0);
						retVal.add(anOpenMPPragma);

					}
//					anOpenMPPragmas.addAll(newOpenMPPragmas);
					aNumOpenBracesStack.add(0);
//					retVal.add(lastOpenMPPragma);					
					aNextCodeLineIsAPragmaBlock = true;
//					String lastReductionOperation = lastOpenMPPragma.getReductionOperation();
//					String lastReductionVariable = lastOpenMPPragma.getReductionVariable();
					continue;
				} 
			}
			if (anOpenMPPragmas.isEmpty()) {
				continue;
			}	
			if (aNextCodeLineIsAPragmaBlock) {				
				anOpenMPPragmas.peek().setAnnotatedTextStartLineNumber(i);				
				aNextCodeLineIsAPragmaBlock = false;
			}
//			anOpenMPPragmas.peek().getAnnotatedText().add(aFileLine);
			if (isBlockStart(aFileLine)) {
				incrementStackTop(aNumOpenBracesStack);
			}
//			} else 
			if (isBlockEnd(aFileLine)) {
				decrementStackTop(aNumOpenBracesStack);

			}
			if (isLoopStart(aFileLine) && endsWithLoopHeader(aFileLine)) {
				continue; // gather following block also
			}
			if (aNumOpenBracesStack.peek() == 0) {
				
				anOpenMPPragmas.peek().setAnnotatedTextEndLineNumber(i);
				for (int j = 0; j < newOpenMPPragmas.size(); j++) {
					anOpenMPPragmas.pop();
					aNumOpenBracesStack.pop();
				}
//				lastOpenMPPragma = null;
//				lastReductionVariable = null;
//				lastReductionOperation = null;
				continue;
			}					
		}
		return retVal;
	}
	public static List<OpenMPPragma> getOpenMPPragmas(String aFileLine, int aLineIndex) {
		String[] aTokens = aFileLine.split("\\s+");
		if (aTokens.length <= 2) {
			return null;
		}
		if (!aTokens[1].equals("omp")) {
			return null;
		}
		if (aTokens.length < 3) {
			return null;
		}
		String aFirstToken = aTokens[2];
		OpenMPKeywordEnum anOpenMPKeyword = stringToOpenMPKeyword.get(aFirstToken);
		List<OpenMPPragma> retVal = new ArrayList();
		OpenMPPragma lastChild;
		int aStartIndex = 2;
		switch (anOpenMPKeyword) {
		case PARALLEL:
			lastChild = new AnOpenMPParallelPragma(aLineIndex);
			
//			lastChild.setFirstOpenMPKeyword(stringToOpenMPKeyword.get(aFirstToken));	

			retVal.add(lastChild);
			if (aTokens.length > 3 && aTokens[3].equals("for")) {
				OpenMPPragma aForChild = new AnOpenMPForPragma(aLineIndex);
				retVal.add(aForChild);
				lastChild = aForChild;
				aStartIndex++;
			}
			break;
		case FOR:
			lastChild = new AnOpenMPForPragma(aLineIndex);
			retVal.add (lastChild);
			break;
		case CRITICAL:
			lastChild = new AnOpenMPCriticalPragma(aLineIndex);
			retVal.add (lastChild);
			break;
			default: 
				lastChild = new AnOpenMPPragma(aLineIndex);
				retVal.add(lastChild);
			
		}
//		retVal.setFirstOpenMPKeyword(stringToOpenMPKeyword.get(aFirstToken));	
//		OpenMPPragma retVal = new AnOpenMPPragma(aLineIndex);


		for (int i = aStartIndex; i < aTokens.length; i ++) {
			String aStoredToken = aTokens[i].trim();
			if (aStoredToken.isEmpty()) {
				continue;
			}
			if (aStoredToken.startsWith("reduction")) {
				while (!aStoredToken.endsWith(")")) {
					i++;
					if (i >= aTokens.length) {
						break;
					}
					String aNewToken = aTokens[i].trim();
					aStoredToken += aNewToken; 					
				}
				int aLeftParenIndex = aStoredToken.indexOf("(");
				int aRightParenIndex = aStoredToken.indexOf(")");
				int aColonIndex = aStoredToken.indexOf(":");
				if (aLeftParenIndex != -1 && aRightParenIndex != -1 && aColonIndex != -1) {
					String anOperationString = aStoredToken.substring(aLeftParenIndex + 1, aColonIndex).trim();
					String aVariableString = aStoredToken.substring(aColonIndex + 1, aRightParenIndex).trim();
					((OpenMPForPragma) lastChild).setReductionVariable(aVariableString);
					((OpenMPForPragma) lastChild).setReductionOperation(anOperationString);
				}
				
			}
//			aTokens[i] = aStoredToken;
			lastChild.getOpenMPTokens().add(aStoredToken);
		}
//		String aFirstToken = retVal.getOpenMPTokens().get(0);
//		retVal.setFirstOpenMPKeyword(stringToOpenMPKeyword.get(aFirstToken));		
		return retVal;
		
		
	}
	static {
		stringToOpenMPKeyword.put("for", OpenMPKeywordEnum.FOR);
		stringToOpenMPKeyword.put("parallel", OpenMPKeywordEnum.PARALLEL);
		stringToOpenMPKeyword.put("reduce", OpenMPKeywordEnum.REDUCE);
		stringToOpenMPKeyword.put("shared", OpenMPKeywordEnum.SHARED);
		stringToOpenMPKeyword.put("private", OpenMPKeywordEnum.PRIVATE);
		stringToOpenMPKeyword.put("critical", OpenMPKeywordEnum.CRITICAL);





	}
	

}
]]></snapshot>
  </Command>
  <DocumentChange __id="60359" _type="Delete" date="Mon Dec 23 07:47:42 EST 2019" docASTNodeCount="1140" docActiveCodeLength="7663" docExpressionCount="708" docLength="9545" endLine="46" length="1" offset="1610" startLine="46" starttimestamp="1576666505112" timestamp="438757760">
    <text><![CDATA[A]]></text>
  </DocumentChange>
  <Command __id="60386" _type="EclipseCommand" commandID="" date="Mon Dec 23 07:47:45 EST 2019" starttimestamp="1576666505112" timestamp="438760398" />
  <Command __id="60387" _type="EclipseCommand" commandID="" date="Mon Dec 23 07:47:45 EST 2019" starttimestamp="1576666505112" timestamp="438760398" />
  <Command __id="60388" _type="EclipseCommand" commandID="" date="Mon Dec 23 07:47:45 EST 2019" starttimestamp="1576666505112" timestamp="438760398" />
  <Command __id="60389" _type="EclipseCommand" commandID="" date="Mon Dec 23 07:47:45 EST 2019" starttimestamp="1576666505112" timestamp="438760398" />
  <Command __id="60390" _type="EclipseCommand" commandID="" date="Mon Dec 23 07:47:45 EST 2019" starttimestamp="1576666505112" timestamp="438760398" />
  <Command __id="60391" _type="EclipseCommand" commandID="" date="Mon Dec 23 07:47:45 EST 2019" starttimestamp="1576666505112" timestamp="438760398" />
  <Command __id="60392" _type="EclipseCommand" commandID="" date="Mon Dec 23 07:47:45 EST 2019" starttimestamp="1576666505112" timestamp="438760414" />
  <Command __id="60393" _type="EclipseCommand" commandID="" date="Mon Dec 23 07:47:45 EST 2019" starttimestamp="1576666505112" timestamp="438760414" />
  <Command __id="60394" _type="EclipseCommand" commandID="" date="Mon Dec 23 07:47:45 EST 2019" starttimestamp="1576666505112" timestamp="438760414" />
  <Command __id="60395" _type="EclipseCommand" commandID="" date="Mon Dec 23 07:47:45 EST 2019" starttimestamp="1576666505112" timestamp="438760414" />
  <Command __id="60396" _type="EclipseCommand" commandID="" date="Mon Dec 23 07:47:45 EST 2019" starttimestamp="1576666505112" timestamp="438760430" />
  <Command __id="62625" _type="DiffBasedFileOpenCommand" date="Mon Dec 23 08:29:21 EST 2019" docASTNodeCount="395" docActiveCodeLength="2839" docExpressionCount="210" docLength="4742" projectName="GraderBasics" starttimestamp="1576666505112" timestamp="441255986">
    <filePath><![CDATA[D:\dewan_backup\Java\GraderBasics\src\gradingTools\shared\testcases\openmp\AnOpenMPPragma.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package gradingTools.shared.testcases.openmp;¬∂¬∂import java.util.ArrayList;¬∂import java.util.Arrays;¬∂import java.util.List;¬∂¬∂public class AnOpenMPPragma implements OpenMPPragma {¬∂//	protected List<OpenMPKeywordEnum> openMPKeywords = new ArrayList();¬∂	protected List<String> openMPTokens = new ArrayList();¬∂//	protected OpenMPKeywordEnum firstOpenMPKeyword;¬∂	¬∂//	protected List<String> variableDeclarationsInParallel = new ArrayList();//separate subclass for this variable?¬∂	¬∂//	protected String assignedVariableInCritical;// separate subclass for this variable?¬∂	¬∂	protected int lineNumber;¬∂	protected List<String> annotatedText = new ArrayList();¬∂	protected List<String> openMPCalls = new ArrayList();¬∂	"), Diff(INSERT,"protected List<String> linesWithOpenMPCalls = new ArrayList();¬∂	"), Diff(EQUAL,"protected List<ForHeader> forHeaders = new ArrayList();¬∂	¬∂	protected int annotatedTextStartLineNumber;¬∂	protected int annotatedTextEndLineNumber;¬∂	protected OpenMPPragma parent;¬∂	¬∂¬∂	protected List<OpenMPPragma> children = new ArrayList();¬∂¬∂	//	protected String reductionVariable;¬∂//	protected String reductionOperation;¬∂//	protected List<String> reductionVariableAssignments = new ArrayList();¬∂//	protected List<String> reductionOperationUses = new ArrayList();¬∂//	¬∂	public AnOpenMPPragma(int lineNumber) {¬∂		super();¬∂//		this.openMPTokens = openMPTokens;¬∂		this.lineNumber = lineNumber;¬∂		¬∂//		this.nextNonEmptyString = nextNonEmptyString;¬∂	}¬∂	@Override¬∂	public List<String> getOpenMPTokens() {¬∂		return openMPTokens;¬∂	}¬∂	@Override¬∂	public int getLineNumber() {¬∂		return lineNumber;¬∂	}¬∂	@Override¬∂	public List<String> getAnnotatedText() {¬∂		return annotatedText;¬∂	}¬∂	@Override¬∂	public void addToAnnotatedText(String aFileLine, int aLineNumber) {¬∂		annotatedText.add(aFileLine);¬∂		List<String> anOpenMPCalls = OpenMPUtils.getOMPCalls(aFileLine);¬∂		¬∂			for (String anOpenMPCall:anOpenMPCalls) {¬∂				addOpenMPCall(anOpenMPCall, aLineNumber);¬∂			}¬∂			"), Diff(INSERT,"if (anOpenMPCalls.size() > 1) {¬∂				linesWithOpenMPCalls.add(aFileLine);¬∂			}¬∂			"), Diff(EQUAL,"ForHeader aForHeader = OpenMPUtils.getForHeader(aFileLine, aLineNumber);¬∂			if (aForHeader != null) {¬∂				forHeaders.add(aForHeader);¬∂			}¬∂			¬∂	}¬∂//	@Override¬∂//	public void setAnnotatedText(List<String> nextNonEmptyString) {¬∂//		this.annotatedText = nextNonEmptyString;¬∂//	}¬∂	@Override¬∂	public int getAnnotatedTextStartLineNumber() {¬∂		return annotatedTextStartLineNumber;¬∂	}¬∂	@Override¬∂	public void setAnnotatedTextStartLineNumber(int annotatedLineNumber) {¬∂		this.annotatedTextStartLineNumber = annotatedLineNumber;¬∂	}¬∂	¬∂	@Override¬∂	public int getAnnotatedTextEndLineNumber() {¬∂		return annotatedTextEndLineNumber;¬∂	}¬∂	@Override¬∂	public void setAnnotatedTextEndLineNumber(int annotatedTextEndLineNumber) {¬∂		this.annotatedTextEndLineNumber = annotatedTextEndLineNumber;¬∂	}¬∂//	@Override¬∂//	public String getReductionVariable() {¬∂//		return reductionVariable;¬∂//	}¬∂//	@Override¬∂//	public void setReductionVariable(String reductionVariable) {¬∂//		this.reductionVariable = reductionVariable;¬∂//	}¬∂//	@Override¬∂//	public String getReductionOperation() {¬∂//		return reductionOperation;¬∂//	}¬∂//	@Override¬∂//	public void setReductionOperation(String reductionOperation) {¬∂//		this.reductionOperation = reductionOperation;¬∂//	}¬∂//	@Override¬∂//	public List<String> getReductionVariableAssignments() {¬∂//		return reductionVariableAssignments;¬∂//	}¬∂//	@Override¬∂//	public List<String> getReductionOperationUses() {¬∂//		return reductionOperationUses;¬∂//	}¬∂//	@Override¬∂//	public OpenMPKeywordEnum getFirstOpenMPKeyword() {¬∂//		return firstOpenMPKeyword;¬∂//	}¬∂//	@Override¬∂//	public void setFirstOpenMPKeyword(OpenMPKeywordEnum firstOpenMPKeyword) {¬∂//		this.firstOpenMPKeyword = firstOpenMPKeyword;¬∂//	}¬∂//	@Override¬∂//	public String getAssignedVariableInCritical() {¬∂//		return assignedVariableInCritical;¬∂//	}¬∂//	@Override¬∂//	public void setAssignedVariableInCritical(String assignedVariableInCritical) {¬∂//		this.assignedVariableInCritical = assignedVariableInCritical;¬∂//	}¬∂	@Override¬∂	public OpenMPPragma getParent() {¬∂		return parent;¬∂	}¬∂	@Override¬∂	public void setParent(OpenMPPragma parent) {¬∂		this.parent = parent;¬∂		parent.getChildren().add(this);¬∂	}¬∂	@Override¬∂	public List<OpenMPPragma> getChildren() {¬∂		return children;¬∂	}¬∂	@Override¬∂	public List<String> getOpenMPCalls() {¬∂		return openMPCalls;¬∂	}¬∂	@Override¬∂	public void addOpenMPCall(String aFileLine, int aLineNumber) {¬∂		openMPCalls.add(aFileLine);¬∂	}¬∂	public String toString() {¬∂		return lineNumber + ":" + openMPTokens +¬∂				"--> (" + annotatedTextStartLineNumber + "," + annotatedTextEndLineNumber + "):" + annotatedText;¬∂	}¬∂}¬∂")]]]></diff>
    <snapshot><![CDATA[package gradingTools.shared.testcases.openmp;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public class AnOpenMPPragma implements OpenMPPragma {
//	protected List<OpenMPKeywordEnum> openMPKeywords = new ArrayList();
	protected List<String> openMPTokens = new ArrayList();
//	protected OpenMPKeywordEnum firstOpenMPKeyword;
	
//	protected List<String> variableDeclarationsInParallel = new ArrayList();//separate subclass for this variable?
	
//	protected String assignedVariableInCritical;// separate subclass for this variable?
	
	protected int lineNumber;
	protected List<String> annotatedText = new ArrayList();
	protected List<String> openMPCalls = new ArrayList();
	protected List<String> linesWithOpenMPCalls = new ArrayList();
	protected List<ForHeader> forHeaders = new ArrayList();
	
	protected int annotatedTextStartLineNumber;
	protected int annotatedTextEndLineNumber;
	protected OpenMPPragma parent;
	

	protected List<OpenMPPragma> children = new ArrayList();

	//	protected String reductionVariable;
//	protected String reductionOperation;
//	protected List<String> reductionVariableAssignments = new ArrayList();
//	protected List<String> reductionOperationUses = new ArrayList();
//	
	public AnOpenMPPragma(int lineNumber) {
		super();
//		this.openMPTokens = openMPTokens;
		this.lineNumber = lineNumber;
		
//		this.nextNonEmptyString = nextNonEmptyString;
	}
	@Override
	public List<String> getOpenMPTokens() {
		return openMPTokens;
	}
	@Override
	public int getLineNumber() {
		return lineNumber;
	}
	@Override
	public List<String> getAnnotatedText() {
		return annotatedText;
	}
	@Override
	public void addToAnnotatedText(String aFileLine, int aLineNumber) {
		annotatedText.add(aFileLine);
		List<String> anOpenMPCalls = OpenMPUtils.getOMPCalls(aFileLine);
		
			for (String anOpenMPCall:anOpenMPCalls) {
				addOpenMPCall(anOpenMPCall, aLineNumber);
			}
			if (anOpenMPCalls.size() > 1) {
				linesWithOpenMPCalls.add(aFileLine);
			}
			ForHeader aForHeader = OpenMPUtils.getForHeader(aFileLine, aLineNumber);
			if (aForHeader != null) {
				forHeaders.add(aForHeader);
			}
			
	}
//	@Override
//	public void setAnnotatedText(List<String> nextNonEmptyString) {
//		this.annotatedText = nextNonEmptyString;
//	}
	@Override
	public int getAnnotatedTextStartLineNumber() {
		return annotatedTextStartLineNumber;
	}
	@Override
	public void setAnnotatedTextStartLineNumber(int annotatedLineNumber) {
		this.annotatedTextStartLineNumber = annotatedLineNumber;
	}
	
	@Override
	public int getAnnotatedTextEndLineNumber() {
		return annotatedTextEndLineNumber;
	}
	@Override
	public void setAnnotatedTextEndLineNumber(int annotatedTextEndLineNumber) {
		this.annotatedTextEndLineNumber = annotatedTextEndLineNumber;
	}
//	@Override
//	public String getReductionVariable() {
//		return reductionVariable;
//	}
//	@Override
//	public void setReductionVariable(String reductionVariable) {
//		this.reductionVariable = reductionVariable;
//	}
//	@Override
//	public String getReductionOperation() {
//		return reductionOperation;
//	}
//	@Override
//	public void setReductionOperation(String reductionOperation) {
//		this.reductionOperation = reductionOperation;
//	}
//	@Override
//	public List<String> getReductionVariableAssignments() {
//		return reductionVariableAssignments;
//	}
//	@Override
//	public List<String> getReductionOperationUses() {
//		return reductionOperationUses;
//	}
//	@Override
//	public OpenMPKeywordEnum getFirstOpenMPKeyword() {
//		return firstOpenMPKeyword;
//	}
//	@Override
//	public void setFirstOpenMPKeyword(OpenMPKeywordEnum firstOpenMPKeyword) {
//		this.firstOpenMPKeyword = firstOpenMPKeyword;
//	}
//	@Override
//	public String getAssignedVariableInCritical() {
//		return assignedVariableInCritical;
//	}
//	@Override
//	public void setAssignedVariableInCritical(String assignedVariableInCritical) {
//		this.assignedVariableInCritical = assignedVariableInCritical;
//	}
	@Override
	public OpenMPPragma getParent() {
		return parent;
	}
	@Override
	public void setParent(OpenMPPragma parent) {
		this.parent = parent;
		parent.getChildren().add(this);
	}
	@Override
	public List<OpenMPPragma> getChildren() {
		return children;
	}
	@Override
	public List<String> getOpenMPCalls() {
		return openMPCalls;
	}
	@Override
	public void addOpenMPCall(String aFileLine, int aLineNumber) {
		openMPCalls.add(aFileLine);
	}
	public String toString() {
		return lineNumber + ":" + openMPTokens +
				"--> (" + annotatedTextStartLineNumber + "," + annotatedTextEndLineNumber + "):" + annotatedText;
	}
}
]]></snapshot>
  </Command>
  <DocumentChange __id="62713" _type="Replace" date="Mon Dec 23 08:30:06 EST 2019" docASTNodeCount="395" docActiveCodeLength="2839" docExpressionCount="210" docLength="4742" endLine="60" insertionLength="1" int_docASTNodeCount="363" int_docActiveCodeLength="2838" int_docExpressionCount="187" int_docLength="4741" length="1" offset="2002" startLine="60" starttimestamp="1576666505112" timestamp="441301796">
    <deletedText><![CDATA[1]]></deletedText>
    <insertedText><![CDATA[0]]></insertedText>
  </DocumentChange>
  <Command __id="62791" _type="EclipseCommand" commandID="org.eclipse.debug.ui.commands.Resume" date="Mon Dec 23 08:32:47 EST 2019" starttimestamp="1576666505112" timestamp="441462118" />
  <Command __id="62792" _type="RunCommand" date="Mon Dec 23 08:32:47 EST 2019" kind="StepInto" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="441462118" type="Run" />
  <Command __id="62793" _type="EHExceptionCommand" date="Mon Dec 23 08:32:47 EST 2019" starttimestamp="1576666505112" timestamp="441462225" type="Exception">
    <outputString><![CDATA[file name:sum_parallel.cp
pragmas:[18:[parallel]--> (19,0):[{, double local_sum = 0;, int rank = omp_get_thread_num();, int threads = omp_get_num_threads();, int start_index = (size/threads)*rank;, int end_index = (size/threads)*(rank+1);, if(rank==threads-1), end_index=size;, for(int i = start_index; i < end_index; i++), local_sum += array[i];, #pragma omp critical, sum += local_sum;, }, double end = omp_get_wtime();, printSumWithTimes(sum, start, end);, }], 34:[critical]--> (35,35):[sum += local_sum;]]
I***(TestCaseResult) ### anonymous: 1.0
]]></outputString>
  </Command>
  <Command __id="63437" _type="RunCommand" date="Mon Dec 23 08:59:09 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="443044205" type="Debug" />
  <Command __id="63438" _type="RunCommand" date="Mon Dec 23 08:59:09 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="443044205" type="Debug" />
  <Command __id="63439" _type="RunCommand" date="Mon Dec 23 08:59:09 EST 2019" kind="HitBreakPoint" projectName="PL_Java" starttimestamp="1576666505112" timestamp="443044205" type="Run" />
  <Command __id="63441" _type="ShellCommand" date="Mon Dec 23 09:00:49 EST 2019" starttimestamp="1576666505112" timestamp="443144716" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="63442" _type="EclipseCommand" commandID="org.eclipse.jdt.ui.edit.text.java.rename.element" date="Mon Dec 23 09:00:49 EST 2019" starttimestamp="1576666505112" timestamp="443144741" />
  <Command __id="63443" _type="ShellCommand" date="Mon Dec 23 09:01:03 EST 2019" starttimestamp="1576666505112" timestamp="443158817" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="63444" _type="ShellCommand" date="Mon Dec 23 09:01:06 EST 2019" starttimestamp="1576666505112" timestamp="443161033" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="63445" _type="EclipseCommand" commandID="org.eclipse.ui.project.cleanAction" date="Mon Dec 23 09:01:06 EST 2019" starttimestamp="1576666505112" timestamp="443161046" />
  <Command __id="63446" _type="EclipseCommand" commandID="org.eclipse.ui.project.buildProject" date="Mon Dec 23 09:01:15 EST 2019" starttimestamp="1576666505112" timestamp="443170200" />
  <Command __id="63448" _type="ShellCommand" date="Mon Dec 23 09:01:30 EST 2019" starttimestamp="1576666505112" timestamp="443185629" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="63449" _type="EclipseCommand" commandID="org.eclipse.jdt.ui.edit.text.java.rename.element" date="Mon Dec 23 09:01:30 EST 2019" starttimestamp="1576666505112" timestamp="443185645" />
  <Command __id="63451" _type="ShellCommand" date="Mon Dec 23 09:01:39 EST 2019" starttimestamp="1576666505112" timestamp="443194813" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="63452" _type="EclipseCommand" commandID="org.eclipse.jdt.ui.edit.text.java.rename.element" date="Mon Dec 23 09:01:39 EST 2019" starttimestamp="1576666505112" timestamp="443194829" />
  <Command __id="63454" _type="ShellCommand" date="Mon Dec 23 09:01:48 EST 2019" starttimestamp="1576666505112" timestamp="443203387" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="63455" _type="EclipseCommand" commandID="org.eclipse.jdt.ui.edit.text.java.rename.element" date="Mon Dec 23 09:01:48 EST 2019" starttimestamp="1576666505112" timestamp="443203403" />
  <DocumentChange __id="63434" _type="Insert" date="Mon Dec 23 08:57:06 EST 2019" docASTNodeCount="136" docActiveCodeLength="1021" docExpressionCount="77" docLength="1136" length="2" offset="893" starttimestamp="1576666505112" timestamp="442921485">
    <text><![CDATA[
]]></text>
  </DocumentChange>
  <Command __id="63460" _type="ShellCommand" date="Mon Dec 23 22:33:14 EST 2019" starttimestamp="1576666505112" timestamp="491889409" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="63461" _type="DiffBasedFileOpenCommand" date="Mon Dec 23 22:33:21 EST 2019" docASTNodeCount="1" docActiveCodeLength="611" docExpressionCount="0" docLength="699" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="491896212">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\my_sum_parallel_for_local_var.cpp]]></filePath>
    <diff><![CDATA[null]]></diff>
    <snapshot><![CDATA[#include <iostream>
#include <omp.h>

using namespace std;

void printSumWithTimes (int sum, int start, int end);
void printNumThreads();
void recordThreadIndex(int index);
void sum_parallel_for_local_var(double* array, int size)
{
	cout << "sum_parallel_for_local_var\n";

	double start = omp_get_wtime();

	double sum = 0;
//
//	for (int i = 0; i < size; i++) {
//			sum += array[i];
//			recordThreadIndex(i);
//	}
    #pragma omp parallel
	{
		double local_sum = 0;

		#pragma omp for
		for(int i = 0; i < size; i++) {
			local_sum += array[i];
			recordThreadIndex(i);
		}

		#pragma omp critical
		sum += local_sum;
	}

	double end = omp_get_wtime();

	printSumWithTimes(sum, start, end);
	
}
]]></snapshot>
  </Command>
  <Command __id="63462" _type="MoveCaretCommand" caretOffset="488" date="Mon Dec 23 22:33:21 EST 2019" docOffset="488" starttimestamp="1576666505112" timestamp="491896585" />
  <DocumentChange __id="63463" _type="Insert" date="Mon Dec 23 22:33:31 EST 2019" docASTNodeCount="1" docActiveCodeLength="612" docExpressionCount="0" docLength="700" length="1" offset="488" starttimestamp="1576666505112" timestamp="491906720">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <Command __id="63464" _type="InsertStringCommand" date="Mon Dec 23 22:33:31 EST 2019" starttimestamp="1576666505112" timestamp="491906726" timestamp2="491906726">
    <data><![CDATA[ ]]></data>
  </Command>
  <DocumentChange __id="63465" _type="Insert" date="Mon Dec 23 22:33:32 EST 2019" docASTNodeCount="1" docActiveCodeLength="613" docExpressionCount="0" docLength="701" length="1" offset="489" starttimestamp="1576666505112" timestamp="491907001">
    <text><![CDATA[s]]></text>
  </DocumentChange>
  <Command __id="63466" _type="InsertStringCommand" date="Mon Dec 23 22:33:32 EST 2019" starttimestamp="1576666505112" timestamp="491907014" timestamp2="491907014">
    <data><![CDATA[s]]></data>
  </Command>
  <DocumentChange __id="63467" _type="Insert" date="Mon Dec 23 22:33:32 EST 2019" docASTNodeCount="1" docActiveCodeLength="614" docExpressionCount="0" docLength="702" length="1" offset="490" starttimestamp="1576666505112" timestamp="491907121">
    <text><![CDATA[h]]></text>
  </DocumentChange>
  <Command __id="63468" _type="InsertStringCommand" date="Mon Dec 23 22:33:32 EST 2019" starttimestamp="1576666505112" timestamp="491907128" timestamp2="491907128">
    <data><![CDATA[h]]></data>
  </Command>
  <DocumentChange __id="63469" _type="Insert" date="Mon Dec 23 22:33:32 EST 2019" docASTNodeCount="1" docActiveCodeLength="615" docExpressionCount="0" docLength="703" length="1" offset="491" starttimestamp="1576666505112" timestamp="491907360">
    <text><![CDATA[a]]></text>
  </DocumentChange>
  <Command __id="63470" _type="InsertStringCommand" date="Mon Dec 23 22:33:32 EST 2019" starttimestamp="1576666505112" timestamp="491907373" timestamp2="491907373">
    <data><![CDATA[a]]></data>
  </Command>
  <DocumentChange __id="63471" _type="Insert" date="Mon Dec 23 22:33:32 EST 2019" docASTNodeCount="1" docActiveCodeLength="616" docExpressionCount="0" docLength="704" length="1" offset="492" starttimestamp="1576666505112" timestamp="491907464">
    <text><![CDATA[r]]></text>
  </DocumentChange>
  <Command __id="63472" _type="InsertStringCommand" date="Mon Dec 23 22:33:32 EST 2019" starttimestamp="1576666505112" timestamp="491907473" timestamp2="491907473">
    <data><![CDATA[r]]></data>
  </Command>
  <DocumentChange __id="63473" _type="Insert" date="Mon Dec 23 22:33:32 EST 2019" docASTNodeCount="1" docActiveCodeLength="617" docExpressionCount="0" docLength="705" length="1" offset="493" starttimestamp="1576666505112" timestamp="491907608">
    <text><![CDATA[e]]></text>
  </DocumentChange>
  <Command __id="63474" _type="InsertStringCommand" date="Mon Dec 23 22:33:32 EST 2019" starttimestamp="1576666505112" timestamp="491907616" timestamp2="491907616">
    <data><![CDATA[e]]></data>
  </Command>
  <DocumentChange __id="63475" _type="Insert" date="Mon Dec 23 22:33:32 EST 2019" docASTNodeCount="1" docActiveCodeLength="618" docExpressionCount="0" docLength="706" length="1" offset="494" starttimestamp="1576666505112" timestamp="491907762">
    <text><![CDATA[d]]></text>
  </DocumentChange>
  <Command __id="63476" _type="InsertStringCommand" date="Mon Dec 23 22:33:32 EST 2019" starttimestamp="1576666505112" timestamp="491907769" timestamp2="491907769">
    <data><![CDATA[d]]></data>
  </Command>
  <DocumentChange __id="63477" _type="Insert" date="Mon Dec 23 22:33:33 EST 2019" docASTNodeCount="1" docActiveCodeLength="620" docExpressionCount="0" docLength="708" length="2" offset="495" starttimestamp="1576666505112" timestamp="491908661">
    <text><![CDATA[()]]></text>
  </DocumentChange>
  <Command __id="63478" _type="InsertStringCommand" date="Mon Dec 23 22:33:33 EST 2019" starttimestamp="1576666505112" timestamp="491908686" timestamp2="491908686">
    <data><![CDATA[(]]></data>
  </Command>
  <DocumentChange __id="63479" _type="Insert" date="Mon Dec 23 22:33:34 EST 2019" docASTNodeCount="1" docActiveCodeLength="621" docExpressionCount="0" docLength="709" length="1" offset="496" starttimestamp="1576666505112" timestamp="491908908">
    <text><![CDATA[l]]></text>
  </DocumentChange>
  <Command __id="63480" _type="InsertStringCommand" date="Mon Dec 23 22:33:34 EST 2019" starttimestamp="1576666505112" timestamp="491908914" timestamp2="491908914">
    <data><![CDATA[l]]></data>
  </Command>
  <DocumentChange __id="63481" _type="Insert" date="Mon Dec 23 22:33:34 EST 2019" docASTNodeCount="1" docActiveCodeLength="622" docExpressionCount="0" docLength="710" length="1" offset="497" starttimestamp="1576666505112" timestamp="491909153">
    <text><![CDATA[o]]></text>
  </DocumentChange>
  <Command __id="63482" _type="InsertStringCommand" date="Mon Dec 23 22:33:34 EST 2019" starttimestamp="1576666505112" timestamp="491909155" timestamp2="491909155">
    <data><![CDATA[o]]></data>
  </Command>
  <DocumentChange __id="63483" _type="Insert" date="Mon Dec 23 22:33:34 EST 2019" docASTNodeCount="1" docActiveCodeLength="623" docExpressionCount="0" docLength="711" length="1" offset="498" starttimestamp="1576666505112" timestamp="491909249">
    <text><![CDATA[c]]></text>
  </DocumentChange>
  <Command __id="63484" _type="InsertStringCommand" date="Mon Dec 23 22:33:34 EST 2019" starttimestamp="1576666505112" timestamp="491909252" timestamp2="491909252">
    <data><![CDATA[c]]></data>
  </Command>
  <DocumentChange __id="63485" _type="Insert" date="Mon Dec 23 22:33:34 EST 2019" docASTNodeCount="1" docActiveCodeLength="624" docExpressionCount="0" docLength="712" length="1" offset="499" starttimestamp="1576666505112" timestamp="491909410">
    <text><![CDATA[a]]></text>
  </DocumentChange>
  <Command __id="63486" _type="InsertStringCommand" date="Mon Dec 23 22:33:34 EST 2019" starttimestamp="1576666505112" timestamp="491909412" timestamp2="491909412">
    <data><![CDATA[a]]></data>
  </Command>
  <DocumentChange __id="63487" _type="Insert" date="Mon Dec 23 22:33:34 EST 2019" docASTNodeCount="1" docActiveCodeLength="625" docExpressionCount="0" docLength="713" length="1" offset="500" starttimestamp="1576666505112" timestamp="491909626">
    <text><![CDATA[l]]></text>
  </DocumentChange>
  <Command __id="63488" _type="InsertStringCommand" date="Mon Dec 23 22:33:34 EST 2019" starttimestamp="1576666505112" timestamp="491909631" timestamp2="491909631">
    <data><![CDATA[l]]></data>
  </Command>
  <DocumentChange __id="63489" _type="Insert" date="Mon Dec 23 22:33:35 EST 2019" docASTNodeCount="1" docActiveCodeLength="626" docExpressionCount="0" docLength="714" length="1" offset="501" starttimestamp="1576666505112" timestamp="491910421">
    <text><![CDATA[_]]></text>
  </DocumentChange>
  <Command __id="63490" _type="InsertStringCommand" date="Mon Dec 23 22:33:35 EST 2019" starttimestamp="1576666505112" timestamp="491910425" timestamp2="491910425">
    <data><![CDATA[_]]></data>
  </Command>
  <DocumentChange __id="63491" _type="Insert" date="Mon Dec 23 22:33:35 EST 2019" docASTNodeCount="1" docActiveCodeLength="627" docExpressionCount="0" docLength="715" length="1" offset="502" starttimestamp="1576666505112" timestamp="491910612">
    <text><![CDATA[s]]></text>
  </DocumentChange>
  <Command __id="63492" _type="InsertStringCommand" date="Mon Dec 23 22:33:35 EST 2019" starttimestamp="1576666505112" timestamp="491910623" timestamp2="491910623">
    <data><![CDATA[s]]></data>
  </Command>
  <DocumentChange __id="63493" _type="Insert" date="Mon Dec 23 22:33:35 EST 2019" docASTNodeCount="1" docActiveCodeLength="628" docExpressionCount="0" docLength="716" length="1" offset="503" starttimestamp="1576666505112" timestamp="491910834">
    <text><![CDATA[u]]></text>
  </DocumentChange>
  <Command __id="63494" _type="InsertStringCommand" date="Mon Dec 23 22:33:35 EST 2019" starttimestamp="1576666505112" timestamp="491910841" timestamp2="491910841">
    <data><![CDATA[u]]></data>
  </Command>
  <Command __id="63496" _type="InsertStringCommand" date="Mon Dec 23 22:33:36 EST 2019" starttimestamp="1576666505112" timestamp="491911052" timestamp2="491911052">
    <data><![CDATA[m]]></data>
  </Command>
  <Command __id="63497" _type="EclipseCommand" commandID="org.eclipse.ui.file.save" date="Mon Dec 23 22:33:39 EST 2019" starttimestamp="1576666505112" timestamp="491913893" />
  <Command __id="63498" _type="MoveCaretCommand" caretOffset="506" date="Mon Dec 23 22:33:48 EST 2019" docOffset="506" starttimestamp="1576666505112" timestamp="491923226" />
  <Command __id="63499" _type="ShellCommand" date="Mon Dec 23 22:33:57 EST 2019" starttimestamp="1576666505112" timestamp="491932473" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="63500" _type="ShellCommand" date="Mon Dec 23 22:33:57 EST 2019" starttimestamp="1576666505112" timestamp="491932642" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="63501" _type="ShellCommand" date="Mon Dec 23 22:33:58 EST 2019" starttimestamp="1576666505112" timestamp="491933011" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="63502" _type="ShellCommand" date="Mon Dec 23 22:34:00 EST 2019" starttimestamp="1576666505112" timestamp="491935502" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="63503" _type="EclipseCommand" commandID="org.eclipse.cdt.debug.ui.localCShortcut.debug" date="Mon Dec 23 22:34:00 EST 2019" starttimestamp="1576666505112" timestamp="491935569" />
  <Command __id="63504" _type="ShellCommand" date="Mon Dec 23 22:34:04 EST 2019" starttimestamp="1576666505112" timestamp="491939195" type="ECLIPSE_LOST_FOCUS" />
  <DocumentChange __id="63495" _type="Insert" date="Mon Dec 23 22:33:36 EST 2019" docASTNodeCount="1" docActiveCodeLength="629" docExpressionCount="0" docLength="717" length="1" offset="504" starttimestamp="1576666505112" timestamp="491911051">
    <text><![CDATA[m]]></text>
  </DocumentChange>
  <Command __id="63509" _type="RunCommand" date="Mon Dec 23 22:34:15 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="491950682" type="Debug" />
  <Command __id="63510" _type="RunCommand" date="Mon Dec 23 22:34:15 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="491950684" type="Run" />
  <Command __id="63511" _type="RunCommand" date="Mon Dec 23 22:34:15 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="491950684" type="Debug" />
  <Command __id="63512" _type="RunCommand" date="Mon Dec 23 22:34:15 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="491950684" type="Run" />
  <Command __id="63513" _type="RunCommand" date="Mon Dec 23 22:34:16 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="491951250" type="Debug" />
  <Command __id="63514" _type="RunCommand" date="Mon Dec 23 22:34:16 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="491951250" type="Run" />
  <Command __id="63515" _type="RunCommand" date="Mon Dec 23 22:34:16 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="491951250" type="Debug" />
  <Command __id="63516" _type="RunCommand" date="Mon Dec 23 22:34:16 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="491951250" type="Run" />
  <Command __id="63517" _type="DiffBasedFileOpenCommand" date="Mon Dec 23 22:34:40 EST 2019" docASTNodeCount="1" docActiveCodeLength="1642" docExpressionCount="0" docLength="1924" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="491975305">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\my_sum_main.cpp]]></filePath>
    <diff><![CDATA[null]]></diff>
    <snapshot><![CDATA[#include <iostream>
#include <omp.h>

using namespace std;
//need to declare headers of external functions called
void sum_sequential(double* array, int size);
void sum_parallel_for_reduction(double* array, int size);
void sum_parallel(double* array, int size);
void sum_parallel_for_local_var(double* array, int size);

// if this main is used to call functions to do other computations
// then those headers should also be declared here

const int SIZE = 1000;
void initArray (double* array, int size ) {
	for(int i = 0; i < size; i++)
			array[i]=i;
}
/**
 * Called by each of the summing alternatives
 */
void printSumWithTimes (int sum, int start, int end) {
	cout << "Sum: " << sum << endl;
	cout << "Took: " << end - start << endl;
}
void printNumThreads() {
	cout << "threads:" << omp_get_num_threads() << endl;
}
/**
 * an array to learn how much concurrency occcurred
 */
int MAX_THREADS = 100;
double* threadsLastIndex = new double[MAX_THREADS];
int numThreads;


void recordThreadIndex(int index) {
	int thread =  omp_get_thread_num();
	if (thread >= MAX_THREADS) {
		return;
	}
	threadsLastIndex[thread] = index;
	numThreads = omp_get_num_threads();
}
void initThreadRecording() {
	numThreads = 0;
	for (int i = 0; i < MAX_THREADS; i++) {
		threadsLastIndex[i] = -1;
	}
}

void printThreadLastIndex() {
	for (int i = 0; i < numThreads; i++) {
		cout << "thread:" << i << " lastIndex:" << threadsLastIndex[i] << endl;
	}
	cout << "_____________________________" << endl;
}


int main()
{
	double* array = new double[SIZE];
	initArray(array, SIZE);
	initThreadRecording();
	sum_sequential(array, SIZE);
	printThreadLastIndex();
	initThreadRecording();
	sum_parallel_for_reduction(array, SIZE);
	printThreadLastIndex();
	initThreadRecording();
	sum_parallel_for_local_var(array, SIZE);
	printThreadLastIndex();
	initThreadRecording();
	sum_parallel(array, SIZE);
	printThreadLastIndex();
	initThreadRecording();
}
]]></snapshot>
  </Command>
  <Command __id="63518" _type="MoveCaretCommand" caretOffset="1500" date="Mon Dec 23 22:34:40 EST 2019" docOffset="1500" starttimestamp="1576666505112" timestamp="491975461" />
  <Command __id="63520" _type="MoveCaretCommand" caretOffset="506" date="Mon Dec 23 22:36:23 EST 2019" docOffset="506" starttimestamp="1576666505112" timestamp="492078554" />
  <Command __id="63519" _type="DiffBasedFileOpenCommand" date="Mon Dec 23 22:36:23 EST 2019" docASTNodeCount="1" docActiveCodeLength="629" docExpressionCount="0" docLength="717" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="492078192">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\my_sum_parallel_for_local_var.cpp]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"#include <iostream>¬∂#include <omp.h>¬∂¬∂using namespace std;¬∂¬∂void printSumWithTimes (int sum, int start, int end);¬∂void printNumThreads();¬∂void recordThreadIndex(int index);¬∂void sum_parallel_for_local_var(double* array, int size)¬∂{¬∂	cout << "sum_parallel_for_local_var\n";¬∂¬∂	double start = omp_get_wtime();¬∂¬∂	double sum = 0;¬∂//¬∂//	for (int i = 0; i < size; i++) {¬∂//			sum += array[i];¬∂//			recordThreadIndex(i);¬∂//	}¬∂    #pragma omp parallel¬∂	{¬∂		double local_sum = 0;¬∂¬∂		#pragma omp for"), Diff(INSERT," shared(local_sum)"), Diff(EQUAL,"¬∂		for(int i = 0; i < size; i++) {¬∂			local_sum += array[i];¬∂			recordThreadIndex(i);¬∂		}¬∂¬∂		#pragma omp critical¬∂		sum += local_sum;¬∂	}¬∂¬∂	double end = omp_get_wtime();¬∂¬∂	printSumWithTimes(sum, start, end);¬∂	¬∂}¬∂")]]]></diff>
    <snapshot><![CDATA[#include <iostream>
#include <omp.h>

using namespace std;

void printSumWithTimes (int sum, int start, int end);
void printNumThreads();
void recordThreadIndex(int index);
void sum_parallel_for_local_var(double* array, int size)
{
	cout << "sum_parallel_for_local_var\n";

	double start = omp_get_wtime();

	double sum = 0;
//
//	for (int i = 0; i < size; i++) {
//			sum += array[i];
//			recordThreadIndex(i);
//	}
    #pragma omp parallel
	{
		double local_sum = 0;

		#pragma omp for shared(local_sum)
		for(int i = 0; i < size; i++) {
			local_sum += array[i];
			recordThreadIndex(i);
		}

		#pragma omp critical
		sum += local_sum;
	}

	double end = omp_get_wtime();

	printSumWithTimes(sum, start, end);
	
}
]]></snapshot>
  </Command>
  <DocumentChange __id="63522" _type="Delete" date="Mon Dec 23 22:36:32 EST 2019" docASTNodeCount="1" docActiveCodeLength="612" docExpressionCount="0" docLength="700" endLine="24" length="17" offset="489" startLine="24" starttimestamp="1576666505112" timestamp="492087814">
    <text><![CDATA[shared(local_sum)]]></text>
  </DocumentChange>
  <Command __id="63521" _type="SelectTextCommand" caretOffset="506" date="Mon Dec 23 22:36:32 EST 2019" end="506" start="489" starttimestamp="1576666505112" timestamp="492087038" />
  <Command __id="63523" _type="EclipseCommand" commandID="org.eclipse.ui.edit.delete" date="Mon Dec 23 22:36:32 EST 2019" starttimestamp="1576666505112" timestamp="492087853" />
  <Command __id="63525" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Mon Dec 23 22:36:35 EST 2019" starttimestamp="1576666505112" timestamp="492090360" />
  <DocumentChange __id="63524" _type="Delete" date="Mon Dec 23 22:36:35 EST 2019" docASTNodeCount="1" docActiveCodeLength="611" docExpressionCount="0" docLength="699" endLine="24" length="1" offset="488" startLine="24" starttimestamp="1576666505112" timestamp="492090352">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <Command __id="63526" _type="EclipseCommand" commandID="org.eclipse.ui.file.save" date="Mon Dec 23 22:36:39 EST 2019" starttimestamp="1576666505112" timestamp="492094057" />
  <DocumentChange __id="63527" _type="Insert" date="Mon Dec 23 22:37:00 EST 2019" docASTNodeCount="1" docActiveCodeLength="612" docExpressionCount="0" docLength="700" length="1" offset="488" starttimestamp="1576666505112" timestamp="492115522">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <Command __id="63528" _type="InsertStringCommand" date="Mon Dec 23 22:37:00 EST 2019" starttimestamp="1576666505112" timestamp="492115529" timestamp2="492115529">
    <data><![CDATA[ ]]></data>
  </Command>
  <DocumentChange __id="63529" _type="Insert" date="Mon Dec 23 22:37:01 EST 2019" docASTNodeCount="1" docActiveCodeLength="613" docExpressionCount="0" docLength="701" length="1" offset="489" starttimestamp="1576666505112" timestamp="492116224">
    <text><![CDATA[p]]></text>
  </DocumentChange>
  <Command __id="63530" _type="InsertStringCommand" date="Mon Dec 23 22:37:01 EST 2019" starttimestamp="1576666505112" timestamp="492116242" timestamp2="492116242">
    <data><![CDATA[p]]></data>
  </Command>
  <DocumentChange __id="63531" _type="Insert" date="Mon Dec 23 22:37:01 EST 2019" docASTNodeCount="1" docActiveCodeLength="614" docExpressionCount="0" docLength="702" length="1" offset="490" starttimestamp="1576666505112" timestamp="492116445">
    <text><![CDATA[r]]></text>
  </DocumentChange>
  <Command __id="63532" _type="InsertStringCommand" date="Mon Dec 23 22:37:01 EST 2019" starttimestamp="1576666505112" timestamp="492116452" timestamp2="492116452">
    <data><![CDATA[r]]></data>
  </Command>
  <DocumentChange __id="63533" _type="Insert" date="Mon Dec 23 22:37:01 EST 2019" docASTNodeCount="1" docActiveCodeLength="615" docExpressionCount="0" docLength="703" length="1" offset="491" starttimestamp="1576666505112" timestamp="492116621">
    <text><![CDATA[i]]></text>
  </DocumentChange>
  <Command __id="63534" _type="InsertStringCommand" date="Mon Dec 23 22:37:01 EST 2019" starttimestamp="1576666505112" timestamp="492116630" timestamp2="492116630">
    <data><![CDATA[i]]></data>
  </Command>
  <DocumentChange __id="63535" _type="Insert" date="Mon Dec 23 22:37:02 EST 2019" docASTNodeCount="1" docActiveCodeLength="616" docExpressionCount="0" docLength="704" length="1" offset="492" starttimestamp="1576666505112" timestamp="492116974">
    <text><![CDATA[v]]></text>
  </DocumentChange>
  <Command __id="63536" _type="InsertStringCommand" date="Mon Dec 23 22:37:02 EST 2019" starttimestamp="1576666505112" timestamp="492116978" timestamp2="492116978">
    <data><![CDATA[v]]></data>
  </Command>
  <DocumentChange __id="63537" _type="Insert" date="Mon Dec 23 22:37:02 EST 2019" docASTNodeCount="1" docActiveCodeLength="617" docExpressionCount="0" docLength="705" length="1" offset="493" starttimestamp="1576666505112" timestamp="492117208">
    <text><![CDATA[a]]></text>
  </DocumentChange>
  <Command __id="63538" _type="InsertStringCommand" date="Mon Dec 23 22:37:02 EST 2019" starttimestamp="1576666505112" timestamp="492117214" timestamp2="492117214">
    <data><![CDATA[a]]></data>
  </Command>
  <DocumentChange __id="63539" _type="Insert" date="Mon Dec 23 22:37:02 EST 2019" docASTNodeCount="1" docActiveCodeLength="618" docExpressionCount="0" docLength="706" length="1" offset="494" starttimestamp="1576666505112" timestamp="492117387">
    <text><![CDATA[t]]></text>
  </DocumentChange>
  <Command __id="63540" _type="InsertStringCommand" date="Mon Dec 23 22:37:02 EST 2019" starttimestamp="1576666505112" timestamp="492117396" timestamp2="492117396">
    <data><![CDATA[t]]></data>
  </Command>
  <DocumentChange __id="63541" _type="Insert" date="Mon Dec 23 22:37:02 EST 2019" docASTNodeCount="1" docActiveCodeLength="619" docExpressionCount="0" docLength="707" length="1" offset="495" starttimestamp="1576666505112" timestamp="492117499">
    <text><![CDATA[e]]></text>
  </DocumentChange>
  <Command __id="63542" _type="InsertStringCommand" date="Mon Dec 23 22:37:02 EST 2019" starttimestamp="1576666505112" timestamp="492117511" timestamp2="492117511">
    <data><![CDATA[e]]></data>
  </Command>
  <DocumentChange __id="63543" _type="Insert" date="Mon Dec 23 22:37:03 EST 2019" docASTNodeCount="1" docActiveCodeLength="621" docExpressionCount="0" docLength="709" length="2" offset="496" starttimestamp="1576666505112" timestamp="492118875">
    <text><![CDATA[()]]></text>
  </DocumentChange>
  <Command __id="63544" _type="InsertStringCommand" date="Mon Dec 23 22:37:04 EST 2019" starttimestamp="1576666505112" timestamp="492118903" timestamp2="492118903">
    <data><![CDATA[(]]></data>
  </Command>
  <DocumentChange __id="63545" _type="Insert" date="Mon Dec 23 22:37:04 EST 2019" docASTNodeCount="1" docActiveCodeLength="622" docExpressionCount="0" docLength="710" length="1" offset="497" starttimestamp="1576666505112" timestamp="492119131">
    <text><![CDATA[s]]></text>
  </DocumentChange>
  <Command __id="63546" _type="InsertStringCommand" date="Mon Dec 23 22:37:04 EST 2019" starttimestamp="1576666505112" timestamp="492119138" timestamp2="492119138">
    <data><![CDATA[s]]></data>
  </Command>
  <DocumentChange __id="63547" _type="Insert" date="Mon Dec 23 22:37:04 EST 2019" docASTNodeCount="1" docActiveCodeLength="623" docExpressionCount="0" docLength="711" length="1" offset="498" starttimestamp="1576666505112" timestamp="492119242">
    <text><![CDATA[u]]></text>
  </DocumentChange>
  <Command __id="63548" _type="InsertStringCommand" date="Mon Dec 23 22:37:04 EST 2019" starttimestamp="1576666505112" timestamp="492119249" timestamp2="492119249">
    <data><![CDATA[u]]></data>
  </Command>
  <Command __id="63550" _type="InsertStringCommand" date="Mon Dec 23 22:37:04 EST 2019" starttimestamp="1576666505112" timestamp="492119499" timestamp2="492119499">
    <data><![CDATA[m]]></data>
  </Command>
  <Command __id="63551" _type="InsertStringCommand" date="Mon Dec 23 22:37:05 EST 2019" starttimestamp="1576666505112" timestamp="492120409" timestamp2="492120409">
    <data><![CDATA[)]]></data>
  </Command>
  <Command __id="63552" _type="EclipseCommand" commandID="org.eclipse.ui.file.save" date="Mon Dec 23 22:37:06 EST 2019" starttimestamp="1576666505112" timestamp="492121454" />
  <Command __id="63554" _type="RunCommand" date="Mon Dec 23 22:37:25 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="492140546" type="Run" />
  <Command __id="63555" _type="RunCommand" date="Mon Dec 23 22:37:25 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="492140546" type="Run" />
  <Command __id="63556" _type="RunCommand" date="Mon Dec 23 22:37:25 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="492140553" type="Debug" />
  <Command __id="63557" _type="RunCommand" date="Mon Dec 23 22:37:25 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="492140553" type="Run" />
  <Command __id="63558" _type="RunCommand" date="Mon Dec 23 22:37:25 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="492140553" type="Debug" />
  <Command __id="63559" _type="RunCommand" date="Mon Dec 23 22:37:25 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="492140553" type="Run" />
  <Command __id="63560" _type="EHExceptionCommand" date="Mon Dec 23 22:37:25 EST 2019" starttimestamp="1576666505112" timestamp="492140726" type="Exception">
    <outputString><![CDATA[sum_sequential
Sum: 499500
Took: 0
thread:0 lastIndex:999
_____________________________
sum_parallel_for_reduction
Sum: 499500
Took: 0
thread:0 lastIndex:124
thread:1 lastIndex:249
thread:2 lastIndex:374
thread:3 lastIndex:499
thread:4 lastIndex:624
thread:5 lastIndex:749
thread:6 lastIndex:874
thread:7 lastIndex:999
_____________________________
sum_parallel_for_local_var
Sum: 499500
Took: 0
thread:0 lastIndex:124
thread:1 lastIndex:249
thread:2 lastIndex:374
thread:3 lastIndex:499
thread:4 lastIndex:624
thread:5 lastIndex:749
thread:6 lastIndex:874
thread:7 lastIndex:999
_____________________________
sum_parallel
Sum: 499500
Took: 0
_____________________________
]]></outputString>
  </Command>
  <Command __id="63561" _type="MoveCaretCommand" caretOffset="492" date="Mon Dec 23 22:37:31 EST 2019" docOffset="492" starttimestamp="1576666505112" timestamp="492146153" />
  <Command __id="63562" _type="SelectTextCommand" caretOffset="496" date="Mon Dec 23 22:37:31 EST 2019" end="496" start="489" starttimestamp="1576666505112" timestamp="492146428" />
  <Command __id="63564" _type="InsertStringCommand" date="Mon Dec 23 22:37:32 EST 2019" starttimestamp="1576666505112" timestamp="492147359" timestamp2="492147359">
    <data><![CDATA[s]]></data>
  </Command>
  <Command __id="63566" _type="InsertStringCommand" date="Mon Dec 23 22:37:32 EST 2019" starttimestamp="1576666505112" timestamp="492147456" timestamp2="492147456">
    <data><![CDATA[h]]></data>
  </Command>
  <Command __id="63568" _type="InsertStringCommand" date="Mon Dec 23 22:37:32 EST 2019" starttimestamp="1576666505112" timestamp="492147621" timestamp2="492147621">
    <data><![CDATA[a]]></data>
  </Command>
  <Command __id="63570" _type="InsertStringCommand" date="Mon Dec 23 22:37:32 EST 2019" starttimestamp="1576666505112" timestamp="492147811" timestamp2="492147811">
    <data><![CDATA[r]]></data>
  </Command>
  <Command __id="63572" _type="InsertStringCommand" date="Mon Dec 23 22:37:33 EST 2019" starttimestamp="1576666505112" timestamp="492147917" timestamp2="492147917">
    <data><![CDATA[e]]></data>
  </Command>
  <Command __id="63574" _type="InsertStringCommand" date="Mon Dec 23 22:37:33 EST 2019" starttimestamp="1576666505112" timestamp="492148079" timestamp2="492148079">
    <data><![CDATA[d]]></data>
  </Command>
  <Command __id="63575" _type="EclipseCommand" commandID="org.eclipse.ui.file.save" date="Mon Dec 23 22:37:35 EST 2019" starttimestamp="1576666505112" timestamp="492150788" />
  <Command __id="63576" _type="EclipseCommand" commandID="org.eclipse.ui.edit.text.showRulerContextMenu" date="Mon Dec 23 22:37:37 EST 2019" starttimestamp="1576666505112" timestamp="492152462" />
  <Command __id="63577" _type="MoveCaretCommand" caretOffset="469" date="Mon Dec 23 22:37:40 EST 2019" docOffset="469" starttimestamp="1576666505112" timestamp="492155626" />
  <Command __id="63578" _type="EclipseCommand" commandID="org.eclipse.debug.ui.commands.RunLast" date="Mon Dec 23 22:37:42 EST 2019" starttimestamp="1576666505112" timestamp="492156952" />
  <Command __id="63579" _type="ShellCommand" date="Mon Dec 23 22:37:43 EST 2019" starttimestamp="1576666505112" timestamp="492158200" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="63580" _type="ShellCommand" date="Mon Dec 23 22:37:45 EST 2019" starttimestamp="1576666505112" timestamp="492160793" type="ECLIPSE_GAINED_FOCUS" />
  <DocumentChange __id="63549" _type="Insert" date="Mon Dec 23 22:37:04 EST 2019" docASTNodeCount="1" docActiveCodeLength="624" docExpressionCount="0" docLength="712" length="1" offset="499" starttimestamp="1576666505112" timestamp="492119487">
    <text><![CDATA[m]]></text>
  </DocumentChange>
  <DocumentChange __id="63563" _type="Replace" date="Mon Dec 23 22:37:32 EST 2019" docASTNodeCount="1" docActiveCodeLength="618" docExpressionCount="0" docLength="706" endLine="24" insertionLength="1" int_docASTNodeCount="1" int_docActiveCodeLength="617" int_docExpressionCount="0" int_docLength="705" length="7" offset="489" startLine="24" starttimestamp="1576666505112" timestamp="492147317">
    <deletedText><![CDATA[private]]></deletedText>
    <insertedText><![CDATA[s]]></insertedText>
  </DocumentChange>
  <DocumentChange __id="63565" _type="Insert" date="Mon Dec 23 22:37:32 EST 2019" docASTNodeCount="1" docActiveCodeLength="619" docExpressionCount="0" docLength="707" length="1" offset="490" starttimestamp="1576666505112" timestamp="492147445">
    <text><![CDATA[h]]></text>
  </DocumentChange>
  <DocumentChange __id="63567" _type="Insert" date="Mon Dec 23 22:37:32 EST 2019" docASTNodeCount="1" docActiveCodeLength="620" docExpressionCount="0" docLength="708" length="1" offset="491" starttimestamp="1576666505112" timestamp="492147614">
    <text><![CDATA[a]]></text>
  </DocumentChange>
  <DocumentChange __id="63569" _type="Insert" date="Mon Dec 23 22:37:32 EST 2019" docASTNodeCount="1" docActiveCodeLength="621" docExpressionCount="0" docLength="709" length="1" offset="492" starttimestamp="1576666505112" timestamp="492147802">
    <text><![CDATA[r]]></text>
  </DocumentChange>
  <DocumentChange __id="63571" _type="Insert" date="Mon Dec 23 22:37:33 EST 2019" docASTNodeCount="1" docActiveCodeLength="622" docExpressionCount="0" docLength="710" length="1" offset="493" starttimestamp="1576666505112" timestamp="492147905">
    <text><![CDATA[e]]></text>
  </DocumentChange>
  <DocumentChange __id="63573" _type="Insert" date="Mon Dec 23 22:37:33 EST 2019" docASTNodeCount="1" docActiveCodeLength="623" docExpressionCount="0" docLength="711" length="1" offset="494" starttimestamp="1576666505112" timestamp="492148072">
    <text><![CDATA[d]]></text>
  </DocumentChange>
  <DocumentChange __id="63582" _type="Delete" date="Mon Dec 23 22:37:55 EST 2019" docASTNodeCount="1" docActiveCodeLength="612" docExpressionCount="0" docLength="700" endLine="24" length="11" offset="489" startLine="24" starttimestamp="1576666505112" timestamp="492170694">
    <text><![CDATA[shared(sum)]]></text>
  </DocumentChange>
  <Command __id="63581" _type="SelectTextCommand" caretOffset="500" date="Mon Dec 23 22:37:55 EST 2019" end="500" start="489" starttimestamp="1576666505112" timestamp="492169920" />
  <Command __id="63583" _type="EclipseCommand" commandID="org.eclipse.ui.edit.delete" date="Mon Dec 23 22:37:55 EST 2019" starttimestamp="1576666505112" timestamp="492170720" />
  <Command __id="63585" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Mon Dec 23 22:37:58 EST 2019" starttimestamp="1576666505112" timestamp="492173393" />
  <Command __id="63586" _type="EclipseCommand" commandID="org.eclipse.ui.file.save" date="Mon Dec 23 22:38:00 EST 2019" starttimestamp="1576666505112" timestamp="492174959" />
  <Command __id="63587" _type="ShellCommand" date="Mon Dec 23 22:38:09 EST 2019" starttimestamp="1576666505112" timestamp="492184409" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="63588" _type="ShellCommand" date="Mon Dec 23 22:38:25 EST 2019" starttimestamp="1576666505112" timestamp="492200869" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="63589" _type="MoveCaretCommand" caretOffset="390" date="Mon Dec 23 22:38:35 EST 2019" docOffset="390" starttimestamp="1576666505112" timestamp="492210301" />
  <Command __id="63590" _type="MoveCaretCommand" caretOffset="417" date="Mon Dec 23 22:38:36 EST 2019" docOffset="417" starttimestamp="1576666505112" timestamp="492211877" />
  <Command __id="63592" _type="InsertStringCommand" date="Mon Dec 23 22:38:37 EST 2019" starttimestamp="1576666505112" timestamp="492212822" timestamp2="492212822">
    <data><![CDATA[]]></data>
  </Command>
  <Command __id="63594" _type="InsertStringCommand" date="Mon Dec 23 22:38:38 EST 2019" starttimestamp="1576666505112" timestamp="492213520" timestamp2="492213520">
    <data><![CDATA[i]]></data>
  </Command>
  <Command __id="63596" _type="InsertStringCommand" date="Mon Dec 23 22:38:38 EST 2019" starttimestamp="1576666505112" timestamp="492213788" timestamp2="492213788">
    <data><![CDATA[n]]></data>
  </Command>
  <Command __id="63598" _type="InsertStringCommand" date="Mon Dec 23 22:38:39 EST 2019" starttimestamp="1576666505112" timestamp="492213893" timestamp2="492213893">
    <data><![CDATA[t]]></data>
  </Command>
  <Command __id="63600" _type="InsertStringCommand" date="Mon Dec 23 22:38:39 EST 2019" starttimestamp="1576666505112" timestamp="492214095" timestamp2="492214095">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="63602" _type="InsertStringCommand" date="Mon Dec 23 22:38:39 EST 2019" starttimestamp="1576666505112" timestamp="492214299" timestamp2="492214299">
    <data><![CDATA[i]]></data>
  </Command>
  <Command __id="63604" _type="InsertStringCommand" date="Mon Dec 23 22:38:40 EST 2019" starttimestamp="1576666505112" timestamp="492215148" timestamp2="492215148">
    <data><![CDATA[;]]></data>
  </Command>
  <Command __id="63605" _type="MoveCaretCommand" caretOffset="507" date="Mon Dec 23 22:38:42 EST 2019" docOffset="507" starttimestamp="1576666505112" timestamp="492217684" />
  <Command __id="63607" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Mon Dec 23 22:38:43 EST 2019" starttimestamp="1576666505112" timestamp="492218182" />
  <Command __id="63609" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Mon Dec 23 22:38:43 EST 2019" starttimestamp="1576666505112" timestamp="492218353" />
  <Command __id="63611" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Mon Dec 23 22:38:43 EST 2019" starttimestamp="1576666505112" timestamp="492218528" />
  <Command __id="63613" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Mon Dec 23 22:38:44 EST 2019" starttimestamp="1576666505112" timestamp="492219204" />
  <Command __id="63614" _type="MoveCaretCommand" caretOffset="496" date="Mon Dec 23 22:38:46 EST 2019" docOffset="496" starttimestamp="1576666505112" timestamp="492221176" />
  <Command __id="63616" _type="InsertStringCommand" date="Mon Dec 23 22:38:46 EST 2019" starttimestamp="1576666505112" timestamp="492221500" timestamp2="492221500">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="63618" _type="InsertStringCommand" date="Mon Dec 23 22:38:46 EST 2019" starttimestamp="1576666505112" timestamp="492221690" timestamp2="492221690">
    <data><![CDATA[s]]></data>
  </Command>
  <Command __id="63620" _type="InsertStringCommand" date="Mon Dec 23 22:38:46 EST 2019" starttimestamp="1576666505112" timestamp="492221799" timestamp2="492221799">
    <data><![CDATA[h]]></data>
  </Command>
  <Command __id="63622" _type="InsertStringCommand" date="Mon Dec 23 22:38:47 EST 2019" starttimestamp="1576666505112" timestamp="492221942" timestamp2="492221942">
    <data><![CDATA[a]]></data>
  </Command>
  <Command __id="63624" _type="InsertStringCommand" date="Mon Dec 23 22:38:47 EST 2019" starttimestamp="1576666505112" timestamp="492222097" timestamp2="492222097">
    <data><![CDATA[r]]></data>
  </Command>
  <Command __id="63626" _type="InsertStringCommand" date="Mon Dec 23 22:38:47 EST 2019" starttimestamp="1576666505112" timestamp="492222170" timestamp2="492222170">
    <data><![CDATA[e]]></data>
  </Command>
  <Command __id="63628" _type="InsertStringCommand" date="Mon Dec 23 22:38:47 EST 2019" starttimestamp="1576666505112" timestamp="492222341" timestamp2="492222341">
    <data><![CDATA[d]]></data>
  </Command>
  <Command __id="63630" _type="InsertStringCommand" date="Mon Dec 23 22:38:48 EST 2019" starttimestamp="1576666505112" timestamp="492223146" timestamp2="492223146">
    <data><![CDATA[(]]></data>
  </Command>
  <Command __id="63632" _type="InsertStringCommand" date="Mon Dec 23 22:38:48 EST 2019" starttimestamp="1576666505112" timestamp="492223397" timestamp2="492223397">
    <data><![CDATA[i]]></data>
  </Command>
  <Command __id="63633" _type="EclipseCommand" commandID="org.eclipse.ui.file.save" date="Mon Dec 23 22:38:50 EST 2019" starttimestamp="1576666505112" timestamp="492225467" />
  <Command __id="63634" _type="EclipseCommand" commandID="org.eclipse.debug.ui.commands.RunLast" date="Mon Dec 23 22:38:53 EST 2019" starttimestamp="1576666505112" timestamp="492228066" />
  <Command __id="63635" _type="ShellCommand" date="Mon Dec 23 22:38:53 EST 2019" starttimestamp="1576666505112" timestamp="492228444" type="ECLIPSE_LOST_FOCUS" />
  <DocumentChange __id="63584" _type="Delete" date="Mon Dec 23 22:37:58 EST 2019" docASTNodeCount="1" docActiveCodeLength="611" docExpressionCount="0" docLength="699" endLine="24" length="1" offset="488" startLine="24" starttimestamp="1576666505112" timestamp="492173385">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="63591" _type="Insert" date="Mon Dec 23 22:38:37 EST 2019" docASTNodeCount="1" docActiveCodeLength="613" docExpressionCount="0" docLength="701" length="2" offset="417" starttimestamp="1576666505112" timestamp="492212808">
    <text><![CDATA[
	]]></text>
  </DocumentChange>
  <DocumentChange __id="63593" _type="Insert" date="Mon Dec 23 22:38:38 EST 2019" docASTNodeCount="1" docActiveCodeLength="614" docExpressionCount="0" docLength="702" length="1" offset="419" starttimestamp="1576666505112" timestamp="492213517">
    <text><![CDATA[i]]></text>
  </DocumentChange>
  <DocumentChange __id="63595" _type="Insert" date="Mon Dec 23 22:38:38 EST 2019" docASTNodeCount="1" docActiveCodeLength="615" docExpressionCount="0" docLength="703" length="1" offset="420" starttimestamp="1576666505112" timestamp="492213783">
    <text><![CDATA[n]]></text>
  </DocumentChange>
  <DocumentChange __id="63597" _type="Insert" date="Mon Dec 23 22:38:39 EST 2019" docASTNodeCount="1" docActiveCodeLength="616" docExpressionCount="0" docLength="704" length="1" offset="421" starttimestamp="1576666505112" timestamp="492213889">
    <text><![CDATA[t]]></text>
  </DocumentChange>
  <DocumentChange __id="63599" _type="Insert" date="Mon Dec 23 22:38:39 EST 2019" docASTNodeCount="1" docActiveCodeLength="617" docExpressionCount="0" docLength="705" length="1" offset="422" starttimestamp="1576666505112" timestamp="492214088">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="63601" _type="Insert" date="Mon Dec 23 22:38:39 EST 2019" docASTNodeCount="1" docActiveCodeLength="618" docExpressionCount="0" docLength="706" length="1" offset="423" starttimestamp="1576666505112" timestamp="492214294">
    <text><![CDATA[i]]></text>
  </DocumentChange>
  <DocumentChange __id="63603" _type="Insert" date="Mon Dec 23 22:38:40 EST 2019" docASTNodeCount="1" docActiveCodeLength="619" docExpressionCount="0" docLength="707" length="1" offset="424" starttimestamp="1576666505112" timestamp="492215144">
    <text><![CDATA[;]]></text>
  </DocumentChange>
  <DocumentChange __id="63606" _type="Delete" date="Mon Dec 23 22:38:43 EST 2019" docASTNodeCount="1" docActiveCodeLength="618" docExpressionCount="0" docLength="706" endLine="26" length="1" offset="506" startLine="26" starttimestamp="1576666505112" timestamp="492218182">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="63608" _type="Delete" date="Mon Dec 23 22:38:43 EST 2019" docASTNodeCount="1" docActiveCodeLength="617" docExpressionCount="0" docLength="705" endLine="26" length="1" offset="505" startLine="26" starttimestamp="1576666505112" timestamp="492218344">
    <text><![CDATA[t]]></text>
  </DocumentChange>
  <DocumentChange __id="63610" _type="Delete" date="Mon Dec 23 22:38:43 EST 2019" docASTNodeCount="1" docActiveCodeLength="616" docExpressionCount="0" docLength="704" endLine="26" length="1" offset="504" startLine="26" starttimestamp="1576666505112" timestamp="492218519">
    <text><![CDATA[n]]></text>
  </DocumentChange>
  <DocumentChange __id="63612" _type="Delete" date="Mon Dec 23 22:38:44 EST 2019" docASTNodeCount="1" docActiveCodeLength="615" docExpressionCount="0" docLength="703" endLine="26" length="1" offset="503" startLine="26" starttimestamp="1576666505112" timestamp="492219198">
    <text><![CDATA[i]]></text>
  </DocumentChange>
  <DocumentChange __id="63615" _type="Insert" date="Mon Dec 23 22:38:46 EST 2019" docASTNodeCount="1" docActiveCodeLength="616" docExpressionCount="0" docLength="704" length="1" offset="496" starttimestamp="1576666505112" timestamp="492221498">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="63617" _type="Insert" date="Mon Dec 23 22:38:46 EST 2019" docASTNodeCount="1" docActiveCodeLength="617" docExpressionCount="0" docLength="705" length="1" offset="497" starttimestamp="1576666505112" timestamp="492221678">
    <text><![CDATA[s]]></text>
  </DocumentChange>
  <DocumentChange __id="63619" _type="Insert" date="Mon Dec 23 22:38:46 EST 2019" docASTNodeCount="1" docActiveCodeLength="618" docExpressionCount="0" docLength="706" length="1" offset="498" starttimestamp="1576666505112" timestamp="492221790">
    <text><![CDATA[h]]></text>
  </DocumentChange>
  <DocumentChange __id="63621" _type="Insert" date="Mon Dec 23 22:38:47 EST 2019" docASTNodeCount="1" docActiveCodeLength="619" docExpressionCount="0" docLength="707" length="1" offset="499" starttimestamp="1576666505112" timestamp="492221934">
    <text><![CDATA[a]]></text>
  </DocumentChange>
  <DocumentChange __id="63623" _type="Insert" date="Mon Dec 23 22:38:47 EST 2019" docASTNodeCount="1" docActiveCodeLength="620" docExpressionCount="0" docLength="708" length="1" offset="500" starttimestamp="1576666505112" timestamp="492222087">
    <text><![CDATA[r]]></text>
  </DocumentChange>
  <DocumentChange __id="63625" _type="Insert" date="Mon Dec 23 22:38:47 EST 2019" docASTNodeCount="1" docActiveCodeLength="621" docExpressionCount="0" docLength="709" length="1" offset="501" starttimestamp="1576666505112" timestamp="492222161">
    <text><![CDATA[e]]></text>
  </DocumentChange>
  <DocumentChange __id="63627" _type="Insert" date="Mon Dec 23 22:38:47 EST 2019" docASTNodeCount="1" docActiveCodeLength="622" docExpressionCount="0" docLength="710" length="1" offset="502" starttimestamp="1576666505112" timestamp="492222336">
    <text><![CDATA[d]]></text>
  </DocumentChange>
  <DocumentChange __id="63629" _type="Insert" date="Mon Dec 23 22:38:48 EST 2019" docASTNodeCount="1" docActiveCodeLength="624" docExpressionCount="0" docLength="712" length="2" offset="503" starttimestamp="1576666505112" timestamp="492223138">
    <text><![CDATA[()]]></text>
  </DocumentChange>
  <DocumentChange __id="63631" _type="Insert" date="Mon Dec 23 22:38:48 EST 2019" docASTNodeCount="1" docActiveCodeLength="625" docExpressionCount="0" docLength="713" length="1" offset="504" starttimestamp="1576666505112" timestamp="492223391">
    <text><![CDATA[i]]></text>
  </DocumentChange>
  <Command __id="63636" _type="ShellCommand" date="Mon Dec 23 22:38:55 EST 2019" starttimestamp="1576666505112" timestamp="492230286" type="ECLIPSE_GAINED_FOCUS" />
  <DocumentChange __id="63637" _type="Delete" date="Mon Dec 23 22:39:03 EST 2019" docASTNodeCount="1" docActiveCodeLength="624" docExpressionCount="0" docLength="712" endLine="25" length="1" offset="505" startLine="25" starttimestamp="1576666505112" timestamp="492238876">
    <text><![CDATA[)]]></text>
  </DocumentChange>
  <Command __id="63638" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Mon Dec 23 22:39:04 EST 2019" starttimestamp="1576666505112" timestamp="492238906" />
  <DocumentChange __id="63639" _type="Delete" date="Mon Dec 23 22:39:04 EST 2019" docASTNodeCount="1" docActiveCodeLength="623" docExpressionCount="0" docLength="711" endLine="25" length="1" offset="504" startLine="25" starttimestamp="1576666505112" timestamp="492239162">
    <text><![CDATA[i]]></text>
  </DocumentChange>
  <Command __id="63640" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Mon Dec 23 22:39:04 EST 2019" starttimestamp="1576666505112" timestamp="492239163" />
  <DocumentChange __id="63641" _type="Delete" date="Mon Dec 23 22:39:04 EST 2019" docASTNodeCount="1" docActiveCodeLength="622" docExpressionCount="0" docLength="710" endLine="25" length="1" offset="503" startLine="25" starttimestamp="1576666505112" timestamp="492239342">
    <text><![CDATA[(]]></text>
  </DocumentChange>
  <Command __id="63642" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Mon Dec 23 22:39:04 EST 2019" starttimestamp="1576666505112" timestamp="492239346" />
  <DocumentChange __id="63643" _type="Delete" date="Mon Dec 23 22:39:04 EST 2019" docASTNodeCount="1" docActiveCodeLength="621" docExpressionCount="0" docLength="709" endLine="25" length="1" offset="502" startLine="25" starttimestamp="1576666505112" timestamp="492239517">
    <text><![CDATA[d]]></text>
  </DocumentChange>
  <Command __id="63644" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Mon Dec 23 22:39:04 EST 2019" starttimestamp="1576666505112" timestamp="492239520" />
  <DocumentChange __id="63645" _type="Delete" date="Mon Dec 23 22:39:04 EST 2019" docASTNodeCount="1" docActiveCodeLength="620" docExpressionCount="0" docLength="708" endLine="25" length="1" offset="501" startLine="25" starttimestamp="1576666505112" timestamp="492239682">
    <text><![CDATA[e]]></text>
  </DocumentChange>
  <Command __id="63646" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Mon Dec 23 22:39:04 EST 2019" starttimestamp="1576666505112" timestamp="492239689" />
  <DocumentChange __id="63647" _type="Delete" date="Mon Dec 23 22:39:05 EST 2019" docASTNodeCount="1" docActiveCodeLength="619" docExpressionCount="0" docLength="707" endLine="25" length="1" offset="500" startLine="25" starttimestamp="1576666505112" timestamp="492239894">
    <text><![CDATA[r]]></text>
  </DocumentChange>
  <Command __id="63648" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Mon Dec 23 22:39:05 EST 2019" starttimestamp="1576666505112" timestamp="492239901" />
  <DocumentChange __id="63649" _type="Delete" date="Mon Dec 23 22:39:05 EST 2019" docASTNodeCount="1" docActiveCodeLength="618" docExpressionCount="0" docLength="706" endLine="25" length="1" offset="499" startLine="25" starttimestamp="1576666505112" timestamp="492240089">
    <text><![CDATA[a]]></text>
  </DocumentChange>
  <Command __id="63650" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Mon Dec 23 22:39:05 EST 2019" starttimestamp="1576666505112" timestamp="492240097" />
  <DocumentChange __id="63651" _type="Delete" date="Mon Dec 23 22:39:05 EST 2019" docASTNodeCount="1" docActiveCodeLength="617" docExpressionCount="0" docLength="705" endLine="25" length="1" offset="498" startLine="25" starttimestamp="1576666505112" timestamp="492240260">
    <text><![CDATA[h]]></text>
  </DocumentChange>
  <Command __id="63652" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Mon Dec 23 22:39:05 EST 2019" starttimestamp="1576666505112" timestamp="492240264" />
  <DocumentChange __id="63653" _type="Delete" date="Mon Dec 23 22:39:05 EST 2019" docASTNodeCount="1" docActiveCodeLength="616" docExpressionCount="0" docLength="704" endLine="25" length="1" offset="497" startLine="25" starttimestamp="1576666505112" timestamp="492240415">
    <text><![CDATA[s]]></text>
  </DocumentChange>
  <Command __id="63654" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Mon Dec 23 22:39:05 EST 2019" starttimestamp="1576666505112" timestamp="492240419" />
  <Command __id="63656" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Mon Dec 23 22:39:05 EST 2019" starttimestamp="1576666505112" timestamp="492240578" />
  <Command __id="63657" _type="MoveCaretCommand" caretOffset="503" date="Mon Dec 23 22:39:09 EST 2019" docOffset="503" starttimestamp="1576666505112" timestamp="492244033" />
  <Command __id="63659" _type="InsertStringCommand" date="Mon Dec 23 22:39:09 EST 2019" starttimestamp="1576666505112" timestamp="492244726" timestamp2="492244726">
    <data><![CDATA[i]]></data>
  </Command>
  <Command __id="63661" _type="InsertStringCommand" date="Mon Dec 23 22:39:10 EST 2019" starttimestamp="1576666505112" timestamp="492245025" timestamp2="492245025">
    <data><![CDATA[n]]></data>
  </Command>
  <Command __id="63663" _type="InsertStringCommand" date="Mon Dec 23 22:39:10 EST 2019" starttimestamp="1576666505112" timestamp="492245340" timestamp2="492245340">
    <data><![CDATA[t]]></data>
  </Command>
  <Command __id="63665" _type="InsertStringCommand" date="Mon Dec 23 22:39:10 EST 2019" starttimestamp="1576666505112" timestamp="492245726" timestamp2="492245726">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="63666" _type="MoveCaretCommand" caretOffset="422" date="Mon Dec 23 22:39:14 EST 2019" docOffset="422" starttimestamp="1576666505112" timestamp="492249272" />
  <Command __id="63667" _type="SelectTextCommand" caretOffset="422" date="Mon Dec 23 22:39:14 EST 2019" end="422" start="419" starttimestamp="1576666505112" timestamp="492249465" />
  <Command __id="63668" _type="SelectTextCommand" caretOffset="426" date="Mon Dec 23 22:39:15 EST 2019" end="426" start="418" starttimestamp="1576666505112" timestamp="492249955" />
  <Command __id="63670" _type="EclipseCommand" commandID="org.eclipse.ui.edit.delete" date="Mon Dec 23 22:39:15 EST 2019" starttimestamp="1576666505112" timestamp="492250811" />
  <Command __id="63671" _type="EclipseCommand" commandID="org.eclipse.ui.file.save" date="Mon Dec 23 22:39:17 EST 2019" starttimestamp="1576666505112" timestamp="492252084" />
  <DocumentChange __id="63655" _type="Delete" date="Mon Dec 23 22:39:05 EST 2019" docASTNodeCount="1" docActiveCodeLength="615" docExpressionCount="0" docLength="703" endLine="25" length="1" offset="496" startLine="25" starttimestamp="1576666505112" timestamp="492240567">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="63658" _type="Insert" date="Mon Dec 23 22:39:09 EST 2019" docASTNodeCount="1" docActiveCodeLength="616" docExpressionCount="0" docLength="704" length="1" offset="503" starttimestamp="1576666505112" timestamp="492244708">
    <text><![CDATA[i]]></text>
  </DocumentChange>
  <DocumentChange __id="63660" _type="Insert" date="Mon Dec 23 22:39:10 EST 2019" docASTNodeCount="1" docActiveCodeLength="617" docExpressionCount="0" docLength="705" length="1" offset="504" starttimestamp="1576666505112" timestamp="492245011">
    <text><![CDATA[n]]></text>
  </DocumentChange>
  <DocumentChange __id="63662" _type="Insert" date="Mon Dec 23 22:39:10 EST 2019" docASTNodeCount="1" docActiveCodeLength="618" docExpressionCount="0" docLength="706" length="1" offset="505" starttimestamp="1576666505112" timestamp="492245333">
    <text><![CDATA[t]]></text>
  </DocumentChange>
  <DocumentChange __id="63664" _type="Insert" date="Mon Dec 23 22:39:10 EST 2019" docASTNodeCount="1" docActiveCodeLength="619" docExpressionCount="0" docLength="707" length="1" offset="506" starttimestamp="1576666505112" timestamp="492245721">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="63669" _type="Delete" date="Mon Dec 23 22:39:15 EST 2019" docASTNodeCount="1" docActiveCodeLength="611" docExpressionCount="0" docLength="699" endLine="21" length="8" offset="418" startLine="20" starttimestamp="1576666505112" timestamp="492250789">
    <text><![CDATA[	int i;
]]></text>
  </DocumentChange>
  <Command __id="63672" _type="MoveCaretCommand" caretOffset="488" date="Mon Dec 23 22:39:19 EST 2019" docOffset="488" starttimestamp="1576666505112" timestamp="492254734" />
  <DocumentChange __id="63673" _type="Insert" date="Mon Dec 23 22:39:23 EST 2019" docASTNodeCount="1" docActiveCodeLength="612" docExpressionCount="0" docLength="700" length="1" offset="488" starttimestamp="1576666505112" timestamp="492258602">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <Command __id="63674" _type="InsertStringCommand" date="Mon Dec 23 22:39:23 EST 2019" starttimestamp="1576666505112" timestamp="492258606" timestamp2="492258606">
    <data><![CDATA[ ]]></data>
  </Command>
  <DocumentChange __id="63675" _type="Insert" date="Mon Dec 23 22:39:23 EST 2019" docASTNodeCount="1" docActiveCodeLength="613" docExpressionCount="0" docLength="701" length="1" offset="489" starttimestamp="1576666505112" timestamp="492258866">
    <text><![CDATA[p]]></text>
  </DocumentChange>
  <Command __id="63676" _type="InsertStringCommand" date="Mon Dec 23 22:39:23 EST 2019" starttimestamp="1576666505112" timestamp="492258870" timestamp2="492258870">
    <data><![CDATA[p]]></data>
  </Command>
  <DocumentChange __id="63677" _type="Insert" date="Mon Dec 23 22:39:24 EST 2019" docASTNodeCount="1" docActiveCodeLength="614" docExpressionCount="0" docLength="702" length="1" offset="490" starttimestamp="1576666505112" timestamp="492259064">
    <text><![CDATA[r]]></text>
  </DocumentChange>
  <Command __id="63678" _type="InsertStringCommand" date="Mon Dec 23 22:39:24 EST 2019" starttimestamp="1576666505112" timestamp="492259079" timestamp2="492259079">
    <data><![CDATA[r]]></data>
  </Command>
  <DocumentChange __id="63679" _type="Insert" date="Mon Dec 23 22:39:24 EST 2019" docASTNodeCount="1" docActiveCodeLength="615" docExpressionCount="0" docLength="703" length="1" offset="491" starttimestamp="1576666505112" timestamp="492259210">
    <text><![CDATA[o]]></text>
  </DocumentChange>
  <Command __id="63680" _type="InsertStringCommand" date="Mon Dec 23 22:39:24 EST 2019" starttimestamp="1576666505112" timestamp="492259219" timestamp2="492259219">
    <data><![CDATA[o]]></data>
  </Command>
  <DocumentChange __id="63681" _type="Insert" date="Mon Dec 23 22:39:24 EST 2019" docASTNodeCount="1" docActiveCodeLength="616" docExpressionCount="0" docLength="704" length="1" offset="492" starttimestamp="1576666505112" timestamp="492259607">
    <text><![CDATA[v]]></text>
  </DocumentChange>
  <Command __id="63682" _type="InsertStringCommand" date="Mon Dec 23 22:39:24 EST 2019" starttimestamp="1576666505112" timestamp="492259611" timestamp2="492259611">
    <data><![CDATA[v]]></data>
  </Command>
  <DocumentChange __id="63683" _type="Insert" date="Mon Dec 23 22:39:24 EST 2019" docASTNodeCount="1" docActiveCodeLength="617" docExpressionCount="0" docLength="705" length="1" offset="493" starttimestamp="1576666505112" timestamp="492259878">
    <text><![CDATA[a]]></text>
  </DocumentChange>
  <Command __id="63684" _type="InsertStringCommand" date="Mon Dec 23 22:39:25 EST 2019" starttimestamp="1576666505112" timestamp="492259889" timestamp2="492259889">
    <data><![CDATA[a]]></data>
  </Command>
  <DocumentChange __id="63685" _type="Insert" date="Mon Dec 23 22:39:25 EST 2019" docASTNodeCount="1" docActiveCodeLength="618" docExpressionCount="0" docLength="706" length="1" offset="494" starttimestamp="1576666505112" timestamp="492260070">
    <text><![CDATA[t]]></text>
  </DocumentChange>
  <Command __id="63686" _type="InsertStringCommand" date="Mon Dec 23 22:39:25 EST 2019" starttimestamp="1576666505112" timestamp="492260077" timestamp2="492260077">
    <data><![CDATA[t]]></data>
  </Command>
  <DocumentChange __id="63687" _type="Insert" date="Mon Dec 23 22:39:25 EST 2019" docASTNodeCount="1" docActiveCodeLength="619" docExpressionCount="0" docLength="707" length="1" offset="495" starttimestamp="1576666505112" timestamp="492260179">
    <text><![CDATA[e]]></text>
  </DocumentChange>
  <Command __id="63688" _type="InsertStringCommand" date="Mon Dec 23 22:39:25 EST 2019" starttimestamp="1576666505112" timestamp="492260188" timestamp2="492260188">
    <data><![CDATA[e]]></data>
  </Command>
  <DocumentChange __id="63689" _type="Delete" date="Mon Dec 23 22:39:25 EST 2019" docASTNodeCount="1" docActiveCodeLength="618" docExpressionCount="0" docLength="706" endLine="24" length="1" offset="495" startLine="24" starttimestamp="1576666505112" timestamp="492260605">
    <text><![CDATA[e]]></text>
  </DocumentChange>
  <Command __id="63690" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Mon Dec 23 22:39:25 EST 2019" starttimestamp="1576666505112" timestamp="492260609" />
  <DocumentChange __id="63691" _type="Delete" date="Mon Dec 23 22:39:25 EST 2019" docASTNodeCount="1" docActiveCodeLength="617" docExpressionCount="0" docLength="705" endLine="24" length="1" offset="494" startLine="24" starttimestamp="1576666505112" timestamp="492260760">
    <text><![CDATA[t]]></text>
  </DocumentChange>
  <Command __id="63692" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Mon Dec 23 22:39:25 EST 2019" starttimestamp="1576666505112" timestamp="492260766" />
  <DocumentChange __id="63693" _type="Delete" date="Mon Dec 23 22:39:26 EST 2019" docASTNodeCount="1" docActiveCodeLength="616" docExpressionCount="0" docLength="704" endLine="24" length="1" offset="493" startLine="24" starttimestamp="1576666505112" timestamp="492260945">
    <text><![CDATA[a]]></text>
  </DocumentChange>
  <Command __id="63694" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Mon Dec 23 22:39:26 EST 2019" starttimestamp="1576666505112" timestamp="492260948" />
  <DocumentChange __id="63695" _type="Delete" date="Mon Dec 23 22:39:26 EST 2019" docASTNodeCount="1" docActiveCodeLength="615" docExpressionCount="0" docLength="703" endLine="24" length="1" offset="492" startLine="24" starttimestamp="1576666505112" timestamp="492261128">
    <text><![CDATA[v]]></text>
  </DocumentChange>
  <Command __id="63696" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Mon Dec 23 22:39:26 EST 2019" starttimestamp="1576666505112" timestamp="492261138" />
  <DocumentChange __id="63697" _type="Delete" date="Mon Dec 23 22:39:26 EST 2019" docASTNodeCount="1" docActiveCodeLength="614" docExpressionCount="0" docLength="702" endLine="24" length="1" offset="491" startLine="24" starttimestamp="1576666505112" timestamp="492261302">
    <text><![CDATA[o]]></text>
  </DocumentChange>
  <Command __id="63698" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Mon Dec 23 22:39:26 EST 2019" starttimestamp="1576666505112" timestamp="492261311" />
  <DocumentChange __id="63699" _type="Insert" date="Mon Dec 23 22:39:27 EST 2019" docASTNodeCount="1" docActiveCodeLength="615" docExpressionCount="0" docLength="703" length="1" offset="491" starttimestamp="1576666505112" timestamp="492262035">
    <text><![CDATA[i]]></text>
  </DocumentChange>
  <Command __id="63700" _type="InsertStringCommand" date="Mon Dec 23 22:39:27 EST 2019" starttimestamp="1576666505112" timestamp="492262038" timestamp2="492262038">
    <data><![CDATA[i]]></data>
  </Command>
  <DocumentChange __id="63701" _type="Insert" date="Mon Dec 23 22:39:27 EST 2019" docASTNodeCount="1" docActiveCodeLength="616" docExpressionCount="0" docLength="704" length="1" offset="492" starttimestamp="1576666505112" timestamp="492262423">
    <text><![CDATA[v]]></text>
  </DocumentChange>
  <Command __id="63702" _type="InsertStringCommand" date="Mon Dec 23 22:39:27 EST 2019" starttimestamp="1576666505112" timestamp="492262433" timestamp2="492262433">
    <data><![CDATA[v]]></data>
  </Command>
  <DocumentChange __id="63703" _type="Insert" date="Mon Dec 23 22:39:27 EST 2019" docASTNodeCount="1" docActiveCodeLength="617" docExpressionCount="0" docLength="705" length="1" offset="493" starttimestamp="1576666505112" timestamp="492262557">
    <text><![CDATA[a]]></text>
  </DocumentChange>
  <Command __id="63704" _type="InsertStringCommand" date="Mon Dec 23 22:39:27 EST 2019" starttimestamp="1576666505112" timestamp="492262561" timestamp2="492262561">
    <data><![CDATA[a]]></data>
  </Command>
  <DocumentChange __id="63705" _type="Insert" date="Mon Dec 23 22:39:27 EST 2019" docASTNodeCount="1" docActiveCodeLength="618" docExpressionCount="0" docLength="706" length="1" offset="494" starttimestamp="1576666505112" timestamp="492262717">
    <text><![CDATA[t]]></text>
  </DocumentChange>
  <Command __id="63706" _type="InsertStringCommand" date="Mon Dec 23 22:39:27 EST 2019" starttimestamp="1576666505112" timestamp="492262727" timestamp2="492262727">
    <data><![CDATA[t]]></data>
  </Command>
  <DocumentChange __id="63707" _type="Insert" date="Mon Dec 23 22:39:27 EST 2019" docASTNodeCount="1" docActiveCodeLength="619" docExpressionCount="0" docLength="707" length="1" offset="495" starttimestamp="1576666505112" timestamp="492262798">
    <text><![CDATA[e]]></text>
  </DocumentChange>
  <Command __id="63708" _type="InsertStringCommand" date="Mon Dec 23 22:39:27 EST 2019" starttimestamp="1576666505112" timestamp="492262804" timestamp2="492262804">
    <data><![CDATA[e]]></data>
  </Command>
  <DocumentChange __id="63709" _type="Insert" date="Mon Dec 23 22:39:28 EST 2019" docASTNodeCount="1" docActiveCodeLength="621" docExpressionCount="0" docLength="709" length="2" offset="496" starttimestamp="1576666505112" timestamp="492263852">
    <text><![CDATA[()]]></text>
  </DocumentChange>
  <Command __id="63710" _type="InsertStringCommand" date="Mon Dec 23 22:39:28 EST 2019" starttimestamp="1576666505112" timestamp="492263866" timestamp2="492263866">
    <data><![CDATA[(]]></data>
  </Command>
  <DocumentChange __id="63711" _type="Insert" date="Mon Dec 23 22:39:29 EST 2019" docASTNodeCount="1" docActiveCodeLength="622" docExpressionCount="0" docLength="710" length="1" offset="497" starttimestamp="1576666505112" timestamp="492264250">
    <text><![CDATA[s]]></text>
  </DocumentChange>
  <Command __id="63712" _type="InsertStringCommand" date="Mon Dec 23 22:39:29 EST 2019" starttimestamp="1576666505112" timestamp="492264255" timestamp2="492264255">
    <data><![CDATA[s]]></data>
  </Command>
  <DocumentChange __id="63713" _type="Insert" date="Mon Dec 23 22:39:29 EST 2019" docASTNodeCount="1" docActiveCodeLength="623" docExpressionCount="0" docLength="711" length="1" offset="498" starttimestamp="1576666505112" timestamp="492264603">
    <text><![CDATA[u]]></text>
  </DocumentChange>
  <Command __id="63714" _type="InsertStringCommand" date="Mon Dec 23 22:39:29 EST 2019" starttimestamp="1576666505112" timestamp="492264608" timestamp2="492264608">
    <data><![CDATA[u]]></data>
  </Command>
  <Command __id="63716" _type="InsertStringCommand" date="Mon Dec 23 22:39:30 EST 2019" starttimestamp="1576666505112" timestamp="492264929" timestamp2="492264929">
    <data><![CDATA[m]]></data>
  </Command>
  <Command __id="63717" _type="EclipseCommand" commandID="org.eclipse.ui.file.save" date="Mon Dec 23 22:39:31 EST 2019" starttimestamp="1576666505112" timestamp="492266241" />
  <Command __id="63719" _type="RunCommand" date="Mon Dec 23 22:39:35 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="492270347" type="Run" />
  <Command __id="63720" _type="RunCommand" date="Mon Dec 23 22:39:35 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="492270347" type="Run" />
  <Command __id="63721" _type="RunCommand" date="Mon Dec 23 22:39:35 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="492270363" type="Debug" />
  <Command __id="63722" _type="RunCommand" date="Mon Dec 23 22:39:35 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="492270363" type="Run" />
  <Command __id="63723" _type="RunCommand" date="Mon Dec 23 22:39:35 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="492270363" type="Debug" />
  <Command __id="63724" _type="RunCommand" date="Mon Dec 23 22:39:35 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="492270363" type="Run" />
  <Command __id="63725" _type="EHExceptionCommand" date="Mon Dec 23 22:39:35 EST 2019" starttimestamp="1576666505112" timestamp="492270527" type="Exception">
    <outputString><![CDATA[sum_sequential
Sum: 499500
Took: 0
thread:0 lastIndex:999
_____________________________
sum_parallel_for_reduction
Sum: 499500
Took: 0
thread:0 lastIndex:124
thread:1 lastIndex:249
thread:2 lastIndex:374
thread:3 lastIndex:499
thread:4 lastIndex:624
thread:5 lastIndex:749
thread:6 lastIndex:874
thread:7 lastIndex:999
_____________________________
sum_parallel_for_local_var
Sum: 499500
Took: 0
thread:0 lastIndex:124
thread:1 lastIndex:249
thread:2 lastIndex:374
thread:3 lastIndex:499
thread:4 lastIndex:624
thread:5 lastIndex:749
thread:6 lastIndex:874
thread:7 lastIndex:999
_____________________________
sum_parallel
Sum: 499500
Took: 0
_____________________________
]]></outputString>
  </Command>
  <DocumentChange __id="63715" _type="Insert" date="Mon Dec 23 22:39:30 EST 2019" docASTNodeCount="1" docActiveCodeLength="624" docExpressionCount="0" docLength="712" length="1" offset="499" starttimestamp="1576666505112" timestamp="492264924">
    <text><![CDATA[m]]></text>
  </DocumentChange>
  <DocumentChange __id="63727" _type="Delete" date="Mon Dec 23 22:39:38 EST 2019" docASTNodeCount="1" docActiveCodeLength="612" docExpressionCount="0" docLength="700" endLine="24" length="12" offset="489" startLine="24" starttimestamp="1576666505112" timestamp="492272896">
    <text><![CDATA[private(sum)]]></text>
  </DocumentChange>
  <Command __id="63726" _type="SelectTextCommand" caretOffset="501" date="Mon Dec 23 22:39:37 EST 2019" end="501" start="489" starttimestamp="1576666505112" timestamp="492272296" />
  <Command __id="63728" _type="EclipseCommand" commandID="org.eclipse.ui.edit.delete" date="Mon Dec 23 22:39:38 EST 2019" starttimestamp="1576666505112" timestamp="492272922" />
  <Command __id="63730" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Mon Dec 23 22:39:40 EST 2019" starttimestamp="1576666505112" timestamp="492275161" />
  <Command __id="63731" _type="EclipseCommand" commandID="org.eclipse.ui.file.save" date="Mon Dec 23 22:39:41 EST 2019" starttimestamp="1576666505112" timestamp="492276345" />
  <Command __id="63732" _type="ShellCommand" date="Mon Dec 23 22:40:06 EST 2019" starttimestamp="1576666505112" timestamp="492301583" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="63733" _type="ShellCommand" date="Mon Dec 23 22:41:55 EST 2019" starttimestamp="1576666505112" timestamp="492410169" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="67713" _type="DiffBasedFileOpenCommand" date="Mon Dec 23 23:30:41 EST 2019" docASTNodeCount="467" docActiveCodeLength="3343" docExpressionCount="244" docLength="5334" projectName="GraderBasics" starttimestamp="1576666505112" timestamp="495336877">
    <filePath><![CDATA[D:\dewan_backup\Java\GraderBasics\src\gradingTools\shared\testcases\openmp\AnOpenMPPragma.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package gradingTools.shared.testcases.openmp;¬∂¬∂import java.util.ArrayList;¬∂import java.util.Arrays;¬∂import java.util.List;¬∂¬∂public class AnOpenMPPragma implements OpenMPPragma {¬∂//	protected List<OpenMPKeywordEnum> openMPKeywords = new ArrayList();¬∂	protected List<String> openMPTokens = new ArrayList();¬∂//	protected OpenMPKeywordEnum firstOpenMPKeyword;¬∂	¬∂//	protected List<String> variableDeclarationsInParallel = new ArrayList();//separate subclass for this variable?¬∂	¬∂//	protected String assignedVariableInCritical;// separate subclass for this variable?¬∂	¬∂	protected int lineNumber;¬∂	protected List<String> annotatedText = new ArrayList();¬∂	protected List<String> openMPCalls = new ArrayList();¬∂	protected List<String> linesWithOpenMPCalls = new ArrayList();¬∂	protected List<ForHeader> forHeaders = new ArrayList();¬∂	¬∂	protected int annotatedTextStartLineNumber;¬∂	protected int annotatedTextEndLineNumber;¬∂	protected OpenMPPragma parent;¬∂	protected String[] privateVariables ; // can occur in for and parallel¬∂	¬∂	protected String[]  sharedVariables ; // can occur only in parallel, but let us keep them here¬∂	¬∂¬∂	¬∂¬∂	protected List<OpenMPPragma> children = new ArrayList();¬∂¬∂	//	protected String reductionVariable;¬∂//	protected String reductionOperation;¬∂//	protected List<String> reductionVariableAssignments = new ArrayList();¬∂//	protected List<String> reductionOperationUses = new ArrayList();¬∂//	¬∂	public AnOpenMPPragma(int lineNumber) {¬∂		super();¬∂//		this.openMPTokens = openMPTokens;¬∂		this.lineNumber = lineNumber;¬∂		¬∂//		this.nextNonEmptyString = nextNonEmptyString;¬∂	}¬∂	@Override¬∂	public List<String> getOpenMPTokens() {¬∂		return openMPTokens;¬∂	}¬∂	@Override¬∂	public int getLineNumber() {¬∂		return lineNumber;¬∂	}¬∂	@Override¬∂	public List<String> getAnnotatedText() {¬∂		return annotatedText;¬∂	}¬∂	@Override¬∂	public void addToAnnotatedText(String aFileLine, int aLineNumber) {¬∂		annotatedText.add(aFileLine);¬∂		List<String> anOpenMPCalls = OpenMPUtils.getOMPCalls(aFileLine);¬∂		¬∂			for (String anOpenMPCall:anOpenMPCalls) {¬∂				addOpenMPCall(anOpenMPCall, aLineNumber);¬∂			}¬∂			if (anOpenMPCalls.size() > 0) {¬∂				linesWithOpenMPCalls.add(aFileLine);¬∂			}¬∂			ForHeader aForHeader = OpenMPUtils.getForHeader(aFileLine, aLineNumber);¬∂			if (aForHeader != null) {¬∂				forHeaders.add(aForHeader);¬∂			}¬∂			¬∂	}¬∂//	@Override¬∂//	public void setAnnotatedText(List<String> nextNonEmptyString) {¬∂//		this.annotatedText = nextNonEmptyString;¬∂//	}¬∂	@Override¬∂	public int getAnnotatedTextStartLineNumber() {¬∂		return annotatedTextStartLineNumber;¬∂	}¬∂	@Override¬∂	public void setAnnotatedTextStartLineNumber(int annotatedLineNumber) {¬∂		this.annotatedTextStartLineNumber = annotatedLineNumber;¬∂	}¬∂	¬∂	@Override¬∂	public int getAnnotatedTextEndLineNumber() {¬∂		return annotatedTextEndLineNumber;¬∂	}¬∂	@Override¬∂	public void setAnnotatedTextEndLineNumber(int annotatedTextEndLineNumber) {¬∂		this.annotatedTextEndLineNumber = annotatedTextEndLineNumber;¬∂	}¬∂//	@Override¬∂//	public String getReductionVariable() {¬∂//		return reductionVariable;¬∂//	}¬∂//	@Override¬∂//	public void setReductionVariable(String reductionVariable) {¬∂//		this.reductionVariable = reductionVariable;¬∂//	}¬∂//	@Override¬∂//	public String getReductionOperation() {¬∂//		return reductionOperation;¬∂//	}¬∂//	@Override¬∂//	public void setReductionOperation(String reductionOperation) {¬∂//		this.reductionOperation = reductionOperation;¬∂//	}¬∂//	@Override¬∂//	public List<String> getReductionVariableAssignments() {¬∂//		return reductionVariableAssignments;¬∂//	}¬∂//	@Override¬∂//	public List<String> getReductionOperationUses() {¬∂//		return reductionOperationUses;¬∂//	}¬∂//	@Override¬∂//	public OpenMPKeywordEnum getFirstOpenMPKeyword() {¬∂//		return firstOpenMPKeyword;¬∂//	}¬∂//	@Override¬∂//	public void setFirstOpenMPKeyword(OpenMPKeywordEnum firstOpenMPKeyword) {¬∂//		this.firstOpenMPKeyword = firstOpenMPKeyword;¬∂//	}¬∂//	@Override¬∂//	public String getAssignedVariableInCritical() {¬∂//		return assignedVariableInCritical;¬∂//	}¬∂//	@Override¬∂//	public void setAssignedVariableInCritical(String assignedVariableInCritical) {¬∂//		this.assignedVariableInCritical = assignedVariableInCritical;¬∂//	}¬∂	@Override¬∂	public OpenMPPragma getParent() {¬∂		return parent;¬∂	}¬∂	@Override¬∂	public void setParent(OpenMPPragma parent) {¬∂		this.parent = parent;¬∂		parent.getChildren().add(this);¬∂	}¬∂	@Override¬∂	public List<OpenMPPragma> getChildren() {¬∂		return children;¬∂	}¬∂	@Override¬∂	public List<String> getOpenMPCalls() {¬∂		return openMPCalls;¬∂	}¬∂	@Override¬∂	public void addOpenMPCall(String aFileLine, int aLineNumber) {¬∂		openMPCalls.add(aFileLine);¬∂	}¬∂	@Override¬∂	public String[] getSharedVariables() {¬∂		return sharedVariables;¬∂	}¬∂	@Override¬∂	public String[] getPrivateVariables() {¬∂		return privateVariables;¬∂	}¬∂	@Override¬∂	public void setPrivateVariables(String[] privateVariables) {¬∂		this.privateVariables = privateVariables;¬∂	}¬∂	@Override¬∂	public void setSharedVariables(String[] sharedVariables) {¬∂		this.sharedVariables = sharedVariables;¬∂	}¬∂	public String toString() {¬∂		return lineNumber + ":" + openMPTokens +¬∂				"--> (" + annotatedTextStartLineNumber + "," + annotatedTextEndLineNumber + "):" + annotatedText;¬∂	}¬∂}¬∂")]]]></diff>
  </Command>
  <Command __id="67714" _type="SelectTextCommand" caretOffset="5100" date="Mon Dec 23 23:30:42 EST 2019" end="5100" start="5056" starttimestamp="1576666505112" timestamp="495337028" />
  <Command __id="67716" _type="MoveCaretCommand" caretOffset="523" date="Mon Dec 23 23:30:50 EST 2019" docOffset="523" starttimestamp="1576666505112" timestamp="495345218" />
  <Command __id="67715" _type="DiffBasedFileOpenCommand" date="Mon Dec 23 23:30:50 EST 2019" docASTNodeCount="1" docActiveCodeLength="611" docExpressionCount="0" docLength="699" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="495345075">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\my_sum_parallel_for_local_var.cpp]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"#include <iostream>¬∂#include <omp.h>¬∂¬∂using namespace std;¬∂¬∂void printSumWithTimes (int sum, int start, int end);¬∂void printNumThreads();¬∂void recordThreadIndex(int index);¬∂void sum_parallel_for_local_var(double* array, int size)¬∂{¬∂	cout << "sum_parallel_for_local_var\n";¬∂¬∂	double start = omp_get_wtime();¬∂¬∂	double sum = 0;¬∂//¬∂//	for (int i = 0; i < size; i++) {¬∂//			sum += array[i];¬∂//			recordThreadIndex(i);¬∂//	}¬∂    #pragma omp parallel¬∂	{¬∂		double local_sum = 0;¬∂¬∂		#pragma omp for"), Diff(DELETE," shared(local_sum)"), Diff(EQUAL,"¬∂		for(int i = 0; i < size; i++) {¬∂			local_sum += array[i];¬∂			recordThreadIndex(i);¬∂		}¬∂¬∂		#pragma omp critical¬∂		sum += local_sum;¬∂	}¬∂¬∂	double end = omp_get_wtime();¬∂¬∂	printSumWithTimes(sum, start, end);¬∂	¬∂}¬∂")]]]></diff>
    <snapshot><![CDATA[#include <iostream>
#include <omp.h>

using namespace std;

void printSumWithTimes (int sum, int start, int end);
void printNumThreads();
void recordThreadIndex(int index);
void sum_parallel_for_local_var(double* array, int size)
{
	cout << "sum_parallel_for_local_var\n";

	double start = omp_get_wtime();

	double sum = 0;
//
//	for (int i = 0; i < size; i++) {
//			sum += array[i];
//			recordThreadIndex(i);
//	}
    #pragma omp parallel
	{
		double local_sum = 0;

		#pragma omp for
		for(int i = 0; i < size; i++) {
			local_sum += array[i];
			recordThreadIndex(i);
		}

		#pragma omp critical
		sum += local_sum;
	}

	double end = omp_get_wtime();

	printSumWithTimes(sum, start, end);
	
}
]]></snapshot>
  </Command>
  <DocumentChange __id="67718" _type="Insert" date="Mon Dec 23 23:30:54 EST 2019" docASTNodeCount="1" docActiveCodeLength="612" docExpressionCount="0" docLength="700" length="1" offset="442" starttimestamp="1576666505112" timestamp="495349414">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="67720" _type="Insert" date="Mon Dec 23 23:30:54 EST 2019" docASTNodeCount="1" docActiveCodeLength="613" docExpressionCount="0" docLength="701" length="1" offset="443" starttimestamp="1576666505112" timestamp="495349648">
    <text><![CDATA[s]]></text>
  </DocumentChange>
  <DocumentChange __id="67722" _type="Insert" date="Mon Dec 23 23:30:54 EST 2019" docASTNodeCount="1" docActiveCodeLength="614" docExpressionCount="0" docLength="702" length="1" offset="444" starttimestamp="1576666505112" timestamp="495349756">
    <text><![CDATA[h]]></text>
  </DocumentChange>
  <DocumentChange __id="67724" _type="Insert" date="Mon Dec 23 23:30:55 EST 2019" docASTNodeCount="1" docActiveCodeLength="615" docExpressionCount="0" docLength="703" length="1" offset="445" starttimestamp="1576666505112" timestamp="495349915">
    <text><![CDATA[a]]></text>
  </DocumentChange>
  <DocumentChange __id="67726" _type="Insert" date="Mon Dec 23 23:30:55 EST 2019" docASTNodeCount="1" docActiveCodeLength="616" docExpressionCount="0" docLength="704" length="1" offset="446" starttimestamp="1576666505112" timestamp="495350115">
    <text><![CDATA[r]]></text>
  </DocumentChange>
  <DocumentChange __id="67728" _type="Insert" date="Mon Dec 23 23:30:55 EST 2019" docASTNodeCount="1" docActiveCodeLength="617" docExpressionCount="0" docLength="705" length="1" offset="447" starttimestamp="1576666505112" timestamp="495350188">
    <text><![CDATA[e]]></text>
  </DocumentChange>
  <DocumentChange __id="67730" _type="Insert" date="Mon Dec 23 23:30:55 EST 2019" docASTNodeCount="1" docActiveCodeLength="618" docExpressionCount="0" docLength="706" length="1" offset="448" starttimestamp="1576666505112" timestamp="495350358">
    <text><![CDATA[d]]></text>
  </DocumentChange>
  <DocumentChange __id="67732" _type="Insert" date="Mon Dec 23 23:30:56 EST 2019" docASTNodeCount="1" docActiveCodeLength="620" docExpressionCount="0" docLength="708" length="2" offset="449" starttimestamp="1576666505112" timestamp="495351669">
    <text><![CDATA[()]]></text>
  </DocumentChange>
  <DocumentChange __id="67734" _type="Insert" date="Mon Dec 23 23:30:57 EST 2019" docASTNodeCount="1" docActiveCodeLength="621" docExpressionCount="0" docLength="709" length="1" offset="450" starttimestamp="1576666505112" timestamp="495351944">
    <text><![CDATA[s]]></text>
  </DocumentChange>
  <DocumentChange __id="67736" _type="Insert" date="Mon Dec 23 23:30:57 EST 2019" docASTNodeCount="1" docActiveCodeLength="622" docExpressionCount="0" docLength="710" length="1" offset="451" starttimestamp="1576666505112" timestamp="495352178">
    <text><![CDATA[u]]></text>
  </DocumentChange>
  <DocumentChange __id="67738" _type="Insert" date="Mon Dec 23 23:30:57 EST 2019" docASTNodeCount="1" docActiveCodeLength="623" docExpressionCount="0" docLength="711" length="1" offset="452" starttimestamp="1576666505112" timestamp="495352569">
    <text><![CDATA[m]]></text>
  </DocumentChange>
  <DocumentChange __id="67740" _type="Insert" date="Mon Dec 23 23:30:58 EST 2019" docASTNodeCount="1" docActiveCodeLength="624" docExpressionCount="0" docLength="712" length="1" offset="453" starttimestamp="1576666505112" timestamp="495353817">
    <text><![CDATA[,]]></text>
  </DocumentChange>
  <DocumentChange __id="67742" _type="Insert" date="Mon Dec 23 23:30:59 EST 2019" docASTNodeCount="1" docActiveCodeLength="625" docExpressionCount="0" docLength="713" length="1" offset="454" starttimestamp="1576666505112" timestamp="495354130">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="67744" _type="Insert" date="Mon Dec 23 23:30:59 EST 2019" docASTNodeCount="1" docActiveCodeLength="626" docExpressionCount="0" docLength="714" length="1" offset="455" starttimestamp="1576666505112" timestamp="495354280">
    <text><![CDATA[s]]></text>
  </DocumentChange>
  <DocumentChange __id="67746" _type="Insert" date="Mon Dec 23 23:30:59 EST 2019" docASTNodeCount="1" docActiveCodeLength="627" docExpressionCount="0" docLength="715" length="1" offset="456" starttimestamp="1576666505112" timestamp="495354505">
    <text><![CDATA[u]]></text>
  </DocumentChange>
  <DocumentChange __id="67748" _type="Insert" date="Mon Dec 23 23:30:59 EST 2019" docASTNodeCount="1" docActiveCodeLength="628" docExpressionCount="0" docLength="716" length="1" offset="457" starttimestamp="1576666505112" timestamp="495354780">
    <text><![CDATA[m]]></text>
  </DocumentChange>
  <Command __id="67717" _type="MoveCaretCommand" caretOffset="442" date="Mon Dec 23 23:30:54 EST 2019" docOffset="442" starttimestamp="1576666505112" timestamp="495348984" />
  <Command __id="67719" _type="InsertStringCommand" date="Mon Dec 23 23:30:54 EST 2019" starttimestamp="1576666505112" timestamp="495349418" timestamp2="495349418">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="67721" _type="InsertStringCommand" date="Mon Dec 23 23:30:54 EST 2019" starttimestamp="1576666505112" timestamp="495349657" timestamp2="495349657">
    <data><![CDATA[s]]></data>
  </Command>
  <Command __id="67723" _type="InsertStringCommand" date="Mon Dec 23 23:30:54 EST 2019" starttimestamp="1576666505112" timestamp="495349761" timestamp2="495349761">
    <data><![CDATA[h]]></data>
  </Command>
  <Command __id="67725" _type="InsertStringCommand" date="Mon Dec 23 23:30:55 EST 2019" starttimestamp="1576666505112" timestamp="495349918" timestamp2="495349918">
    <data><![CDATA[a]]></data>
  </Command>
  <Command __id="67727" _type="InsertStringCommand" date="Mon Dec 23 23:30:55 EST 2019" starttimestamp="1576666505112" timestamp="495350127" timestamp2="495350127">
    <data><![CDATA[r]]></data>
  </Command>
  <Command __id="67729" _type="InsertStringCommand" date="Mon Dec 23 23:30:55 EST 2019" starttimestamp="1576666505112" timestamp="495350201" timestamp2="495350201">
    <data><![CDATA[e]]></data>
  </Command>
  <Command __id="67731" _type="InsertStringCommand" date="Mon Dec 23 23:30:55 EST 2019" starttimestamp="1576666505112" timestamp="495350368" timestamp2="495350368">
    <data><![CDATA[d]]></data>
  </Command>
  <Command __id="67733" _type="InsertStringCommand" date="Mon Dec 23 23:30:56 EST 2019" starttimestamp="1576666505112" timestamp="495351678" timestamp2="495351678">
    <data><![CDATA[(]]></data>
  </Command>
  <Command __id="67735" _type="InsertStringCommand" date="Mon Dec 23 23:30:57 EST 2019" starttimestamp="1576666505112" timestamp="495351948" timestamp2="495351948">
    <data><![CDATA[s]]></data>
  </Command>
  <Command __id="67737" _type="InsertStringCommand" date="Mon Dec 23 23:30:57 EST 2019" starttimestamp="1576666505112" timestamp="495352184" timestamp2="495352184">
    <data><![CDATA[u]]></data>
  </Command>
  <Command __id="67739" _type="InsertStringCommand" date="Mon Dec 23 23:30:57 EST 2019" starttimestamp="1576666505112" timestamp="495352571" timestamp2="495352571">
    <data><![CDATA[m]]></data>
  </Command>
  <Command __id="67741" _type="InsertStringCommand" date="Mon Dec 23 23:30:58 EST 2019" starttimestamp="1576666505112" timestamp="495353820" timestamp2="495353820">
    <data><![CDATA[,]]></data>
  </Command>
  <Command __id="67743" _type="InsertStringCommand" date="Mon Dec 23 23:30:59 EST 2019" starttimestamp="1576666505112" timestamp="495354135" timestamp2="495354135">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="67745" _type="InsertStringCommand" date="Mon Dec 23 23:30:59 EST 2019" starttimestamp="1576666505112" timestamp="495354284" timestamp2="495354284">
    <data><![CDATA[s]]></data>
  </Command>
  <Command __id="67747" _type="InsertStringCommand" date="Mon Dec 23 23:30:59 EST 2019" starttimestamp="1576666505112" timestamp="495354512" timestamp2="495354512">
    <data><![CDATA[u]]></data>
  </Command>
  <Command __id="67749" _type="InsertStringCommand" date="Mon Dec 23 23:30:59 EST 2019" starttimestamp="1576666505112" timestamp="495354784" timestamp2="495354784">
    <data><![CDATA[m]]></data>
  </Command>
  <Command __id="67751" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Mon Dec 23 23:31:01 EST 2019" starttimestamp="1576666505112" timestamp="495356000" />
  <Command __id="67753" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Mon Dec 23 23:31:01 EST 2019" starttimestamp="1576666505112" timestamp="495356159" />
  <Command __id="67755" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Mon Dec 23 23:31:01 EST 2019" starttimestamp="1576666505112" timestamp="495356335" />
  <Command __id="67757" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Mon Dec 23 23:31:01 EST 2019" starttimestamp="1576666505112" timestamp="495356500" />
  <Command __id="67759" _type="InsertStringCommand" date="Mon Dec 23 23:31:02 EST 2019" starttimestamp="1576666505112" timestamp="495357181" timestamp2="495357181">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="67761" _type="InsertStringCommand" date="Mon Dec 23 23:31:02 EST 2019" starttimestamp="1576666505112" timestamp="495357302" timestamp2="495357302">
    <data><![CDATA[s]]></data>
  </Command>
  <Command __id="67763" _type="InsertStringCommand" date="Mon Dec 23 23:31:02 EST 2019" starttimestamp="1576666505112" timestamp="495357522" timestamp2="495357522">
    <data><![CDATA[r]]></data>
  </Command>
  <Command __id="67765" _type="InsertStringCommand" date="Mon Dec 23 23:31:02 EST 2019" starttimestamp="1576666505112" timestamp="495357528" timestamp2="495357528">
    <data><![CDATA[t]]></data>
  </Command>
  <Command __id="67767" _type="InsertStringCommand" date="Mon Dec 23 23:31:02 EST 2019" starttimestamp="1576666505112" timestamp="495357575" timestamp2="495357575">
    <data><![CDATA[a]]></data>
  </Command>
  <Command __id="67769" _type="InsertStringCommand" date="Mon Dec 23 23:31:02 EST 2019" starttimestamp="1576666505112" timestamp="495357717" timestamp2="495357717">
    <data><![CDATA[r]]></data>
  </Command>
  <Command __id="67771" _type="InsertStringCommand" date="Mon Dec 23 23:31:03 EST 2019" starttimestamp="1576666505112" timestamp="495357936" timestamp2="495357936">
    <data><![CDATA[t]]></data>
  </Command>
  <Command __id="67773" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Mon Dec 23 23:31:03 EST 2019" starttimestamp="1576666505112" timestamp="495358442" />
  <Command __id="67775" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Mon Dec 23 23:31:03 EST 2019" starttimestamp="1576666505112" timestamp="495358595" />
  <Command __id="67777" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Mon Dec 23 23:31:03 EST 2019" starttimestamp="1576666505112" timestamp="495358757" />
  <Command __id="67779" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Mon Dec 23 23:31:04 EST 2019" starttimestamp="1576666505112" timestamp="495358927" />
  <Command __id="67781" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Mon Dec 23 23:31:04 EST 2019" starttimestamp="1576666505112" timestamp="495359357" />
  <Command __id="67783" _type="InsertStringCommand" date="Mon Dec 23 23:31:05 EST 2019" starttimestamp="1576666505112" timestamp="495359895" timestamp2="495359895">
    <data><![CDATA[t]]></data>
  </Command>
  <Command __id="67785" _type="InsertStringCommand" date="Mon Dec 23 23:31:05 EST 2019" starttimestamp="1576666505112" timestamp="495359969" timestamp2="495359969">
    <data><![CDATA[a]]></data>
  </Command>
  <Command __id="67787" _type="InsertStringCommand" date="Mon Dec 23 23:31:05 EST 2019" starttimestamp="1576666505112" timestamp="495360162" timestamp2="495360162">
    <data><![CDATA[r]]></data>
  </Command>
  <Command __id="67789" _type="InsertStringCommand" date="Mon Dec 23 23:31:05 EST 2019" starttimestamp="1576666505112" timestamp="495360378" timestamp2="495360378">
    <data><![CDATA[t]]></data>
  </Command>
  <Command __id="67790" _type="MoveCaretCommand" caretOffset="461" date="Mon Dec 23 23:31:08 EST 2019" docOffset="461" starttimestamp="1576666505112" timestamp="495362894" />
  <Command __id="67791" _type="MoveCaretCommand" caretOffset="449" date="Mon Dec 23 23:31:16 EST 2019" docOffset="449" starttimestamp="1576666505112" timestamp="495371048" />
  <Command __id="67793" _type="InsertStringCommand" date="Mon Dec 23 23:31:16 EST 2019" starttimestamp="1576666505112" timestamp="495371443" timestamp2="495371443">
    <data><![CDATA[ ]]></data>
  </Command>
  <DocumentChange __id="67750" _type="Delete" date="Mon Dec 23 23:31:01 EST 2019" docASTNodeCount="1" docActiveCodeLength="627" docExpressionCount="0" docLength="715" endLine="20" length="1" offset="457" startLine="20" starttimestamp="1576666505112" timestamp="495355991">
    <text><![CDATA[m]]></text>
  </DocumentChange>
  <DocumentChange __id="67752" _type="Delete" date="Mon Dec 23 23:31:01 EST 2019" docASTNodeCount="1" docActiveCodeLength="626" docExpressionCount="0" docLength="714" endLine="20" length="1" offset="456" startLine="20" starttimestamp="1576666505112" timestamp="495356151">
    <text><![CDATA[u]]></text>
  </DocumentChange>
  <DocumentChange __id="67754" _type="Delete" date="Mon Dec 23 23:31:01 EST 2019" docASTNodeCount="1" docActiveCodeLength="625" docExpressionCount="0" docLength="713" endLine="20" length="1" offset="455" startLine="20" starttimestamp="1576666505112" timestamp="495356329">
    <text><![CDATA[s]]></text>
  </DocumentChange>
  <DocumentChange __id="67756" _type="Delete" date="Mon Dec 23 23:31:01 EST 2019" docASTNodeCount="1" docActiveCodeLength="624" docExpressionCount="0" docLength="712" endLine="20" length="1" offset="454" startLine="20" starttimestamp="1576666505112" timestamp="495356496">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="67758" _type="Insert" date="Mon Dec 23 23:31:02 EST 2019" docASTNodeCount="1" docActiveCodeLength="625" docExpressionCount="0" docLength="713" length="1" offset="454" starttimestamp="1576666505112" timestamp="495357177">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="67760" _type="Insert" date="Mon Dec 23 23:31:02 EST 2019" docASTNodeCount="1" docActiveCodeLength="626" docExpressionCount="0" docLength="714" length="1" offset="455" starttimestamp="1576666505112" timestamp="495357298">
    <text><![CDATA[s]]></text>
  </DocumentChange>
  <DocumentChange __id="67762" _type="Insert" date="Mon Dec 23 23:31:02 EST 2019" docASTNodeCount="1" docActiveCodeLength="627" docExpressionCount="0" docLength="715" length="1" offset="456" starttimestamp="1576666505112" timestamp="495357516">
    <text><![CDATA[r]]></text>
  </DocumentChange>
  <DocumentChange __id="67764" _type="Insert" date="Mon Dec 23 23:31:02 EST 2019" docASTNodeCount="1" docActiveCodeLength="628" docExpressionCount="0" docLength="716" length="1" offset="457" starttimestamp="1576666505112" timestamp="495357526">
    <text><![CDATA[t]]></text>
  </DocumentChange>
  <DocumentChange __id="67766" _type="Insert" date="Mon Dec 23 23:31:02 EST 2019" docASTNodeCount="1" docActiveCodeLength="629" docExpressionCount="0" docLength="717" length="1" offset="458" starttimestamp="1576666505112" timestamp="495357569">
    <text><![CDATA[a]]></text>
  </DocumentChange>
  <DocumentChange __id="67768" _type="Insert" date="Mon Dec 23 23:31:02 EST 2019" docASTNodeCount="1" docActiveCodeLength="630" docExpressionCount="0" docLength="718" length="1" offset="459" starttimestamp="1576666505112" timestamp="495357709">
    <text><![CDATA[r]]></text>
  </DocumentChange>
  <DocumentChange __id="67770" _type="Insert" date="Mon Dec 23 23:31:03 EST 2019" docASTNodeCount="1" docActiveCodeLength="631" docExpressionCount="0" docLength="719" length="1" offset="460" starttimestamp="1576666505112" timestamp="495357926">
    <text><![CDATA[t]]></text>
  </DocumentChange>
  <DocumentChange __id="67772" _type="Delete" date="Mon Dec 23 23:31:03 EST 2019" docASTNodeCount="1" docActiveCodeLength="630" docExpressionCount="0" docLength="718" endLine="20" length="1" offset="460" startLine="20" starttimestamp="1576666505112" timestamp="495358435">
    <text><![CDATA[t]]></text>
  </DocumentChange>
  <DocumentChange __id="67774" _type="Delete" date="Mon Dec 23 23:31:03 EST 2019" docASTNodeCount="1" docActiveCodeLength="629" docExpressionCount="0" docLength="717" endLine="20" length="1" offset="459" startLine="20" starttimestamp="1576666505112" timestamp="495358587">
    <text><![CDATA[r]]></text>
  </DocumentChange>
  <DocumentChange __id="67776" _type="Delete" date="Mon Dec 23 23:31:03 EST 2019" docASTNodeCount="1" docActiveCodeLength="628" docExpressionCount="0" docLength="716" endLine="20" length="1" offset="458" startLine="20" starttimestamp="1576666505112" timestamp="495358753">
    <text><![CDATA[a]]></text>
  </DocumentChange>
  <DocumentChange __id="67778" _type="Delete" date="Mon Dec 23 23:31:04 EST 2019" docASTNodeCount="1" docActiveCodeLength="627" docExpressionCount="0" docLength="715" endLine="20" length="1" offset="457" startLine="20" starttimestamp="1576666505112" timestamp="495358924">
    <text><![CDATA[t]]></text>
  </DocumentChange>
  <DocumentChange __id="67780" _type="Delete" date="Mon Dec 23 23:31:04 EST 2019" docASTNodeCount="1" docActiveCodeLength="626" docExpressionCount="0" docLength="714" endLine="20" length="1" offset="456" startLine="20" starttimestamp="1576666505112" timestamp="495359354">
    <text><![CDATA[r]]></text>
  </DocumentChange>
  <DocumentChange __id="67782" _type="Insert" date="Mon Dec 23 23:31:05 EST 2019" docASTNodeCount="1" docActiveCodeLength="627" docExpressionCount="0" docLength="715" length="1" offset="456" starttimestamp="1576666505112" timestamp="495359893">
    <text><![CDATA[t]]></text>
  </DocumentChange>
  <DocumentChange __id="67784" _type="Insert" date="Mon Dec 23 23:31:05 EST 2019" docASTNodeCount="1" docActiveCodeLength="628" docExpressionCount="0" docLength="716" length="1" offset="457" starttimestamp="1576666505112" timestamp="495359965">
    <text><![CDATA[a]]></text>
  </DocumentChange>
  <DocumentChange __id="67786" _type="Insert" date="Mon Dec 23 23:31:05 EST 2019" docASTNodeCount="1" docActiveCodeLength="629" docExpressionCount="0" docLength="717" length="1" offset="458" starttimestamp="1576666505112" timestamp="495360157">
    <text><![CDATA[r]]></text>
  </DocumentChange>
  <DocumentChange __id="67788" _type="Insert" date="Mon Dec 23 23:31:05 EST 2019" docASTNodeCount="1" docActiveCodeLength="630" docExpressionCount="0" docLength="718" length="1" offset="459" starttimestamp="1576666505112" timestamp="495360372">
    <text><![CDATA[t]]></text>
  </DocumentChange>
  <DocumentChange __id="67792" _type="Insert" date="Mon Dec 23 23:31:16 EST 2019" docASTNodeCount="1" docActiveCodeLength="631" docExpressionCount="0" docLength="719" length="1" offset="449" starttimestamp="1576666505112" timestamp="495371438">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="67795" _type="Insert" date="Mon Dec 23 23:31:18 EST 2019" docASTNodeCount="1" docActiveCodeLength="632" docExpressionCount="0" docLength="720" length="1" offset="462" starttimestamp="1576666505112" timestamp="495373737">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="67797" _type="Insert" date="Mon Dec 23 23:31:19 EST 2019" docASTNodeCount="1" docActiveCodeLength="633" docExpressionCount="0" docLength="721" length="1" offset="463" starttimestamp="1576666505112" timestamp="495374128">
    <text><![CDATA[p]]></text>
  </DocumentChange>
  <DocumentChange __id="67799" _type="Insert" date="Mon Dec 23 23:31:19 EST 2019" docASTNodeCount="1" docActiveCodeLength="634" docExpressionCount="0" docLength="722" length="1" offset="464" starttimestamp="1576666505112" timestamp="495374277">
    <text><![CDATA[r]]></text>
  </DocumentChange>
  <Command __id="67794" _type="MoveCaretCommand" caretOffset="462" date="Mon Dec 23 23:31:18 EST 2019" docOffset="462" starttimestamp="1576666505112" timestamp="495372892" />
  <Command __id="67796" _type="InsertStringCommand" date="Mon Dec 23 23:31:18 EST 2019" starttimestamp="1576666505112" timestamp="495373750" timestamp2="495373750">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="67798" _type="InsertStringCommand" date="Mon Dec 23 23:31:19 EST 2019" starttimestamp="1576666505112" timestamp="495374137" timestamp2="495374137">
    <data><![CDATA[p]]></data>
  </Command>
  <Command __id="67800" _type="InsertStringCommand" date="Mon Dec 23 23:31:19 EST 2019" starttimestamp="1576666505112" timestamp="495374282" timestamp2="495374282">
    <data><![CDATA[r]]></data>
  </Command>
  <Command __id="67802" _type="InsertStringCommand" date="Mon Dec 23 23:31:19 EST 2019" starttimestamp="1576666505112" timestamp="495374436" timestamp2="495374436">
    <data><![CDATA[i]]></data>
  </Command>
  <Command __id="67804" _type="InsertStringCommand" date="Mon Dec 23 23:31:20 EST 2019" starttimestamp="1576666505112" timestamp="495375203" timestamp2="495375203">
    <data><![CDATA[v]]></data>
  </Command>
  <Command __id="67806" _type="InsertStringCommand" date="Mon Dec 23 23:31:20 EST 2019" starttimestamp="1576666505112" timestamp="495375421" timestamp2="495375421">
    <data><![CDATA[a]]></data>
  </Command>
  <Command __id="67808" _type="InsertStringCommand" date="Mon Dec 23 23:31:20 EST 2019" starttimestamp="1576666505112" timestamp="495375571" timestamp2="495375571">
    <data><![CDATA[t]]></data>
  </Command>
  <Command __id="67810" _type="InsertStringCommand" date="Mon Dec 23 23:31:20 EST 2019" starttimestamp="1576666505112" timestamp="495375707" timestamp2="495375707">
    <data><![CDATA[e]]></data>
  </Command>
  <Command __id="67812" _type="InsertStringCommand" date="Mon Dec 23 23:31:21 EST 2019" starttimestamp="1576666505112" timestamp="495376483" timestamp2="495376483">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="67814" _type="InsertStringCommand" date="Mon Dec 23 23:31:22 EST 2019" starttimestamp="1576666505112" timestamp="495377122" timestamp2="495377122">
    <data><![CDATA[(]]></data>
  </Command>
  <Command __id="67816" _type="InsertStringCommand" date="Mon Dec 23 23:31:22 EST 2019" starttimestamp="1576666505112" timestamp="495377571" timestamp2="495377571">
    <data><![CDATA[s]]></data>
  </Command>
  <Command __id="67818" _type="InsertStringCommand" date="Mon Dec 23 23:31:22 EST 2019" starttimestamp="1576666505112" timestamp="495377835" timestamp2="495377835">
    <data><![CDATA[u]]></data>
  </Command>
  <Command __id="67820" _type="InsertStringCommand" date="Mon Dec 23 23:31:23 EST 2019" starttimestamp="1576666505112" timestamp="495378213" timestamp2="495378213">
    <data><![CDATA[,]]></data>
  </Command>
  <Command __id="67822" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Mon Dec 23 23:31:23 EST 2019" starttimestamp="1576666505112" timestamp="495378833" />
  <Command __id="67824" _type="InsertStringCommand" date="Mon Dec 23 23:31:24 EST 2019" starttimestamp="1576666505112" timestamp="495379345" timestamp2="495379345">
    <data><![CDATA[m]]></data>
  </Command>
  <Command __id="67826" _type="InsertStringCommand" date="Mon Dec 23 23:31:25 EST 2019" starttimestamp="1576666505112" timestamp="495380146" timestamp2="495380146">
    <data><![CDATA[,]]></data>
  </Command>
  <Command __id="67828" _type="InsertStringCommand" date="Mon Dec 23 23:31:25 EST 2019" starttimestamp="1576666505112" timestamp="495380397" timestamp2="495380397">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="67830" _type="InsertStringCommand" date="Mon Dec 23 23:31:25 EST 2019" starttimestamp="1576666505112" timestamp="495380559" timestamp2="495380559">
    <data><![CDATA[s]]></data>
  </Command>
  <Command __id="67832" _type="InsertStringCommand" date="Mon Dec 23 23:31:25 EST 2019" starttimestamp="1576666505112" timestamp="495380749" timestamp2="495380749">
    <data><![CDATA[t]]></data>
  </Command>
  <Command __id="67834" _type="InsertStringCommand" date="Mon Dec 23 23:31:25 EST 2019" starttimestamp="1576666505112" timestamp="495380829" timestamp2="495380829">
    <data><![CDATA[a]]></data>
  </Command>
  <Command __id="67836" _type="InsertStringCommand" date="Mon Dec 23 23:31:26 EST 2019" starttimestamp="1576666505112" timestamp="495380972" timestamp2="495380972">
    <data><![CDATA[r]]></data>
  </Command>
  <Command __id="67838" _type="InsertStringCommand" date="Mon Dec 23 23:31:26 EST 2019" starttimestamp="1576666505112" timestamp="495381194" timestamp2="495381194">
    <data><![CDATA[t]]></data>
  </Command>
  <Command __id="67839" _type="EclipseCommand" commandID="org.eclipse.ui.file.save" date="Mon Dec 23 23:31:28 EST 2019" starttimestamp="1576666505112" timestamp="495382966" />
  <Command __id="67840" _type="EclipseCommand" commandID="org.eclipse.debug.ui.commands.RunLast" date="Mon Dec 23 23:31:31 EST 2019" starttimestamp="1576666505112" timestamp="495386500" />
  <Command __id="67841" _type="ShellCommand" date="Mon Dec 23 23:31:34 EST 2019" starttimestamp="1576666505112" timestamp="495389535" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="67842" _type="ShellCommand" date="Mon Dec 23 23:31:36 EST 2019" starttimestamp="1576666505112" timestamp="495391476" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="67843" _type="MoveCaretCommand" caretOffset="417" date="Mon Dec 23 23:31:42 EST 2019" docOffset="417" starttimestamp="1576666505112" timestamp="495397484" />
  <Command __id="67844" _type="MoveCaretCommand" caretOffset="476" date="Mon Dec 23 23:31:43 EST 2019" docOffset="476" starttimestamp="1576666505112" timestamp="495398344" />
  <DocumentChange __id="67801" _type="Insert" date="Mon Dec 23 23:31:19 EST 2019" docASTNodeCount="1" docActiveCodeLength="635" docExpressionCount="0" docLength="723" length="1" offset="465" starttimestamp="1576666505112" timestamp="495374421">
    <text><![CDATA[i]]></text>
  </DocumentChange>
  <DocumentChange __id="67803" _type="Insert" date="Mon Dec 23 23:31:20 EST 2019" docASTNodeCount="1" docActiveCodeLength="636" docExpressionCount="0" docLength="724" length="1" offset="466" starttimestamp="1576666505112" timestamp="495375198">
    <text><![CDATA[v]]></text>
  </DocumentChange>
  <DocumentChange __id="67805" _type="Insert" date="Mon Dec 23 23:31:20 EST 2019" docASTNodeCount="1" docActiveCodeLength="637" docExpressionCount="0" docLength="725" length="1" offset="467" starttimestamp="1576666505112" timestamp="495375412">
    <text><![CDATA[a]]></text>
  </DocumentChange>
  <DocumentChange __id="67807" _type="Insert" date="Mon Dec 23 23:31:20 EST 2019" docASTNodeCount="1" docActiveCodeLength="638" docExpressionCount="0" docLength="726" length="1" offset="468" starttimestamp="1576666505112" timestamp="495375562">
    <text><![CDATA[t]]></text>
  </DocumentChange>
  <DocumentChange __id="67809" _type="Insert" date="Mon Dec 23 23:31:20 EST 2019" docASTNodeCount="1" docActiveCodeLength="639" docExpressionCount="0" docLength="727" length="1" offset="469" starttimestamp="1576666505112" timestamp="495375698">
    <text><![CDATA[e]]></text>
  </DocumentChange>
  <DocumentChange __id="67811" _type="Insert" date="Mon Dec 23 23:31:21 EST 2019" docASTNodeCount="1" docActiveCodeLength="640" docExpressionCount="0" docLength="728" length="1" offset="470" starttimestamp="1576666505112" timestamp="495376479">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="67813" _type="Insert" date="Mon Dec 23 23:31:22 EST 2019" docASTNodeCount="1" docActiveCodeLength="642" docExpressionCount="0" docLength="730" length="2" offset="471" starttimestamp="1576666505112" timestamp="495377121">
    <text><![CDATA[()]]></text>
  </DocumentChange>
  <DocumentChange __id="67815" _type="Insert" date="Mon Dec 23 23:31:22 EST 2019" docASTNodeCount="1" docActiveCodeLength="643" docExpressionCount="0" docLength="731" length="1" offset="472" starttimestamp="1576666505112" timestamp="495377569">
    <text><![CDATA[s]]></text>
  </DocumentChange>
  <DocumentChange __id="67817" _type="Insert" date="Mon Dec 23 23:31:22 EST 2019" docASTNodeCount="1" docActiveCodeLength="644" docExpressionCount="0" docLength="732" length="1" offset="473" starttimestamp="1576666505112" timestamp="495377833">
    <text><![CDATA[u]]></text>
  </DocumentChange>
  <DocumentChange __id="67819" _type="Insert" date="Mon Dec 23 23:31:23 EST 2019" docASTNodeCount="1" docActiveCodeLength="645" docExpressionCount="0" docLength="733" length="1" offset="474" starttimestamp="1576666505112" timestamp="495378210">
    <text><![CDATA[,]]></text>
  </DocumentChange>
  <DocumentChange __id="67821" _type="Delete" date="Mon Dec 23 23:31:23 EST 2019" docASTNodeCount="1" docActiveCodeLength="644" docExpressionCount="0" docLength="732" endLine="20" length="1" offset="474" startLine="20" starttimestamp="1576666505112" timestamp="495378827">
    <text><![CDATA[,]]></text>
  </DocumentChange>
  <DocumentChange __id="67823" _type="Insert" date="Mon Dec 23 23:31:24 EST 2019" docASTNodeCount="1" docActiveCodeLength="645" docExpressionCount="0" docLength="733" length="1" offset="474" starttimestamp="1576666505112" timestamp="495379340">
    <text><![CDATA[m]]></text>
  </DocumentChange>
  <DocumentChange __id="67825" _type="Insert" date="Mon Dec 23 23:31:25 EST 2019" docASTNodeCount="1" docActiveCodeLength="646" docExpressionCount="0" docLength="734" length="1" offset="475" starttimestamp="1576666505112" timestamp="495380144">
    <text><![CDATA[,]]></text>
  </DocumentChange>
  <DocumentChange __id="67827" _type="Insert" date="Mon Dec 23 23:31:25 EST 2019" docASTNodeCount="1" docActiveCodeLength="647" docExpressionCount="0" docLength="735" length="1" offset="476" starttimestamp="1576666505112" timestamp="495380390">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="67829" _type="Insert" date="Mon Dec 23 23:31:25 EST 2019" docASTNodeCount="1" docActiveCodeLength="648" docExpressionCount="0" docLength="736" length="1" offset="477" starttimestamp="1576666505112" timestamp="495380552">
    <text><![CDATA[s]]></text>
  </DocumentChange>
  <DocumentChange __id="67831" _type="Insert" date="Mon Dec 23 23:31:25 EST 2019" docASTNodeCount="1" docActiveCodeLength="649" docExpressionCount="0" docLength="737" length="1" offset="478" starttimestamp="1576666505112" timestamp="495380744">
    <text><![CDATA[t]]></text>
  </DocumentChange>
  <DocumentChange __id="67833" _type="Insert" date="Mon Dec 23 23:31:25 EST 2019" docASTNodeCount="1" docActiveCodeLength="650" docExpressionCount="0" docLength="738" length="1" offset="479" starttimestamp="1576666505112" timestamp="495380823">
    <text><![CDATA[a]]></text>
  </DocumentChange>
  <DocumentChange __id="67835" _type="Insert" date="Mon Dec 23 23:31:26 EST 2019" docASTNodeCount="1" docActiveCodeLength="651" docExpressionCount="0" docLength="739" length="1" offset="480" starttimestamp="1576666505112" timestamp="495380969">
    <text><![CDATA[r]]></text>
  </DocumentChange>
  <DocumentChange __id="67837" _type="Insert" date="Mon Dec 23 23:31:26 EST 2019" docASTNodeCount="1" docActiveCodeLength="652" docExpressionCount="0" docLength="740" length="1" offset="481" starttimestamp="1576666505112" timestamp="495381188">
    <text><![CDATA[t]]></text>
  </DocumentChange>
  <DocumentChange __id="67846" _type="Insert" date="Mon Dec 23 23:31:48 EST 2019" docASTNodeCount="1" docActiveCodeLength="654" docExpressionCount="0" docLength="742" length="2" offset="324" starttimestamp="1576666505112" timestamp="495403148">
    <text><![CDATA[
	]]></text>
  </DocumentChange>
  <DocumentChange __id="67848" _type="Insert" date="Mon Dec 23 23:31:48 EST 2019" docASTNodeCount="1" docActiveCodeLength="656" docExpressionCount="0" docLength="744" length="2" offset="326" starttimestamp="1576666505112" timestamp="495403674">
    <text><![CDATA[
	]]></text>
  </DocumentChange>
  <DocumentChange __id="67850" _type="Insert" date="Mon Dec 23 23:31:49 EST 2019" docASTNodeCount="1" docActiveCodeLength="657" docExpressionCount="0" docLength="745" length="1" offset="328" starttimestamp="1576666505112" timestamp="495404084">
    <text><![CDATA[i]]></text>
  </DocumentChange>
  <DocumentChange __id="67852" _type="Insert" date="Mon Dec 23 23:31:49 EST 2019" docASTNodeCount="1" docActiveCodeLength="658" docExpressionCount="0" docLength="746" length="1" offset="329" starttimestamp="1576666505112" timestamp="495404315">
    <text><![CDATA[n]]></text>
  </DocumentChange>
  <DocumentChange __id="67854" _type="Insert" date="Mon Dec 23 23:31:49 EST 2019" docASTNodeCount="1" docActiveCodeLength="659" docExpressionCount="0" docLength="747" length="1" offset="330" starttimestamp="1576666505112" timestamp="495404390">
    <text><![CDATA[t]]></text>
  </DocumentChange>
  <Command __id="67845" _type="MoveCaretCommand" caretOffset="324" date="Mon Dec 23 23:31:47 EST 2019" docOffset="324" starttimestamp="1576666505112" timestamp="495402627" />
  <Command __id="67847" _type="InsertStringCommand" date="Mon Dec 23 23:31:48 EST 2019" starttimestamp="1576666505112" timestamp="495403152" timestamp2="495403152">
    <data><![CDATA[]]></data>
  </Command>
  <Command __id="67849" _type="InsertStringCommand" date="Mon Dec 23 23:31:48 EST 2019" starttimestamp="1576666505112" timestamp="495403679" timestamp2="495403679">
    <data><![CDATA[]]></data>
  </Command>
  <Command __id="67851" _type="InsertStringCommand" date="Mon Dec 23 23:31:49 EST 2019" starttimestamp="1576666505112" timestamp="495404093" timestamp2="495404093">
    <data><![CDATA[i]]></data>
  </Command>
  <Command __id="67853" _type="InsertStringCommand" date="Mon Dec 23 23:31:49 EST 2019" starttimestamp="1576666505112" timestamp="495404324" timestamp2="495404324">
    <data><![CDATA[n]]></data>
  </Command>
  <Command __id="67855" _type="InsertStringCommand" date="Mon Dec 23 23:31:49 EST 2019" starttimestamp="1576666505112" timestamp="495404400" timestamp2="495404400">
    <data><![CDATA[t]]></data>
  </Command>
  <Command __id="67857" _type="InsertStringCommand" date="Mon Dec 23 23:31:50 EST 2019" starttimestamp="1576666505112" timestamp="495405073" timestamp2="495405073">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="67859" _type="InsertStringCommand" date="Mon Dec 23 23:31:50 EST 2019" starttimestamp="1576666505112" timestamp="495405795" timestamp2="495405795">
    <data><![CDATA[j]]></data>
  </Command>
  <Command __id="67861" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Mon Dec 23 23:31:51 EST 2019" starttimestamp="1576666505112" timestamp="495406506" />
  <Command __id="67863" _type="InsertStringCommand" date="Mon Dec 23 23:31:52 EST 2019" starttimestamp="1576666505112" timestamp="495406957" timestamp2="495406957">
    <data><![CDATA[a]]></data>
  </Command>
  <Command __id="67865" _type="InsertStringCommand" date="Mon Dec 23 23:31:52 EST 2019" starttimestamp="1576666505112" timestamp="495407310" timestamp2="495407310">
    <data><![CDATA[,]]></data>
  </Command>
  <Command __id="67867" _type="InsertStringCommand" date="Mon Dec 23 23:31:52 EST 2019" starttimestamp="1576666505112" timestamp="495407496" timestamp2="495407496">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="67869" _type="InsertStringCommand" date="Mon Dec 23 23:31:52 EST 2019" starttimestamp="1576666505112" timestamp="495407801" timestamp2="495407801">
    <data><![CDATA[b]]></data>
  </Command>
  <Command __id="67870" _type="MoveCaretCommand" caretOffset="486" date="Mon Dec 23 23:31:55 EST 2019" docOffset="486" starttimestamp="1576666505112" timestamp="495410010" />
  <Command __id="67871" _type="SelectTextCommand" caretOffset="487" date="Mon Dec 23 23:31:55 EST 2019" end="487" start="484" starttimestamp="1576666505112" timestamp="495410284" />
  <Command __id="67873" _type="InsertStringCommand" date="Mon Dec 23 23:31:55 EST 2019" starttimestamp="1576666505112" timestamp="495410527" timestamp2="495410527">
    <data><![CDATA[a]]></data>
  </Command>
  <Command __id="67874" _type="MoveCaretCommand" caretOffset="489" date="Mon Dec 23 23:31:57 EST 2019" docOffset="489" starttimestamp="1576666505112" timestamp="495411962" />
  <Command __id="67875" _type="SelectTextCommand" caretOffset="492" date="Mon Dec 23 23:31:57 EST 2019" end="492" start="487" starttimestamp="1576666505112" timestamp="495412164" />
  <Command __id="67877" _type="InsertStringCommand" date="Mon Dec 23 23:31:57 EST 2019" starttimestamp="1576666505112" timestamp="495412562" timestamp2="495412562">
    <data><![CDATA[b]]></data>
  </Command>
  <Command __id="67879" _type="EclipseCommand" commandID="org.eclipse.ui.file.save" date="Mon Dec 23 23:31:58 EST 2019" starttimestamp="1576666505112" timestamp="495413567" />
  <Command __id="67880" _type="EclipseCommand" commandID="org.eclipse.debug.ui.commands.RunLast" date="Mon Dec 23 23:32:06 EST 2019" starttimestamp="1576666505112" timestamp="495421375" />
  <Command __id="67881" _type="ShellCommand" date="Mon Dec 23 23:32:06 EST 2019" starttimestamp="1576666505112" timestamp="495421817" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="67882" _type="ShellCommand" date="Mon Dec 23 23:32:08 EST 2019" starttimestamp="1576666505112" timestamp="495423297" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="67883" _type="MoveCaretCommand" caretOffset="335" date="Mon Dec 23 23:32:22 EST 2019" docOffset="335" starttimestamp="1576666505112" timestamp="495437115" />
  <Command __id="67885" _type="InsertStringCommand" date="Mon Dec 23 23:32:23 EST 2019" starttimestamp="1576666505112" timestamp="495437980" timestamp2="495437980">
    <data><![CDATA[;]]></data>
  </Command>
  <Command __id="67886" _type="EclipseCommand" commandID="org.eclipse.ui.file.save" date="Mon Dec 23 23:32:23 EST 2019" starttimestamp="1576666505112" timestamp="495438494" />
  <Command __id="67895" _type="RunCommand" date="Mon Dec 23 23:32:40 EST 2019" kind="HitBreakPoint" projectName="PL_Java" starttimestamp="1576666505112" timestamp="495455466" type="Run" />
  <Command __id="67896" _type="RunCommand" date="Mon Dec 23 23:32:40 EST 2019" kind="HitBreakPoint" projectName="PL_Java" starttimestamp="1576666505112" timestamp="495455466" type="Run" />
  <Command __id="67897" _type="RunCommand" date="Mon Dec 23 23:32:40 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="495455689" type="Run" />
  <Command __id="67898" _type="RunCommand" date="Mon Dec 23 23:32:40 EST 2019" kind="StepInto" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="495455853" type="Run" />
  <Command __id="67899" _type="RunCommand" date="Mon Dec 23 23:32:41 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="495456120" type="Run" />
  <Command __id="67900" _type="EHExceptionCommand" date="Mon Dec 23 23:32:41 EST 2019" starttimestamp="1576666505112" timestamp="495456243" type="Exception">
    <outputString><![CDATA[I***Tracer: showInfo = true
]]></outputString>
  </Command>
  <Command __id="67901" _type="EHExceptionCommand" date="Mon Dec 23 23:32:41 EST 2019" starttimestamp="1576666505112" timestamp="495456429" type="Exception">
    <outputString><![CDATA[Buffer traced nessages =false
]]></outputString>
  </Command>
  <Command __id="67902" _type="RunCommand" date="Mon Dec 23 23:32:42 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="495457380" type="Run" />
  <Command __id="67903" _type="RunCommand" date="Mon Dec 23 23:32:42 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="495457381" type="Run" />
  <Command __id="67904" _type="RunCommand" date="Mon Dec 23 23:32:42 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="495457383" type="Run" />
  <Command __id="67905" _type="RunCommand" date="Mon Dec 23 23:32:42 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="495457384" type="Run" />
  <Command __id="67906" _type="EHExceptionCommand" date="Mon Dec 23 23:32:43 EST 2019" starttimestamp="1576666505112" timestamp="495457934" type="Exception">
    <outputString><![CDATA[ObjectEditor(Version 22, built on Thu Dec 06 16:26:09 EST 2018). Copyright Prasun Dewan, 2012, All rights reserved. US Patent Appl. No.: 12/532,327
]]></outputString>
  </Command>
  <Command __id="67907" _type="ShellCommand" date="Mon Dec 23 23:32:43 EST 2019" starttimestamp="1576666505112" timestamp="495458616" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="67908" _type="EHExceptionCommand" date="Mon Dec 23 23:32:46 EST 2019" starttimestamp="1576666505112" timestamp="495460899" type="Exception">
    <outputString><![CDATA[I***(TestCaseResult) ### SequentialSumTestCase: 1.0
]]></outputString>
  </Command>
  <Command __id="67909" _type="RunCommand" date="Mon Dec 23 23:32:46 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="495460918" type="Run" />
  <Command __id="67910" _type="EHExceptionCommand" date="Mon Dec 23 23:32:46 EST 2019" starttimestamp="1576666505112" timestamp="495460954" type="Exception">
    <outputString><![CDATA[Returning first of multiple entry points:[MyOpenMPTraining.exe, OpenMPTraining.exe]
I***(BasicProcessRunner) Running command:D:\dewan_backup\C\MyOpenMPTraining\Debug\MyOpenMPTraining.exe
I***(BasicProcessRunner) Running in folder: D:\dewan_backup\C\MyOpenMPTraining\Debug
I***(BasicProcessRunner)  Process started: D:\dewan_backup\C\MyOpenMPTraining\Debug\MyOpenMPTraining.exe folder: D:\dewan_backup\C\MyOpenMPTraining\Debug entry point: null class path: D:\dewan_backup\Java\PLTeaching\PL_Java\bin;D:\dewan_backup\Java\lib\oeall22.jar;C:\Users\dewan\.p2\pool\plugins\org.junit_4.12.0.v201504281640\junit.jar;C:\Users\dewan\.p2\pool\plugins\org.hamcrest.core_1.3.0.v20180420-1519.jar;D:\dewan_backup\Java\GraderBasics\lib\commons-configuration-1.9.jar;D:\dewan_backup\Java\GraderBasics\lib\commons-lang-2.6.jar;D:\dewan_backup\Java\GraderBasics\lib\commons-logging-1.1.1.jar;G:\My Drive\Java\lib\Herrmes\lib\weka3_6.jar;D:\dewan_backup\Java\GraderBasics\target\classes;D:\dewan_backup\Java\DemoCourseLocalBasicChecks\bin
]]></outputString>
  </Command>
  <Command __id="67911" _type="RunCommand" date="Mon Dec 23 23:32:46 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="495460991" type="Run" />
  <Command __id="67912" _type="RunCommand" date="Mon Dec 23 23:32:46 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="495460994" type="Run" />
  <Command __id="67913" _type="EHExceptionCommand" date="Mon Dec 23 23:32:46 EST 2019" starttimestamp="1576666505112" timestamp="495461092" type="Exception">
    <outputString><![CDATA[I***(BasicRunningProject) 1577161966104:Received output from main: sum_sequential
I***(BasicRunningProject) 1577161966107:Processing line from main: sum_sequential
I***(BasicRunningProject) 1577161966108:Received output from main: Sum: 499500
I***(BasicRunningProject) 1577161966108:Processing line from main: Sum: 499500
I***(BasicRunningProject) 1577161966108:Received output from main: Took: 0
I***(BasicRunningProject) 1577161966108:Processing line from main: Took: 0
I***(BasicRunningProject) 1577161966108:Received output from main: thread:0 lastIndex:999
I***(BasicRunningProject) 1577161966108:Processing line from main: thread:0 lastIndex:999
I***(BasicRunningProject) 1577161966108:Received output from main: _____________________________
I***(BasicRunningProject) 1577161966109:Processing line from main: _____________________________
I***(BasicRunningProject) 1577161966109:Received output from main: sum_parallel_for_reduction
I***(BasicRunningProject) 1577161966109:Processing line from main: sum_parallel_for_reduction
I***(BasicRunningProject) 1577161966109:Received output from main: Sum: 499500
I***(BasicRunningProject) 1577161966109:Processing line from main: Sum: 499500
I***(BasicRunningProject) 1577161966109:Received output from main: Took: 0
I***(BasicRunningProject) 1577161966109:Processing line from main: Took: 0
I***(BasicRunningProject) 1577161966109:Received output from main: thread:0 lastIndex:124
I***(BasicRunningProject) 1577161966109:Processing line from main: thread:0 lastIndex:124
I***(BasicRunningProject) 1577161966110:Received output from main: thread:1 lastIndex:249
I***(BasicRunningProject) 1577161966110:Processing line from main: thread:1 lastIndex:249
I***(BasicRunningProject) 1577161966110:Received output from main: thread:2 lastIndex:374
I***(BasicRunningProject) 1577161966110:Processing line from main: thread:2 lastIndex:374
I***(BasicRunningProject) 1577161966110:Received output from main: thread:3 lastIndex:499
I***(BasicRunningProject) 1577161966110:Processing line from main: thread:3 lastIndex:499
I***(BasicRunningProject) 1577161966110:Received output from main: thread:4 lastIndex:624
I***(BasicRunningProject) 1577161966110:Processing line from main: thread:4 lastIndex:624
I***(BasicRunningProject) 1577161966110:Received output from main: thread:5 lastIndex:749
I***(BasicRunningProject) 1577161966110:Processing line from main: thread:5 lastIndex:749
I***(BasicRunningProject) 1577161966110:Received output from main: thread:6 lastIndex:874
I***(BasicRunningProject) 1577161966111:Processing line from main: thread:6 lastIndex:874
I***(BasicRunningProject) 1577161966111:Received output from main: thread:7 lastIndex:999
I***(BasicRunningProject) 1577161966111:Processing line from main: thread:7 lastIndex:999
I***(BasicRunningProject) 1577161966111:Received output from main: _____________________________
I***(BasicRunningProject) 1577161966111:Processing line from main: _____________________________
I***(BasicRunningProject) 1577161966111:Received output from main: sum_parallel_for_local_var
I***(BasicRunningProject) 1577161966111:Processing line from main: sum_parallel_for_local_var
I***(BasicRunningProject) 1577161966111:Received output from main: Sum: 499500
I***(BasicRunningProject) 1577161966111:Processing line from main: Sum: 499500
I***(BasicRunningProject) 1577161966112:Received output from main: Took: 0
I***(BasicRunningProject) 1577161966112:Processing line from main: Took: 0
I***(BasicRunningProject) 1577161966112:Received output from main: thread:0 lastIndex:124
I***(BasicRunningProject) 1577161966112:Processing line from main: thread:0 lastIndex:124
I***(BasicRunningProject) 1577161966112:Received output from main: thread:1 lastIndex:249
I***(BasicRunningProject) 1577161966112:Processing line from main: thread:1 lastIndex:249
I***(BasicRunningProject) 1577161966112:Received output from main: thread:2 lastIndex:374
I***(BasicRunningProject) 1577161966112:Processing line from main: thread:2 lastIndex:374
I***(BasicRunningProject) 1577161966112:Received output from main: thread:3 lastIndex:499
I***(BasicRunningProject) 1577161966113:Processing line from main: thread:3 lastIndex:499
I***(BasicRunningProject) 1577161966113:Received output from main: thread:4 lastIndex:624
I***(BasicRunningProject) 1577161966113:Processing line from main: thread:4 lastIndex:624
I***(BasicRunningProject) 1577161966113:Received output from main: thread:5 lastIndex:749
I***(BasicRunningProject) 1577161966121:Processing line from main: thread:5 lastIndex:749
I***(ARunnerInputStreamProcessor) Provided Input:
I***(BasicRunningProject) 1577161966121:Received output from main: thread:6 lastIndex:874
I***(BasicRunningProject) 1577161966121:Processing line from main: thread:6 lastIndex:874
I***(BasicRunningProject) 1577161966121:Received output from main: thread:7 lastIndex:999
I***(BasicRunningProject) 1577161966121:Processing line from main: thread:7 lastIndex:999
I***(BasicRunningProject) 1577161966122:Received output from main: _____________________________
I***(BasicRunningProject) 1577161966122:Processing line from main: _____________________________
I***(BasicRunningProject) 1577161966122:Received output from main: sum_parallel
I***(BasicRunningProject) 1577161966122:Processing line from main: sum_parallel
I***(BasicRunningProject) 1577161966122:Received output from main: Sum: 499500
I***(BasicRunningProject) 1577161966122:Processing line from main: Sum: 499500
I***(BasicRunningProject) 1577161966122:Received output from main: Took: 0
I***(BasicRunningProject) 1577161966122:Processing line from main: Took: 0
I***(BasicRunningProject) 1577161966122:Received output from main: _____________________________
I***(BasicRunningProject) 1577161966122:Processing line from main: _____________________________
I***(BasicProcessRunner)  Process finished; folder: D:\dewan_backup\C\MyOpenMPTraining\Debug entry point: null class path: D:\dewan_backup\Java\PLTeaching\PL_Java\bin;D:\dewan_backup\Java\lib\oeall22.jar;C:\Users\dewan\.p2\pool\plugins\org.junit_4.12.0.v201504281640\junit.jar;C:\Users\dewan\.p2\pool\plugins\org.hamcrest.core_1.3.0.v20180420-1519.jar;D:\dewan_backup\Java\GraderBasics\lib\commons-configuration-1.9.jar;D:\dewan_backup\Java\GraderBasics\lib\commons-lang-2.6.jar;D:\dewan_backup\Java\GraderBasics\lib\commons-logging-1.1.1.jar;G:\My Drive\Java\lib\Herrmes\lib\weka3_6.jar;D:\dewan_backup\Java\GraderBasics\target\classes;D:\dewan_backup\Java\DemoCourseLocalBasicChecks\bin
I***(BasicRunningProject) Thread[AWT-EventQueue-0,6,main] sleeping for ms:2000 waiting for pending output from threads 
]]></outputString>
  </Command>
  <DocumentChange __id="67856" _type="Insert" date="Mon Dec 23 23:31:50 EST 2019" docASTNodeCount="1" docActiveCodeLength="660" docExpressionCount="0" docLength="748" length="1" offset="331" starttimestamp="1576666505112" timestamp="495405070">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="67858" _type="Insert" date="Mon Dec 23 23:31:50 EST 2019" docASTNodeCount="1" docActiveCodeLength="661" docExpressionCount="0" docLength="749" length="1" offset="332" starttimestamp="1576666505112" timestamp="495405786">
    <text><![CDATA[j]]></text>
  </DocumentChange>
  <DocumentChange __id="67860" _type="Delete" date="Mon Dec 23 23:31:51 EST 2019" docASTNodeCount="1" docActiveCodeLength="660" docExpressionCount="0" docLength="748" endLine="16" length="1" offset="332" startLine="16" starttimestamp="1576666505112" timestamp="495406502">
    <text><![CDATA[j]]></text>
  </DocumentChange>
  <DocumentChange __id="67862" _type="Insert" date="Mon Dec 23 23:31:52 EST 2019" docASTNodeCount="1" docActiveCodeLength="661" docExpressionCount="0" docLength="749" length="1" offset="332" starttimestamp="1576666505112" timestamp="495406951">
    <text><![CDATA[a]]></text>
  </DocumentChange>
  <DocumentChange __id="67864" _type="Insert" date="Mon Dec 23 23:31:52 EST 2019" docASTNodeCount="1" docActiveCodeLength="662" docExpressionCount="0" docLength="750" length="1" offset="333" starttimestamp="1576666505112" timestamp="495407300">
    <text><![CDATA[,]]></text>
  </DocumentChange>
  <DocumentChange __id="67866" _type="Insert" date="Mon Dec 23 23:31:52 EST 2019" docASTNodeCount="1" docActiveCodeLength="663" docExpressionCount="0" docLength="751" length="1" offset="334" starttimestamp="1576666505112" timestamp="495407489">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="67868" _type="Insert" date="Mon Dec 23 23:31:52 EST 2019" docASTNodeCount="1" docActiveCodeLength="664" docExpressionCount="0" docLength="752" length="1" offset="335" starttimestamp="1576666505112" timestamp="495407791">
    <text><![CDATA[b]]></text>
  </DocumentChange>
  <DocumentChange __id="67872" _type="Replace" date="Mon Dec 23 23:31:55 EST 2019" docASTNodeCount="1" docActiveCodeLength="662" docExpressionCount="0" docLength="750" endLine="22" insertionLength="1" int_docASTNodeCount="1" int_docActiveCodeLength="661" int_docExpressionCount="0" int_docLength="749" length="3" offset="484" startLine="22" starttimestamp="1576666505112" timestamp="495410519">
    <deletedText><![CDATA[sum]]></deletedText>
    <insertedText><![CDATA[a]]></insertedText>
  </DocumentChange>
  <DocumentChange __id="67876" _type="Replace" date="Mon Dec 23 23:31:57 EST 2019" docASTNodeCount="1" docActiveCodeLength="658" docExpressionCount="0" docLength="746" endLine="22" insertionLength="1" int_docASTNodeCount="1" int_docActiveCodeLength="657" int_docExpressionCount="0" int_docLength="745" length="5" offset="487" startLine="22" starttimestamp="1576666505112" timestamp="495412549">
    <deletedText><![CDATA[start]]></deletedText>
    <insertedText><![CDATA[b]]></insertedText>
  </DocumentChange>
  <DocumentChange __id="67878" _type="Delete" date="Mon Dec 23 23:31:58 EST 2019" docASTNodeCount="1" docActiveCodeLength="657" docExpressionCount="0" docLength="745" endLine="15" length="1" offset="325" startLine="15" starttimestamp="1576666505112" timestamp="495413478">
    <text><![CDATA[	]]></text>
  </DocumentChange>
  <DocumentChange __id="67884" _type="Insert" date="Mon Dec 23 23:32:23 EST 2019" docASTNodeCount="1" docActiveCodeLength="658" docExpressionCount="0" docLength="746" length="1" offset="335" starttimestamp="1576666505112" timestamp="495437973">
    <text><![CDATA[;]]></text>
  </DocumentChange>
  <Command __id="67917" _type="DiffBasedFileOpenCommand" date="Mon Dec 23 23:32:50 EST 2019" docASTNodeCount="1278" docActiveCodeLength="8826" docExpressionCount="798" docLength="11251" projectName="GraderBasics" starttimestamp="1576666505112" timestamp="495465266">
    <filePath><![CDATA[D:\dewan_backup\Java\GraderBasics\src\gradingTools\shared\testcases\openmp\OpenMPUtils.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package gradingTools.shared.testcases.openmp;¬∂¬∂import java.util.ArrayList;¬∂import java.util.HashMap;¬∂import java.util.List;¬∂import java.util.Map;¬∂import java.util.Stack;¬∂¬∂¬∂public class OpenMPUtils {¬∂	¬∂	protected static Map<String, OpenMPKeywordEnum> stringToOpenMPKeyword = new HashMap();¬∂	protected static String[] typeNames = {"double", "float", "int", "short", "long"};¬∂	protected static String[] openMPCalls = {"omp_get_thread_num()", "omp_get_num_threads()"};¬∂	public static List<OpenMPPragma> getOpemMPPragmas(StringBuffer aFileBuffer) {¬∂		String[] aFileLines = aFileBuffer.toString().split("\n");¬∂		return getOpenMPPragmas(aFileLines);¬∂	}¬∂	¬∂	public static boolean isCodeLine(String aLine) {¬∂		return !aLine.isEmpty() && !aLine.startsWith("//");¬∂	}¬∂	public static boolean isBlockStart(String aLine) {¬∂		return aLine.contains("{");¬∂	}¬∂	public static boolean isBlockEnd(String aLine) {¬∂		return aLine.contains("}");¬∂	}¬∂	public static boolean isLoopStart(String aLine) {¬∂		return aLine.startsWith("for");¬∂	}¬∂	public static boolean endsWithLoopHeader(String aLine) {¬∂		return aLine.endsWith(")");¬∂	}¬∂	public static boolean isPragmaStart(String aLine) {¬∂		return aLine.startsWith("#pragma");¬∂	}¬∂	public static void addToStack(Stack<OpenMPPragma> anOpenMPPragmas, String aFileLine, int aLineNumber) {¬∂		for (OpenMPPragma anOpenMPPragma:anOpenMPPragmas) {¬∂			anOpenMPPragma.addToAnnotatedText(aFileLine, aLineNumber);				¬∂		}¬∂		¬∂	}¬∂	public static ForHeader getForHeader(String aFileLine, int aLineNumber) {¬∂		if (!aFileLine.startsWith("for"))¬∂			return null;¬∂		int aLeftParenIndex = aFileLine.indexOf("(");¬∂		int aRightParenIndex = aFileLine.indexOf(")");¬∂		if (aLeftParenIndex < 0 || aRightParenIndex < 0) {¬∂			return null;¬∂		}¬∂		String aHeaderString = aFileLine.substring(aLeftParenIndex + 1, aRightParenIndex);¬∂		String[] aForComponents = aHeaderString.split(";");¬∂		return new AForHeader(aForComponents[0], aForComponents[1], aForComponents[2], aLineNumber);¬∂	}¬∂	public static List<String> getOMPCalls(String aFileLine) {¬∂		List<String> retVal = new ArrayList();¬∂		for (String anOpenMPCall:openMPCalls) {¬∂			if (aFileLine.contains(anOpenMPCall)) {¬∂				retVal.add(anOpenMPCall);¬∂			}¬∂		}¬∂		return retVal;¬∂	}¬∂	¬∂	public static void incrementStackTop (Stack<Integer> aNumOpenBracesStack) {¬∂		int aTopIndex = aNumOpenBracesStack.size() - 1;¬∂		Integer aCurrentValue = aNumOpenBracesStack.get(aTopIndex);¬∂		aNumOpenBracesStack.set(aTopIndex, aCurrentValue + 1);¬∂	}¬∂	public static void decrementStackTop (Stack<Integer> aNumOpenBracesStack) {¬∂		int aTopIndex = aNumOpenBracesStack.size() - 1;¬∂		Integer aCurrentValue = aNumOpenBracesStack.get(aTopIndex);¬∂		aNumOpenBracesStack.set(aTopIndex, aCurrentValue - 1);¬∂	}¬∂	¬∂	public static boolean startsWithTypeName(String aLine) {¬∂		for (String aTypeName:typeNames) {¬∂			if (aLine.startsWith(aTypeName)) {¬∂				return true;¬∂			}¬∂		}¬∂		return false;¬∂	}¬∂¬∂	public static List<OpenMPPragma> getOpenMPPragmas(String[] aFileLines) {¬∂		List<OpenMPPragma> retVal = new ArrayList();¬∂		Stack<OpenMPPragma> anOpenMPPragmas = new Stack();¬∂		Stack<Integer> aNumOpenBracesStack = new Stack();¬∂//		OpenMPPragma lastOpenMPPragma = null;¬∂//		String lastReductionVariable = null;¬∂//		String lastReductionOperation = null;¬∂//		int aNumOpenBraces = 0;¬∂		boolean aNextCodeLineIsAPragmaBlock = false;¬∂		List<OpenMPPragma> newOpenMPPragmas = null;¬∂		for (int i = 0; i < aFileLines.length; i++) {¬∂			String aFileLine = aFileLines[i].trim();¬∂			if (!isCodeLine(aFileLine)) {¬∂				continue;¬∂			}¬∂			addToStack(anOpenMPPragmas, aFileLine, i); // if it is empty add to none¬∂//			if (lastReductionVariable != null) {¬∂//				if (aFileLine.startsWith(lastReductionVariable)) {¬∂//					lastOpenMPPragma.getReductionVariableAssignments().add(aFileLine);¬∂//					if (lastReductionOperation != null) { // can it ever be not null¬∂//						if (aFileLine.contains(lastReductionOperation)) {¬∂//							lastOpenMPPragma.getReductionOperationUses().add(aFileLine);¬∂//						}¬∂//					}¬∂//				}			¬∂//			}¬∂//			if (lastOpenMPPragma != null && lastOpenMPPragma.getFirstOpenMPKeyword() == OpenMPKeywordEnum.PARALLEL) {¬∂//				if (startsWithTypeName(aFileLine)) {¬∂//					lastOpenMPPragma.getVariableDeclarationsInParallel().add(aFileLine);¬∂//				}¬∂//			} ¬∂//			else if (lastOpenMPPragma != null && lastOpenMPPragma.getFirstOpenMPKeyword() == OpenMPKeywordEnum.CRITICAL) {¬∂//				String[] aTokens = aFileLine.split("\\s+");¬∂//				lastOpenMPPragma.setAssignedVariableInCritical(aTokens[0]);				¬∂//			}¬∂			if (isPragmaStart(aFileLine)) {¬∂				¬∂				newOpenMPPragmas = getOpenMPPragmas(aFileLine, i);¬∂				if (newOpenMPPragmas.size() != 0) {¬∂					for (OpenMPPragma anOpenMPPragma:newOpenMPPragmas) {¬∂						if (anOpenMPPragmas.size() > 0) {¬∂						    anOpenMPPragma.setParent(anOpenMPPragmas.peek());¬∂						}¬∂						anOpenMPPragmas.push(anOpenMPPragma);¬∂						aNumOpenBracesStack.push(0);¬∂						retVal.add(anOpenMPPragma);¬∂¬∂					}¬∂//					anOpenMPPragmas.addAll(newOpenMPPragmas);¬∂					aNumOpenBracesStack.add(0);¬∂//					retVal.add(lastOpenMPPragma);					¬∂					aNextCodeLineIsAPragmaBlock = true;¬∂//					String lastReductionOperation = lastOpenMPPragma.getReductionOperation();¬∂//					String lastReductionVariable = lastOpenMPPragma.getReductionVariable();¬∂					continue;¬∂				} ¬∂			}¬∂			if (anOpenMPPragmas.isEmpty()) {¬∂				continue;¬∂			}	¬∂			if (aNextCodeLineIsAPragmaBlock) {				¬∂				anOpenMPPragmas.peek().setAnnotatedTextStartLineNumber(i);				¬∂				aNextCodeLineIsAPragmaBlock = false;¬∂			}¬∂//			anOpenMPPragmas.peek().getAnnotatedText().add(aFileLine);¬∂			if (isBlockStart(aFileLine)) {¬∂				incrementStackTop(aNumOpenBracesStack);¬∂			}¬∂//			} else ¬∂			if (isBlockEnd(aFileLine)) {¬∂				decrementStackTop(aNumOpenBracesStack);¬∂¬∂			}¬∂			if (isLoopStart(aFileLine) && endsWithLoopHeader(aFileLine)) {¬∂				continue; // gather following block also¬∂			}¬∂			if (aNumOpenBracesStack.peek() == 0) {¬∂				¬∂				anOpenMPPragmas.peek().setAnnotatedTextEndLineNumber(i);¬∂				for (int j = 0; j < newOpenMPPragmas.size(); j++) {¬∂					anOpenMPPragmas.pop();¬∂					aNumOpenBracesStack.pop();¬∂				}¬∂//				lastOpenMPPragma = null;¬∂//				lastReductionVariable = null;¬∂//				lastReductionOperation = null;¬∂				continue;¬∂			}					¬∂		}¬∂		return retVal;¬∂	}¬∂	public static void setReductionData (OpenMPPragma lastChild, String aStoredToken, int aLeftParenIndex, int aRightParenIndex) {¬∂		int aColonIndex = aStoredToken.indexOf(":");¬∂		if (aLeftParenIndex != -1 && aRightParenIndex != -1 && aColonIndex != -1) {¬∂			String anOperationString = aStoredToken.substring(aLeftParenIndex + 1, aColonIndex).trim();¬∂			String aVariableString = aStoredToken.substring(aColonIndex + 1, aRightParenIndex).trim();¬∂			((OpenMPForPragma) lastChild).setReductionVariable(aVariableString);¬∂			((OpenMPForPragma) lastChild).setReductionOperation(anOperationString);¬∂		}¬∂	}¬∂	public static void setSharedOrPrivateData (OpenMPPragma lastChild, String aStoredToken, int aLeftParenIndex, int aRightParenIndex, boolean isShared) {¬∂		int aColonIndex = aStoredToken.indexOf(":");¬∂		if (aLeftParenIndex != -1 && aRightParenIndex != -1 ) {¬∂			String aVariableDeclarations = aStoredToken.substring(aLeftParenIndex + 1, aRightParenIndex);¬∂			String[]"), Diff(DELETE,"¬∂			String anOperationString = aStoredToken.substring(aLeftParenIndex + 1, aColonIndex).trim();¬∂			String aVariableString = aStoredToken.substring(aColonIndex + 1, aRightParenIndex).trim();"), Diff(INSERT," aVariables = aVariableDeclarations.split(",");¬∂			if (isShared) {"), Diff(EQUAL,"¬∂			"), Diff(INSERT,"	"), Diff(DELETE,"((OpenMPForPragma) "), Diff(EQUAL,"lastChild"), Diff(DELETE,")"), Diff(EQUAL,".set"), Diff(DELETE,"Reduction"), Diff(INSERT,"Shared"), Diff(EQUAL,"Variable"), Diff(INSERT,"s"), Diff(EQUAL,"(aVariable"), Diff(DELETE,"String"), Diff(INSERT,"s"), Diff(EQUAL,");¬∂			"), Diff(DELETE,"((OpenMPForPragma) "), Diff(INSERT,"} else {¬∂				"), Diff(EQUAL,"lastChild"), Diff(DELETE,")"), Diff(EQUAL,".set"), Diff(DELETE,"ReductionOperation(anOperationString);"), Diff(INSERT,"PrivateVariables(aVariables);¬∂			}			"), Diff(EQUAL,"¬∂		}¬∂	}¬∂	public static List<OpenMPPragma> getOpenMPPragmas(String aFileLine, int aLineIndex) {¬∂		String[] aTokens = aFileLine.split("\\s+");¬∂		if (aTokens.length <= 2) {¬∂			return null;¬∂		}¬∂		if (!aTokens[1].equals("omp")) {¬∂			return null;¬∂		}¬∂		if (aTokens.length < 3) {¬∂			return null;¬∂		}¬∂		String aFirstToken = aTokens[2];¬∂		OpenMPKeywordEnum anOpenMPKeyword = stringToOpenMPKeyword.get(aFirstToken);¬∂		List<OpenMPPragma> retVal = new ArrayList();¬∂		OpenMPPragma lastChild;¬∂		int aStartIndex = 2;¬∂		switch (anOpenMPKeyword) {¬∂		case PARALLEL:¬∂			lastChild = new AnOpenMPParallelPragma(aLineIndex);¬∂			¬∂//			lastChild.setFirstOpenMPKeyword(stringToOpenMPKeyword.get(aFirstToken));	¬∂¬∂			retVal.add(lastChild);¬∂			if (aTokens.length > 3 && aTokens[3].equals("for")) {¬∂				OpenMPPragma aForChild = new AnOpenMPForPragma(aLineIndex);¬∂				retVal.add(aForChild);¬∂				lastChild = aForChild;¬∂				aStartIndex++;¬∂			}¬∂			break;¬∂		case FOR:¬∂			lastChild = new AnOpenMPForPragma(aLineIndex);¬∂			retVal.add (lastChild);¬∂			break;¬∂		case CRITICAL:¬∂			lastChild = new AnOpenMPCriticalPragma(aLineIndex);¬∂			retVal.add (lastChild);¬∂			break;¬∂			default: ¬∂				lastChild = new AnOpenMPPragma(aLineIndex);¬∂				retVal.add(lastChild);¬∂			¬∂		}¬∂//		retVal.setFirstOpenMPKeyword(stringToOpenMPKeyword.get(aFirstToken));	¬∂//		OpenMPPragma retVal = new AnOpenMPPragma(aLineIndex);¬∂¬∂¬∂		for (int i = aStartIndex; i < aTokens.length; i ++) {¬∂			String aStoredToken = aTokens[i].trim();¬∂			if (aStoredToken.isEmpty()) {¬∂				continue;¬∂			}¬∂			if (aStoredToken.startsWith("reduction") || aStoredToken.startsWith("shared") || aStoredToken.startsWith("private")) {¬∂				//combine all tokens until ")" into one for normalization¬∂				while (!aStoredToken.endsWith(")")) {¬∂					i++;¬∂					if (i >= aTokens.length) {¬∂						break;¬∂					}¬∂					String aNewToken = aTokens[i].trim();¬∂					aStoredToken += aNewToken; 					¬∂				}¬∂				int aLeftParenIndex = aStoredToken.indexOf("(");¬∂				int aRightParenIndex = aStoredToken.indexOf(")");¬∂				if (aStoredToken.startsWith("reduction")) {¬∂					setReductionData(lastChild, aStoredToken, aLeftParenIndex, aRightParenIndex);¬∂				} else if (aStoredToken.startsWith("private")) {¬∂					set"), Diff(DELETE,"PrivateOrShared"), Diff(INSERT,"SharedOrPrivate"), Diff(EQUAL,"Data(lastChild, aStoredToken, aLeftParenIndex, aRightParenIndex, true);¬∂¬∂				} else if "), Diff(DELETE,"("), Diff(EQUAL,"(aStoredToken.startsWith("shared")) {¬∂					set"), Diff(DELETE,"PrivateOrShared"), Diff(INSERT,"SharedOrPrivate"), Diff(EQUAL,"Data(lastChild, aStoredToken, aLeftParenIndex, aRightParenIndex, false);¬∂¬∂				}¬∂//				int aColonIndex = aStoredToken.indexOf(":");¬∂//				if (aLeftParenIndex != -1 && aRightParenIndex != -1 && aColonIndex != -1) {¬∂//					String anOperationString = aStoredToken.substring(aLeftParenIndex + 1, aColonIndex).trim();¬∂//					String aVariableString = aStoredToken.substring(aColonIndex + 1, aRightParenIndex).trim();¬∂//					((OpenMPForPragma) lastChild).setReductionVariable(aVariableString);¬∂//					((OpenMPForPragma) lastChild).setReductionOperation(anOperationString);¬∂//				}¬∂				¬∂			}¬∂			¬∂//			aTokens[i] = aStoredToken;¬∂			lastChild.getOpenMPTokens().add(aStoredToken);¬∂		}¬∂//		String aFirstToken = retVal.getOpenMPTokens().get(0);¬∂//		retVal.setFirstOpenMPKeyword(stringToOpenMPKeyword.get(aFirstToken));		¬∂		return retVal;¬∂		¬∂		¬∂	}¬∂	static {¬∂		stringToOpenMPKeyword.put("for", OpenMPKeywordEnum.FOR);¬∂		stringToOpenMPKeyword.put("parallel", OpenMPKeywordEnum.PARALLEL);¬∂		stringToOpenMPKeyword.put("reduce", OpenMPKeywordEnum.REDUCE);¬∂		stringToOpenMPKeyword.put("shared", OpenMPKeywordEnum.SHARED);¬∂		stringToOpenMPKeyword.put("private", OpenMPKeywordEnum.PRIVATE);¬∂		stringToOpenMPKeyword.put("critical", OpenMPKeywordEnum.CRITICAL);¬∂¬∂¬∂¬∂¬∂¬∂	}¬∂	¬∂¬∂}¬∂")]]]></diff>
    <snapshot><![CDATA[package gradingTools.shared.testcases.openmp;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Stack;


public class OpenMPUtils {
	
	protected static Map<String, OpenMPKeywordEnum> stringToOpenMPKeyword = new HashMap();
	protected static String[] typeNames = {"double", "float", "int", "short", "long"};
	protected static String[] openMPCalls = {"omp_get_thread_num()", "omp_get_num_threads()"};
	public static List<OpenMPPragma> getOpemMPPragmas(StringBuffer aFileBuffer) {
		String[] aFileLines = aFileBuffer.toString().split("\n");
		return getOpenMPPragmas(aFileLines);
	}
	
	public static boolean isCodeLine(String aLine) {
		return !aLine.isEmpty() && !aLine.startsWith("//");
	}
	public static boolean isBlockStart(String aLine) {
		return aLine.contains("{");
	}
	public static boolean isBlockEnd(String aLine) {
		return aLine.contains("}");
	}
	public static boolean isLoopStart(String aLine) {
		return aLine.startsWith("for");
	}
	public static boolean endsWithLoopHeader(String aLine) {
		return aLine.endsWith(")");
	}
	public static boolean isPragmaStart(String aLine) {
		return aLine.startsWith("#pragma");
	}
	public static void addToStack(Stack<OpenMPPragma> anOpenMPPragmas, String aFileLine, int aLineNumber) {
		for (OpenMPPragma anOpenMPPragma:anOpenMPPragmas) {
			anOpenMPPragma.addToAnnotatedText(aFileLine, aLineNumber);				
		}
		
	}
	public static ForHeader getForHeader(String aFileLine, int aLineNumber) {
		if (!aFileLine.startsWith("for"))
			return null;
		int aLeftParenIndex = aFileLine.indexOf("(");
		int aRightParenIndex = aFileLine.indexOf(")");
		if (aLeftParenIndex < 0 || aRightParenIndex < 0) {
			return null;
		}
		String aHeaderString = aFileLine.substring(aLeftParenIndex + 1, aRightParenIndex);
		String[] aForComponents = aHeaderString.split(";");
		return new AForHeader(aForComponents[0], aForComponents[1], aForComponents[2], aLineNumber);
	}
	public static List<String> getOMPCalls(String aFileLine) {
		List<String> retVal = new ArrayList();
		for (String anOpenMPCall:openMPCalls) {
			if (aFileLine.contains(anOpenMPCall)) {
				retVal.add(anOpenMPCall);
			}
		}
		return retVal;
	}
	
	public static void incrementStackTop (Stack<Integer> aNumOpenBracesStack) {
		int aTopIndex = aNumOpenBracesStack.size() - 1;
		Integer aCurrentValue = aNumOpenBracesStack.get(aTopIndex);
		aNumOpenBracesStack.set(aTopIndex, aCurrentValue + 1);
	}
	public static void decrementStackTop (Stack<Integer> aNumOpenBracesStack) {
		int aTopIndex = aNumOpenBracesStack.size() - 1;
		Integer aCurrentValue = aNumOpenBracesStack.get(aTopIndex);
		aNumOpenBracesStack.set(aTopIndex, aCurrentValue - 1);
	}
	
	public static boolean startsWithTypeName(String aLine) {
		for (String aTypeName:typeNames) {
			if (aLine.startsWith(aTypeName)) {
				return true;
			}
		}
		return false;
	}

	public static List<OpenMPPragma> getOpenMPPragmas(String[] aFileLines) {
		List<OpenMPPragma> retVal = new ArrayList();
		Stack<OpenMPPragma> anOpenMPPragmas = new Stack();
		Stack<Integer> aNumOpenBracesStack = new Stack();
//		OpenMPPragma lastOpenMPPragma = null;
//		String lastReductionVariable = null;
//		String lastReductionOperation = null;
//		int aNumOpenBraces = 0;
		boolean aNextCodeLineIsAPragmaBlock = false;
		List<OpenMPPragma> newOpenMPPragmas = null;
		for (int i = 0; i < aFileLines.length; i++) {
			String aFileLine = aFileLines[i].trim();
			if (!isCodeLine(aFileLine)) {
				continue;
			}
			addToStack(anOpenMPPragmas, aFileLine, i); // if it is empty add to none
//			if (lastReductionVariable != null) {
//				if (aFileLine.startsWith(lastReductionVariable)) {
//					lastOpenMPPragma.getReductionVariableAssignments().add(aFileLine);
//					if (lastReductionOperation != null) { // can it ever be not null
//						if (aFileLine.contains(lastReductionOperation)) {
//							lastOpenMPPragma.getReductionOperationUses().add(aFileLine);
//						}
//					}
//				}			
//			}
//			if (lastOpenMPPragma != null && lastOpenMPPragma.getFirstOpenMPKeyword() == OpenMPKeywordEnum.PARALLEL) {
//				if (startsWithTypeName(aFileLine)) {
//					lastOpenMPPragma.getVariableDeclarationsInParallel().add(aFileLine);
//				}
//			} 
//			else if (lastOpenMPPragma != null && lastOpenMPPragma.getFirstOpenMPKeyword() == OpenMPKeywordEnum.CRITICAL) {
//				String[] aTokens = aFileLine.split("\\s+");
//				lastOpenMPPragma.setAssignedVariableInCritical(aTokens[0]);				
//			}
			if (isPragmaStart(aFileLine)) {
				
				newOpenMPPragmas = getOpenMPPragmas(aFileLine, i);
				if (newOpenMPPragmas.size() != 0) {
					for (OpenMPPragma anOpenMPPragma:newOpenMPPragmas) {
						if (anOpenMPPragmas.size() > 0) {
						    anOpenMPPragma.setParent(anOpenMPPragmas.peek());
						}
						anOpenMPPragmas.push(anOpenMPPragma);
						aNumOpenBracesStack.push(0);
						retVal.add(anOpenMPPragma);

					}
//					anOpenMPPragmas.addAll(newOpenMPPragmas);
					aNumOpenBracesStack.add(0);
//					retVal.add(lastOpenMPPragma);					
					aNextCodeLineIsAPragmaBlock = true;
//					String lastReductionOperation = lastOpenMPPragma.getReductionOperation();
//					String lastReductionVariable = lastOpenMPPragma.getReductionVariable();
					continue;
				} 
			}
			if (anOpenMPPragmas.isEmpty()) {
				continue;
			}	
			if (aNextCodeLineIsAPragmaBlock) {				
				anOpenMPPragmas.peek().setAnnotatedTextStartLineNumber(i);				
				aNextCodeLineIsAPragmaBlock = false;
			}
//			anOpenMPPragmas.peek().getAnnotatedText().add(aFileLine);
			if (isBlockStart(aFileLine)) {
				incrementStackTop(aNumOpenBracesStack);
			}
//			} else 
			if (isBlockEnd(aFileLine)) {
				decrementStackTop(aNumOpenBracesStack);

			}
			if (isLoopStart(aFileLine) && endsWithLoopHeader(aFileLine)) {
				continue; // gather following block also
			}
			if (aNumOpenBracesStack.peek() == 0) {
				
				anOpenMPPragmas.peek().setAnnotatedTextEndLineNumber(i);
				for (int j = 0; j < newOpenMPPragmas.size(); j++) {
					anOpenMPPragmas.pop();
					aNumOpenBracesStack.pop();
				}
//				lastOpenMPPragma = null;
//				lastReductionVariable = null;
//				lastReductionOperation = null;
				continue;
			}					
		}
		return retVal;
	}
	public static void setReductionData (OpenMPPragma lastChild, String aStoredToken, int aLeftParenIndex, int aRightParenIndex) {
		int aColonIndex = aStoredToken.indexOf(":");
		if (aLeftParenIndex != -1 && aRightParenIndex != -1 && aColonIndex != -1) {
			String anOperationString = aStoredToken.substring(aLeftParenIndex + 1, aColonIndex).trim();
			String aVariableString = aStoredToken.substring(aColonIndex + 1, aRightParenIndex).trim();
			((OpenMPForPragma) lastChild).setReductionVariable(aVariableString);
			((OpenMPForPragma) lastChild).setReductionOperation(anOperationString);
		}
	}
	public static void setSharedOrPrivateData (OpenMPPragma lastChild, String aStoredToken, int aLeftParenIndex, int aRightParenIndex, boolean isShared) {
		int aColonIndex = aStoredToken.indexOf(":");
		if (aLeftParenIndex != -1 && aRightParenIndex != -1 ) {
			String aVariableDeclarations = aStoredToken.substring(aLeftParenIndex + 1, aRightParenIndex);
			String[] aVariables = aVariableDeclarations.split(",");
			if (isShared) {
				lastChild.setSharedVariables(aVariables);
			} else {
				lastChild.setPrivateVariables(aVariables);
			}			
		}
	}
	public static List<OpenMPPragma> getOpenMPPragmas(String aFileLine, int aLineIndex) {
		String[] aTokens = aFileLine.split("\\s+");
		if (aTokens.length <= 2) {
			return null;
		}
		if (!aTokens[1].equals("omp")) {
			return null;
		}
		if (aTokens.length < 3) {
			return null;
		}
		String aFirstToken = aTokens[2];
		OpenMPKeywordEnum anOpenMPKeyword = stringToOpenMPKeyword.get(aFirstToken);
		List<OpenMPPragma> retVal = new ArrayList();
		OpenMPPragma lastChild;
		int aStartIndex = 2;
		switch (anOpenMPKeyword) {
		case PARALLEL:
			lastChild = new AnOpenMPParallelPragma(aLineIndex);
			
//			lastChild.setFirstOpenMPKeyword(stringToOpenMPKeyword.get(aFirstToken));	

			retVal.add(lastChild);
			if (aTokens.length > 3 && aTokens[3].equals("for")) {
				OpenMPPragma aForChild = new AnOpenMPForPragma(aLineIndex);
				retVal.add(aForChild);
				lastChild = aForChild;
				aStartIndex++;
			}
			break;
		case FOR:
			lastChild = new AnOpenMPForPragma(aLineIndex);
			retVal.add (lastChild);
			break;
		case CRITICAL:
			lastChild = new AnOpenMPCriticalPragma(aLineIndex);
			retVal.add (lastChild);
			break;
			default: 
				lastChild = new AnOpenMPPragma(aLineIndex);
				retVal.add(lastChild);
			
		}
//		retVal.setFirstOpenMPKeyword(stringToOpenMPKeyword.get(aFirstToken));	
//		OpenMPPragma retVal = new AnOpenMPPragma(aLineIndex);


		for (int i = aStartIndex; i < aTokens.length; i ++) {
			String aStoredToken = aTokens[i].trim();
			if (aStoredToken.isEmpty()) {
				continue;
			}
			if (aStoredToken.startsWith("reduction") || aStoredToken.startsWith("shared") || aStoredToken.startsWith("private")) {
				//combine all tokens until ")" into one for normalization
				while (!aStoredToken.endsWith(")")) {
					i++;
					if (i >= aTokens.length) {
						break;
					}
					String aNewToken = aTokens[i].trim();
					aStoredToken += aNewToken; 					
				}
				int aLeftParenIndex = aStoredToken.indexOf("(");
				int aRightParenIndex = aStoredToken.indexOf(")");
				if (aStoredToken.startsWith("reduction")) {
					setReductionData(lastChild, aStoredToken, aLeftParenIndex, aRightParenIndex);
				} else if (aStoredToken.startsWith("private")) {
					setSharedOrPrivateData(lastChild, aStoredToken, aLeftParenIndex, aRightParenIndex, true);

				} else if (aStoredToken.startsWith("shared")) {
					setSharedOrPrivateData(lastChild, aStoredToken, aLeftParenIndex, aRightParenIndex, false);

				}
//				int aColonIndex = aStoredToken.indexOf(":");
//				if (aLeftParenIndex != -1 && aRightParenIndex != -1 && aColonIndex != -1) {
//					String anOperationString = aStoredToken.substring(aLeftParenIndex + 1, aColonIndex).trim();
//					String aVariableString = aStoredToken.substring(aColonIndex + 1, aRightParenIndex).trim();
//					((OpenMPForPragma) lastChild).setReductionVariable(aVariableString);
//					((OpenMPForPragma) lastChild).setReductionOperation(anOperationString);
//				}
				
			}
			
//			aTokens[i] = aStoredToken;
			lastChild.getOpenMPTokens().add(aStoredToken);
		}
//		String aFirstToken = retVal.getOpenMPTokens().get(0);
//		retVal.setFirstOpenMPKeyword(stringToOpenMPKeyword.get(aFirstToken));		
		return retVal;
		
		
	}
	static {
		stringToOpenMPKeyword.put("for", OpenMPKeywordEnum.FOR);
		stringToOpenMPKeyword.put("parallel", OpenMPKeywordEnum.PARALLEL);
		stringToOpenMPKeyword.put("reduce", OpenMPKeywordEnum.REDUCE);
		stringToOpenMPKeyword.put("shared", OpenMPKeywordEnum.SHARED);
		stringToOpenMPKeyword.put("private", OpenMPKeywordEnum.PRIVATE);
		stringToOpenMPKeyword.put("critical", OpenMPKeywordEnum.CRITICAL);





	}
	

}
]]></snapshot>
  </Command>
  <DocumentChange __id="67924" _type="Insert" date="Mon Dec 23 23:33:09 EST 2019" docASTNodeCount="1270" docActiveCodeLength="8780" docExpressionCount="793" docLength="11253" length="2" offset="7140" starttimestamp="1576666505112" timestamp="495484196">
    <text><![CDATA[//]]></text>
  </DocumentChange>
  <Command __id="67969" _type="DiffBasedFileOpenCommand" date="Mon Dec 23 23:33:16 EST 2019" projectName="null" starttimestamp="1576666505112" timestamp="495491769">
    <filePath><![CDATA[null]]></filePath>
    <diff><![CDATA[null]]></diff>
  </Command>
  <Command __id="67973" _type="DiffBasedFileOpenCommand" date="Mon Dec 23 23:33:19 EST 2019" docASTNodeCount="1270" docActiveCodeLength="8780" docExpressionCount="793" docLength="11253" projectName="GraderBasics" starttimestamp="1576666505112" timestamp="495494278">
    <filePath><![CDATA[D:\dewan_backup\Java\GraderBasics\src\gradingTools\shared\testcases\openmp\OpenMPUtils.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package gradingTools.shared.testcases.openmp;¬∂¬∂import java.util.ArrayList;¬∂import java.util.HashMap;¬∂import java.util.List;¬∂import java.util.Map;¬∂import java.util.Stack;¬∂¬∂¬∂public class OpenMPUtils {¬∂	¬∂	protected static Map<String, OpenMPKeywordEnum> stringToOpenMPKeyword = new HashMap();¬∂	protected static String[] typeNames = {"double", "float", "int", "short", "long"};¬∂	protected static String[] openMPCalls = {"omp_get_thread_num()", "omp_get_num_threads()"};¬∂	public static List<OpenMPPragma> getOpemMPPragmas(StringBuffer aFileBuffer) {¬∂		String[] aFileLines = aFileBuffer.toString().split("\n");¬∂		return getOpenMPPragmas(aFileLines);¬∂	}¬∂	¬∂	public static boolean isCodeLine(String aLine) {¬∂		return !aLine.isEmpty() && !aLine.startsWith("//");¬∂	}¬∂	public static boolean isBlockStart(String aLine) {¬∂		return aLine.contains("{");¬∂	}¬∂	public static boolean isBlockEnd(String aLine) {¬∂		return aLine.contains("}");¬∂	}¬∂	public static boolean isLoopStart(String aLine) {¬∂		return aLine.startsWith("for");¬∂	}¬∂	public static boolean endsWithLoopHeader(String aLine) {¬∂		return aLine.endsWith(")");¬∂	}¬∂	public static boolean isPragmaStart(String aLine) {¬∂		return aLine.startsWith("#pragma");¬∂	}¬∂	public static void addToStack(Stack<OpenMPPragma> anOpenMPPragmas, String aFileLine, int aLineNumber) {¬∂		for (OpenMPPragma anOpenMPPragma:anOpenMPPragmas) {¬∂			anOpenMPPragma.addToAnnotatedText(aFileLine, aLineNumber);				¬∂		}¬∂		¬∂	}¬∂	public static ForHeader getForHeader(String aFileLine, int aLineNumber) {¬∂		if (!aFileLine.startsWith("for"))¬∂			return null;¬∂		int aLeftParenIndex = aFileLine.indexOf("(");¬∂		int aRightParenIndex = aFileLine.indexOf(")");¬∂		if (aLeftParenIndex < 0 || aRightParenIndex < 0) {¬∂			return null;¬∂		}¬∂		String aHeaderString = aFileLine.substring(aLeftParenIndex + 1, aRightParenIndex);¬∂		String[] aForComponents = aHeaderString.split(";");¬∂		return new AForHeader(aForComponents[0], aForComponents[1], aForComponents[2], aLineNumber);¬∂	}¬∂	public static List<String> getOMPCalls(String aFileLine) {¬∂		List<String> retVal = new ArrayList();¬∂		for (String anOpenMPCall:openMPCalls) {¬∂			if (aFileLine.contains(anOpenMPCall)) {¬∂				retVal.add(anOpenMPCall);¬∂			}¬∂		}¬∂		return retVal;¬∂	}¬∂	¬∂	public static void incrementStackTop (Stack<Integer> aNumOpenBracesStack) {¬∂		int aTopIndex = aNumOpenBracesStack.size() - 1;¬∂		Integer aCurrentValue = aNumOpenBracesStack.get(aTopIndex);¬∂		aNumOpenBracesStack.set(aTopIndex, aCurrentValue + 1);¬∂	}¬∂	public static void decrementStackTop (Stack<Integer> aNumOpenBracesStack) {¬∂		int aTopIndex = aNumOpenBracesStack.size() - 1;¬∂		Integer aCurrentValue = aNumOpenBracesStack.get(aTopIndex);¬∂		aNumOpenBracesStack.set(aTopIndex, aCurrentValue - 1);¬∂	}¬∂	¬∂	public static boolean startsWithTypeName(String aLine) {¬∂		for (String aTypeName:typeNames) {¬∂			if (aLine.startsWith(aTypeName)) {¬∂				return true;¬∂			}¬∂		}¬∂		return false;¬∂	}¬∂¬∂	public static List<OpenMPPragma> getOpenMPPragmas(String[] aFileLines) {¬∂		List<OpenMPPragma> retVal = new ArrayList();¬∂		Stack<OpenMPPragma> anOpenMPPragmas = new Stack();¬∂		Stack<Integer> aNumOpenBracesStack = new Stack();¬∂//		OpenMPPragma lastOpenMPPragma = null;¬∂//		String lastReductionVariable = null;¬∂//		String lastReductionOperation = null;¬∂//		int aNumOpenBraces = 0;¬∂		boolean aNextCodeLineIsAPragmaBlock = false;¬∂		List<OpenMPPragma> newOpenMPPragmas = null;¬∂		for (int i = 0; i < aFileLines.length; i++) {¬∂			String aFileLine = aFileLines[i].trim();¬∂			if (!isCodeLine(aFileLine)) {¬∂				continue;¬∂			}¬∂			addToStack(anOpenMPPragmas, aFileLine, i); // if it is empty add to none¬∂//			if (lastReductionVariable != null) {¬∂//				if (aFileLine.startsWith(lastReductionVariable)) {¬∂//					lastOpenMPPragma.getReductionVariableAssignments().add(aFileLine);¬∂//					if (lastReductionOperation != null) { // can it ever be not null¬∂//						if (aFileLine.contains(lastReductionOperation)) {¬∂//							lastOpenMPPragma.getReductionOperationUses().add(aFileLine);¬∂//						}¬∂//					}¬∂//				}			¬∂//			}¬∂//			if (lastOpenMPPragma != null && lastOpenMPPragma.getFirstOpenMPKeyword() == OpenMPKeywordEnum.PARALLEL) {¬∂//				if (startsWithTypeName(aFileLine)) {¬∂//					lastOpenMPPragma.getVariableDeclarationsInParallel().add(aFileLine);¬∂//				}¬∂//			} ¬∂//			else if (lastOpenMPPragma != null && lastOpenMPPragma.getFirstOpenMPKeyword() == OpenMPKeywordEnum.CRITICAL) {¬∂//				String[] aTokens = aFileLine.split("\\s+");¬∂//				lastOpenMPPragma.setAssignedVariableInCritical(aTokens[0]);				¬∂//			}¬∂			if (isPragmaStart(aFileLine)) {¬∂				¬∂				newOpenMPPragmas = getOpenMPPragmas(aFileLine, i);¬∂				if (newOpenMPPragmas.size() != 0) {¬∂					for (OpenMPPragma anOpenMPPragma:newOpenMPPragmas) {¬∂						if (anOpenMPPragmas.size() > 0) {¬∂						    anOpenMPPragma.setParent(anOpenMPPragmas.peek());¬∂						}¬∂						anOpenMPPragmas.push(anOpenMPPragma);¬∂						aNumOpenBracesStack.push(0);¬∂						retVal.add(anOpenMPPragma);¬∂¬∂					}¬∂//					anOpenMPPragmas.addAll(newOpenMPPragmas);¬∂					aNumOpenBracesStack.add(0);¬∂//					retVal.add(lastOpenMPPragma);					¬∂					aNextCodeLineIsAPragmaBlock = true;¬∂//					String lastReductionOperation = lastOpenMPPragma.getReductionOperation();¬∂//					String lastReductionVariable = lastOpenMPPragma.getReductionVariable();¬∂					continue;¬∂				} ¬∂			}¬∂			if (anOpenMPPragmas.isEmpty()) {¬∂				continue;¬∂			}	¬∂			if (aNextCodeLineIsAPragmaBlock) {				¬∂				anOpenMPPragmas.peek().setAnnotatedTextStartLineNumber(i);				¬∂				aNextCodeLineIsAPragmaBlock = false;¬∂			}¬∂//			anOpenMPPragmas.peek().getAnnotatedText().add(aFileLine);¬∂			if (isBlockStart(aFileLine)) {¬∂				incrementStackTop(aNumOpenBracesStack);¬∂			}¬∂//			} else ¬∂			if (isBlockEnd(aFileLine)) {¬∂				decrementStackTop(aNumOpenBracesStack);¬∂¬∂			}¬∂			if (isLoopStart(aFileLine) && endsWithLoopHeader(aFileLine)) {¬∂				continue; // gather following block also¬∂			}¬∂			if (aNumOpenBracesStack.peek() == 0) {¬∂				¬∂				anOpenMPPragmas.peek().setAnnotatedTextEndLineNumber(i);¬∂				for (int j = 0; j < newOpenMPPragmas.size(); j++) {¬∂					anOpenMPPragmas.pop();¬∂					aNumOpenBracesStack.pop();¬∂				}¬∂//				lastOpenMPPragma = null;¬∂//				lastReductionVariable = null;¬∂//				lastReductionOperation = null;¬∂				continue;¬∂			}					¬∂		}¬∂		return retVal;¬∂	}¬∂	public static void setReductionData (OpenMPPragma lastChild, String aStoredToken, int aLeftParenIndex, int aRightParenIndex) {¬∂		int aColonIndex = aStoredToken.indexOf(":");¬∂		if (aLeftParenIndex != -1 && aRightParenIndex != -1 && aColonIndex != -1) {¬∂			String anOperationString = aStoredToken.substring(aLeftParenIndex + 1, aColonIndex).trim();¬∂			String aVariableString = aStoredToken.substring(aColonIndex + 1, aRightParenIndex).trim();¬∂			((OpenMPForPragma) lastChild).setReductionVariable(aVariableString);¬∂			((OpenMPForPragma) lastChild).setReductionOperation(anOperationString);¬∂		}¬∂	}¬∂	public static void setSharedOrPrivateData (OpenMPPragma lastChild, String aStoredToken, int aLeftParenIndex, int aRightParenIndex, boolean isShared) {¬∂"), Diff(INSERT,"//"), Diff(EQUAL,"		int aColonIndex = aStoredToken.indexOf(":");¬∂		if (aLeftParenIndex != -1 && aRightParenIndex != -1 ) {¬∂			String aVariableDeclarations = aStoredToken.substring(aLeftParenIndex + 1, aRightParenIndex);¬∂			String[] aVariables = aVariableDeclarations.split(",");¬∂			if (isShared) {¬∂				lastChild.setSharedVariables(aVariables);¬∂			} else {¬∂				lastChild.setPrivateVariables(aVariables);¬∂			}			¬∂		}¬∂	}¬∂	public static List<OpenMPPragma> getOpenMPPragmas(String aFileLine, int aLineIndex) {¬∂		String[] aTokens = aFileLine.split("\\s+");¬∂		if (aTokens.length <= 2) {¬∂			return null;¬∂		}¬∂		if (!aTokens[1].equals("omp")) {¬∂			return null;¬∂		}¬∂		if (aTokens.length < 3) {¬∂			return null;¬∂		}¬∂		String aFirstToken = aTokens[2];¬∂		OpenMPKeywordEnum anOpenMPKeyword = stringToOpenMPKeyword.get(aFirstToken);¬∂		List<OpenMPPragma> retVal = new ArrayList();¬∂		OpenMPPragma lastChild;¬∂		int aStartIndex = 2;¬∂		switch (anOpenMPKeyword) {¬∂		case PARALLEL:¬∂			lastChild = new AnOpenMPParallelPragma(aLineIndex);¬∂			¬∂//			lastChild.setFirstOpenMPKeyword(stringToOpenMPKeyword.get(aFirstToken));	¬∂¬∂			retVal.add(lastChild);¬∂			if (aTokens.length > 3 && aTokens[3].equals("for")) {¬∂				OpenMPPragma aForChild = new AnOpenMPForPragma(aLineIndex);¬∂				retVal.add(aForChild);¬∂				lastChild = aForChild;¬∂				aStartIndex++;¬∂			}¬∂			break;¬∂		case FOR:¬∂			lastChild = new AnOpenMPForPragma(aLineIndex);¬∂			retVal.add (lastChild);¬∂			break;¬∂		case CRITICAL:¬∂			lastChild = new AnOpenMPCriticalPragma(aLineIndex);¬∂			retVal.add (lastChild);¬∂			break;¬∂			default: ¬∂				lastChild = new AnOpenMPPragma(aLineIndex);¬∂				retVal.add(lastChild);¬∂			¬∂		}¬∂//		retVal.setFirstOpenMPKeyword(stringToOpenMPKeyword.get(aFirstToken));	¬∂//		OpenMPPragma retVal = new AnOpenMPPragma(aLineIndex);¬∂¬∂¬∂		for (int i = aStartIndex; i < aTokens.length; i ++) {¬∂			String aStoredToken = aTokens[i].trim();¬∂			if (aStoredToken.isEmpty()) {¬∂				continue;¬∂			}¬∂			if (aStoredToken.startsWith("reduction") || aStoredToken.startsWith("shared") || aStoredToken.startsWith("private")) {¬∂				//combine all tokens until ")" into one for normalization¬∂				while (!aStoredToken.endsWith(")")) {¬∂					i++;¬∂					if (i >= aTokens.length) {¬∂						break;¬∂					}¬∂					String aNewToken = aTokens[i].trim();¬∂					aStoredToken += aNewToken; 					¬∂				}¬∂				int aLeftParenIndex = aStoredToken.indexOf("(");¬∂				int aRightParenIndex = aStoredToken.indexOf(")");¬∂				if (aStoredToken.startsWith("reduction")) {¬∂					setReductionData(lastChild, aStoredToken, aLeftParenIndex, aRightParenIndex);¬∂				} else if (aStoredToken.startsWith("private")) {¬∂					setSharedOrPrivateData(lastChild, aStoredToken, aLeftParenIndex, aRightParenIndex, true);¬∂¬∂				} else if (aStoredToken.startsWith("shared")) {¬∂					setSharedOrPrivateData(lastChild, aStoredToken, aLeftParenIndex, aRightParenIndex, false);¬∂¬∂				}¬∂//				int aColonIndex = aStoredToken.indexOf(":");¬∂//				if (aLeftParenIndex != -1 && aRightParenIndex != -1 && aColonIndex != -1) {¬∂//					String anOperationString = aStoredToken.substring(aLeftParenIndex + 1, aColonIndex).trim();¬∂//					String aVariableString = aStoredToken.substring(aColonIndex + 1, aRightParenIndex).trim();¬∂//					((OpenMPForPragma) lastChild).setReductionVariable(aVariableString);¬∂//					((OpenMPForPragma) lastChild).setReductionOperation(anOperationString);¬∂//				}¬∂				¬∂			}¬∂			¬∂//			aTokens[i] = aStoredToken;¬∂			lastChild.getOpenMPTokens().add(aStoredToken);¬∂		}¬∂//		String aFirstToken = retVal.getOpenMPTokens().get(0);¬∂//		retVal.setFirstOpenMPKeyword(stringToOpenMPKeyword.get(aFirstToken));		¬∂		return retVal;¬∂		¬∂		¬∂	}¬∂	static {¬∂		stringToOpenMPKeyword.put("for", OpenMPKeywordEnum.FOR);¬∂		stringToOpenMPKeyword.put("parallel", OpenMPKeywordEnum.PARALLEL);¬∂		stringToOpenMPKeyword.put("reduce", OpenMPKeywordEnum.REDUCE);¬∂		stringToOpenMPKeyword.put("shared", OpenMPKeywordEnum.SHARED);¬∂		stringToOpenMPKeyword.put("private", OpenMPKeywordEnum.PRIVATE);¬∂		stringToOpenMPKeyword.put("critical", OpenMPKeywordEnum.CRITICAL);¬∂¬∂¬∂¬∂¬∂¬∂	}¬∂	¬∂¬∂}¬∂")]]]></diff>
    <snapshot><![CDATA[package gradingTools.shared.testcases.openmp;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Stack;


public class OpenMPUtils {
	
	protected static Map<String, OpenMPKeywordEnum> stringToOpenMPKeyword = new HashMap();
	protected static String[] typeNames = {"double", "float", "int", "short", "long"};
	protected static String[] openMPCalls = {"omp_get_thread_num()", "omp_get_num_threads()"};
	public static List<OpenMPPragma> getOpemMPPragmas(StringBuffer aFileBuffer) {
		String[] aFileLines = aFileBuffer.toString().split("\n");
		return getOpenMPPragmas(aFileLines);
	}
	
	public static boolean isCodeLine(String aLine) {
		return !aLine.isEmpty() && !aLine.startsWith("//");
	}
	public static boolean isBlockStart(String aLine) {
		return aLine.contains("{");
	}
	public static boolean isBlockEnd(String aLine) {
		return aLine.contains("}");
	}
	public static boolean isLoopStart(String aLine) {
		return aLine.startsWith("for");
	}
	public static boolean endsWithLoopHeader(String aLine) {
		return aLine.endsWith(")");
	}
	public static boolean isPragmaStart(String aLine) {
		return aLine.startsWith("#pragma");
	}
	public static void addToStack(Stack<OpenMPPragma> anOpenMPPragmas, String aFileLine, int aLineNumber) {
		for (OpenMPPragma anOpenMPPragma:anOpenMPPragmas) {
			anOpenMPPragma.addToAnnotatedText(aFileLine, aLineNumber);				
		}
		
	}
	public static ForHeader getForHeader(String aFileLine, int aLineNumber) {
		if (!aFileLine.startsWith("for"))
			return null;
		int aLeftParenIndex = aFileLine.indexOf("(");
		int aRightParenIndex = aFileLine.indexOf(")");
		if (aLeftParenIndex < 0 || aRightParenIndex < 0) {
			return null;
		}
		String aHeaderString = aFileLine.substring(aLeftParenIndex + 1, aRightParenIndex);
		String[] aForComponents = aHeaderString.split(";");
		return new AForHeader(aForComponents[0], aForComponents[1], aForComponents[2], aLineNumber);
	}
	public static List<String> getOMPCalls(String aFileLine) {
		List<String> retVal = new ArrayList();
		for (String anOpenMPCall:openMPCalls) {
			if (aFileLine.contains(anOpenMPCall)) {
				retVal.add(anOpenMPCall);
			}
		}
		return retVal;
	}
	
	public static void incrementStackTop (Stack<Integer> aNumOpenBracesStack) {
		int aTopIndex = aNumOpenBracesStack.size() - 1;
		Integer aCurrentValue = aNumOpenBracesStack.get(aTopIndex);
		aNumOpenBracesStack.set(aTopIndex, aCurrentValue + 1);
	}
	public static void decrementStackTop (Stack<Integer> aNumOpenBracesStack) {
		int aTopIndex = aNumOpenBracesStack.size() - 1;
		Integer aCurrentValue = aNumOpenBracesStack.get(aTopIndex);
		aNumOpenBracesStack.set(aTopIndex, aCurrentValue - 1);
	}
	
	public static boolean startsWithTypeName(String aLine) {
		for (String aTypeName:typeNames) {
			if (aLine.startsWith(aTypeName)) {
				return true;
			}
		}
		return false;
	}

	public static List<OpenMPPragma> getOpenMPPragmas(String[] aFileLines) {
		List<OpenMPPragma> retVal = new ArrayList();
		Stack<OpenMPPragma> anOpenMPPragmas = new Stack();
		Stack<Integer> aNumOpenBracesStack = new Stack();
//		OpenMPPragma lastOpenMPPragma = null;
//		String lastReductionVariable = null;
//		String lastReductionOperation = null;
//		int aNumOpenBraces = 0;
		boolean aNextCodeLineIsAPragmaBlock = false;
		List<OpenMPPragma> newOpenMPPragmas = null;
		for (int i = 0; i < aFileLines.length; i++) {
			String aFileLine = aFileLines[i].trim();
			if (!isCodeLine(aFileLine)) {
				continue;
			}
			addToStack(anOpenMPPragmas, aFileLine, i); // if it is empty add to none
//			if (lastReductionVariable != null) {
//				if (aFileLine.startsWith(lastReductionVariable)) {
//					lastOpenMPPragma.getReductionVariableAssignments().add(aFileLine);
//					if (lastReductionOperation != null) { // can it ever be not null
//						if (aFileLine.contains(lastReductionOperation)) {
//							lastOpenMPPragma.getReductionOperationUses().add(aFileLine);
//						}
//					}
//				}			
//			}
//			if (lastOpenMPPragma != null && lastOpenMPPragma.getFirstOpenMPKeyword() == OpenMPKeywordEnum.PARALLEL) {
//				if (startsWithTypeName(aFileLine)) {
//					lastOpenMPPragma.getVariableDeclarationsInParallel().add(aFileLine);
//				}
//			} 
//			else if (lastOpenMPPragma != null && lastOpenMPPragma.getFirstOpenMPKeyword() == OpenMPKeywordEnum.CRITICAL) {
//				String[] aTokens = aFileLine.split("\\s+");
//				lastOpenMPPragma.setAssignedVariableInCritical(aTokens[0]);				
//			}
			if (isPragmaStart(aFileLine)) {
				
				newOpenMPPragmas = getOpenMPPragmas(aFileLine, i);
				if (newOpenMPPragmas.size() != 0) {
					for (OpenMPPragma anOpenMPPragma:newOpenMPPragmas) {
						if (anOpenMPPragmas.size() > 0) {
						    anOpenMPPragma.setParent(anOpenMPPragmas.peek());
						}
						anOpenMPPragmas.push(anOpenMPPragma);
						aNumOpenBracesStack.push(0);
						retVal.add(anOpenMPPragma);

					}
//					anOpenMPPragmas.addAll(newOpenMPPragmas);
					aNumOpenBracesStack.add(0);
//					retVal.add(lastOpenMPPragma);					
					aNextCodeLineIsAPragmaBlock = true;
//					String lastReductionOperation = lastOpenMPPragma.getReductionOperation();
//					String lastReductionVariable = lastOpenMPPragma.getReductionVariable();
					continue;
				} 
			}
			if (anOpenMPPragmas.isEmpty()) {
				continue;
			}	
			if (aNextCodeLineIsAPragmaBlock) {				
				anOpenMPPragmas.peek().setAnnotatedTextStartLineNumber(i);				
				aNextCodeLineIsAPragmaBlock = false;
			}
//			anOpenMPPragmas.peek().getAnnotatedText().add(aFileLine);
			if (isBlockStart(aFileLine)) {
				incrementStackTop(aNumOpenBracesStack);
			}
//			} else 
			if (isBlockEnd(aFileLine)) {
				decrementStackTop(aNumOpenBracesStack);

			}
			if (isLoopStart(aFileLine) && endsWithLoopHeader(aFileLine)) {
				continue; // gather following block also
			}
			if (aNumOpenBracesStack.peek() == 0) {
				
				anOpenMPPragmas.peek().setAnnotatedTextEndLineNumber(i);
				for (int j = 0; j < newOpenMPPragmas.size(); j++) {
					anOpenMPPragmas.pop();
					aNumOpenBracesStack.pop();
				}
//				lastOpenMPPragma = null;
//				lastReductionVariable = null;
//				lastReductionOperation = null;
				continue;
			}					
		}
		return retVal;
	}
	public static void setReductionData (OpenMPPragma lastChild, String aStoredToken, int aLeftParenIndex, int aRightParenIndex) {
		int aColonIndex = aStoredToken.indexOf(":");
		if (aLeftParenIndex != -1 && aRightParenIndex != -1 && aColonIndex != -1) {
			String anOperationString = aStoredToken.substring(aLeftParenIndex + 1, aColonIndex).trim();
			String aVariableString = aStoredToken.substring(aColonIndex + 1, aRightParenIndex).trim();
			((OpenMPForPragma) lastChild).setReductionVariable(aVariableString);
			((OpenMPForPragma) lastChild).setReductionOperation(anOperationString);
		}
	}
	public static void setSharedOrPrivateData (OpenMPPragma lastChild, String aStoredToken, int aLeftParenIndex, int aRightParenIndex, boolean isShared) {
//		int aColonIndex = aStoredToken.indexOf(":");
		if (aLeftParenIndex != -1 && aRightParenIndex != -1 ) {
			String aVariableDeclarations = aStoredToken.substring(aLeftParenIndex + 1, aRightParenIndex);
			String[] aVariables = aVariableDeclarations.split(",");
			if (isShared) {
				lastChild.setSharedVariables(aVariables);
			} else {
				lastChild.setPrivateVariables(aVariables);
			}			
		}
	}
	public static List<OpenMPPragma> getOpenMPPragmas(String aFileLine, int aLineIndex) {
		String[] aTokens = aFileLine.split("\\s+");
		if (aTokens.length <= 2) {
			return null;
		}
		if (!aTokens[1].equals("omp")) {
			return null;
		}
		if (aTokens.length < 3) {
			return null;
		}
		String aFirstToken = aTokens[2];
		OpenMPKeywordEnum anOpenMPKeyword = stringToOpenMPKeyword.get(aFirstToken);
		List<OpenMPPragma> retVal = new ArrayList();
		OpenMPPragma lastChild;
		int aStartIndex = 2;
		switch (anOpenMPKeyword) {
		case PARALLEL:
			lastChild = new AnOpenMPParallelPragma(aLineIndex);
			
//			lastChild.setFirstOpenMPKeyword(stringToOpenMPKeyword.get(aFirstToken));	

			retVal.add(lastChild);
			if (aTokens.length > 3 && aTokens[3].equals("for")) {
				OpenMPPragma aForChild = new AnOpenMPForPragma(aLineIndex);
				retVal.add(aForChild);
				lastChild = aForChild;
				aStartIndex++;
			}
			break;
		case FOR:
			lastChild = new AnOpenMPForPragma(aLineIndex);
			retVal.add (lastChild);
			break;
		case CRITICAL:
			lastChild = new AnOpenMPCriticalPragma(aLineIndex);
			retVal.add (lastChild);
			break;
			default: 
				lastChild = new AnOpenMPPragma(aLineIndex);
				retVal.add(lastChild);
			
		}
//		retVal.setFirstOpenMPKeyword(stringToOpenMPKeyword.get(aFirstToken));	
//		OpenMPPragma retVal = new AnOpenMPPragma(aLineIndex);


		for (int i = aStartIndex; i < aTokens.length; i ++) {
			String aStoredToken = aTokens[i].trim();
			if (aStoredToken.isEmpty()) {
				continue;
			}
			if (aStoredToken.startsWith("reduction") || aStoredToken.startsWith("shared") || aStoredToken.startsWith("private")) {
				//combine all tokens until ")" into one for normalization
				while (!aStoredToken.endsWith(")")) {
					i++;
					if (i >= aTokens.length) {
						break;
					}
					String aNewToken = aTokens[i].trim();
					aStoredToken += aNewToken; 					
				}
				int aLeftParenIndex = aStoredToken.indexOf("(");
				int aRightParenIndex = aStoredToken.indexOf(")");
				if (aStoredToken.startsWith("reduction")) {
					setReductionData(lastChild, aStoredToken, aLeftParenIndex, aRightParenIndex);
				} else if (aStoredToken.startsWith("private")) {
					setSharedOrPrivateData(lastChild, aStoredToken, aLeftParenIndex, aRightParenIndex, true);

				} else if (aStoredToken.startsWith("shared")) {
					setSharedOrPrivateData(lastChild, aStoredToken, aLeftParenIndex, aRightParenIndex, false);

				}
//				int aColonIndex = aStoredToken.indexOf(":");
//				if (aLeftParenIndex != -1 && aRightParenIndex != -1 && aColonIndex != -1) {
//					String anOperationString = aStoredToken.substring(aLeftParenIndex + 1, aColonIndex).trim();
//					String aVariableString = aStoredToken.substring(aColonIndex + 1, aRightParenIndex).trim();
//					((OpenMPForPragma) lastChild).setReductionVariable(aVariableString);
//					((OpenMPForPragma) lastChild).setReductionOperation(anOperationString);
//				}
				
			}
			
//			aTokens[i] = aStoredToken;
			lastChild.getOpenMPTokens().add(aStoredToken);
		}
//		String aFirstToken = retVal.getOpenMPTokens().get(0);
//		retVal.setFirstOpenMPKeyword(stringToOpenMPKeyword.get(aFirstToken));		
		return retVal;
		
		
	}
	static {
		stringToOpenMPKeyword.put("for", OpenMPKeywordEnum.FOR);
		stringToOpenMPKeyword.put("parallel", OpenMPKeywordEnum.PARALLEL);
		stringToOpenMPKeyword.put("reduce", OpenMPKeywordEnum.REDUCE);
		stringToOpenMPKeyword.put("shared", OpenMPKeywordEnum.SHARED);
		stringToOpenMPKeyword.put("private", OpenMPKeywordEnum.PRIVATE);
		stringToOpenMPKeyword.put("critical", OpenMPKeywordEnum.CRITICAL);





	}
	

}
]]></snapshot>
  </Command>
  <Command __id="67983" _type="EclipseCommand" commandID="AUTOGEN:::org.eclipse.jdt.debug.CompilationUnitEditor.BreakpointRulerActions/org.eclipse.jdt.debug.ui.actions.ManageBreakpointRulerAction" date="Mon Dec 23 23:33:44 EST 2019" starttimestamp="1576666505112" timestamp="495519662" />
  <Command __id="67984" _type="BreakPointCommand" date="Mon Dec 23 23:33:44 EST 2019" lineNumber="194" starttimestamp="1576666505112" timestamp="495519662" type="BreakPointAdded" />
  <Command __id="69343" _type="DiffBasedFileOpenCommand" date="Mon Dec 23 23:55:02 EST 2019" docASTNodeCount="146" docActiveCodeLength="1259" docExpressionCount="84" docLength="1469" projectName="GraderBasics" starttimestamp="1576666505112" timestamp="496797424">
    <filePath><![CDATA[D:\dewan_backup\Java\GraderBasics\src\gradingTools\shared\testcases\openmp\AnOpenMPCriticalPragma.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package gradingTools.shared.testcases.openmp;¬∂¬∂public class AnOpenMPCriticalPragma extends AnOpenMPPragma implements OpenMPCriticalPragma {¬∂	protected String assignedVariableInCritical;// separate subclass for this variable?¬∂	protected String assignedExpressionInCritical;// separate subclass for this variable?¬∂¬∂¬∂	¬∂	public AnOpenMPCriticalPragma(int lineNumber) {¬∂		super(lineNumber);¬∂	}¬∂	@Override¬∂	public void addToAnnotatedText(String aFileLine, int aLineNumber) {¬∂		super.addToAnnotatedText(aFileLine, aLineNumber);¬∂		String[] aTokens = aFileLine.split("\\s+");¬∂		setAssignedVariableInCritical(aTokens[0]);¬∂		"), Diff(INSERT,"¬∂//		String anExpressionString = aFileLine.substring(aFileLine.indexOf("=") + 1, aFileLine.length());¬∂		"), Diff(EQUAL,"String anExpressionString = aFileLine.substring(aTokens[0].length(), aFileLine.length());"), Diff(INSERT," // keep the assignment operation¬∂"), Diff(EQUAL,"¬∂		setAssignedExpressionInCritical(anExpressionString);¬∂	}¬∂	@Override¬∂	public String getAssignedVariableInCritical() {¬∂		return assignedVariableInCritical;¬∂	}¬∂	@Override¬∂	public void setAssignedVariableInCritical(String assignedVariableInCritical) {¬∂		this.assignedVariableInCritical = assignedVariableInCritical;¬∂	}¬∂	@Override¬∂	public String getAssignedExpressionInCritical() {¬∂		return assignedExpressionInCritical;¬∂	}¬∂	@Override¬∂	public void setAssignedExpressionInCritical(String assignedExpressionInCritical) {¬∂		this.assignedExpressionInCritical = assignedExpressionInCritical;¬∂	}¬∂}¬∂")]]]></diff>
    <snapshot><![CDATA[package gradingTools.shared.testcases.openmp;

public class AnOpenMPCriticalPragma extends AnOpenMPPragma implements OpenMPCriticalPragma {
	protected String assignedVariableInCritical;// separate subclass for this variable?
	protected String assignedExpressionInCritical;// separate subclass for this variable?


	
	public AnOpenMPCriticalPragma(int lineNumber) {
		super(lineNumber);
	}
	@Override
	public void addToAnnotatedText(String aFileLine, int aLineNumber) {
		super.addToAnnotatedText(aFileLine, aLineNumber);
		String[] aTokens = aFileLine.split("\\s+");
		setAssignedVariableInCritical(aTokens[0]);
		
//		String anExpressionString = aFileLine.substring(aFileLine.indexOf("=") + 1, aFileLine.length());
		String anExpressionString = aFileLine.substring(aTokens[0].length(), aFileLine.length()); // keep the assignment operation

		setAssignedExpressionInCritical(anExpressionString);
	}
	@Override
	public String getAssignedVariableInCritical() {
		return assignedVariableInCritical;
	}
	@Override
	public void setAssignedVariableInCritical(String assignedVariableInCritical) {
		this.assignedVariableInCritical = assignedVariableInCritical;
	}
	@Override
	public String getAssignedExpressionInCritical() {
		return assignedExpressionInCritical;
	}
	@Override
	public void setAssignedExpressionInCritical(String assignedExpressionInCritical) {
		this.assignedExpressionInCritical = assignedExpressionInCritical;
	}
}
]]></snapshot>
  </Command>
  <Command __id="69344" _type="MoveCaretCommand" caretOffset="858" date="Mon Dec 23 23:55:02 EST 2019" docOffset="858" starttimestamp="1576666505112" timestamp="496797760" />
  <Command __id="69346" _type="MoveCaretCommand" caretOffset="336" date="Mon Dec 23 23:55:33 EST 2019" docOffset="336" starttimestamp="1576666505112" timestamp="496828132" />
  <Command __id="69347" _type="EclipseCommand" commandID="" date="Mon Dec 23 23:55:33 EST 2019" starttimestamp="1576666505112" timestamp="496828608" />
  <Command __id="69348" _type="EclipseCommand" commandID="" date="Mon Dec 23 23:55:33 EST 2019" starttimestamp="1576666505112" timestamp="496828728" />
  <Command __id="69345" _type="DiffBasedFileOpenCommand" date="Mon Dec 23 23:55:32 EST 2019" docASTNodeCount="1" docActiveCodeLength="658" docExpressionCount="0" docLength="746" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="496827801">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\my_sum_parallel_for_local_var.cpp]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"#include <iostream>¬∂#include <omp.h>¬∂¬∂using namespace std;¬∂¬∂void printSumWithTimes (int sum, int start, int end);¬∂void printNumThreads();¬∂void recordThreadIndex(int index);¬∂void sum_parallel_for_local_var(double* array, int size)¬∂{¬∂	cout << "sum_parallel_for_local_var\n";¬∂¬∂	double start = omp_get_wtime();¬∂¬∂	double sum = 0;¬∂¬∂	int a, b;¬∂//¬∂//	for (int i = 0; i < size; i++) {¬∂//			sum += array[i];¬∂//			recordThreadIndex(i);¬∂//	}¬∂    #pragma omp parallel shared (sum, start) private (a, b)¬∂	{¬∂		double local_sum = 0;¬∂¬∂		#pragma omp for¬∂		for(int i = 0; i < size; i++) {¬∂			local_sum += array[i];¬∂			recordThreadIndex(i);¬∂		}¬∂¬∂		#pragma omp critical¬∂		sum += local_sum;¬∂	}¬∂¬∂	double end = omp_get_wtime();¬∂¬∂	printSumWithTimes(sum, start, end);¬∂	¬∂}¬∂")]]]></diff>
  </Command>
  <DocumentChange __id="69350" _type="Delete" date="Mon Dec 23 23:55:40 EST 2019" docASTNodeCount="1" docActiveCodeLength="624" docExpressionCount="0" docLength="712" endLine="22" length="34" offset="455" startLine="22" starttimestamp="1576666505112" timestamp="496835017">
    <text><![CDATA[shared (sum, start) private (a, b)]]></text>
  </DocumentChange>
  <Command __id="69349" _type="SelectTextCommand" caretOffset="489" date="Mon Dec 23 23:55:39 EST 2019" end="489" start="455" starttimestamp="1576666505112" timestamp="496834448" />
  <Command __id="69351" _type="EclipseCommand" commandID="org.eclipse.ui.edit.delete" date="Mon Dec 23 23:55:40 EST 2019" starttimestamp="1576666505112" timestamp="496835040" />
  <Command __id="69353" _type="UndoCommand" date="Mon Dec 23 23:55:43 EST 2019" starttimestamp="1576666505112" timestamp="496838802" />
  <Command __id="69354" _type="MoveCaretCommand" caretOffset="668" date="Mon Dec 23 23:56:04 EST 2019" docOffset="668" starttimestamp="1576666505112" timestamp="496859241" />
  <Command __id="69355" _type="SelectTextCommand" caretOffset="627" date="Mon Dec 23 23:56:07 EST 2019" end="668" start="627" starttimestamp="1576666505112" timestamp="496862018" />
  <Command __id="69356" _type="CopyCommand" date="Mon Dec 23 23:56:08 EST 2019" starttimestamp="1576666505112" timestamp="496862903" />
  <Command __id="69357" _type="MoveCaretCommand" caretOffset="429" date="Mon Dec 23 23:56:09 EST 2019" docOffset="429" starttimestamp="1576666505112" timestamp="496864518" />
  <Command __id="69359" _type="InsertStringCommand" date="Mon Dec 23 23:56:10 EST 2019" starttimestamp="1576666505112" timestamp="496865325" timestamp2="496865325">
    <data><![CDATA[]]></data>
  </Command>
  <Command __id="69361" _type="PasteCommand" date="Mon Dec 23 23:56:11 EST 2019" starttimestamp="1576666505112" timestamp="496866143" />
  <Command __id="69362" _type="MoveCaretCommand" caretOffset="430" date="Mon Dec 23 23:56:13 EST 2019" docOffset="430" starttimestamp="1576666505112" timestamp="496868016" />
  <Command __id="69364" _type="InsertStringCommand" date="Mon Dec 23 23:56:13 EST 2019" starttimestamp="1576666505112" timestamp="496868586" timestamp2="496868586">
    <data><![CDATA[	]]></data>
  </Command>
  <Command __id="69365" _type="SelectTextCommand" caretOffset="469" date="Mon Dec 23 23:56:16 EST 2019" end="469" start="460" starttimestamp="1576666505112" timestamp="496870889" />
  <Command __id="69367" _type="InsertStringCommand" date="Mon Dec 23 23:56:16 EST 2019" starttimestamp="1576666505112" timestamp="496871647" timestamp2="496871647">
    <data><![CDATA[0]]></data>
  </Command>
  <Command __id="69368" _type="EclipseCommand" commandID="org.eclipse.ui.file.save" date="Mon Dec 23 23:56:17 EST 2019" starttimestamp="1576666505112" timestamp="496872685" />
  <Command __id="69369" _type="EclipseCommand" commandID="org.eclipse.debug.ui.commands.RunLast" date="Mon Dec 23 23:56:21 EST 2019" starttimestamp="1576666505112" timestamp="496875926" />
  <Command __id="69370" _type="RunCommand" date="Mon Dec 23 23:56:21 EST 2019" kind="HitBreakPoint" projectName="PL_Java" starttimestamp="1576666505112" timestamp="496876444" type="Run" />
  <Command __id="69371" _type="RunCommand" date="Mon Dec 23 23:56:21 EST 2019" kind="HitBreakPoint" projectName="PL_Java" starttimestamp="1576666505112" timestamp="496876444" type="Run" />
  <Command __id="69372" _type="EHExceptionCommand" date="Mon Dec 23 23:56:21 EST 2019" starttimestamp="1576666505112" timestamp="496876698" type="Exception">
    <outputString><![CDATA[I***Tracer: showInfo = true
Buffer traced nessages =false
]]></outputString>
  </Command>
  <Command __id="69373" _type="EHExceptionCommand" date="Mon Dec 23 23:56:22 EST 2019" starttimestamp="1576666505112" timestamp="496877406" type="Exception">
    <outputString><![CDATA[ObjectEditor(Version 22, built on Thu Dec 06 16:26:09 EST 2018). Copyright Prasun Dewan, 2012, All rights reserved. US Patent Appl. No.: 12/532,327
]]></outputString>
  </Command>
  <Command __id="69374" _type="ShellCommand" date="Mon Dec 23 23:56:22 EST 2019" starttimestamp="1576666505112" timestamp="496877801" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="69375" _type="ShellCommand" date="Mon Dec 23 23:56:24 EST 2019" starttimestamp="1576666505112" timestamp="496879330" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="69376" _type="MoveCaretCommand" caretOffset="451" date="Mon Dec 23 23:56:24 EST 2019" docOffset="451" starttimestamp="1576666505112" timestamp="496879457" />
  <Command __id="69377" _type="SelectTextCommand" caretOffset="430" date="Mon Dec 23 23:56:36 EST 2019" end="462" start="430" starttimestamp="1576666505112" timestamp="496890891" />
  <Command __id="69379" _type="EclipseCommand" commandID="org.eclipse.ui.edit.delete" date="Mon Dec 23 23:56:36 EST 2019" starttimestamp="1576666505112" timestamp="496891535" />
  <Command __id="69380" _type="EclipseCommand" commandID="org.eclipse.ui.file.save" date="Mon Dec 23 23:56:38 EST 2019" starttimestamp="1576666505112" timestamp="496893312" />
  <Command __id="69381" _type="ShellCommand" date="Mon Dec 23 23:58:22 EST 2019" starttimestamp="1576666505112" timestamp="496997689" type="ECLIPSE_LOST_FOCUS" />
  <DocumentChange __id="71055" _type="Insert" date="Tue Dec 24 07:08:07 EST 2019" docASTNodeCount="1271" docActiveCodeLength="8808" docExpressionCount="793" docLength="11329" length="1" offset="4971" starttimestamp="1576666505112" timestamp="522782419">
    <text><![CDATA[t]]></text>
  </DocumentChange>
  <DocumentChange __id="71058" _type="Insert" date="Tue Dec 24 07:08:07 EST 2019" docASTNodeCount="1271" docActiveCodeLength="8808" docExpressionCount="793" docLength="11330" length="1" offset="4972" starttimestamp="1576666505112" timestamp="522782614">
    <text><![CDATA[o]]></text>
  </DocumentChange>
  <DocumentChange __id="71061" _type="Insert" date="Tue Dec 24 07:08:07 EST 2019" docASTNodeCount="1271" docActiveCodeLength="8808" docExpressionCount="793" docLength="11331" length="1" offset="4973" starttimestamp="1576666505112" timestamp="522782771">
    <text><![CDATA[p]]></text>
  </DocumentChange>
  <DocumentChange __id="71064" _type="Insert" date="Tue Dec 24 07:08:08 EST 2019" docASTNodeCount="1271" docActiveCodeLength="8808" docExpressionCount="793" docLength="11332" length="1" offset="4974" starttimestamp="1576666505112" timestamp="522783042">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="71067" _type="Insert" date="Tue Dec 24 07:08:08 EST 2019" docASTNodeCount="1271" docActiveCodeLength="8808" docExpressionCount="793" docLength="11333" length="1" offset="4975" starttimestamp="1576666505112" timestamp="522783185">
    <text><![CDATA[l]]></text>
  </DocumentChange>
  <DocumentChange __id="71070" _type="Insert" date="Tue Dec 24 07:08:08 EST 2019" docASTNodeCount="1271" docActiveCodeLength="8808" docExpressionCount="793" docLength="11334" length="1" offset="4976" starttimestamp="1576666505112" timestamp="522783306">
    <text><![CDATA[e]]></text>
  </DocumentChange>
  <DocumentChange __id="71073" _type="Insert" date="Tue Dec 24 07:08:08 EST 2019" docASTNodeCount="1271" docActiveCodeLength="8808" docExpressionCount="793" docLength="11335" length="1" offset="4977" starttimestamp="1576666505112" timestamp="522783504">
    <text><![CDATA[v]]></text>
  </DocumentChange>
  <DocumentChange __id="71076" _type="Insert" date="Tue Dec 24 07:08:08 EST 2019" docASTNodeCount="1271" docActiveCodeLength="8808" docExpressionCount="793" docLength="11336" length="1" offset="4978" starttimestamp="1576666505112" timestamp="522783619">
    <text><![CDATA[e]]></text>
  </DocumentChange>
  <DocumentChange __id="71079" _type="Insert" date="Tue Dec 24 07:08:08 EST 2019" docASTNodeCount="1271" docActiveCodeLength="8808" docExpressionCount="793" docLength="11337" length="1" offset="4979" starttimestamp="1576666505112" timestamp="522783812">
    <text><![CDATA[l]]></text>
  </DocumentChange>
  <DocumentChange __id="71082" _type="Insert" date="Tue Dec 24 07:08:09 EST 2019" docASTNodeCount="1271" docActiveCodeLength="8808" docExpressionCount="793" docLength="11338" length="1" offset="4980" starttimestamp="1576666505112" timestamp="522783972">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="71085" _type="Insert" date="Tue Dec 24 07:08:09 EST 2019" docASTNodeCount="1271" docActiveCodeLength="8808" docExpressionCount="793" docLength="11339" length="1" offset="4981" starttimestamp="1576666505112" timestamp="522784183">
    <text><![CDATA[p]]></text>
  </DocumentChange>
  <DocumentChange __id="71088" _type="Insert" date="Tue Dec 24 07:08:09 EST 2019" docASTNodeCount="1271" docActiveCodeLength="8808" docExpressionCount="793" docLength="11340" length="1" offset="4982" starttimestamp="1576666505112" timestamp="522784386">
    <text><![CDATA[r]]></text>
  </DocumentChange>
  <DocumentChange __id="71091" _type="Insert" date="Tue Dec 24 07:08:09 EST 2019" docASTNodeCount="1271" docActiveCodeLength="8808" docExpressionCount="793" docLength="11341" length="1" offset="4983" starttimestamp="1576666505112" timestamp="522784706">
    <text><![CDATA[g]]></text>
  </DocumentChange>
  <DocumentChange __id="71094" _type="Insert" date="Tue Dec 24 07:08:10 EST 2019" docASTNodeCount="1271" docActiveCodeLength="8808" docExpressionCount="793" docLength="11342" length="1" offset="4984" starttimestamp="1576666505112" timestamp="522784893">
    <text><![CDATA[a]]></text>
  </DocumentChange>
  <DocumentChange __id="71097" _type="Insert" date="Tue Dec 24 07:08:10 EST 2019" docASTNodeCount="1271" docActiveCodeLength="8808" docExpressionCount="793" docLength="11343" length="1" offset="4985" starttimestamp="1576666505112" timestamp="522785088">
    <text><![CDATA[m]]></text>
  </DocumentChange>
  <DocumentChange __id="71100" _type="Insert" date="Tue Dec 24 07:08:10 EST 2019" docASTNodeCount="1271" docActiveCodeLength="8808" docExpressionCount="793" docLength="11344" length="1" offset="4986" starttimestamp="1576666505112" timestamp="522785296">
    <text><![CDATA[a]]></text>
  </DocumentChange>
  <DocumentChange __id="71103" _type="Insert" date="Tue Dec 24 07:08:10 EST 2019" docASTNodeCount="1271" docActiveCodeLength="8808" docExpressionCount="793" docLength="11345" length="1" offset="4987" starttimestamp="1576666505112" timestamp="522785621">
    <text><![CDATA[s]]></text>
  </DocumentChange>
  <Command __id="71141" _type="RunCommand" date="Tue Dec 24 07:08:14 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="522789147" type="Debug" />
  <Command __id="71142" _type="RunCommand" date="Tue Dec 24 07:08:14 EST 2019" kind="HitBreakPoint" projectName="PL_Java" starttimestamp="1576666505112" timestamp="522789147" type="Run" />
  <Command __id="71143" _type="RunCommand" date="Tue Dec 24 07:08:14 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="522789147" type="Debug" />
  <Command __id="71144" _type="RunCommand" date="Tue Dec 24 07:08:14 EST 2019" kind="HitBreakPoint" projectName="PL_Java" starttimestamp="1576666505112" timestamp="522789147" type="Run" />
  <Command __id="71146" _type="SelectTextCommand" caretOffset="501" date="Tue Dec 24 07:08:39 EST 2019" end="501" start="480" starttimestamp="1576666505112" timestamp="522813954" />
  <Command __id="71147" _type="EclipseCommand" commandID="" date="Tue Dec 24 07:08:39 EST 2019" starttimestamp="1576666505112" timestamp="522814598" />
  <Command __id="71148" _type="EclipseCommand" commandID="" date="Tue Dec 24 07:08:39 EST 2019" starttimestamp="1576666505112" timestamp="522814648" />
  <Command __id="71149" _type="SelectTextCommand" caretOffset="706" date="Tue Dec 24 07:08:54 EST 2019" end="747" start="706" starttimestamp="1576666505112" timestamp="522829751" />
  <Command __id="71150" _type="CopyCommand" date="Tue Dec 24 07:08:55 EST 2019" starttimestamp="1576666505112" timestamp="522830567" />
  <Command __id="71151" _type="MoveCaretCommand" caretOffset="375" date="Tue Dec 24 07:09:01 EST 2019" docOffset="375" starttimestamp="1576666505112" timestamp="522836812" />
  <Command __id="71153" _type="InsertStringCommand" date="Tue Dec 24 07:09:02 EST 2019" starttimestamp="1576666505112" timestamp="522837411" timestamp2="522837411">
    <data><![CDATA[]]></data>
  </Command>
  <Command __id="71155" _type="PasteCommand" date="Tue Dec 24 07:09:03 EST 2019" starttimestamp="1576666505112" timestamp="522838264" />
  <Command __id="71156" _type="MoveCaretCommand" caretOffset="376" date="Tue Dec 24 07:09:05 EST 2019" docOffset="376" starttimestamp="1576666505112" timestamp="522840481" />
  <Command __id="71158" _type="InsertStringCommand" date="Tue Dec 24 07:09:05 EST 2019" starttimestamp="1576666505112" timestamp="522840759" timestamp2="522840759">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="71160" _type="InsertStringCommand" date="Tue Dec 24 07:09:06 EST 2019" starttimestamp="1576666505112" timestamp="522841005" timestamp2="522841005">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="71162" _type="InsertStringCommand" date="Tue Dec 24 07:09:06 EST 2019" starttimestamp="1576666505112" timestamp="522841184" timestamp2="522841184">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="71163" _type="SelectTextCommand" caretOffset="417" date="Tue Dec 24 07:09:11 EST 2019" end="417" start="408" starttimestamp="1576666505112" timestamp="522846111" />
  <Command __id="71165" _type="InsertStringCommand" date="Tue Dec 24 07:09:11 EST 2019" starttimestamp="1576666505112" timestamp="522846820" timestamp2="522846820">
    <data><![CDATA[0]]></data>
  </Command>
  <Command __id="71166" _type="EclipseCommand" commandID="org.eclipse.ui.file.save" date="Tue Dec 24 07:09:14 EST 2019" starttimestamp="1576666505112" timestamp="522848923" />
  <Command __id="71167" _type="SelectTextCommand" caretOffset="297" date="Tue Dec 24 07:09:18 EST 2019" end="375" start="297" starttimestamp="1576666505112" timestamp="522853049" />
  <Command __id="71169" _type="EclipseCommand" commandID="org.eclipse.ui.edit.delete" date="Tue Dec 24 07:09:18 EST 2019" starttimestamp="1576666505112" timestamp="522853756" />
  <Command __id="71170" _type="EclipseCommand" commandID="org.eclipse.ui.file.save" date="Tue Dec 24 07:09:20 EST 2019" starttimestamp="1576666505112" timestamp="522855285" />
  <Command __id="71171" _type="MoveCaretCommand" caretOffset="301" date="Tue Dec 24 07:09:23 EST 2019" docOffset="301" starttimestamp="1576666505112" timestamp="522857895" />
  <Command __id="71173" _type="InsertStringCommand" date="Tue Dec 24 07:09:23 EST 2019" starttimestamp="1576666505112" timestamp="522858139" timestamp2="522858139">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="71627" _type="DiffBasedFileOpenCommand" date="Tue Dec 24 07:27:01 EST 2019" docASTNodeCount="346" docActiveCodeLength="2355" docExpressionCount="251" docLength="2362" projectName="DemoCourseLocalBasicChecks" starttimestamp="1576666505112" timestamp="523915964">
    <filePath><![CDATA[D:\dewan_backup\Java\DemoCourseLocalBasicChecks\src\gradingTools\comp123\assignment1\openmp\testcases\SequentialSumTestCase.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package gradingTools.comp123.assignment1.openmp.testcases;¬∂¬∂import java.util.Arrays;¬∂import java.util.List;¬∂import java.util.Map;¬∂import java.util.regex.Pattern;¬∂¬∂import grader.basics.execution.NotRunnableException;¬∂import grader.basics.execution.RunningProject;¬∂import grader.basics.junit.NotAutomatableException;¬∂import grader.basics.junit.TestCaseResult;¬∂import grader.basics.project.NotGradableException;¬∂import grader.basics.project.Project;¬∂import grader.basics.project.source.ABasicTextManager;¬∂import grader.basics.testcase.PassFailJUnitTestCase;¬∂import gradingTools.shared.testcases.SubstringSequenceChecker;¬∂import gradingTools.shared.testcases.openmp.OpenMPPragma;¬∂import gradingTools.shared.testcases.openmp.OpenMPUtils;¬∂import gradingTools.shared.testcases.utils.LinesMatchKind;¬∂import gradingTools.shared.testcases.utils.LinesMatcher;¬∂import gradingTools.utils.RunningProjectUtils;¬∂¬∂public class SequentialSumTestCase extends PassFailJUnitTestCase {¬∂	public static final int TIME_OUT_SECS = 1; // secs¬∂	protected SubstringSequenceChecker checker = new ASequentialSumChecker();	¬∂¬∂	public SequentialSumTestCase() {¬∂	}¬∂¬∂	¬∂¬∂	@Override¬∂	public TestCaseResult test(Project project, boolean autoGrade) throws NotAutomatableException,¬∂			NotGradableException {¬∂		try {¬∂			RunningProject aRunningProject = RunningProjectUtils.runProject(project, TIME_OUT_SECS);¬∂			String anOutput = aRunningProject.await();¬∂			LinesMatcher aLinesMatcher = aRunningProject.getLinesMatcher();¬∂			boolean aRetval = checker.check(aLinesMatcher, LinesMatchKind.ONE_TIME_LINE, Pattern.DOTALL);¬∂			String aSource = project.getSource();¬∂			Map<String, StringBuffer> aFileNameToContents = ABasicTextManager.extractFileContents(aSource);¬∂			for (String aFileName:aFileNameToContents.keySet()) {¬∂				StringBuffer aFileContents = aFileNameToContents.get(aFileName);¬∂				List<OpenMPPragma> anOpenMPPragmas = OpenMPUtils.getOpemMPPragmas(aFileContents);¬∂				System.out.println("file name:" + aFileName);¬∂				System.out.println("pragmas:" + anOpenMPPragmas);¬∂			}¬∂			String anExpectedLines = Arrays.toString(checker.getSubstrings());¬∂¬∂			if (!aRetval) {¬∂				return fail("Output  did not match:" + anExpectedLines);¬∂¬∂			}¬∂			return pass();¬∂			¬∂¬∂		} catch (NotRunnableException e) {¬∂			throw new NotGradableException();¬∂		}¬∂	}¬∂}¬∂")]]]></diff>
  </Command>
  <Command __id="71636" _type="DiffBasedFileOpenCommand" date="Tue Dec 24 07:27:05 EST 2019" docASTNodeCount="1268" docActiveCodeLength="8768" docExpressionCount="793" docLength="11466" projectName="GraderBasics" starttimestamp="1576666505112" timestamp="523920374">
    <filePath><![CDATA[D:\dewan_backup\Java\GraderBasics\src\gradingTools\shared\testcases\openmp\OpenMPUtils.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package gradingTools.shared.testcases.openmp;¬∂¬∂import java.util.ArrayList;¬∂import java.util.HashMap;¬∂import java.util.List;¬∂import java.util.Map;¬∂import java.util.Stack;¬∂¬∂¬∂public class OpenMPUtils {¬∂	¬∂	protected static Map<String, OpenMPKeywordEnum> stringToOpenMPKeyword = new HashMap();¬∂	protected static String[] typeNames = {"double", "float", "int", "short", "long"};¬∂	protected static String[] openMPCalls = {"omp_get_thread_num()", "omp_get_num_threads()"};¬∂	public static List<OpenMPPragma> getOpemMPPragmas(StringBuffer aFileBuffer) {¬∂		String[] aFileLines = aFileBuffer.toString().split("\n");¬∂		return getOpenMPPragmas(aFileLines);¬∂	}¬∂	¬∂	public static boolean isCodeLine(String aLine) {¬∂		return !aLine.isEmpty() && !aLine.startsWith("//");¬∂	}¬∂	public static boolean isBlockStart(String aLine) {¬∂		return aLine.contains("{");¬∂	}¬∂	public static boolean isBlockEnd(String aLine) {¬∂		return aLine.contains("}");¬∂	}¬∂	public static boolean isLoopStart(String aLine) {¬∂		return aLine.startsWith("for");¬∂	}¬∂	public static boolean endsWithLoopHeader(String aLine) {¬∂		return aLine.endsWith(")");¬∂	}¬∂	public static boolean isPragmaStart(String aLine) {¬∂		return aLine.startsWith("#pragma");¬∂	}¬∂	public static void addToStack(Stack<OpenMPPragma> anOpenMPPragmas, String aFileLine, int aLineNumber) {¬∂		if (anOpenMPPragmas.size() > 0) {¬∂			anOpenMPPragmas.peek().addToAnnotatedText(aFileLine, aLineNumber);¬∂		}¬∂//		for (OpenMPPragma anOpenMPPragma:anOpenMPPragmas) {¬∂//			anOpenMPPragma.addToAnnotatedText(aFileLine, aLineNumber);				¬∂//		}¬∂		¬∂	}¬∂	public static ForHeader getForHeader(String aFileLine, int aLineNumber) {¬∂		if (!aFileLine.startsWith("for"))¬∂			return null;¬∂		int aLeftParenIndex = aFileLine.indexOf("(");¬∂		int aRightParenIndex = aFileLine.indexOf(")");¬∂		if (aLeftParenIndex < 0 || aRightParenIndex < 0) {¬∂			return null;¬∂		}¬∂		String aHeaderString = aFileLine.substring(aLeftParenIndex + 1, aRightParenIndex);¬∂		String[] aForComponents = aHeaderString.split(";");¬∂		return new AForHeader(aForComponents[0], aForComponents[1], aForComponents[2], aLineNumber);¬∂	}¬∂	public static List<String> getOMPCalls(String aFileLine) {¬∂		List<String> retVal = new ArrayList();¬∂		for (String anOpenMPCall:openMPCalls) {¬∂			if (aFileLine.contains(anOpenMPCall)) {¬∂				retVal.add(anOpenMPCall);¬∂			}¬∂		}¬∂		return retVal;¬∂	}¬∂	¬∂	¬∂	¬∂	public static void incrementStackTop (Stack<Integer> aNumOpenBracesStack) {¬∂		int aTopIndex = aNumOpenBracesStack.size() - 1;¬∂		Integer aCurrentValue = aNumOpenBracesStack.get(aTopIndex);¬∂		aNumOpenBracesStack.set(aTopIndex, aCurrentValue + 1);¬∂	}¬∂	public static void decrementStackTop (Stack<Integer> aNumOpenBracesStack) {¬∂		int aTopIndex = aNumOpenBracesStack.size() - 1;¬∂		Integer aCurrentValue = aNumOpenBracesStack.get(aTopIndex);¬∂		aNumOpenBracesStack.set(aTopIndex, aCurrentValue - 1);¬∂	}¬∂	¬∂	public static boolean startsWithTypeName(String aLine) {¬∂		for (String aTypeName:typeNames) {¬∂			if (aLine.startsWith(aTypeName)) {¬∂				return true;¬∂			}¬∂		}¬∂		return false;¬∂	}¬∂¬∂	public static List<OpenMPPragma> getOpenMPPragmas(String[] aFileLines) {¬∂		List<OpenMPPragma> retVal = new ArrayList();¬∂		Stack<OpenMPPragma> anOpenMPPragmas = new Stack();¬∂		Stack<Integer> aNumOpenBracesStack = new Stack();¬∂//		OpenMPPragma lastOpenMPPragma = null;¬∂//		String lastReductionVariable = null;¬∂//		String lastReductionOperation = null;¬∂//		int aNumOpenBraces = 0;¬∂		boolean aNextCodeLineIsAPragmaBlock = false;¬∂		List<OpenMPPragma> newOpenMPPragmas = null;¬∂		for (int i = 0; i < aFileLines.length; i++) {¬∂			String aFileLine = aFileLines[i].trim();¬∂			if (!isCodeLine(aFileLine)) {¬∂				continue;¬∂			}¬∂			addToStack(anOpenMPPragmas, aFileLine, i); // if it is empty add to none¬∂//			if (lastReductionVariable != null) {¬∂//				if (aFileLine.startsWith(lastReductionVariable)) {¬∂//					lastOpenMPPragma.getReductionVariableAssignments().add(aFileLine);¬∂//					if (lastReductionOperation != null) { // can it ever be not null¬∂//						if (aFileLine.contains(lastReductionOperation)) {¬∂//							lastOpenMPPragma.getReductionOperationUses().add(aFileLine);¬∂//						}¬∂//					}¬∂//				}			¬∂//			}¬∂//			if (lastOpenMPPragma != null && lastOpenMPPragma.getFirstOpenMPKeyword() == OpenMPKeywordEnum.PARALLEL) {¬∂//				if (startsWithTypeName(aFileLine)) {¬∂//					lastOpenMPPragma.getVariableDeclarationsInParallel().add(aFileLine);¬∂//				}¬∂//			} ¬∂//			else if (lastOpenMPPragma != null && lastOpenMPPragma.getFirstOpenMPKeyword() == OpenMPKeywordEnum.CRITICAL) {¬∂//				String[] aTokens = aFileLine.split("\\s+");¬∂//				lastOpenMPPragma.setAssignedVariableInCritical(aTokens[0]);				¬∂//			}¬∂			if (isPragmaStart(aFileLine)) {¬∂				¬∂				newOpenMPPragmas = getOpenMPPragmas(aFileLine, i);¬∂				if (newOpenMPPragmas.size() != 0) {¬∂					for (OpenMPPragma anOpenMPPragma:newOpenMPPragmas) {¬∂						if (anOpenMPPragmas.size() > 0) {¬∂						    anOpenMPPragma.setParent(anOpenMPPragmas.peek());¬∂						} else {¬∂							retVal.add(anOpenMPPragma); // add only top level prgamas¬∂¬∂						}¬∂						anOpenMPPragmas.push(anOpenMPPragma);¬∂						aNumOpenBracesStack.push(0);¬∂//						retVal.add(anOpenMPPragma);¬∂¬∂					}¬∂//					anOpenMPPragmas.addAll(newOpenMPPragmas);¬∂"), Diff(INSERT,"//"), Diff(EQUAL,"					aNumOpenBracesStack.add(0);¬∂//					retVal.add(lastOpenMPPragma);					¬∂					aNextCodeLineIsAPragmaBlock = true;¬∂//					String lastReductionOperation = lastOpenMPPragma.getReductionOperation();¬∂//					String lastReductionVariable = lastOpenMPPragma.getReductionVariable();¬∂					continue;¬∂				} ¬∂			}¬∂			if (anOpenMPPragmas.isEmpty()) {¬∂				continue;¬∂			}	¬∂			if (aNextCodeLineIsAPragmaBlock) {				¬∂				anOpenMPPragmas.peek().setAnnotatedTextStartLineNumber(i);				¬∂				aNextCodeLineIsAPragmaBlock = false;¬∂			}¬∂//			anOpenMPPragmas.peek().getAnnotatedText().add(aFileLine);¬∂			if (isBlockStart(aFileLine)) {¬∂				incrementStackTop(aNumOpenBracesStack);¬∂			}¬∂//			} else ¬∂			if (isBlockEnd(aFileLine)) {¬∂				decrementStackTop(aNumOpenBracesStack);¬∂¬∂			}¬∂			if (isLoopStart(aFileLine) && endsWithLoopHeader(aFileLine)) {¬∂				continue; // gather following block also¬∂			}¬∂			if (aNumOpenBracesStack.peek() == 0) {¬∂				¬∂				anOpenMPPragmas.peek().setAnnotatedTextEndLineNumber(i);¬∂				for (int j = 0; j < newOpenMPPragmas.size(); j++) {¬∂					anOpenMPPragmas.pop();¬∂					aNumOpenBracesStack.pop();¬∂				}¬∂//				lastOpenMPPragma = null;¬∂//				lastReductionVariable = null;¬∂//				lastReductionOperation = null;¬∂				continue;¬∂			}					¬∂		}¬∂		return retVal;¬∂	}¬∂	public static void setReductionData (OpenMPPragma lastChild, String aStoredToken, int aLeftParenIndex, int aRightParenIndex) {¬∂		int aColonIndex = aStoredToken.indexOf(":");¬∂		if (aLeftParenIndex != -1 && aRightParenIndex != -1 && aColonIndex != -1) {¬∂			String anOperationString = aStoredToken.substring(aLeftParenIndex + 1, aColonIndex).trim();¬∂			String aVariableString = aStoredToken.substring(aColonIndex + 1, aRightParenIndex).trim();¬∂			((OpenMPForPragma) lastChild).setReductionVariable(aVariableString);¬∂			((OpenMPForPragma) lastChild).setReductionOperation(anOperationString);¬∂		}¬∂	}¬∂	public static void setSharedOrPrivateData (OpenMPPragma lastChild, String aStoredToken, int aLeftParenIndex, int aRightParenIndex, boolean isShared) {¬∂//		int aColonIndex = aStoredToken.indexOf(":");¬∂		if (aLeftParenIndex != -1 && aRightParenIndex != -1 ) {¬∂			String aVariableDeclarations = aStoredToken.substring(aLeftParenIndex + 1, aRightParenIndex);¬∂			String[] aVariables = aVariableDeclarations.split(",");¬∂			if (isShared) {¬∂				lastChild.setSharedVariables(aVariables);¬∂			} else {¬∂				lastChild.setPrivateVariables(aVariables);¬∂			}			¬∂		}¬∂	}¬∂	public static List<OpenMPPragma> getOpenMPPragmas(String aFileLine, int aLineIndex) {¬∂		String[] aTokens = aFileLine.split("\\s+");¬∂		if (aTokens.length <= 2) {¬∂			return null;¬∂		}¬∂		if (!aTokens[1].equals("omp")) {¬∂			return null;¬∂		}¬∂		if (aTokens.length < 3) {¬∂			return null;¬∂		}¬∂		String aFirstToken = aTokens[2];¬∂		OpenMPKeywordEnum anOpenMPKeyword = stringToOpenMPKeyword.get(aFirstToken);¬∂		List<OpenMPPragma> retVal = new ArrayList();¬∂		OpenMPPragma lastChild;¬∂		int aStartIndex = 2;¬∂		switch (anOpenMPKeyword) {¬∂		case PARALLEL:¬∂			lastChild = new AnOpenMPParallelPragma(aLineIndex);¬∂			¬∂//			lastChild.setFirstOpenMPKeyword(stringToOpenMPKeyword.get(aFirstToken));	¬∂¬∂			retVal.add(lastChild);¬∂			if (aTokens.length > 3 && aTokens[3].equals("for")) {¬∂				OpenMPPragma aForChild = new AnOpenMPForPragma(aLineIndex);¬∂				retVal.add(aForChild);¬∂				lastChild = aForChild;¬∂				aStartIndex++;¬∂			}¬∂			break;¬∂		case FOR:¬∂			lastChild = new AnOpenMPForPragma(aLineIndex);¬∂			retVal.add (lastChild);¬∂			break;¬∂		case CRITICAL:¬∂			lastChild = new AnOpenMPCriticalPragma(aLineIndex);¬∂			retVal.add (lastChild);¬∂			break;¬∂			default: ¬∂				lastChild = new AnOpenMPPragma(aLineIndex);¬∂				retVal.add(lastChild);¬∂			¬∂		}¬∂//		retVal.setFirstOpenMPKeyword(stringToOpenMPKeyword.get(aFirstToken));	¬∂//		OpenMPPragma retVal = new AnOpenMPPragma(aLineIndex);¬∂¬∂¬∂		for (int i = aStartIndex; i < aTokens.length; i ++) {¬∂			String aStoredToken = aTokens[i].trim();¬∂			if (aStoredToken.isEmpty()) {¬∂				continue;¬∂			}¬∂			if (aStoredToken.startsWith("reduction") || aStoredToken.startsWith("shared") || aStoredToken.startsWith("private")) {¬∂				//combine all tokens until ")" into one for normalization¬∂				while (!aStoredToken.endsWith(")")) {¬∂					i++;¬∂					if (i >= aTokens.length) {¬∂						break;¬∂					}¬∂					String aNewToken = aTokens[i].trim();¬∂					aStoredToken += aNewToken; 					¬∂				}¬∂				int aLeftParenIndex = aStoredToken.indexOf("(");¬∂				int aRightParenIndex = aStoredToken.indexOf(")");¬∂				if (aStoredToken.startsWith("reduction")) {¬∂					setReductionData(lastChild, aStoredToken, aLeftParenIndex, aRightParenIndex);¬∂				} else if (aStoredToken.startsWith("private")) {¬∂					setSharedOrPrivateData(lastChild, aStoredToken, aLeftParenIndex, aRightParenIndex, false);¬∂¬∂				} else if (aStoredToken.startsWith("shared")) {¬∂					setSharedOrPrivateData(lastChild, aStoredToken, aLeftParenIndex, aRightParenIndex, true);¬∂¬∂				}¬∂//				int aColonIndex = aStoredToken.indexOf(":");¬∂//				if (aLeftParenIndex != -1 && aRightParenIndex != -1 && aColonIndex != -1) {¬∂//					String anOperationString = aStoredToken.substring(aLeftParenIndex + 1, aColonIndex).trim();¬∂//					String aVariableString = aStoredToken.substring(aColonIndex + 1, aRightParenIndex).trim();¬∂//					((OpenMPForPragma) lastChild).setReductionVariable(aVariableString);¬∂//					((OpenMPForPragma) lastChild).setReductionOperation(anOperationString);¬∂//				}¬∂				¬∂			}¬∂			¬∂//			aTokens[i] = aStoredToken;¬∂			lastChild.getOpenMPTokens().add(aStoredToken);¬∂		}¬∂//		String aFirstToken = retVal.getOpenMPTokens().get(0);¬∂//		retVal.setFirstOpenMPKeyword(stringToOpenMPKeyword.get(aFirstToken));		¬∂		return retVal;¬∂		¬∂		¬∂	}¬∂	static {¬∂		stringToOpenMPKeyword.put("for", OpenMPKeywordEnum.FOR);¬∂		stringToOpenMPKeyword.put("parallel", OpenMPKeywordEnum.PARALLEL);¬∂		stringToOpenMPKeyword.put("reduce", OpenMPKeywordEnum.REDUCE);¬∂		stringToOpenMPKeyword.put("shared", OpenMPKeywordEnum.SHARED);¬∂		stringToOpenMPKeyword.put("private", OpenMPKeywordEnum.PRIVATE);¬∂		stringToOpenMPKeyword.put("critical", OpenMPKeywordEnum.CRITICAL);¬∂¬∂¬∂¬∂¬∂¬∂	}¬∂	¬∂¬∂}¬∂")]]]></diff>
    <snapshot><![CDATA[package gradingTools.shared.testcases.openmp;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Stack;


public class OpenMPUtils {
	
	protected static Map<String, OpenMPKeywordEnum> stringToOpenMPKeyword = new HashMap();
	protected static String[] typeNames = {"double", "float", "int", "short", "long"};
	protected static String[] openMPCalls = {"omp_get_thread_num()", "omp_get_num_threads()"};
	public static List<OpenMPPragma> getOpemMPPragmas(StringBuffer aFileBuffer) {
		String[] aFileLines = aFileBuffer.toString().split("\n");
		return getOpenMPPragmas(aFileLines);
	}
	
	public static boolean isCodeLine(String aLine) {
		return !aLine.isEmpty() && !aLine.startsWith("//");
	}
	public static boolean isBlockStart(String aLine) {
		return aLine.contains("{");
	}
	public static boolean isBlockEnd(String aLine) {
		return aLine.contains("}");
	}
	public static boolean isLoopStart(String aLine) {
		return aLine.startsWith("for");
	}
	public static boolean endsWithLoopHeader(String aLine) {
		return aLine.endsWith(")");
	}
	public static boolean isPragmaStart(String aLine) {
		return aLine.startsWith("#pragma");
	}
	public static void addToStack(Stack<OpenMPPragma> anOpenMPPragmas, String aFileLine, int aLineNumber) {
		if (anOpenMPPragmas.size() > 0) {
			anOpenMPPragmas.peek().addToAnnotatedText(aFileLine, aLineNumber);
		}
//		for (OpenMPPragma anOpenMPPragma:anOpenMPPragmas) {
//			anOpenMPPragma.addToAnnotatedText(aFileLine, aLineNumber);				
//		}
		
	}
	public static ForHeader getForHeader(String aFileLine, int aLineNumber) {
		if (!aFileLine.startsWith("for"))
			return null;
		int aLeftParenIndex = aFileLine.indexOf("(");
		int aRightParenIndex = aFileLine.indexOf(")");
		if (aLeftParenIndex < 0 || aRightParenIndex < 0) {
			return null;
		}
		String aHeaderString = aFileLine.substring(aLeftParenIndex + 1, aRightParenIndex);
		String[] aForComponents = aHeaderString.split(";");
		return new AForHeader(aForComponents[0], aForComponents[1], aForComponents[2], aLineNumber);
	}
	public static List<String> getOMPCalls(String aFileLine) {
		List<String> retVal = new ArrayList();
		for (String anOpenMPCall:openMPCalls) {
			if (aFileLine.contains(anOpenMPCall)) {
				retVal.add(anOpenMPCall);
			}
		}
		return retVal;
	}
	
	
	
	public static void incrementStackTop (Stack<Integer> aNumOpenBracesStack) {
		int aTopIndex = aNumOpenBracesStack.size() - 1;
		Integer aCurrentValue = aNumOpenBracesStack.get(aTopIndex);
		aNumOpenBracesStack.set(aTopIndex, aCurrentValue + 1);
	}
	public static void decrementStackTop (Stack<Integer> aNumOpenBracesStack) {
		int aTopIndex = aNumOpenBracesStack.size() - 1;
		Integer aCurrentValue = aNumOpenBracesStack.get(aTopIndex);
		aNumOpenBracesStack.set(aTopIndex, aCurrentValue - 1);
	}
	
	public static boolean startsWithTypeName(String aLine) {
		for (String aTypeName:typeNames) {
			if (aLine.startsWith(aTypeName)) {
				return true;
			}
		}
		return false;
	}

	public static List<OpenMPPragma> getOpenMPPragmas(String[] aFileLines) {
		List<OpenMPPragma> retVal = new ArrayList();
		Stack<OpenMPPragma> anOpenMPPragmas = new Stack();
		Stack<Integer> aNumOpenBracesStack = new Stack();
//		OpenMPPragma lastOpenMPPragma = null;
//		String lastReductionVariable = null;
//		String lastReductionOperation = null;
//		int aNumOpenBraces = 0;
		boolean aNextCodeLineIsAPragmaBlock = false;
		List<OpenMPPragma> newOpenMPPragmas = null;
		for (int i = 0; i < aFileLines.length; i++) {
			String aFileLine = aFileLines[i].trim();
			if (!isCodeLine(aFileLine)) {
				continue;
			}
			addToStack(anOpenMPPragmas, aFileLine, i); // if it is empty add to none
//			if (lastReductionVariable != null) {
//				if (aFileLine.startsWith(lastReductionVariable)) {
//					lastOpenMPPragma.getReductionVariableAssignments().add(aFileLine);
//					if (lastReductionOperation != null) { // can it ever be not null
//						if (aFileLine.contains(lastReductionOperation)) {
//							lastOpenMPPragma.getReductionOperationUses().add(aFileLine);
//						}
//					}
//				}			
//			}
//			if (lastOpenMPPragma != null && lastOpenMPPragma.getFirstOpenMPKeyword() == OpenMPKeywordEnum.PARALLEL) {
//				if (startsWithTypeName(aFileLine)) {
//					lastOpenMPPragma.getVariableDeclarationsInParallel().add(aFileLine);
//				}
//			} 
//			else if (lastOpenMPPragma != null && lastOpenMPPragma.getFirstOpenMPKeyword() == OpenMPKeywordEnum.CRITICAL) {
//				String[] aTokens = aFileLine.split("\\s+");
//				lastOpenMPPragma.setAssignedVariableInCritical(aTokens[0]);				
//			}
			if (isPragmaStart(aFileLine)) {
				
				newOpenMPPragmas = getOpenMPPragmas(aFileLine, i);
				if (newOpenMPPragmas.size() != 0) {
					for (OpenMPPragma anOpenMPPragma:newOpenMPPragmas) {
						if (anOpenMPPragmas.size() > 0) {
						    anOpenMPPragma.setParent(anOpenMPPragmas.peek());
						} else {
							retVal.add(anOpenMPPragma); // add only top level prgamas

						}
						anOpenMPPragmas.push(anOpenMPPragma);
						aNumOpenBracesStack.push(0);
//						retVal.add(anOpenMPPragma);

					}
//					anOpenMPPragmas.addAll(newOpenMPPragmas);
//					aNumOpenBracesStack.add(0);
//					retVal.add(lastOpenMPPragma);					
					aNextCodeLineIsAPragmaBlock = true;
//					String lastReductionOperation = lastOpenMPPragma.getReductionOperation();
//					String lastReductionVariable = lastOpenMPPragma.getReductionVariable();
					continue;
				} 
			}
			if (anOpenMPPragmas.isEmpty()) {
				continue;
			}	
			if (aNextCodeLineIsAPragmaBlock) {				
				anOpenMPPragmas.peek().setAnnotatedTextStartLineNumber(i);				
				aNextCodeLineIsAPragmaBlock = false;
			}
//			anOpenMPPragmas.peek().getAnnotatedText().add(aFileLine);
			if (isBlockStart(aFileLine)) {
				incrementStackTop(aNumOpenBracesStack);
			}
//			} else 
			if (isBlockEnd(aFileLine)) {
				decrementStackTop(aNumOpenBracesStack);

			}
			if (isLoopStart(aFileLine) && endsWithLoopHeader(aFileLine)) {
				continue; // gather following block also
			}
			if (aNumOpenBracesStack.peek() == 0) {
				
				anOpenMPPragmas.peek().setAnnotatedTextEndLineNumber(i);
				for (int j = 0; j < newOpenMPPragmas.size(); j++) {
					anOpenMPPragmas.pop();
					aNumOpenBracesStack.pop();
				}
//				lastOpenMPPragma = null;
//				lastReductionVariable = null;
//				lastReductionOperation = null;
				continue;
			}					
		}
		return retVal;
	}
	public static void setReductionData (OpenMPPragma lastChild, String aStoredToken, int aLeftParenIndex, int aRightParenIndex) {
		int aColonIndex = aStoredToken.indexOf(":");
		if (aLeftParenIndex != -1 && aRightParenIndex != -1 && aColonIndex != -1) {
			String anOperationString = aStoredToken.substring(aLeftParenIndex + 1, aColonIndex).trim();
			String aVariableString = aStoredToken.substring(aColonIndex + 1, aRightParenIndex).trim();
			((OpenMPForPragma) lastChild).setReductionVariable(aVariableString);
			((OpenMPForPragma) lastChild).setReductionOperation(anOperationString);
		}
	}
	public static void setSharedOrPrivateData (OpenMPPragma lastChild, String aStoredToken, int aLeftParenIndex, int aRightParenIndex, boolean isShared) {
//		int aColonIndex = aStoredToken.indexOf(":");
		if (aLeftParenIndex != -1 && aRightParenIndex != -1 ) {
			String aVariableDeclarations = aStoredToken.substring(aLeftParenIndex + 1, aRightParenIndex);
			String[] aVariables = aVariableDeclarations.split(",");
			if (isShared) {
				lastChild.setSharedVariables(aVariables);
			} else {
				lastChild.setPrivateVariables(aVariables);
			}			
		}
	}
	public static List<OpenMPPragma> getOpenMPPragmas(String aFileLine, int aLineIndex) {
		String[] aTokens = aFileLine.split("\\s+");
		if (aTokens.length <= 2) {
			return null;
		}
		if (!aTokens[1].equals("omp")) {
			return null;
		}
		if (aTokens.length < 3) {
			return null;
		}
		String aFirstToken = aTokens[2];
		OpenMPKeywordEnum anOpenMPKeyword = stringToOpenMPKeyword.get(aFirstToken);
		List<OpenMPPragma> retVal = new ArrayList();
		OpenMPPragma lastChild;
		int aStartIndex = 2;
		switch (anOpenMPKeyword) {
		case PARALLEL:
			lastChild = new AnOpenMPParallelPragma(aLineIndex);
			
//			lastChild.setFirstOpenMPKeyword(stringToOpenMPKeyword.get(aFirstToken));	

			retVal.add(lastChild);
			if (aTokens.length > 3 && aTokens[3].equals("for")) {
				OpenMPPragma aForChild = new AnOpenMPForPragma(aLineIndex);
				retVal.add(aForChild);
				lastChild = aForChild;
				aStartIndex++;
			}
			break;
		case FOR:
			lastChild = new AnOpenMPForPragma(aLineIndex);
			retVal.add (lastChild);
			break;
		case CRITICAL:
			lastChild = new AnOpenMPCriticalPragma(aLineIndex);
			retVal.add (lastChild);
			break;
			default: 
				lastChild = new AnOpenMPPragma(aLineIndex);
				retVal.add(lastChild);
			
		}
//		retVal.setFirstOpenMPKeyword(stringToOpenMPKeyword.get(aFirstToken));	
//		OpenMPPragma retVal = new AnOpenMPPragma(aLineIndex);


		for (int i = aStartIndex; i < aTokens.length; i ++) {
			String aStoredToken = aTokens[i].trim();
			if (aStoredToken.isEmpty()) {
				continue;
			}
			if (aStoredToken.startsWith("reduction") || aStoredToken.startsWith("shared") || aStoredToken.startsWith("private")) {
				//combine all tokens until ")" into one for normalization
				while (!aStoredToken.endsWith(")")) {
					i++;
					if (i >= aTokens.length) {
						break;
					}
					String aNewToken = aTokens[i].trim();
					aStoredToken += aNewToken; 					
				}
				int aLeftParenIndex = aStoredToken.indexOf("(");
				int aRightParenIndex = aStoredToken.indexOf(")");
				if (aStoredToken.startsWith("reduction")) {
					setReductionData(lastChild, aStoredToken, aLeftParenIndex, aRightParenIndex);
				} else if (aStoredToken.startsWith("private")) {
					setSharedOrPrivateData(lastChild, aStoredToken, aLeftParenIndex, aRightParenIndex, false);

				} else if (aStoredToken.startsWith("shared")) {
					setSharedOrPrivateData(lastChild, aStoredToken, aLeftParenIndex, aRightParenIndex, true);

				}
//				int aColonIndex = aStoredToken.indexOf(":");
//				if (aLeftParenIndex != -1 && aRightParenIndex != -1 && aColonIndex != -1) {
//					String anOperationString = aStoredToken.substring(aLeftParenIndex + 1, aColonIndex).trim();
//					String aVariableString = aStoredToken.substring(aColonIndex + 1, aRightParenIndex).trim();
//					((OpenMPForPragma) lastChild).setReductionVariable(aVariableString);
//					((OpenMPForPragma) lastChild).setReductionOperation(anOperationString);
//				}
				
			}
			
//			aTokens[i] = aStoredToken;
			lastChild.getOpenMPTokens().add(aStoredToken);
		}
//		String aFirstToken = retVal.getOpenMPTokens().get(0);
//		retVal.setFirstOpenMPKeyword(stringToOpenMPKeyword.get(aFirstToken));		
		return retVal;
		
		
	}
	static {
		stringToOpenMPKeyword.put("for", OpenMPKeywordEnum.FOR);
		stringToOpenMPKeyword.put("parallel", OpenMPKeywordEnum.PARALLEL);
		stringToOpenMPKeyword.put("reduce", OpenMPKeywordEnum.REDUCE);
		stringToOpenMPKeyword.put("shared", OpenMPKeywordEnum.SHARED);
		stringToOpenMPKeyword.put("private", OpenMPKeywordEnum.PRIVATE);
		stringToOpenMPKeyword.put("critical", OpenMPKeywordEnum.CRITICAL);





	}
	

}
]]></snapshot>
  </Command>
  <Command __id="71650" _type="EclipseCommand" commandID="org.eclipse.debug.ui.commands.Terminate" date="Tue Dec 24 07:41:20 EST 2019" starttimestamp="1576666505112" timestamp="524775832" />
  <Command __id="71651" _type="RunCommand" date="Tue Dec 24 07:41:20 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="524775862" type="Debug" />
  <Command __id="71652" _type="RunCommand" date="Tue Dec 24 07:41:20 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="524775862" type="Debug" />
  <Command __id="71653" _type="RunCommand" date="Tue Dec 24 07:41:20 EST 2019" kind="HitBreakPoint" projectName="PL_Java" starttimestamp="1576666505112" timestamp="524775862" type="Run" />
  <Command __id="71655" _type="MoveCaretCommand" caretOffset="302" date="Tue Dec 24 07:41:31 EST 2019" docOffset="302" starttimestamp="1576666505112" timestamp="524786599" />
  <Command __id="71656" _type="MoveCaretCommand" caretOffset="322" date="Tue Dec 24 07:41:36 EST 2019" docOffset="322" starttimestamp="1576666505112" timestamp="524791204" />
  <Command __id="71658" _type="InsertStringCommand" date="Tue Dec 24 07:41:36 EST 2019" starttimestamp="1576666505112" timestamp="524791502" timestamp2="524791502">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="71660" _type="InsertStringCommand" date="Tue Dec 24 07:41:37 EST 2019" starttimestamp="1576666505112" timestamp="524792090" timestamp2="524792090">
    <data><![CDATA[{]]></data>
  </Command>
  <Command __id="71654" _type="DiffBasedFileOpenCommand" date="Tue Dec 24 07:41:31 EST 2019" docASTNodeCount="1" docActiveCodeLength="783" docExpressionCount="0" docLength="783" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="524786471">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\my_sum_parallel.cpp]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"#include <iostream>¬∂#include <omp.h>¬∂¬∂using namespace std;¬∂¬∂void printSumWithTimes(int sum, int start, int end);¬∂void printNumThreads();¬∂void recordThreadIndex(int index);¬∂void sum_parallel(double* array, int size) {¬∂	cout << "sum_parallel\n";¬∂¬∂	double start = omp_get_wtime();¬∂¬∂	double sum = 0;¬∂¬∂"), Diff(DELETE,"//	"), Diff(INSERT,"¬∂    "), Diff(EQUAL,"#pragma omp "), Diff(DELETE,"parallel¬∂//	for (int i = 0; i < size; i++)¬∂//		sum += array[i]"), Diff(INSERT,"critical¬∂	sum += 0"), Diff(EQUAL,";¬∂    #pragma omp parallel¬∂	{¬∂		double local_sum = 0;¬∂¬∂		int rank = omp_get_thread_num();¬∂		int threads = omp_get_num_threads();¬∂¬∂		int start_index = (size/threads)*rank;¬∂		int end_index = (size/threads)*(rank+1);¬∂¬∂		if(rank==threads-1)¬∂			end_index=size;¬∂¬∂		for(int i = start_index; i < end_index; i++)¬∂			local_sum += array[i];¬∂¬∂		#pragma omp critical¬∂		sum += local_sum;¬∂	}¬∂¬∂	double end = omp_get_wtime();¬∂¬∂	printSumWithTimes(sum, start, end);¬∂¬∂¬∂}¬∂")]]]></diff>
    <snapshot><![CDATA[#include <iostream>
#include <omp.h>

using namespace std;

void printSumWithTimes(int sum, int start, int end);
void printNumThreads();
void recordThreadIndex(int index);
void sum_parallel(double* array, int size) {
	cout << "sum_parallel\n";

	double start = omp_get_wtime();

	double sum = 0;


    #pragma omp critical
	sum += 0;
    #pragma omp parallel
	{
		double local_sum = 0;

		int rank = omp_get_thread_num();
		int threads = omp_get_num_threads();

		int start_index = (size/threads)*rank;
		int end_index = (size/threads)*(rank+1);

		if(rank==threads-1)
			end_index=size;

		for(int i = start_index; i < end_index; i++)
			local_sum += array[i];

		#pragma omp critical
		sum += local_sum;
	}

	double end = omp_get_wtime();

	printSumWithTimes(sum, start, end);


}
]]></snapshot>
  </Command>
  <DocumentChange __id="71657" _type="Insert" date="Tue Dec 24 07:41:36 EST 2019" docASTNodeCount="1" docActiveCodeLength="784" docExpressionCount="0" docLength="784" length="1" offset="322" starttimestamp="1576666505112" timestamp="524791498">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="71659" _type="Insert" date="Tue Dec 24 07:41:37 EST 2019" docASTNodeCount="1" docActiveCodeLength="785" docExpressionCount="0" docLength="785" length="1" offset="323" starttimestamp="1576666505112" timestamp="524792087">
    <text><![CDATA[{]]></text>
  </DocumentChange>
  <DocumentChange __id="71662" _type="Insert" date="Tue Dec 24 07:41:38 EST 2019" docASTNodeCount="1" docActiveCodeLength="787" docExpressionCount="0" docLength="787" length="2" offset="335" starttimestamp="1576666505112" timestamp="524793884">
    <text><![CDATA[
	]]></text>
  </DocumentChange>
  <Command __id="71661" _type="MoveCaretCommand" caretOffset="335" date="Tue Dec 24 07:41:38 EST 2019" docOffset="335" starttimestamp="1576666505112" timestamp="524793464" />
  <Command __id="71663" _type="InsertStringCommand" date="Tue Dec 24 07:41:39 EST 2019" starttimestamp="1576666505112" timestamp="524793889" timestamp2="524793889">
    <data><![CDATA[]]></data>
  </Command>
  <Command __id="71665" _type="InsertStringCommand" date="Tue Dec 24 07:41:40 EST 2019" starttimestamp="1576666505112" timestamp="524795672" timestamp2="524795672">
    <data><![CDATA[}]]></data>
  </Command>
  <Command __id="71666" _type="MoveCaretCommand" caretOffset="336" date="Tue Dec 24 07:41:43 EST 2019" docOffset="336" starttimestamp="1576666505112" timestamp="524798185" />
  <Command __id="71668" _type="InsertStringCommand" date="Tue Dec 24 07:41:43 EST 2019" starttimestamp="1576666505112" timestamp="524798420" timestamp2="524798420">
    <data><![CDATA[	]]></data>
  </Command>
  <DocumentChange __id="71664" _type="Replace" date="Tue Dec 24 07:41:40 EST 2019" docASTNodeCount="1" docActiveCodeLength="787" docExpressionCount="0" docLength="787" endLine="18" insertionLength="1" int_docASTNodeCount="1" int_docActiveCodeLength="786" int_docExpressionCount="0" int_docLength="786" length="1" offset="336" startLine="18" starttimestamp="1576666505112" timestamp="524795666">
    <deletedText><![CDATA[	]]></deletedText>
    <insertedText><![CDATA[}]]></insertedText>
  </DocumentChange>
  <DocumentChange __id="71667" _type="Insert" date="Tue Dec 24 07:41:43 EST 2019" docASTNodeCount="1" docActiveCodeLength="788" docExpressionCount="0" docLength="788" length="1" offset="336" starttimestamp="1576666505112" timestamp="524798414">
    <text><![CDATA[	]]></text>
  </DocumentChange>
  <DocumentChange __id="71670" _type="Insert" date="Tue Dec 24 07:41:45 EST 2019" docASTNodeCount="1" docActiveCodeLength="790" docExpressionCount="0" docLength="790" length="2" offset="323" starttimestamp="1576666505112" timestamp="524800628">
    <text><![CDATA[
	]]></text>
  </DocumentChange>
  <Command __id="71669" _type="MoveCaretCommand" caretOffset="323" date="Tue Dec 24 07:41:45 EST 2019" docOffset="323" starttimestamp="1576666505112" timestamp="524800207" />
  <Command __id="71671" _type="InsertStringCommand" date="Tue Dec 24 07:41:45 EST 2019" starttimestamp="1576666505112" timestamp="524800697" timestamp2="524800697">
    <data><![CDATA[]]></data>
  </Command>
  <Command __id="71673" _type="EclipseCommand" commandID="org.eclipse.ui.file.save" date="Tue Dec 24 07:41:48 EST 2019" starttimestamp="1576666505112" timestamp="524803328" />
  <Command __id="71674" _type="MoveCaretCommand" caretOffset="327" date="Tue Dec 24 07:41:51 EST 2019" docOffset="327" starttimestamp="1576666505112" timestamp="524805995" />
  <Command __id="71676" _type="InsertStringCommand" date="Tue Dec 24 07:41:51 EST 2019" starttimestamp="1576666505112" timestamp="524806612" timestamp2="524806612">
    <data><![CDATA[d]]></data>
  </Command>
  <Command __id="71678" _type="InsertStringCommand" date="Tue Dec 24 07:41:51 EST 2019" starttimestamp="1576666505112" timestamp="524806701" timestamp2="524806701">
    <data><![CDATA[o]]></data>
  </Command>
  <Command __id="71680" _type="InsertStringCommand" date="Tue Dec 24 07:41:52 EST 2019" starttimestamp="1576666505112" timestamp="524806972" timestamp2="524806972">
    <data><![CDATA[u]]></data>
  </Command>
  <Command __id="71682" _type="InsertStringCommand" date="Tue Dec 24 07:41:52 EST 2019" starttimestamp="1576666505112" timestamp="524807200" timestamp2="524807200">
    <data><![CDATA[b]]></data>
  </Command>
  <Command __id="71684" _type="InsertStringCommand" date="Tue Dec 24 07:41:52 EST 2019" starttimestamp="1576666505112" timestamp="524807516" timestamp2="524807516">
    <data><![CDATA[l]]></data>
  </Command>
  <Command __id="71686" _type="InsertStringCommand" date="Tue Dec 24 07:41:52 EST 2019" starttimestamp="1576666505112" timestamp="524807625" timestamp2="524807625">
    <data><![CDATA[e]]></data>
  </Command>
  <Command __id="71688" _type="InsertStringCommand" date="Tue Dec 24 07:41:53 EST 2019" starttimestamp="1576666505112" timestamp="524807926" timestamp2="524807926">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="71689" _type="EclipseCommand" commandID="org.eclipse.ui.file.save" date="Tue Dec 24 07:41:53 EST 2019" starttimestamp="1576666505112" timestamp="524808599" />
  <Command __id="71690" _type="MoveCaretCommand" caretOffset="339" date="Tue Dec 24 07:42:03 EST 2019" docOffset="339" starttimestamp="1576666505112" timestamp="524818715" />
  <Command __id="71692" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Tue Dec 24 07:42:04 EST 2019" starttimestamp="1576666505112" timestamp="524819528" />
  <Command __id="71693" _type="EclipseCommand" commandID="org.eclipse.ui.file.save" date="Tue Dec 24 07:42:06 EST 2019" starttimestamp="1576666505112" timestamp="524821233" />
  <Command __id="71694" _type="MoveCaretCommand" caretOffset="339" date="Tue Dec 24 07:42:08 EST 2019" docOffset="339" starttimestamp="1576666505112" timestamp="524823732" />
  <Command __id="71695" _type="ShellCommand" date="Tue Dec 24 07:42:27 EST 2019" starttimestamp="1576666505112" timestamp="524842100" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="71696" _type="ShellCommand" date="Tue Dec 24 07:42:27 EST 2019" starttimestamp="1576666505112" timestamp="524842203" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="71697" _type="ShellCommand" date="Tue Dec 24 07:42:27 EST 2019" starttimestamp="1576666505112" timestamp="524842363" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="71700" _type="RunCommand" date="Tue Dec 24 07:42:34 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="524849528" type="Run" />
  <Command __id="71701" _type="RunCommand" date="Tue Dec 24 07:42:34 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="524849546" type="Run" />
  <Command __id="71702" _type="RunCommand" date="Tue Dec 24 07:42:34 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="524849844" type="Run" />
  <DocumentChange __id="71672" _type="Delete" date="Tue Dec 24 07:41:48 EST 2019" docASTNodeCount="1" docActiveCodeLength="789" docExpressionCount="0" docLength="789" endLine="16" length="1" offset="322" startLine="16" starttimestamp="1576666505112" timestamp="524803281">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="71675" _type="Insert" date="Tue Dec 24 07:41:51 EST 2019" docASTNodeCount="1" docActiveCodeLength="790" docExpressionCount="0" docLength="790" length="1" offset="327" starttimestamp="1576666505112" timestamp="524806604">
    <text><![CDATA[d]]></text>
  </DocumentChange>
  <DocumentChange __id="71677" _type="Insert" date="Tue Dec 24 07:41:51 EST 2019" docASTNodeCount="1" docActiveCodeLength="791" docExpressionCount="0" docLength="791" length="1" offset="328" starttimestamp="1576666505112" timestamp="524806698">
    <text><![CDATA[o]]></text>
  </DocumentChange>
  <DocumentChange __id="71679" _type="Insert" date="Tue Dec 24 07:41:52 EST 2019" docASTNodeCount="1" docActiveCodeLength="792" docExpressionCount="0" docLength="792" length="1" offset="329" starttimestamp="1576666505112" timestamp="524806969">
    <text><![CDATA[u]]></text>
  </DocumentChange>
  <DocumentChange __id="71681" _type="Insert" date="Tue Dec 24 07:41:52 EST 2019" docASTNodeCount="1" docActiveCodeLength="793" docExpressionCount="0" docLength="793" length="1" offset="330" starttimestamp="1576666505112" timestamp="524807197">
    <text><![CDATA[b]]></text>
  </DocumentChange>
  <DocumentChange __id="71683" _type="Insert" date="Tue Dec 24 07:41:52 EST 2019" docASTNodeCount="1" docActiveCodeLength="794" docExpressionCount="0" docLength="794" length="1" offset="331" starttimestamp="1576666505112" timestamp="524807506">
    <text><![CDATA[l]]></text>
  </DocumentChange>
  <DocumentChange __id="71685" _type="Insert" date="Tue Dec 24 07:41:52 EST 2019" docASTNodeCount="1" docActiveCodeLength="795" docExpressionCount="0" docLength="795" length="1" offset="332" starttimestamp="1576666505112" timestamp="524807622">
    <text><![CDATA[e]]></text>
  </DocumentChange>
  <DocumentChange __id="71687" _type="Insert" date="Tue Dec 24 07:41:53 EST 2019" docASTNodeCount="1" docActiveCodeLength="796" docExpressionCount="0" docLength="796" length="1" offset="333" starttimestamp="1576666505112" timestamp="524807923">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="71691" _type="Delete" date="Tue Dec 24 07:42:04 EST 2019" docASTNodeCount="1" docActiveCodeLength="795" docExpressionCount="0" docLength="795" endLine="18" length="1" offset="338" startLine="18" starttimestamp="1576666505112" timestamp="524819521">
    <text><![CDATA[+]]></text>
  </DocumentChange>
  <Command __id="71703" _type="EclipseCommand" commandID="org.eclipse.debug.ui.commands.Resume" date="Tue Dec 24 07:42:40 EST 2019" starttimestamp="1576666505112" timestamp="524855490" />
  <Command __id="71704" _type="EHExceptionCommand" date="Tue Dec 24 07:42:40 EST 2019" starttimestamp="1576666505112" timestamp="524855703" type="Exception">
    <outputString><![CDATA[sum_sequential
Sum: 499500
Took: 0
thread:0 lastIndex:999
_____________________________
sum_parallel_for_reduction
Sum: 499500
Took: 0
thread:0 lastIndex:124
thread:1 lastIndex:249
thread:2 lastIndex:374
thread:3 lastIndex:499
thread:4 lastIndex:624
thread:5 lastIndex:749
thread:6 lastIndex:874
thread:7 lastIndex:999
_____________________________
]]></outputString>
  </Command>
  <Command __id="71706" _type="MoveCaretCommand" caretOffset="571" date="Tue Dec 24 07:42:44 EST 2019" docOffset="571" starttimestamp="1576666505112" timestamp="524859760" />
  <Command __id="71707" _type="BreakPointCommand" date="Tue Dec 24 07:42:44 EST 2019" lineNumber="30" starttimestamp="1576666505112" timestamp="524859764" type="BreakPointRemoved" />
  <Command __id="71708" _type="EclipseCommand" commandID="AUTOGEN:::org.eclipse.cdt.debug.ui.CEditor.BreakpointRulerActions/org.eclipse.cdt.debug.ui.CEditor.RulerTobbleBreakpointAction" date="Tue Dec 24 07:42:44 EST 2019" starttimestamp="1576666505112" timestamp="524859774" />
  <Command __id="71709" _type="EclipseCommand" commandID="org.eclipse.debug.ui.commands.Resume" date="Tue Dec 24 07:42:45 EST 2019" starttimestamp="1576666505112" timestamp="524860386" />
  <Command __id="71710" _type="RunCommand" date="Tue Dec 24 07:42:45 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="524860401" type="Debug" />
  <Command __id="71711" _type="RunCommand" date="Tue Dec 24 07:42:45 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="524860401" type="Run" />
  <Command __id="71712" _type="RunCommand" date="Tue Dec 24 07:42:45 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="524860401" type="Debug" />
  <Command __id="71713" _type="RunCommand" date="Tue Dec 24 07:42:45 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="524860401" type="Run" />
  <Command __id="71714" _type="EHExceptionCommand" date="Tue Dec 24 07:42:45 EST 2019" starttimestamp="1576666505112" timestamp="524860467" type="Exception">
    <outputString><![CDATA[sum_parallel_for_local_var
Sum: 499500
Took: 5
thread:0 lastIndex:124
thread:1 lastIndex:249
thread:2 lastIndex:374
thread:3 lastIndex:499
thread:4 lastIndex:624
thread:5 lastIndex:749
thread:6 lastIndex:874
thread:7 lastIndex:999
_____________________________
sum_parallel
Sum: 499500
Took: 0
_____________________________
]]></outputString>
  </Command>
  <Command __id="71715" _type="RunCommand" date="Tue Dec 24 07:42:46 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="524860941" type="Debug" />
  <Command __id="71716" _type="RunCommand" date="Tue Dec 24 07:42:46 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="524860941" type="Run" />
  <Command __id="71717" _type="RunCommand" date="Tue Dec 24 07:42:46 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="524860941" type="Debug" />
  <Command __id="71718" _type="RunCommand" date="Tue Dec 24 07:42:46 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="524860941" type="Run" />
  <Command __id="71705" _type="DiffBasedFileOpenCommand" date="Tue Dec 24 07:42:44 EST 2019" docASTNodeCount="1" docActiveCodeLength="659" docExpressionCount="0" docLength="747" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="524859572">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\my_sum_parallel_for_local_var.cpp]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"#include <iostream>¬∂#include <omp.h>¬∂¬∂using namespace std;¬∂¬∂void printSumWithTimes (int sum, int start, int end);¬∂void printNumThreads();¬∂void recordThreadIndex(int index);¬∂void sum_parallel_for_local_var(double* array, int size)¬∂{¬∂	cout << "sum_parallel_for_local_var\n";¬∂¬∂	double start = omp_get_wtime();¬∂¬∂	double sum = 0;¬∂¬∂	int a, b;¬∂//¬∂//	for (int i = 0; i < size; i++) {¬∂//			sum += array[i];¬∂//			recordThreadIndex(i);¬∂//	}¬∂"), Diff(INSERT,"¬∂"), Diff(EQUAL,"    #pragma omp parallel shared (sum, start) private (a, b)¬∂	{¬∂		double local_sum = 0;¬∂¬∂		#pragma omp for¬∂		for(int i = 0; i < size; i++) {¬∂			local_sum += array[i];¬∂			recordThreadIndex(i);¬∂		}¬∂¬∂		#pragma omp critical¬∂		sum += local_sum;¬∂	}¬∂¬∂	double end = omp_get_wtime();¬∂¬∂	printSumWithTimes(sum, start, end);¬∂	¬∂}¬∂")]]]></diff>
    <snapshot><![CDATA[#include <iostream>
#include <omp.h>

using namespace std;

void printSumWithTimes (int sum, int start, int end);
void printNumThreads();
void recordThreadIndex(int index);
void sum_parallel_for_local_var(double* array, int size)
{
	cout << "sum_parallel_for_local_var\n";

	double start = omp_get_wtime();

	double sum = 0;

	int a, b;
//
//	for (int i = 0; i < size; i++) {
//			sum += array[i];
//			recordThreadIndex(i);
//	}

    #pragma omp parallel shared (sum, start) private (a, b)
	{
		double local_sum = 0;

		#pragma omp for
		for(int i = 0; i < size; i++) {
			local_sum += array[i];
			recordThreadIndex(i);
		}

		#pragma omp critical
		sum += local_sum;
	}

	double end = omp_get_wtime();

	printSumWithTimes(sum, start, end);
	
}
]]></snapshot>
  </Command>
  <Command __id="71719" _type="SelectTextCommand" caretOffset="493" date="Tue Dec 24 07:43:07 EST 2019" end="493" start="468" starttimestamp="1576666505112" timestamp="524881989" />
  <Command __id="71720" _type="DiffBasedFileOpenCommand" date="Tue Dec 24 07:43:51 EST 2019" docASTNodeCount="1" docActiveCodeLength="1642" docExpressionCount="0" docLength="1924" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="524926189">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\my_sum_main.cpp]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"#include <iostream>¬∂#include <omp.h>¬∂¬∂using namespace std;¬∂//need to declare headers of external functions called¬∂void sum_sequential(double* array, int size);¬∂void sum_parallel_for_reduction(double* array, int size);¬∂void sum_parallel(double* array, int size);¬∂void sum_parallel_for_local_var(double* array, int size);¬∂¬∂// if this main is used to call functions to do other computations¬∂// then those headers should also be declared here¬∂¬∂const int SIZE = 1000;¬∂void initArray (double* array, int size ) {¬∂	for(int i = 0; i < size; i++)¬∂			array[i]=i;¬∂}¬∂/**¬∂ * Called by each of the summing alternatives¬∂ */¬∂void printSumWithTimes (int sum, int start, int end) {¬∂	cout << "Sum: " << sum << endl;¬∂	cout << "Took: " << end - start << endl;¬∂}¬∂void printNumThreads() {¬∂	cout << "threads:" << omp_get_num_threads() << endl;¬∂}¬∂/**¬∂ * an array to learn how much concurrency occcurred¬∂ */¬∂int MAX_THREADS = 100;¬∂double* threadsLastIndex = new double[MAX_THREADS];¬∂int numThreads;¬∂¬∂¬∂void recordThreadIndex(int index) {¬∂	int thread =  omp_get_thread_num();¬∂	if (thread >= MAX_THREADS) {¬∂		return;¬∂	}¬∂	threadsLastIndex[thread] = index;¬∂	numThreads = omp_get_num_threads();¬∂}¬∂void initThreadRecording() {¬∂	numThreads = 0;¬∂	for (int i = 0; i < MAX_THREADS; i++) {¬∂		threadsLastIndex[i] = -1;¬∂	}¬∂}¬∂¬∂void printThreadLastIndex() {¬∂	for (int i = 0; i < numThreads; i++) {¬∂		cout << "thread:" << i << " lastIndex:" << threadsLastIndex[i] << endl;¬∂	}¬∂	cout << "_____________________________" << endl;¬∂}¬∂¬∂¬∂int main()¬∂{¬∂	double* array = new double[SIZE];¬∂	initArray(array, SIZE);¬∂	initThreadRecording();¬∂	sum_sequential(array, SIZE);¬∂	printThreadLastIndex();¬∂	initThreadRecording();¬∂	sum_parallel_for_reduction(array, SIZE);¬∂	printThreadLastIndex();¬∂	initThreadRecording();¬∂	sum_parallel_for_local_var(array, SIZE);¬∂	printThreadLastIndex();¬∂	initThreadRecording();¬∂	sum_parallel(array, SIZE);¬∂	printThreadLastIndex();¬∂	initThreadRecording();¬∂}¬∂")]]]></diff>
  </Command>
  <Command __id="71721" _type="MoveCaretCommand" caretOffset="1500" date="Tue Dec 24 07:43:51 EST 2019" docOffset="1500" starttimestamp="1576666505112" timestamp="524926314" />
  <Command __id="71722" _type="DiffBasedFileOpenCommand" date="Tue Dec 24 07:43:52 EST 2019" docASTNodeCount="1" docActiveCodeLength="659" docExpressionCount="0" docLength="747" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="524927776">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\my_sum_parallel_for_local_var.cpp]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"#include <iostream>¬∂#include <omp.h>¬∂¬∂using namespace std;¬∂¬∂void printSumWithTimes (int sum, int start, int end);¬∂void printNumThreads();¬∂void recordThreadIndex(int index);¬∂void sum_parallel_for_local_var(double* array, int size)¬∂{¬∂	cout << "sum_parallel_for_local_var\n";¬∂¬∂	double start = omp_get_wtime();¬∂¬∂	double sum = 0;¬∂¬∂	int a, b;¬∂//¬∂//	for (int i = 0; i < size; i++) {¬∂//			sum += array[i];¬∂//			recordThreadIndex(i);¬∂//	}¬∂¬∂    #pragma omp parallel shared (sum, start) private (a, b)¬∂	{¬∂		double local_sum = 0;¬∂¬∂		#pragma omp for¬∂		for(int i = 0; i < size; i++) {¬∂			local_sum += array[i];¬∂			recordThreadIndex(i);¬∂		}¬∂¬∂		#pragma omp critical¬∂		sum += local_sum;¬∂	}¬∂¬∂	double end = omp_get_wtime();¬∂¬∂	printSumWithTimes(sum, start, end);¬∂	¬∂}¬∂")]]]></diff>
  </Command>
  <Command __id="71723" _type="SelectTextCommand" caretOffset="493" date="Tue Dec 24 07:43:53 EST 2019" end="493" start="468" starttimestamp="1576666505112" timestamp="524928050" />
  <Command __id="71728" _type="DiffBasedFileOpenCommand" date="Tue Dec 24 07:43:57 EST 2019" projectName="null" starttimestamp="1576666505112" timestamp="524932441">
    <filePath><![CDATA[null]]></filePath>
    <diff><![CDATA[null]]></diff>
  </Command>
  <Command __id="72279" _type="DiffBasedFileOpenCommand" date="Tue Dec 24 07:52:51 EST 2019" docASTNodeCount="20" docActiveCodeLength="147" docExpressionCount="14" docLength="227" projectName="GraderBasics" starttimestamp="1576666505112" timestamp="525466472">
    <filePath><![CDATA[D:\dewan_backup\Java\GraderBasics\src\gradingTools\shared\testcases\openmp\OpenMPParallelPragma.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package gradingTools.shared.testcases.openmp;¬∂¬∂import java.util.List;¬∂¬∂public interface OpenMPParallelPragma extends OpenMPPragma{¬∂"), Diff(INSERT,"//"), Diff(EQUAL,"	List<String> getVariableDeclarations();¬∂"), Diff(DELETE,"¬∂"), Diff(INSERT,"//¬∂//"), Diff(EQUAL,"	List<String> getLocalVariables();¬∂¬∂}¬∂")]]]></diff>
    <snapshot><![CDATA[package gradingTools.shared.testcases.openmp;

import java.util.List;

public interface OpenMPParallelPragma extends OpenMPPragma{
//	List<String> getVariableDeclarations();
//
//	List<String> getLocalVariables();

}
]]></snapshot>
  </Command>
  <Command __id="72305" _type="EclipseCommand" commandID="" date="Tue Dec 24 07:52:54 EST 2019" starttimestamp="1576666505112" timestamp="525469280" />
  <Command __id="72306" _type="EclipseCommand" commandID="" date="Tue Dec 24 07:52:54 EST 2019" starttimestamp="1576666505112" timestamp="525469281" />
  <Command __id="72307" _type="EclipseCommand" commandID="" date="Tue Dec 24 07:52:54 EST 2019" starttimestamp="1576666505112" timestamp="525469290" />
  <Command __id="72308" _type="EclipseCommand" commandID="" date="Tue Dec 24 07:52:54 EST 2019" starttimestamp="1576666505112" timestamp="525469290" />
  <Command __id="72309" _type="EclipseCommand" commandID="" date="Tue Dec 24 07:52:54 EST 2019" starttimestamp="1576666505112" timestamp="525469292" />
  <Command __id="72310" _type="EclipseCommand" commandID="" date="Tue Dec 24 07:52:54 EST 2019" starttimestamp="1576666505112" timestamp="525469292" />
  <Command __id="72311" _type="EclipseCommand" commandID="" date="Tue Dec 24 07:52:54 EST 2019" starttimestamp="1576666505112" timestamp="525469307" />
  <Command __id="72312" _type="EclipseCommand" commandID="" date="Tue Dec 24 07:52:54 EST 2019" starttimestamp="1576666505112" timestamp="525469307" />
  <Command __id="72313" _type="EclipseCommand" commandID="" date="Tue Dec 24 07:52:54 EST 2019" starttimestamp="1576666505112" timestamp="525469311" />
  <Command __id="72314" _type="EclipseCommand" commandID="" date="Tue Dec 24 07:52:54 EST 2019" starttimestamp="1576666505112" timestamp="525469311" />
  <Command __id="72315" _type="EclipseCommand" commandID="" date="Tue Dec 24 07:52:54 EST 2019" starttimestamp="1576666505112" timestamp="525469315" />
  <Command __id="72317" _type="MoveCaretCommand" caretOffset="399" date="Tue Dec 24 07:53:13 EST 2019" docOffset="399" starttimestamp="1576666505112" timestamp="525488287" />
  <Command __id="72318" _type="EclipseCommand" commandID="" date="Tue Dec 24 07:53:13 EST 2019" starttimestamp="1576666505112" timestamp="525488846" />
  <Command __id="72319" _type="EclipseCommand" commandID="" date="Tue Dec 24 07:53:14 EST 2019" starttimestamp="1576666505112" timestamp="525488938" />
  <Command __id="72316" _type="DiffBasedFileOpenCommand" date="Tue Dec 24 07:53:13 EST 2019" docASTNodeCount="1" docActiveCodeLength="530" docExpressionCount="0" docLength="554" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="525487964">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\my_sum_parallel_for_reduction.cpp]]></filePath>
    <diff><![CDATA[null]]></diff>
    <snapshot><![CDATA[#include <iostream>
#include <omp.h>

using namespace std;

//const int SIZE = 1000;
void printSumWithTimes(int sum, int start, int end);
void printNumThreads();
void recordThreadIndex(int index);
void sum_parallel_for_reduction(double* array, int size) {
	cout << "sum_parallel_for_reduction\n";

	double start = omp_get_wtime();

	double sum = 0;
    #pragma omp  parallel for reduction ( + : sum )
	for (int i = 0; i < size; i++) {
		sum += array[i];
		recordThreadIndex(i);
	}

	double end = omp_get_wtime();

	printSumWithTimes(sum, start, end);

}
]]></snapshot>
  </Command>
  <Command __id="72320" _type="MoveCaretCommand" caretOffset="368" date="Tue Dec 24 07:53:17 EST 2019" docOffset="368" starttimestamp="1576666505112" timestamp="525492137" />
  <Command __id="72321" _type="SelectTextCommand" caretOffset="374" date="Tue Dec 24 07:53:17 EST 2019" end="374" start="366" starttimestamp="1576666505112" timestamp="525492440" />
  <Command __id="72323" _type="EclipseCommand" commandID="org.eclipse.ui.edit.delete" date="Tue Dec 24 07:53:19 EST 2019" starttimestamp="1576666505112" timestamp="525494314" />
  <Command __id="72324" _type="EclipseCommand" commandID="org.eclipse.ui.file.save" date="Tue Dec 24 07:53:21 EST 2019" starttimestamp="1576666505112" timestamp="525496450" />
  <Command __id="72325" _type="MoveCaretCommand" caretOffset="368" date="Tue Dec 24 07:53:23 EST 2019" docOffset="368" starttimestamp="1576666505112" timestamp="525498627" />
  <Command __id="72326" _type="MoveCaretCommand" caretOffset="368" date="Tue Dec 24 07:53:25 EST 2019" docOffset="368" starttimestamp="1576666505112" timestamp="525500225" />
  <Command __id="72327" _type="ShellCommand" date="Tue Dec 24 07:53:34 EST 2019" starttimestamp="1576666505112" timestamp="525509467" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="72328" _type="ShellCommand" date="Tue Dec 24 07:53:34 EST 2019" starttimestamp="1576666505112" timestamp="525509652" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="72329" _type="ShellCommand" date="Tue Dec 24 07:53:34 EST 2019" starttimestamp="1576666505112" timestamp="525509772" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="72330" _type="ShellCommand" date="Tue Dec 24 07:53:38 EST 2019" starttimestamp="1576666505112" timestamp="525513333" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="72331" _type="EclipseCommand" commandID="org.eclipse.cdt.debug.ui.localCShortcut.run" date="Tue Dec 24 07:53:38 EST 2019" starttimestamp="1576666505112" timestamp="525513357" />
  <Command __id="72332" _type="ShellCommand" date="Tue Dec 24 07:53:39 EST 2019" starttimestamp="1576666505112" timestamp="525514292" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="72333" _type="ShellCommand" date="Tue Dec 24 07:53:41 EST 2019" starttimestamp="1576666505112" timestamp="525516238" type="ECLIPSE_GAINED_FOCUS" />
  <DocumentChange __id="72322" _type="Delete" date="Tue Dec 24 07:53:19 EST 2019" docASTNodeCount="1" docActiveCodeLength="522" docExpressionCount="0" docLength="546" endLine="15" length="8" offset="366" startLine="15" starttimestamp="1576666505112" timestamp="525494297">
    <text><![CDATA[parallel]]></text>
  </DocumentChange>
  <Command __id="72334" _type="MoveCaretCommand" caretOffset="360" date="Tue Dec 24 07:54:12 EST 2019" docOffset="360" starttimestamp="1576666505112" timestamp="525547319" />
  <Command __id="72336" _type="UndoCommand" date="Tue Dec 24 07:54:13 EST 2019" starttimestamp="1576666505112" timestamp="525548808" />
  <Command __id="72337" _type="EclipseCommand" commandID="org.eclipse.ui.file.save" date="Tue Dec 24 07:54:15 EST 2019" starttimestamp="1576666505112" timestamp="525550816" />
  <Command __id="72338" _type="MoveCaretCommand" caretOffset="327" date="Tue Dec 24 07:54:21 EST 2019" docOffset="327" starttimestamp="1576666505112" timestamp="525556877" />
  <DocumentChange __id="75272" _type="Insert" date="Tue Dec 24 08:28:20 EST 2019" docASTNodeCount="166" docActiveCodeLength="1144" docExpressionCount="104" docLength="1246" length="1" offset="876" starttimestamp="1576666505112" timestamp="527595610">
    <text><![CDATA[t]]></text>
  </DocumentChange>
  <DocumentChange __id="75275" _type="Delete" date="Tue Dec 24 08:28:23 EST 2019" docASTNodeCount="166" docActiveCodeLength="1143" docExpressionCount="104" docLength="1245" endLine="28" length="1" offset="857" startLine="28" starttimestamp="1576666505112" timestamp="527598289">
    <text><![CDATA[P]]></text>
  </DocumentChange>
  <DocumentChange __id="75277" _type="Insert" date="Tue Dec 24 08:28:23 EST 2019" docASTNodeCount="166" docActiveCodeLength="1144" docExpressionCount="104" docLength="1246" length="1" offset="857" starttimestamp="1576666505112" timestamp="527598658">
    <text><![CDATA[p]]></text>
  </DocumentChange>
  <Command __id="75303" _type="EclipseCommand" commandID="" date="Tue Dec 24 08:28:25 EST 2019" starttimestamp="1576666505112" timestamp="527600575" />
  <Command __id="75304" _type="EclipseCommand" commandID="" date="Tue Dec 24 08:28:25 EST 2019" starttimestamp="1576666505112" timestamp="527600575" />
  <Command __id="75305" _type="EclipseCommand" commandID="" date="Tue Dec 24 08:28:25 EST 2019" starttimestamp="1576666505112" timestamp="527600585" />
  <Command __id="75306" _type="EclipseCommand" commandID="" date="Tue Dec 24 08:28:25 EST 2019" starttimestamp="1576666505112" timestamp="527600585" />
  <Command __id="75307" _type="EclipseCommand" commandID="" date="Tue Dec 24 08:28:25 EST 2019" starttimestamp="1576666505112" timestamp="527600587" />
  <Command __id="75308" _type="EclipseCommand" commandID="" date="Tue Dec 24 08:28:25 EST 2019" starttimestamp="1576666505112" timestamp="527600587" />
  <Command __id="75309" _type="EclipseCommand" commandID="" date="Tue Dec 24 08:28:25 EST 2019" starttimestamp="1576666505112" timestamp="527600605" />
  <Command __id="75310" _type="EclipseCommand" commandID="" date="Tue Dec 24 08:28:25 EST 2019" starttimestamp="1576666505112" timestamp="527600606" />
  <Command __id="75311" _type="EclipseCommand" commandID="" date="Tue Dec 24 08:28:25 EST 2019" starttimestamp="1576666505112" timestamp="527600610" />
  <Command __id="75312" _type="EclipseCommand" commandID="" date="Tue Dec 24 08:28:25 EST 2019" starttimestamp="1576666505112" timestamp="527600611" />
  <Command __id="75313" _type="EclipseCommand" commandID="" date="Tue Dec 24 08:28:25 EST 2019" starttimestamp="1576666505112" timestamp="527600617" />
  <Command __id="75314" _type="MoveCaretCommand" caretOffset="873" date="Tue Dec 24 08:28:25 EST 2019" docOffset="873" starttimestamp="1576666505112" timestamp="527600830" />
  <Command __id="75315" _type="SelectTextCommand" caretOffset="877" date="Tue Dec 24 08:28:26 EST 2019" end="877" start="871" starttimestamp="1576666505112" timestamp="527601105" />
  <Command __id="75317" _type="MoveCaretCommand" caretOffset="327" date="Tue Dec 24 08:28:29 EST 2019" docOffset="327" starttimestamp="1576666505112" timestamp="527604413" />
  <Command __id="75318" _type="EclipseCommand" commandID="" date="Tue Dec 24 08:28:30 EST 2019" starttimestamp="1576666505112" timestamp="527605325" />
  <Command __id="75319" _type="EclipseCommand" commandID="" date="Tue Dec 24 08:28:30 EST 2019" starttimestamp="1576666505112" timestamp="527605391" />
  <Command __id="75320" _type="MoveCaretCommand" caretOffset="371" date="Tue Dec 24 08:28:32 EST 2019" docOffset="371" starttimestamp="1576666505112" timestamp="527607665" />
  <Command __id="75321" _type="SelectTextCommand" caretOffset="374" date="Tue Dec 24 08:28:33 EST 2019" end="374" start="366" starttimestamp="1576666505112" timestamp="527608120" />
  <Command __id="75322" _type="MoveCaretCommand" caretOffset="376" date="Tue Dec 24 08:28:39 EST 2019" docOffset="376" starttimestamp="1576666505112" timestamp="527614287" />
  <Command __id="75323" _type="SelectTextCommand" caretOffset="378" date="Tue Dec 24 08:28:39 EST 2019" end="378" start="375" starttimestamp="1576666505112" timestamp="527614547" />
  <Command __id="75324" _type="SelectTextCommand" caretOffset="401" date="Tue Dec 24 08:28:39 EST 2019" end="401" start="349" starttimestamp="1576666505112" timestamp="527614864" />
  <Command __id="75325" _type="CopyCommand" date="Tue Dec 24 08:28:41 EST 2019" starttimestamp="1576666505112" timestamp="527616027" />
  <Command __id="75326" _type="MoveCaretCommand" caretOffset="400" date="Tue Dec 24 08:28:43 EST 2019" docOffset="400" starttimestamp="1576666505112" timestamp="527617926" />
  <Command __id="75328" _type="InsertStringCommand" date="Tue Dec 24 08:28:43 EST 2019" starttimestamp="1576666505112" timestamp="527618357" timestamp2="527618357">
    <data><![CDATA[]]></data>
  </Command>
  <Command __id="75330" _type="PasteCommand" date="Tue Dec 24 08:28:44 EST 2019" starttimestamp="1576666505112" timestamp="527619121" />
  <Command __id="75331" _type="MoveCaretCommand" caretOffset="401" date="Tue Dec 24 08:28:46 EST 2019" docOffset="401" starttimestamp="1576666505112" timestamp="527621237" />
  <Command __id="75333" _type="InsertStringCommand" date="Tue Dec 24 08:28:46 EST 2019" starttimestamp="1576666505112" timestamp="527621482" timestamp2="527621482">
    <data><![CDATA[	]]></data>
  </Command>
  <Command __id="75334" _type="MoveCaretCommand" caretOffset="351" date="Tue Dec 24 08:28:48 EST 2019" docOffset="351" starttimestamp="1576666505112" timestamp="527623233" />
  <Command __id="75336" _type="EclipseCommand" commandID="org.eclipse.cdt.ui.edit.text.c.toggle.comment" date="Tue Dec 24 08:28:49 EST 2019" starttimestamp="1576666505112" timestamp="527624101" />
  <Command __id="75337" _type="MoveCaretCommand" caretOffset="422" date="Tue Dec 24 08:28:53 EST 2019" docOffset="422" starttimestamp="1576666505112" timestamp="527628394" />
  <Command __id="75338" _type="SelectTextCommand" caretOffset="425" date="Tue Dec 24 08:28:53 EST 2019" end="425" start="417" starttimestamp="1576666505112" timestamp="527628637" />
  <Command __id="75340" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Tue Dec 24 08:28:54 EST 2019" starttimestamp="1576666505112" timestamp="527629012" />
  <Command __id="75342" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Tue Dec 24 08:28:54 EST 2019" starttimestamp="1576666505112" timestamp="527629303" />
  <Command __id="75348" _type="RunCommand" date="Tue Dec 24 08:29:09 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="527644220" type="Run" />
  <Command __id="75349" _type="RunCommand" date="Tue Dec 24 08:29:09 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="527644220" type="Run" />
  <Command __id="75350" _type="RunCommand" date="Tue Dec 24 08:29:09 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="527644254" type="Debug" />
  <Command __id="75351" _type="RunCommand" date="Tue Dec 24 08:29:09 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="527644255" type="Run" />
  <Command __id="75352" _type="RunCommand" date="Tue Dec 24 08:29:09 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="527644255" type="Debug" />
  <Command __id="75353" _type="RunCommand" date="Tue Dec 24 08:29:09 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="527644255" type="Run" />
  <Command __id="75354" _type="EHExceptionCommand" date="Tue Dec 24 08:29:09 EST 2019" starttimestamp="1576666505112" timestamp="527644368" type="Exception">
    <outputString><![CDATA[sum_sequential
Sum: 499500
Took: 0
thread:0 lastIndex:999
_____________________________
sum_parallel_for_reduction
Sum: 499500
Took: 0
thread:0 lastIndex:999
_____________________________
sum_parallel_for_local_var
Sum: 499500
Took: 0
thread:0 lastIndex:124
thread:1 lastIndex:249
thread:2 lastIndex:374
thread:3 lastIndex:499
thread:4 lastIndex:624
thread:5 lastIndex:749
thread:6 lastIndex:874
thread:7 lastIndex:999
_____________________________
sum_parallel
Sum: 499500
Took: 0
_____________________________
]]></outputString>
  </Command>
  <Command __id="75316" _type="DiffBasedFileOpenCommand" date="Tue Dec 24 08:28:29 EST 2019" docASTNodeCount="1" docActiveCodeLength="530" docExpressionCount="0" docLength="554" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="527604300">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\my_sum_parallel_for_reduction.cpp]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"#include <iostream>¬∂#include <omp.h>¬∂¬∂using namespace std;¬∂¬∂//const int SIZE = 1000;¬∂void printSumWithTimes(int sum, int start, int end);¬∂void printNumThreads();¬∂void recordThreadIndex(int index);¬∂void sum_parallel_for_reduction(double* array, int size) {¬∂	cout << "sum_parallel_for_reduction\n";¬∂¬∂	double start = omp_get_wtime();¬∂¬∂	double sum = 0;¬∂    #pragma omp  parallel for reduction ( + : sum )¬∂	for (int i = 0; i < size; i++) {¬∂		sum += array[i];¬∂		recordThreadIndex(i);¬∂	}¬∂¬∂	double end = omp_get_wtime();¬∂¬∂	printSumWithTimes(sum, start, end);¬∂¬∂}¬∂")]]]></diff>
  </Command>
  <DocumentChange __id="75327" _type="Insert" date="Tue Dec 24 08:28:43 EST 2019" docASTNodeCount="1" docActiveCodeLength="532" docExpressionCount="0" docLength="556" length="2" offset="400" starttimestamp="1576666505112" timestamp="527618352">
    <text><![CDATA[
	]]></text>
  </DocumentChange>
  <DocumentChange __id="75329" _type="Replace" date="Tue Dec 24 08:28:44 EST 2019" docASTNodeCount="1" docActiveCodeLength="579" docExpressionCount="0" docLength="603" endLine="16" insertionLength="48" int_docASTNodeCount="1" int_docActiveCodeLength="531" int_docExpressionCount="0" int_docLength="555" length="1" offset="401" startLine="16" starttimestamp="1576666505112" timestamp="527619110">
    <deletedText><![CDATA[	]]></deletedText>
    <insertedText><![CDATA[#pragma omp  parallel for reduction ( + : sum )
]]></insertedText>
  </DocumentChange>
  <DocumentChange __id="75332" _type="Insert" date="Tue Dec 24 08:28:46 EST 2019" docASTNodeCount="1" docActiveCodeLength="580" docExpressionCount="0" docLength="604" length="1" offset="401" starttimestamp="1576666505112" timestamp="527621478">
    <text><![CDATA[	]]></text>
  </DocumentChange>
  <DocumentChange __id="75335" _type="Insert" date="Tue Dec 24 08:28:49 EST 2019" docASTNodeCount="1" docActiveCodeLength="529" docExpressionCount="0" docLength="606" length="2" offset="349" starttimestamp="1576666505112" timestamp="527624090">
    <text><![CDATA[//]]></text>
  </DocumentChange>
  <DocumentChange __id="75339" _type="Delete" date="Tue Dec 24 08:28:54 EST 2019" docASTNodeCount="1" docActiveCodeLength="521" docExpressionCount="0" docLength="598" endLine="16" length="8" offset="417" startLine="16" starttimestamp="1576666505112" timestamp="527629007">
    <text><![CDATA[parallel]]></text>
  </DocumentChange>
  <DocumentChange __id="75341" _type="Delete" date="Tue Dec 24 08:28:54 EST 2019" docASTNodeCount="1" docActiveCodeLength="520" docExpressionCount="0" docLength="597" endLine="16" length="1" offset="416" startLine="16" starttimestamp="1576666505112" timestamp="527629300">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="75344" _type="Delete" date="Tue Dec 24 08:28:58 EST 2019" docASTNodeCount="1" docActiveCodeLength="499" docExpressionCount="0" docLength="576" endLine="16" length="21" offset="421" startLine="16" starttimestamp="1576666505112" timestamp="527633022">
    <text><![CDATA[reduction ( + : sum )]]></text>
  </DocumentChange>
  <DocumentChange __id="75346" _type="Delete" date="Tue Dec 24 08:28:58 EST 2019" docASTNodeCount="1" docActiveCodeLength="498" docExpressionCount="0" docLength="575" endLine="16" length="1" offset="420" startLine="16" starttimestamp="1576666505112" timestamp="527633869">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <Command __id="75355" _type="MoveCaretCommand" caretOffset="403" date="Tue Dec 24 08:29:51 EST 2019" docOffset="403" starttimestamp="1576666505112" timestamp="527685940" />
  <Command __id="75357" _type="EclipseCommand" commandID="org.eclipse.cdt.ui.edit.text.c.toggle.comment" date="Tue Dec 24 08:29:52 EST 2019" starttimestamp="1576666505112" timestamp="527686956" />
  <Command __id="106702" _type="DiffBasedFileOpenCommand" date="Wed Dec 25 11:40:28 EST 2019" docASTNodeCount="355" docActiveCodeLength="2389" docExpressionCount="261" docLength="2483" projectName="DemoCourseLocalBasicChecks" starttimestamp="1576666505112" timestamp="625523076">
    <filePath><![CDATA[D:\dewan_backup\Java\DemoCourseLocalBasicChecks\src\gradingTools\comp123\assignment1\openmp\testcases\SequentialSumTestCase.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package gradingTools.comp123.assignment1.openmp.testcases;¬∂¬∂import java.util.Arrays;¬∂import java.util.List;¬∂import java.util.Map;¬∂import java.util.regex.Pattern;¬∂¬∂import grader.basics.execution.NotRunnableException;¬∂import grader.basics.execution.RunningProject;¬∂import grader.basics.junit.NotAutomatableException;¬∂import grader.basics.junit.TestCaseResult;¬∂import grader.basics.project.NotGradableException;¬∂import grader.basics.project.Project;¬∂import grader.basics.project.source.ABasicTextManager;¬∂import grader.basics.testcase.PassFailJUnitTestCase;¬∂import gradingTools.shared.testcases.SubstringSequenceChecker;¬∂import gradingTools.shared.testcases.openmp.OpenMPPragma;¬∂import gradingTools.shared.testcases.openmp.OpenMPUtils;¬∂import gradingTools.shared.testcases.openmp.scannedTree.SNode;¬∂import gradingTools.shared.testcases.utils.LinesMatchKind;¬∂import gradingTools.shared.testcases.utils.LinesMatcher;¬∂import gradingTools.utils.RunningProjectUtils;¬∂¬∂public class SequentialSumTestCase extends PassFailJUnitTestCase {¬∂	public static final int TIME_OUT_SECS = 1; // secs¬∂	protected SubstringSequenceChecker checker = new ASequentialSumChecker();	¬∂¬∂	public SequentialSumTestCase() {¬∂	}¬∂¬∂	¬∂¬∂	@Override¬∂	public TestCaseResult test(Project project, boolean autoGrade) throws NotAutomatableException,¬∂			NotGradableException {¬∂		try {¬∂			RunningProject aRunningProject = RunningProjectUtils.runProject(project, TIME_OUT_SECS);¬∂			String anOutput = aRunningProject.await();¬∂			LinesMatcher aLinesMatcher = aRunningProject.getLinesMatcher();¬∂			boolean aRetval = checker.check(aLinesMatcher, LinesMatchKind.ONE_TIME_LINE, Pattern.DOTALL);¬∂			String aSource = project.getSource();¬∂			Map<String, StringBuffer> aFileNameToContents = ABasicTextManager.extractFileContents(aSource);¬∂			for (String aFileName:aFileNameToContents.keySet()) {¬∂				StringBuffer aFileContents = aFileNameToContents.get(aFileName);¬∂//				List<OpenMPPragma> anOpenMPPragmas = OpenMPUtils.getOpemMPPragmas(aFileContents);¬∂				SNode anSNode = OpenMPUtils.getSNode(aFileLines);¬∂				System.out.println("file name:" + aFileName);¬∂				System.out.println("pragmas:" + anOpenMPPragmas);¬∂			}¬∂			String anExpectedLines = Arrays.toString(checker.getSubstrings());¬∂¬∂			if (!aRetval) {¬∂				return fail("Output  did not match:" + anExpectedLines);¬∂¬∂			}¬∂			return pass();¬∂			¬∂¬∂		} catch (NotRunnableException e) {¬∂			throw new NotGradableException();¬∂		}¬∂	}¬∂}¬∂")]]]></diff>
  </Command>
  <DocumentChange __id="106709" _type="Replace" date="Wed Dec 25 11:40:35 EST 2019" docASTNodeCount="355" docActiveCodeLength="2381" docExpressionCount="261" docLength="2475" endLine="47" insertionLength="7" int_docASTNodeCount="353" int_docActiveCodeLength="2374" int_docExpressionCount="259" int_docLength="2468" length="15" offset="2181" startLine="47" starttimestamp="1576666505112" timestamp="625529987">
    <deletedText><![CDATA[anOpenMPPragmas]]></deletedText>
    <insertedText><![CDATA[anSNode]]></insertedText>
  </DocumentChange>
  <DocumentChange __id="106725" _type="Replace" date="Wed Dec 25 11:40:43 EST 2019" docASTNodeCount="355" docActiveCodeLength="2384" docExpressionCount="261" docLength="2478" endLine="45" insertionLength="13" int_docASTNodeCount="354" int_docActiveCodeLength="2371" int_docExpressionCount="260" int_docLength="2465" length="10" offset="2080" startLine="45" starttimestamp="1576666505112" timestamp="625538793">
    <deletedText><![CDATA[aFileLines]]></deletedText>
    <insertedText><![CDATA[aFileContents]]></insertedText>
  </DocumentChange>
  <Command __id="106737" _type="RunCommand" date="Wed Dec 25 11:40:55 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="625550142" type="Run" />
  <Command __id="106738" _type="RunCommand" date="Wed Dec 25 11:40:55 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="625550142" type="Run" />
  <Command __id="106739" _type="RunCommand" date="Wed Dec 25 11:40:55 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="625550527" type="Run" />
  <Command __id="106741" _type="MoveCaretCommand" caretOffset="1500" date="Wed Dec 25 11:40:57 EST 2019" docOffset="1500" starttimestamp="1576666505112" timestamp="625552755" />
  <Command __id="106751" _type="RunCommand" date="Wed Dec 25 11:41:08 EST 2019" kind="HitBreakPoint" projectName="PL_Java" starttimestamp="1576666505112" timestamp="625563564" type="Run" />
  <Command __id="106752" _type="RunCommand" date="Wed Dec 25 11:41:08 EST 2019" kind="HitBreakPoint" projectName="PL_Java" starttimestamp="1576666505112" timestamp="625563564" type="Run" />
  <Command __id="106753" _type="RunCommand" date="Wed Dec 25 11:41:08 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="625563790" type="Run" />
  <Command __id="106754" _type="RunCommand" date="Wed Dec 25 11:41:09 EST 2019" kind="StepInto" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="625563928" type="Run" />
  <Command __id="106755" _type="RunCommand" date="Wed Dec 25 11:41:09 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="625564081" type="Run" />
  <Command __id="106756" _type="EHExceptionCommand" date="Wed Dec 25 11:41:09 EST 2019" starttimestamp="1576666505112" timestamp="625564176" type="Exception">
    <outputString><![CDATA[I***Tracer: showInfo = true
]]></outputString>
  </Command>
  <Command __id="106757" _type="EHExceptionCommand" date="Wed Dec 25 11:41:09 EST 2019" starttimestamp="1576666505112" timestamp="625564343" type="Exception">
    <outputString><![CDATA[Buffer traced nessages =false
]]></outputString>
  </Command>
  <Command __id="106758" _type="RunCommand" date="Wed Dec 25 11:41:10 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="625565288" type="Run" />
  <Command __id="106759" _type="RunCommand" date="Wed Dec 25 11:41:10 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="625565289" type="Run" />
  <Command __id="106760" _type="RunCommand" date="Wed Dec 25 11:41:10 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="625565290" type="Run" />
  <Command __id="106761" _type="RunCommand" date="Wed Dec 25 11:41:10 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="625565291" type="Run" />
  <Command __id="106762" _type="EHExceptionCommand" date="Wed Dec 25 11:41:10 EST 2019" starttimestamp="1576666505112" timestamp="625565767" type="Exception">
    <outputString><![CDATA[ObjectEditor(Version 22, built on Thu Dec 06 16:26:09 EST 2018). Copyright Prasun Dewan, 2012, All rights reserved. US Patent Appl. No.: 12/532,327
]]></outputString>
  </Command>
  <Command __id="106763" _type="ShellCommand" date="Wed Dec 25 11:41:11 EST 2019" starttimestamp="1576666505112" timestamp="625566498" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="106764" _type="EHExceptionCommand" date="Wed Dec 25 11:41:14 EST 2019" starttimestamp="1576666505112" timestamp="625569704" type="Exception">
    <outputString><![CDATA[I***(TestCaseResult) ### SequentialSumTestCase: 1.0
]]></outputString>
  </Command>
  <Command __id="106765" _type="RunCommand" date="Wed Dec 25 11:41:14 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="625569723" type="Run" />
  <Command __id="106766" _type="EHExceptionCommand" date="Wed Dec 25 11:41:14 EST 2019" starttimestamp="1576666505112" timestamp="625569757" type="Exception">
    <outputString><![CDATA[Returning first of multiple entry points:[MyOpenMPTraining.exe, OpenMPTraining.exe]
I***(BasicProcessRunner) Running command:D:\dewan_backup\C\MyOpenMPTraining\Debug\MyOpenMPTraining.exe
I***(BasicProcessRunner) Running in folder: D:\dewan_backup\C\MyOpenMPTraining\Debug
]]></outputString>
  </Command>
  <Command __id="106767" _type="RunCommand" date="Wed Dec 25 11:41:14 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="625569815" type="Run" />
  <Command __id="106768" _type="RunCommand" date="Wed Dec 25 11:41:14 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="625569827" type="Run" />
  <Command __id="106769" _type="EHExceptionCommand" date="Wed Dec 25 11:41:14 EST 2019" starttimestamp="1576666505112" timestamp="625569837" type="Exception">
    <outputString><![CDATA[I***(BasicProcessRunner)  Process started: D:\dewan_backup\C\MyOpenMPTraining\Debug\MyOpenMPTraining.exe folder: D:\dewan_backup\C\MyOpenMPTraining\Debug entry point: null class path: D:\dewan_backup\Java\PLTeaching\PL_Java\bin;D:\dewan_backup\Java\lib\oeall22.jar;C:\Users\dewan\.p2\pool\plugins\org.junit_4.12.0.v201504281640\junit.jar;C:\Users\dewan\.p2\pool\plugins\org.hamcrest.core_1.3.0.v20180420-1519.jar;D:\dewan_backup\Java\GraderBasics\lib\commons-configuration-1.9.jar;D:\dewan_backup\Java\GraderBasics\lib\commons-lang-2.6.jar;D:\dewan_backup\Java\GraderBasics\lib\commons-logging-1.1.1.jar;G:\My Drive\Java\lib\Herrmes\lib\weka3_6.jar;D:\dewan_backup\Java\GraderBasics\target\classes;D:\dewan_backup\Java\DemoCourseLocalBasicChecks\bin
I***(BasicRunningProject) 1577292074929:Received output from main: sum_sequential
I***(BasicRunningProject) 1577292074941:Processing line from main: sum_sequential
I***(BasicRunningProject) 1577292074941:Received output from main: Sum: 499500
I***(BasicRunningProject) 1577292074941:Processing line from main: Sum: 499500
I***(BasicRunningProject) 1577292074942:Received output from main: Took: 0
I***(BasicRunningProject) 1577292074942:Processing line from main: Took: 0
I***(BasicRunningProject) 1577292074942:Received output from main: thread:0 lastIndex:999
I***(BasicRunningProject) 1577292074942:Processing line from main: thread:0 lastIndex:999
I***(BasicRunningProject) 1577292074942:Received output from main: _____________________________
I***(BasicRunningProject) 1577292074942:Processing line from main: _____________________________
I***(BasicRunningProject) 1577292074943:Received output from main: sum_parallel_for_reduction
I***(BasicRunningProject) 1577292074943:Processing line from main: sum_parallel_for_reduction
I***(BasicRunningProject) 1577292074943:Received output from main: Sum: 499500
I***(BasicRunningProject) 1577292074943:Processing line from main: Sum: 499500
I***(BasicRunningProject) 1577292074943:Received output from main: Took: 0
I***(BasicRunningProject) 1577292074943:Processing line from main: Took: 0
I***(BasicRunningProject) 1577292074943:Received output from main: thread:0 lastIndex:124
I***(BasicRunningProject) 1577292074943:Processing line from main: thread:0 lastIndex:124
I***(BasicRunningProject) 1577292074943:Received output from main: thread:1 lastIndex:249
I***(BasicRunningProject) 1577292074943:Processing line from main: thread:1 lastIndex:249
I***(BasicRunningProject) 1577292074944:Received output from main: thread:2 lastIndex:374
I***(BasicRunningProject) 1577292074944:Processing line from main: thread:2 lastIndex:374
I***(BasicRunningProject) 1577292074944:Received output from main: thread:3 lastIndex:499
I***(BasicRunningProject) 1577292074944:Processing line from main: thread:3 lastIndex:499
I***(BasicRunningProject) 1577292074944:Received output from main: thread:4 lastIndex:624
I***(BasicRunningProject) 1577292074944:Processing line from main: thread:4 lastIndex:624
I***(BasicRunningProject) 1577292074944:Received output from main: thread:5 lastIndex:749
I***(BasicRunningProject) 1577292074944:Processing line from main: thread:5 lastIndex:749
I***(BasicRunningProject) 1577292074944:Received output from main: thread:6 lastIndex:874
I***(BasicRunningProject) 1577292074945:Processing line from main: thread:6 lastIndex:874
I***(BasicRunningProject) 1577292074945:Received output from main: thread:7 lastIndex:999
I***(BasicRunningProject) 1577292074945:Processing line from main: thread:7 lastIndex:999
I***(BasicRunningProject) 1577292074945:Received output from main: _____________________________
I***(BasicRunningProject) 1577292074945:Processing line from main: _____________________________
I***(BasicRunningProject) 1577292074945:Received output from main: sum_parallel_for_local_var
I***(BasicRunningProject) 1577292074945:Processing line from main: sum_parallel_for_local_var
I***(BasicRunningProject) 1577292074945:Received output from main: Sum: 499500
I***(BasicRunningProject) 1577292074945:Processing line from main: Sum: 499500
I***(BasicRunningProject) 1577292074945:Received output from main: Took: 0
I***(BasicRunningProject) 1577292074945:Processing line from main: Took: 0
I***(BasicRunningProject) 1577292074946:Received output from main: thread:0 lastIndex:124
I***(BasicRunningProject) 1577292074946:Processing line from main: thread:0 lastIndex:124
I***(BasicRunningProject) 1577292074946:Received output from main: thread:1 lastIndex:249
I***(BasicRunningProject) 1577292074946:Processing line from main: thread:1 lastIndex:249
I***(BasicRunningProject) 1577292074946:Received output from main: thread:2 lastIndex:374
I***(BasicRunningProject) 1577292074946:Processing line from main: thread:2 lastIndex:374
I***(BasicRunningProject) 1577292074946:Received output from main: thread:3 lastIndex:499
I***(BasicRunningProject) 1577292074946:Processing line from main: thread:3 lastIndex:499
I***(BasicRunningProject) 1577292074946:Received output from main: thread:4 lastIndex:624
I***(BasicRunningProject) 1577292074946:Processing line from main: thread:4 lastIndex:624
I***(BasicRunningProject) 1577292074946:Received output from main: thread:5 lastIndex:749
I***(BasicRunningProject) 1577292074947:Processing line from main: thread:5 lastIndex:749
I***(BasicRunningProject) 1577292074947:Received output from main: thread:6 lastIndex:874
I***(BasicRunningProject) 1577292074947:Processing line from main: thread:6 lastIndex:874
I***(BasicRunningProject) 1577292074947:Received output from main: thread:7 lastIndex:999
I***(BasicRunningProject) 1577292074947:Processing line from main: thread:7 lastIndex:999
I***(BasicRunningProject) 1577292074947:Received output from main: _____________________________
I***(BasicRunningProject) 1577292074947:Processing line from main: _____________________________
I***(BasicRunningProject) 1577292074947:Received output from main: sum_parallel
I***(BasicRunningProject) 1577292074947:Processing line from main: sum_parallel
I***(BasicRunningProject) 1577292074947:Received output from main: Sum: 499500
I***(BasicRunningProject) 1577292074948:Processing line from main: Sum: 499500
I***(BasicRunningProject) 1577292074948:Received output from main: Took: 0
I***(BasicRunningProject) 1577292074948:Processing line from main: Took: 0
I***(BasicRunningProject) 1577292074948:Received output from main: _____________________________
I***(BasicRunningProject) 1577292074948:Processing line from main: _____________________________]]></outputString>
  </Command>
  <Command __id="106770" _type="EHExceptionCommand" date="Wed Dec 25 11:41:15 EST 2019" starttimestamp="1576666505112" timestamp="625569915" type="Exception">
    <outputString><![CDATA[
I***(ARunnerInputStreamProcessor) Provided Input:
I***(BasicProcessRunner)  Process finished; folder: D:\dewan_backup\C\MyOpenMPTraining\Debug entry point: null class path: D:\dewan_backup\Java\PLTeaching\PL_Java\bin;D:\dewan_backup\Java\lib\oeall22.jar;C:\Users\dewan\.p2\pool\plugins\org.junit_4.12.0.v201504281640\junit.jar;C:\Users\dewan\.p2\pool\plugins\org.hamcrest.core_1.3.0.v20180420-1519.jar;D:\dewan_backup\Java\GraderBasics\lib\commons-configuration-1.9.jar;D:\dewan_backup\Java\GraderBasics\lib\commons-lang-2.6.jar;D:\dewan_backup\Java\GraderBasics\lib\commons-logging-1.1.1.jar;G:\My Drive\Java\lib\Herrmes\lib\weka3_6.jar;D:\dewan_backup\Java\GraderBasics\target\classes;D:\dewan_backup\Java\DemoCourseLocalBasicChecks\bin
I***(BasicRunningProject) Thread[AWT-EventQueue-0,6,main] sleeping for ms:2000 waiting for pending output from threads 
]]></outputString>
  </Command>
  <DocumentChange __id="119703" _type="Insert" date="Thu Dec 26 00:20:54 EST 2019" docASTNodeCount="229" docActiveCodeLength="1693" docExpressionCount="124" docLength="2192" length="5" offset="790" starttimestamp="1576666505112" timestamp="671149089">
    <text><![CDATA[
			]]></text>
  </DocumentChange>
  <Command __id="119704" _type="InsertStringCommand" date="Thu Dec 26 00:20:54 EST 2019" starttimestamp="1576666505112" timestamp="671149095" timestamp2="671149095">
    <data><![CDATA[]]></data>
  </Command>
  <Command __id="119705" _type="DiffBasedFileOpenCommand" date="Thu Dec 26 00:21:53 EST 2019" docASTNodeCount="1" docActiveCodeLength="659" docExpressionCount="0" docLength="747" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="671208520">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\my_sum_parallel_for_local_var.cpp]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"#include <iostream>¬∂#include <omp.h>¬∂¬∂using namespace std;¬∂¬∂void printSumWithTimes (int sum, int start, int end);¬∂void printNumThreads();¬∂void recordThreadIndex(int index);¬∂void sum_parallel_for_local_var(double* array, int size)¬∂{¬∂	cout << "sum_parallel_for_local_var\n";¬∂¬∂	double start = omp_get_wtime();¬∂¬∂	double sum = 0;¬∂¬∂	int a, b;¬∂//¬∂//	for (int i = 0; i < size; i++) {¬∂//			sum += array[i];¬∂//			recordThreadIndex(i);¬∂//	}¬∂¬∂    #pragma omp parallel shared (sum, start) private (a, b)¬∂	{¬∂		double local_sum = 0;¬∂¬∂		#pragma omp for¬∂		for(int i = 0; i < size; i++) {¬∂			local_sum += array[i];¬∂			recordThreadIndex(i);¬∂		}¬∂¬∂		#pragma omp critical¬∂		sum += local_sum;¬∂	}¬∂¬∂	double end = omp_get_wtime();¬∂¬∂	printSumWithTimes(sum, start, end);¬∂	¬∂}¬∂")]]]></diff>
  </Command>
  <Command __id="119706" _type="SelectTextCommand" caretOffset="493" date="Thu Dec 26 00:21:53 EST 2019" end="493" start="468" starttimestamp="1576666505112" timestamp="671208722" />
  <Command __id="119707" _type="EclipseCommand" commandID="" date="Thu Dec 26 00:21:54 EST 2019" starttimestamp="1576666505112" timestamp="671209622" />
  <Command __id="119708" _type="EclipseCommand" commandID="" date="Thu Dec 26 00:21:54 EST 2019" starttimestamp="1576666505112" timestamp="671209727" />
  <Command __id="119709" _type="DiffBasedFileOpenCommand" date="Thu Dec 26 00:21:56 EST 2019" docASTNodeCount="1" docActiveCodeLength="795" docExpressionCount="0" docLength="795" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="671211516">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\my_sum_parallel.cpp]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"#include <iostream>¬∂#include <omp.h>¬∂¬∂using namespace std;¬∂¬∂void printSumWithTimes(int sum, int start, int end);¬∂void printNumThreads();¬∂void recordThreadIndex(int index);¬∂void sum_parallel(double* array, int size) {¬∂	cout << "sum_parallel\n";¬∂¬∂	double start = omp_get_wtime();¬∂¬∂	double sum = 0;¬∂¬∂¬∂    #pragma omp critical¬∂	{¬∂	double sum = 0;¬∂	}¬∂    #pragma omp parallel¬∂	{¬∂		double local_sum = 0;¬∂¬∂		int rank = omp_get_thread_num();¬∂		int threads = omp_get_num_threads();¬∂¬∂		int start_index = (size/threads)*rank;¬∂		int end_index = (size/threads)*(rank+1);¬∂¬∂		if(rank==threads-1)¬∂			end_index=size;¬∂¬∂		for(int i = start_index; i < end_index; i++)¬∂			local_sum += array[i];¬∂¬∂		#pragma omp critical¬∂		sum += local_sum;¬∂	}¬∂¬∂	double end = omp_get_wtime();¬∂¬∂	printSumWithTimes(sum, start, end);¬∂¬∂¬∂}¬∂")]]]></diff>
  </Command>
  <Command __id="119710" _type="MoveCaretCommand" caretOffset="339" date="Thu Dec 26 00:21:56 EST 2019" docOffset="339" starttimestamp="1576666505112" timestamp="671211708" />
  <Command __id="119712" _type="MoveCaretCommand" caretOffset="349" date="Thu Dec 26 00:21:59 EST 2019" docOffset="349" starttimestamp="1576666505112" timestamp="671214551" />
  <Command __id="119711" _type="DiffBasedFileOpenCommand" date="Thu Dec 26 00:21:59 EST 2019" docASTNodeCount="1" docActiveCodeLength="532" docExpressionCount="0" docLength="575" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="671214368">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\my_sum_parallel_for_reduction.cpp]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"#include <iostream>¬∂#include <omp.h>¬∂¬∂using namespace std;¬∂¬∂//const int SIZE = 1000;¬∂void printSumWithTimes(int sum, int start, int end);¬∂void printNumThreads();¬∂void recordThreadIndex(int index);¬∂void sum_parallel_for_reduction(double* array, int size) {¬∂	cout << "sum_parallel_for_reduction\n";¬∂¬∂	double start = omp_get_wtime();¬∂¬∂	double sum = 0;¬∂    #pragma omp  parallel for reduction ( + : sum )¬∂"), Diff(INSERT,"//	#pragma omp  for¬∂¬∂"), Diff(EQUAL,"	for (int i = 0; i < size; i++) {¬∂		sum += array[i];¬∂		recordThreadIndex(i);¬∂	}¬∂¬∂	double end = omp_get_wtime();¬∂¬∂	printSumWithTimes(sum, start, end);¬∂¬∂}¬∂")]]]></diff>
    <snapshot><![CDATA[#include <iostream>
#include <omp.h>

using namespace std;

//const int SIZE = 1000;
void printSumWithTimes(int sum, int start, int end);
void printNumThreads();
void recordThreadIndex(int index);
void sum_parallel_for_reduction(double* array, int size) {
	cout << "sum_parallel_for_reduction\n";

	double start = omp_get_wtime();

	double sum = 0;
    #pragma omp  parallel for reduction ( + : sum )
//	#pragma omp  for

	for (int i = 0; i < size; i++) {
		sum += array[i];
		recordThreadIndex(i);
	}

	double end = omp_get_wtime();

	printSumWithTimes(sum, start, end);

}
]]></snapshot>
  </Command>
  <Command __id="119713" _type="MoveCaretCommand" caretOffset="378" date="Thu Dec 26 00:22:14 EST 2019" docOffset="378" starttimestamp="1576666505112" timestamp="671229838" />
  <DocumentChange __id="119714" _type="Insert" date="Thu Dec 26 00:22:15 EST 2019" docASTNodeCount="1" docActiveCodeLength="533" docExpressionCount="0" docLength="576" length="1" offset="378" starttimestamp="1576666505112" timestamp="671230866">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <Command __id="119715" _type="InsertStringCommand" date="Thu Dec 26 00:22:15 EST 2019" starttimestamp="1576666505112" timestamp="671230869" timestamp2="671230869">
    <data><![CDATA[ ]]></data>
  </Command>
  <DocumentChange __id="119716" _type="Insert" date="Thu Dec 26 00:22:16 EST 2019" docASTNodeCount="1" docActiveCodeLength="534" docExpressionCount="0" docLength="577" length="1" offset="379" starttimestamp="1576666505112" timestamp="671231258">
    <text><![CDATA[s]]></text>
  </DocumentChange>
  <Command __id="119717" _type="InsertStringCommand" date="Thu Dec 26 00:22:16 EST 2019" starttimestamp="1576666505112" timestamp="671231258" timestamp2="671231258">
    <data><![CDATA[s]]></data>
  </Command>
  <DocumentChange __id="119718" _type="Insert" date="Thu Dec 26 00:22:16 EST 2019" docASTNodeCount="1" docActiveCodeLength="535" docExpressionCount="0" docLength="578" length="1" offset="380" starttimestamp="1576666505112" timestamp="671231324">
    <text><![CDATA[h]]></text>
  </DocumentChange>
  <Command __id="119719" _type="InsertStringCommand" date="Thu Dec 26 00:22:16 EST 2019" starttimestamp="1576666505112" timestamp="671231324" timestamp2="671231324">
    <data><![CDATA[h]]></data>
  </Command>
  <DocumentChange __id="119720" _type="Insert" date="Thu Dec 26 00:22:16 EST 2019" docASTNodeCount="1" docActiveCodeLength="536" docExpressionCount="0" docLength="579" length="1" offset="381" starttimestamp="1576666505112" timestamp="671231527">
    <text><![CDATA[a]]></text>
  </DocumentChange>
  <Command __id="119721" _type="InsertStringCommand" date="Thu Dec 26 00:22:16 EST 2019" starttimestamp="1576666505112" timestamp="671231527" timestamp2="671231527">
    <data><![CDATA[a]]></data>
  </Command>
  <DocumentChange __id="119722" _type="Insert" date="Thu Dec 26 00:22:16 EST 2019" docASTNodeCount="1" docActiveCodeLength="537" docExpressionCount="0" docLength="580" length="1" offset="382" starttimestamp="1576666505112" timestamp="671231708">
    <text><![CDATA[r]]></text>
  </DocumentChange>
  <Command __id="119723" _type="InsertStringCommand" date="Thu Dec 26 00:22:16 EST 2019" starttimestamp="1576666505112" timestamp="671231724" timestamp2="671231724">
    <data><![CDATA[r]]></data>
  </Command>
  <DocumentChange __id="119724" _type="Insert" date="Thu Dec 26 00:22:16 EST 2019" docASTNodeCount="1" docActiveCodeLength="538" docExpressionCount="0" docLength="581" length="1" offset="383" starttimestamp="1576666505112" timestamp="671231790">
    <text><![CDATA[e]]></text>
  </DocumentChange>
  <Command __id="119725" _type="InsertStringCommand" date="Thu Dec 26 00:22:16 EST 2019" starttimestamp="1576666505112" timestamp="671231793" timestamp2="671231793">
    <data><![CDATA[e]]></data>
  </Command>
  <DocumentChange __id="119726" _type="Insert" date="Thu Dec 26 00:22:17 EST 2019" docASTNodeCount="1" docActiveCodeLength="539" docExpressionCount="0" docLength="582" length="1" offset="384" starttimestamp="1576666505112" timestamp="671231979">
    <text><![CDATA[d]]></text>
  </DocumentChange>
  <Command __id="119727" _type="InsertStringCommand" date="Thu Dec 26 00:22:17 EST 2019" starttimestamp="1576666505112" timestamp="671231982" timestamp2="671231982">
    <data><![CDATA[d]]></data>
  </Command>
  <DocumentChange __id="119728" _type="Insert" date="Thu Dec 26 00:22:17 EST 2019" docASTNodeCount="1" docActiveCodeLength="540" docExpressionCount="0" docLength="583" length="1" offset="385" starttimestamp="1576666505112" timestamp="671232653">
    <text><![CDATA[(]]></text>
  </DocumentChange>
  <Command __id="119729" _type="InsertStringCommand" date="Thu Dec 26 00:22:17 EST 2019" starttimestamp="1576666505112" timestamp="671232656" timestamp2="671232656">
    <data><![CDATA[(]]></data>
  </Command>
  <DocumentChange __id="119730" _type="Insert" date="Thu Dec 26 00:22:18 EST 2019" docASTNodeCount="1" docActiveCodeLength="541" docExpressionCount="0" docLength="584" length="1" offset="386" starttimestamp="1576666505112" timestamp="671232907">
    <text><![CDATA[i]]></text>
  </DocumentChange>
  <Command __id="119731" _type="InsertStringCommand" date="Thu Dec 26 00:22:18 EST 2019" starttimestamp="1576666505112" timestamp="671232915" timestamp2="671232915">
    <data><![CDATA[i]]></data>
  </Command>
  <Command __id="119733" _type="InsertStringCommand" date="Thu Dec 26 00:22:19 EST 2019" starttimestamp="1576666505112" timestamp="671234223" timestamp2="671234223">
    <data><![CDATA[)]]></data>
  </Command>
  <Command __id="119734" _type="EclipseCommand" commandID="org.eclipse.ui.file.save" date="Thu Dec 26 00:22:21 EST 2019" starttimestamp="1576666505112" timestamp="671236604" />
  <Command __id="119735" _type="MoveCaretCommand" caretOffset="378" date="Thu Dec 26 00:22:24 EST 2019" docOffset="378" starttimestamp="1576666505112" timestamp="671239031" />
  <Command __id="119736" _type="MoveCaretCommand" caretOffset="378" date="Thu Dec 26 00:22:26 EST 2019" docOffset="378" starttimestamp="1576666505112" timestamp="671241005" />
  <Command __id="119737" _type="ShellCommand" date="Thu Dec 26 00:22:35 EST 2019" starttimestamp="1576666505112" timestamp="671250171" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="119738" _type="ShellCommand" date="Thu Dec 26 00:22:36 EST 2019" starttimestamp="1576666505112" timestamp="671251802" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="119739" _type="SelectTextCommand" caretOffset="379" date="Thu Dec 26 00:22:42 EST 2019" end="388" start="379" starttimestamp="1576666505112" timestamp="671257665" />
  <Command __id="119741" _type="EclipseCommand" commandID="org.eclipse.ui.edit.delete" date="Thu Dec 26 00:22:43 EST 2019" starttimestamp="1576666505112" timestamp="671258235" />
  <Command __id="119743" _type="EclipseCommand" commandID="org.eclipse.ui.edit.delete" date="Thu Dec 26 00:22:44 EST 2019" starttimestamp="1576666505112" timestamp="671259236" />
  <DocumentChange __id="151304" _type="Delete" date="Sat Dec 28 10:26:48 EST 2019" docASTNodeCount="2764" docActiveCodeLength="18446" docExpressionCount="1782" docLength="20986" endLine="593" length="14" offset="20979" startLine="592" starttimestamp="1576666505112" timestamp="880302913">
    <text><![CDATA[
	public stat]]></text>
  </DocumentChange>
  <Command __id="151312" _type="ShellCommand" date="Sat Dec 28 10:27:34 EST 2019" starttimestamp="1576666505112" timestamp="880348906" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="151314" _type="MoveCaretCommand" caretOffset="1500" date="Sat Dec 28 10:27:44 EST 2019" docOffset="1500" starttimestamp="1576666505112" timestamp="880358932" />
  <Command __id="151315" _type="SelectTextCommand" caretOffset="1165" date="Sat Dec 28 10:27:50 EST 2019" end="1284" start="1165" starttimestamp="1576666505112" timestamp="880365354" />
  <Command __id="151316" _type="CopyCommand" date="Sat Dec 28 10:27:51 EST 2019" starttimestamp="1576666505112" timestamp="880366042" />
  <Command __id="151323" _type="EclipseCommand" commandID="org.eclipse.cdt.ui.edit.text.c.toggle.comment" date="Sat Dec 28 10:27:52 EST 2019" starttimestamp="1576666505112" timestamp="880366891" />
  <Command __id="151324" _type="MoveCaretCommand" caretOffset="1935" date="Sat Dec 28 10:27:57 EST 2019" docOffset="1935" starttimestamp="1576666505112" timestamp="880372363" />
  <Command __id="151326" _type="InsertStringCommand" date="Sat Dec 28 10:27:58 EST 2019" starttimestamp="1576666505112" timestamp="880372960" timestamp2="880372960">
    <data><![CDATA[]]></data>
  </Command>
  <Command __id="151328" _type="PasteCommand" date="Sat Dec 28 10:27:58 EST 2019" starttimestamp="1576666505112" timestamp="880373585" />
  <Command __id="151313" _type="DiffBasedFileOpenCommand" date="Sat Dec 28 10:27:43 EST 2019" docASTNodeCount="1" docActiveCodeLength="1642" docExpressionCount="0" docLength="1924" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="880358704">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\my_sum_main.cpp]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"#include <iostream>¬∂#include <omp.h>¬∂¬∂using namespace std;¬∂//need to declare headers of external functions called¬∂void sum_sequential(double* array, int size);¬∂void sum_parallel_for_reduction(double* array, int size);¬∂void sum_parallel(double* array, int size);¬∂void sum_parallel_for_local_var(double* array, int size);¬∂¬∂// if this main is used to call functions to do other computations¬∂// then those headers should also be declared here¬∂¬∂const int SIZE = 1000;¬∂void initArray (double* array, int size ) {¬∂	for(int i = 0; i < size; i++)¬∂			array[i]=i;¬∂}¬∂/**¬∂ * Called by each of the summing alternatives¬∂ */¬∂void printSumWithTimes (int sum, int start, int end) {¬∂	cout << "Sum: " << sum << endl;¬∂	cout << "Took: " << end - start << endl;¬∂}¬∂void printNumThreads() {¬∂	cout << "threads:" << omp_get_num_threads() << endl;¬∂}¬∂/**¬∂ * an array to learn how much concurrency occcurred¬∂ */¬∂int MAX_THREADS = 100;¬∂double* threadsLastIndex = new double[MAX_THREADS];¬∂int numThreads;¬∂¬∂¬∂void recordThreadIndex(int index) {¬∂	int thread =  omp_get_thread_num();¬∂	if (thread >= MAX_THREADS) {¬∂		return;¬∂	}¬∂	threadsLastIndex[thread] = index;¬∂	numThreads = omp_get_num_threads();¬∂}¬∂void initThreadRecording() {¬∂	numThreads = 0;¬∂	for (int i = 0; i < MAX_THREADS; i++) {¬∂		threadsLastIndex[i] = -1;¬∂	}¬∂}¬∂¬∂void printThreadLastIndex() {¬∂	for (int i = 0; i < numThreads; i++) {¬∂		cout << "thread:" << i << " lastIndex:" << threadsLastIndex[i] << endl;¬∂	}¬∂	cout << "_____________________________" << endl;¬∂}¬∂¬∂¬∂int main()¬∂{¬∂	double* array = new double[SIZE];¬∂	initArray(array, SIZE);¬∂	initThreadRecording();¬∂	sum_sequential(array, SIZE);¬∂	printThreadLastIndex();¬∂	initThreadRecording();¬∂	sum_parallel_for_reduction(array, SIZE);¬∂	printThreadLastIndex();¬∂	initThreadRecording();¬∂	sum_parallel_for_local_var(array, SIZE);¬∂	printThreadLastIndex();¬∂	initThreadRecording();¬∂	sum_parallel(array, SIZE);¬∂	printThreadLastIndex();¬∂	initThreadRecording();¬∂}¬∂")]]]></diff>
  </Command>
  <DocumentChange __id="151317" _type="Insert" date="Sat Dec 28 10:27:51 EST 2019" docASTNodeCount="1" docActiveCodeLength="1614" docExpressionCount="0" docLength="1926" length="2" offset="1165" starttimestamp="1576666505112" timestamp="880366854">
    <text><![CDATA[//]]></text>
  </DocumentChange>
  <DocumentChange __id="151318" _type="Insert" date="Sat Dec 28 10:27:51 EST 2019" docASTNodeCount="1" docActiveCodeLength="1598" docExpressionCount="0" docLength="1928" length="2" offset="1196" starttimestamp="1576666505112" timestamp="880366857">
    <text><![CDATA[//]]></text>
  </DocumentChange>
  <DocumentChange __id="151319" _type="Insert" date="Sat Dec 28 10:27:51 EST 2019" docASTNodeCount="1" docActiveCodeLength="1558" docExpressionCount="0" docLength="1930" length="2" offset="1215" starttimestamp="1576666505112" timestamp="880366860">
    <text><![CDATA[//]]></text>
  </DocumentChange>
  <DocumentChange __id="151320" _type="Insert" date="Sat Dec 28 10:27:51 EST 2019" docASTNodeCount="1" docActiveCodeLength="1531" docExpressionCount="0" docLength="1932" length="2" offset="1258" starttimestamp="1576666505112" timestamp="880366863">
    <text><![CDATA[//]]></text>
  </DocumentChange>
  <DocumentChange __id="151321" _type="Insert" date="Sat Dec 28 10:27:51 EST 2019" docASTNodeCount="1" docActiveCodeLength="1529" docExpressionCount="0" docLength="1934" length="2" offset="1288" starttimestamp="1576666505112" timestamp="880366866">
    <text><![CDATA[//]]></text>
  </DocumentChange>
  <DocumentChange __id="151322" _type="Insert" date="Sat Dec 28 10:27:51 EST 2019" docASTNodeCount="1" docActiveCodeLength="1528" docExpressionCount="0" docLength="1936" length="2" offset="1293" starttimestamp="1576666505112" timestamp="880366869">
    <text><![CDATA[//]]></text>
  </DocumentChange>
  <DocumentChange __id="151325" _type="Insert" date="Sat Dec 28 10:27:58 EST 2019" docASTNodeCount="1" docActiveCodeLength="1529" docExpressionCount="0" docLength="1937" length="1" offset="1935" starttimestamp="1576666505112" timestamp="880372955">
    <text><![CDATA[
]]></text>
  </DocumentChange>
  <DocumentChange __id="151327" _type="Insert" date="Sat Dec 28 10:27:58 EST 2019" docASTNodeCount="1" docActiveCodeLength="1648" docExpressionCount="0" docLength="2056" length="119" offset="1936" starttimestamp="1576666505112" timestamp="880373568">
    <text><![CDATA[void initThreadRecording() {
	numThreads = 0;
	for (int i = 0; i < MAX_THREADS; i++) {
		threadsLastIndex[i] = -1;
	}
}]]></text>
  </DocumentChange>
  <Command __id="151329" _type="EclipseCommand" commandID="org.eclipse.ui.file.save" date="Sat Dec 28 10:28:00 EST 2019" starttimestamp="1576666505112" timestamp="880375625" />
  <DocumentChange __id="151330" _type="Delete" date="Sat Dec 28 10:28:02 EST 2019" docASTNodeCount="1" docActiveCodeLength="1529" docExpressionCount="0" docLength="1937" endLine="82" length="119" offset="1936" startLine="77" starttimestamp="1576666505112" timestamp="880377676">
    <text><![CDATA[void initThreadRecording() {
	numThreads = 0;
	for (int i = 0; i < MAX_THREADS; i++) {
		threadsLastIndex[i] = -1;
	}
}]]></text>
  </DocumentChange>
  <Command __id="151331" _type="UndoCommand" date="Sat Dec 28 10:28:02 EST 2019" starttimestamp="1576666505112" timestamp="880377697" />
  <DocumentChange __id="151332" _type="Delete" date="Sat Dec 28 10:28:03 EST 2019" docASTNodeCount="1" docActiveCodeLength="1528" docExpressionCount="0" docLength="1936" endLine="77" length="1" offset="1935" startLine="76" starttimestamp="1576666505112" timestamp="880378246">
    <text><![CDATA[
]]></text>
  </DocumentChange>
  <Command __id="151333" _type="UndoCommand" date="Sat Dec 28 10:28:03 EST 2019" starttimestamp="1576666505112" timestamp="880378263" />
  <Command __id="151340" _type="UndoCommand" date="Sat Dec 28 10:28:03 EST 2019" starttimestamp="1576666505112" timestamp="880378804" />
  <DocumentChange __id="155741" _type="Insert" date="Sat Dec 28 23:53:09 EST 2019" docASTNodeCount="35" docActiveCodeLength="258" docExpressionCount="18" docLength="297" length="1" offset="176" starttimestamp="1576666505112" timestamp="928684050">
    <text><![CDATA[;]]></text>
  </DocumentChange>
  <DocumentChange __id="155744" _type="Delete" date="Sat Dec 28 23:53:14 EST 2019" docASTNodeCount="35" docActiveCodeLength="257" docExpressionCount="18" docLength="296" endLine="4" length="1" offset="145" startLine="4" starttimestamp="1576666505112" timestamp="928688977">
    <text><![CDATA[r]]></text>
  </DocumentChange>
  <Command __id="155784" _type="ShellCommand" date="Sat Dec 28 23:54:05 EST 2019" starttimestamp="1576666505112" timestamp="928739933" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="155786" _type="MoveCaretCommand" caretOffset="339" date="Sat Dec 28 23:55:40 EST 2019" docOffset="339" starttimestamp="1576666505112" timestamp="928835036" />
  <Command __id="155787" _type="EclipseCommand" commandID="" date="Sat Dec 28 23:55:40 EST 2019" starttimestamp="1576666505112" timestamp="928835646" />
  <Command __id="155788" _type="EclipseCommand" commandID="" date="Sat Dec 28 23:55:40 EST 2019" starttimestamp="1576666505112" timestamp="928835769" />
  <Command __id="155789" _type="SelectTextCommand" caretOffset="431" date="Sat Dec 28 23:55:44 EST 2019" end="431" start="412" starttimestamp="1576666505112" timestamp="928839873" />
  <Command __id="155790" _type="SelectTextCommand" caretOffset="431" date="Sat Dec 28 23:55:44 EST 2019" end="431" start="412" starttimestamp="1576666505112" timestamp="928839873" />
  <Command __id="155791" _type="SelectTextCommand" caretOffset="430" date="Sat Dec 28 23:55:50 EST 2019" end="430" start="411" starttimestamp="1576666505112" timestamp="928845388" />
  <Command __id="155792" _type="SelectTextCommand" caretOffset="430" date="Sat Dec 28 23:55:50 EST 2019" end="430" start="411" starttimestamp="1576666505112" timestamp="928845388" />
  <DocumentChange __id="155813" _type="Insert" date="Sat Dec 28 23:56:31 EST 2019" docASTNodeCount="35" docActiveCodeLength="265" docExpressionCount="18" docLength="304" length="1" offset="141" starttimestamp="1576666505112" timestamp="928886297">
    <text><![CDATA[_]]></text>
  </DocumentChange>
  <Command __id="155814" _type="InsertStringCommand" date="Sat Dec 28 23:56:31 EST 2019" starttimestamp="1576666505112" timestamp="928886301" timestamp2="928886301">
    <data><![CDATA[_]]></data>
  </Command>
  <Command __id="155816" _type="SelectTextCommand" caretOffset="430" date="Sat Dec 28 23:56:35 EST 2019" end="430" start="411" starttimestamp="1576666505112" timestamp="928890529" />
  <Command __id="156081" _type="EclipseCommand" commandID="" date="Sun Dec 29 00:01:07 EST 2019" starttimestamp="1576666505112" timestamp="929162411" />
  <Command __id="156082" _type="EclipseCommand" commandID="" date="Sun Dec 29 00:01:07 EST 2019" starttimestamp="1576666505112" timestamp="929162414" />
  <Command __id="156083" _type="EclipseCommand" commandID="" date="Sun Dec 29 00:01:07 EST 2019" starttimestamp="1576666505112" timestamp="929162426" />
  <Command __id="156084" _type="EclipseCommand" commandID="" date="Sun Dec 29 00:01:07 EST 2019" starttimestamp="1576666505112" timestamp="929162426" />
  <Command __id="156085" _type="EclipseCommand" commandID="" date="Sun Dec 29 00:01:07 EST 2019" starttimestamp="1576666505112" timestamp="929162427" />
  <Command __id="156086" _type="EclipseCommand" commandID="" date="Sun Dec 29 00:01:07 EST 2019" starttimestamp="1576666505112" timestamp="929162427" />
  <Command __id="156087" _type="EclipseCommand" commandID="" date="Sun Dec 29 00:01:07 EST 2019" starttimestamp="1576666505112" timestamp="929162442" />
  <Command __id="156088" _type="EclipseCommand" commandID="" date="Sun Dec 29 00:01:07 EST 2019" starttimestamp="1576666505112" timestamp="929162442" />
  <Command __id="156089" _type="EclipseCommand" commandID="" date="Sun Dec 29 00:01:07 EST 2019" starttimestamp="1576666505112" timestamp="929162446" />
  <Command __id="156090" _type="EclipseCommand" commandID="" date="Sun Dec 29 00:01:07 EST 2019" starttimestamp="1576666505112" timestamp="929162450" />
  <Command __id="156091" _type="EclipseCommand" commandID="" date="Sun Dec 29 00:01:07 EST 2019" starttimestamp="1576666505112" timestamp="929162456" />
  <Command __id="156093" _type="EclipseCommand" commandID="" date="Sun Dec 29 00:06:07 EST 2019" starttimestamp="1576666505112" timestamp="929462176" />
  <Command __id="156094" _type="EclipseCommand" commandID="" date="Sun Dec 29 00:06:07 EST 2019" starttimestamp="1576666505112" timestamp="929462329" />
  <Command __id="157294" _type="DiffBasedFileOpenCommand" date="Sun Dec 29 00:24:30 EST 2019" docASTNodeCount="367" docActiveCodeLength="2458" docExpressionCount="272" docLength="2552" projectName="DemoCourseLocalBasicChecks" starttimestamp="1576666505112" timestamp="930564896">
    <filePath><![CDATA[D:\dewan_backup\Java\DemoCourseLocalBasicChecks\src\gradingTools\comp123\assignment1\openmp\testcases\SequentialSumTestCase.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package gradingTools.comp123.assignment1.openmp.testcases;¬∂¬∂import java.util.Arrays;¬∂import java.util.List;¬∂import java.util.Map;¬∂import java.util.regex.Pattern;¬∂¬∂import grader.basics.execution.NotRunnableException;¬∂import grader.basics.execution.RunningProject;¬∂import grader.basics.junit.NotAutomatableException;¬∂import grader.basics.junit.TestCaseResult;¬∂import grader.basics.project.NotGradableException;¬∂import grader.basics.project.Project;¬∂import grader.basics.project.source.ABasicTextManager;¬∂import grader.basics.testcase.PassFailJUnitTestCase;¬∂import gradingTools.shared.testcases.SubstringSequenceChecker;¬∂import gradingTools.shared.testcases.openmp.OpenMPPragma;¬∂import gradingTools.shared.testcases.openmp.OpenMPUtils;¬∂import gradingTools.shared.testcases.openmp.scannedTree.OMPSNodeUtils;¬∂import gradingTools.shared.testcases.openmp.scannedTree.SNode;¬∂import gradingTools.shared.testcases.utils.LinesMatchKind;¬∂import gradingTools.shared.testcases.utils.LinesMatcher;¬∂import gradingTools.utils.RunningProjectUtils;¬∂¬∂public class SequentialSumTestCase extends PassFailJUnitTestCase {¬∂	public static final int TIME_OUT_SECS = 1; // secs¬∂	protected SubstringSequenceChecker checker = new ASequentialSumChecker();	¬∂¬∂	public SequentialSumTestCase() {¬∂	}¬∂¬∂	¬∂¬∂	@Override¬∂	public TestCaseResult test(Project project, boolean autoGrade) throws NotAutomatableException,¬∂			NotGradableException {¬∂		try {¬∂			RunningProject aRunningProject = RunningProjectUtils.runProject(project, TIME_OUT_SECS);¬∂			String anOutput = aRunningProject.await();¬∂			LinesMatcher aLinesMatcher = aRunningProject.getLinesMatcher();¬∂			boolean aRetval = checker.check(aLinesMatcher, LinesMatchKind.ONE_TIME_LINE, Pattern.DOTALL);¬∂			String aSource = project.getSource();¬∂			Map<String, StringBuffer> aFileNameToContents = ABasicTextManager.extractFileContents(aSource);¬∂			for (String aFileName:aFileNameToContents.keySet()) {¬∂				StringBuffer aFileContents = aFileNameToContents.get(aFileName);¬∂//				List<OpenMPPragma> anOpenMPPragmas = OpenMPUtils.getOpemMPPragmas(aFileContents);¬∂				SNode anSNode = OMPSNodeUtils.getSNode(aFileContents);¬∂				System.out.println("file name:" + aFileName);¬∂				System.out.println("pragmas:" + anSNode);¬∂			}¬∂			String anExpectedLines = Arrays.toString(checker.getSubstrings());¬∂¬∂			if (!aRetval) {¬∂				return fail("Output  did not match:" + anExpectedLines);¬∂¬∂			}¬∂			return pass();¬∂			¬∂¬∂		} catch (NotRunnableException e) {¬∂			throw new NotGradableException();¬∂		}¬∂	}¬∂}¬∂")]]]></diff>
  </Command>
  <DocumentChange __id="157297" _type="Insert" date="Sun Dec 29 00:24:42 EST 2019" docASTNodeCount="367" docActiveCodeLength="2459" docExpressionCount="272" docLength="2553" length="1" offset="2154" starttimestamp="1576666505112" timestamp="930576926">
    <text><![CDATA[a]]></text>
  </DocumentChange>
  <DocumentChange __id="157299" _type="Insert" date="Sun Dec 29 00:24:42 EST 2019" docASTNodeCount="367" docActiveCodeLength="2460" docExpressionCount="272" docLength="2554" length="1" offset="2155" starttimestamp="1576666505112" timestamp="930577499">
    <text><![CDATA[F]]></text>
  </DocumentChange>
  <DocumentChange __id="157301" _type="Insert" date="Sun Dec 29 00:24:43 EST 2019" docASTNodeCount="367" docActiveCodeLength="2461" docExpressionCount="272" docLength="2555" length="1" offset="2156" starttimestamp="1576666505112" timestamp="930578018">
    <text><![CDATA[i]]></text>
  </DocumentChange>
  <DocumentChange __id="157303" _type="Insert" date="Sun Dec 29 00:24:43 EST 2019" docASTNodeCount="367" docActiveCodeLength="2462" docExpressionCount="272" docLength="2556" length="1" offset="2157" starttimestamp="1576666505112" timestamp="930578235">
    <text><![CDATA[l]]></text>
  </DocumentChange>
  <DocumentChange __id="157305" _type="Insert" date="Sun Dec 29 00:24:43 EST 2019" docASTNodeCount="367" docActiveCodeLength="2463" docExpressionCount="272" docLength="2557" length="1" offset="2158" starttimestamp="1576666505112" timestamp="930578307">
    <text><![CDATA[e]]></text>
  </DocumentChange>
  <DocumentChange __id="157307" _type="Insert" date="Sun Dec 29 00:24:43 EST 2019" docASTNodeCount="367" docActiveCodeLength="2464" docExpressionCount="272" docLength="2558" length="1" offset="2159" starttimestamp="1576666505112" timestamp="930578835">
    <text><![CDATA[N]]></text>
  </DocumentChange>
  <DocumentChange __id="157309" _type="Insert" date="Sun Dec 29 00:24:44 EST 2019" docASTNodeCount="367" docActiveCodeLength="2465" docExpressionCount="272" docLength="2559" length="1" offset="2160" starttimestamp="1576666505112" timestamp="930579031">
    <text><![CDATA[a]]></text>
  </DocumentChange>
  <DocumentChange __id="157311" _type="Insert" date="Sun Dec 29 00:24:44 EST 2019" docASTNodeCount="367" docActiveCodeLength="2466" docExpressionCount="272" docLength="2560" length="1" offset="2161" starttimestamp="1576666505112" timestamp="930579218">
    <text><![CDATA[m]]></text>
  </DocumentChange>
  <DocumentChange __id="157313" _type="Insert" date="Sun Dec 29 00:24:44 EST 2019" docASTNodeCount="367" docActiveCodeLength="2467" docExpressionCount="272" docLength="2561" length="1" offset="2162" starttimestamp="1576666505112" timestamp="930579376">
    <text><![CDATA[e]]></text>
  </DocumentChange>
  <DocumentChange __id="157315" _type="Insert" date="Sun Dec 29 00:24:45 EST 2019" docASTNodeCount="368" docActiveCodeLength="2468" docExpressionCount="273" docLength="2562" length="1" offset="2163" starttimestamp="1576666505112" timestamp="930579898">
    <text><![CDATA[,]]></text>
  </DocumentChange>
  <DocumentChange __id="157317" _type="Insert" date="Sun Dec 29 00:24:45 EST 2019" docASTNodeCount="368" docActiveCodeLength="2469" docExpressionCount="273" docLength="2563" length="1" offset="2164" starttimestamp="1576666505112" timestamp="930580192">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <Command __id="157328" _type="EclipseCommand" commandID="AUTOGEN:::org.eclipse.jdt.debug.CompilationUnitEditor.BreakpointRulerActions/org.eclipse.jdt.debug.ui.actions.ManageBreakpointRulerAction" date="Sun Dec 29 00:25:19 EST 2019" starttimestamp="1576666505112" timestamp="930614502" />
  <Command __id="157329" _type="BreakPointCommand" date="Sun Dec 29 00:25:19 EST 2019" lineNumber="47" starttimestamp="1576666505112" timestamp="930614506" type="BreakPointAdded" />
  <Command __id="177316" _type="DiffBasedFileOpenCommand" date="Mon Dec 30 00:18:11 EST 2019" docASTNodeCount="143" docActiveCodeLength="1149" docExpressionCount="84" docLength="1188" projectName="GraderBasics" starttimestamp="1576666505112" timestamp="1016586570">
    <filePath><![CDATA[D:\dewan_backup\Java\GraderBasics\src\gradingTools\shared\testcases\openmp\scannedTree\ARootOfFileSNode.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package gradingTools.shared.testcases.openmp.scannedTree;¬∂¬∂import java.util.ArrayList;¬∂import java.util.List;¬∂¬∂public class ARootOfFileSNode extends AnSNode implements RootOfFileSNode{¬∂	String fileName;¬∂	ExternalMethodSNode  omp_get_thread_num_SNode;¬∂	¬∂	ExternalMethodSNode omp_get_num_threads_SNode;¬∂	public ARootOfFileSNode(String aFileName) {¬∂		super(0);¬∂		fileName = aFileName;¬∂		omp_get_thread_num_SNode = new AnOMPPredefinedExternalMethodSNode("int", "omp_get_thread_num");¬∂		omp_get_num_threads_SNode = new AnOMPPredefinedExternalMethodSNode("int", "omp_get_num_threads");¬∂		¬∂		// TODO Auto-generated constructor stub¬∂	}¬∂	@Override¬∂	public ExternalMethodSNode getOmp_get_thread_num_SNode() {¬∂		return omp_get_thread_num_SNode;¬∂	}¬∂	@Override¬∂	public ExternalMethodSNode getOmp_get_num_threads_SNode() {¬∂		return omp_get_num_threads_SNode;¬∂	}¬∂	@Override¬∂	public String getFileName() {¬∂		return fileName;¬∂	}¬∂	public void setFileName(String fileName) {¬∂		this.fileName = fileName;¬∂	}¬∂	public void setParent(SNode aParent) {¬∂		super.setParent(aParent);¬∂		omp_get_thread_num_SNode.setParent(this);¬∂		omp_get_num_threads_SNode.setParent(this);¬∂	}¬∂}¬∂")]]]></diff>
  </Command>
  <DocumentChange __id="177321" _type="Insert" date="Mon Dec 30 00:18:59 EST 2019" docASTNodeCount="138" docActiveCodeLength="1106" docExpressionCount="80" docLength="1190" length="2" offset="1090" starttimestamp="1576666505112" timestamp="1016634512">
    <text><![CDATA[//]]></text>
  </DocumentChange>
  <DocumentChange __id="177322" _type="Insert" date="Mon Dec 30 00:18:59 EST 2019" docASTNodeCount="133" docActiveCodeLength="1062" docExpressionCount="76" docLength="1192" length="2" offset="1137" starttimestamp="1576666505112" timestamp="1016634513">
    <text><![CDATA[//]]></text>
  </DocumentChange>
  <DocumentChange __id="177325" _type="Insert" date="Mon Dec 30 00:19:07 EST 2019" docASTNodeCount="133" docActiveCodeLength="1066" docExpressionCount="76" docLength="1196" length="4" offset="593" starttimestamp="1576666505112" timestamp="1016642056">
    <text><![CDATA[
		]]></text>
  </DocumentChange>
  <DocumentChange __id="177327" _type="Replace" date="Mon Dec 30 00:19:08 EST 2019" docASTNodeCount="143" docActiveCodeLength="1153" docExpressionCount="84" docLength="1283" endLine="15" insertionLength="89" int_docASTNodeCount="133" int_docActiveCodeLength="1064" int_docExpressionCount="76" int_docLength="1194" length="2" offset="595" startLine="15" starttimestamp="1576666505112" timestamp="1016642992">
    <deletedText><![CDATA[		]]></deletedText>
    <insertedText><![CDATA[		omp_get_thread_num_SNode.setParent(this);
		omp_get_num_threads_SNode.setParent(this);]]></insertedText>
  </DocumentChange>
  <DocumentChange __id="177388" _type="Delete" date="Mon Dec 30 00:19:26 EST 2019" docASTNodeCount="143" docActiveCodeLength="1151" docExpressionCount="84" docLength="1281" endLine="8" length="2" offset="257" startLine="7" starttimestamp="1576666505112" timestamp="1016661612">
    <text><![CDATA[
]]></text>
  </DocumentChange>
  <Command __id="177390" _type="MoveCaretCommand" caretOffset="307" date="Mon Dec 30 00:19:28 EST 2019" docOffset="307" starttimestamp="1576666505112" timestamp="1016663510" />
  <Command __id="177392" _type="SelectTextCommand" caretOffset="471" date="Mon Dec 30 00:21:23 EST 2019" end="471" start="450" starttimestamp="1576666505112" timestamp="1016777991" />
  <Command __id="177391" _type="DiffBasedFileOpenCommand" date="Mon Dec 30 00:21:22 EST 2019" docASTNodeCount="1" docActiveCodeLength="795" docExpressionCount="0" docLength="795" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="1016777665">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\my_sum_parallel.cpp]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"#include <iostream>¬∂#include <omp.h>¬∂¬∂using namespace std;¬∂¬∂void printSumWithTimes(int sum, int start, int end);¬∂void printNumThreads();¬∂void recordThreadIndex(int index);¬∂void sum_parallel(double* array, int size) {¬∂	cout << "sum_parallel\n";¬∂¬∂	double start = omp_get_wtime();¬∂¬∂	double sum = 0;¬∂¬∂¬∂    #pragma omp critical¬∂	{¬∂	double sum = 0;¬∂	}¬∂    #pragma omp parallel¬∂	{¬∂		double local_sum = 0;¬∂¬∂		int rank = omp_get_thread_num();¬∂		int threads = omp_get_num_threads();¬∂¬∂		int start_index = (size/threads)*rank;¬∂		int end_index = (size/threads)*(rank+1);¬∂¬∂		if(rank==threads-1)¬∂			end_index=size;¬∂¬∂		for(int i = start_index; i < end_index; i++)¬∂			local_sum += array[i];¬∂¬∂		#pragma omp critical¬∂		sum += local_sum;¬∂	}¬∂¬∂	double end = omp_get_wtime();¬∂¬∂	printSumWithTimes(sum, start, end);¬∂¬∂¬∂}¬∂")]]]></diff>
  </Command>
  <Command __id="177394" _type="ShellCommand" date="Mon Dec 30 00:21:36 EST 2019" starttimestamp="1576666505112" timestamp="1016791186" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="177395" _type="EclipseCommand" commandID="org.eclipse.ui.edit.delete" date="Mon Dec 30 00:21:36 EST 2019" starttimestamp="1576666505112" timestamp="1016791219" />
  <Command __id="177397" _type="MoveCaretCommand" caretOffset="312" date="Mon Dec 30 00:21:46 EST 2019" docOffset="312" starttimestamp="1576666505112" timestamp="1016801057" />
  <DocumentChange __id="177408" _type="Replace" date="Mon Dec 30 00:22:13 EST 2019" docASTNodeCount="143" docActiveCodeLength="1154" docExpressionCount="84" docLength="1284" endLine="10" insertionLength="1" int_docASTNodeCount="143" int_docActiveCodeLength="1153" int_docExpressionCount="84" int_docLength="1283" length="87" offset="309" startLine="9" starttimestamp="1576666505112" timestamp="1016828397">
    <deletedText><![CDATA[	omp_get_thread_num_SNode.setParent(this);
	omp_get_num_threads_SNode.setParent(this);]]></deletedText>
    <insertedText><![CDATA[	]]></insertedText>
  </DocumentChange>
  <Command __id="177409" _type="UndoCommand" date="Mon Dec 30 00:22:13 EST 2019" starttimestamp="1576666505112" timestamp="1016828423" />
  <Command __id="177411" _type="SelectTextCommand" caretOffset="280" date="Mon Dec 30 00:22:18 EST 2019" end="280" start="265" starttimestamp="1576666505112" timestamp="1016833201" />
  <DocumentChange __id="177609" _type="Insert" date="Mon Dec 30 00:23:51 EST 2019" docASTNodeCount="142" docActiveCodeLength="1127" docExpressionCount="78" docLength="1127" length="1" offset="287" starttimestamp="1576666505112" timestamp="1016926849">
    <text><![CDATA[N]]></text>
  </DocumentChange>
  <DocumentChange __id="177611" _type="Insert" date="Mon Dec 30 00:23:52 EST 2019" docASTNodeCount="142" docActiveCodeLength="1128" docExpressionCount="78" docLength="1128" length="1" offset="288" starttimestamp="1576666505112" timestamp="1016927124">
    <text><![CDATA[o]]></text>
  </DocumentChange>
  <DocumentChange __id="177613" _type="Insert" date="Mon Dec 30 00:23:52 EST 2019" docASTNodeCount="142" docActiveCodeLength="1129" docExpressionCount="78" docLength="1129" length="1" offset="289" starttimestamp="1576666505112" timestamp="1016927242">
    <text><![CDATA[d]]></text>
  </DocumentChange>
  <DocumentChange __id="177615" _type="Insert" date="Mon Dec 30 00:23:52 EST 2019" docASTNodeCount="142" docActiveCodeLength="1130" docExpressionCount="78" docLength="1130" length="1" offset="290" starttimestamp="1576666505112" timestamp="1016927390">
    <text><![CDATA[e]]></text>
  </DocumentChange>
  <DocumentChange __id="177617" _type="Insert" date="Mon Dec 30 00:23:52 EST 2019" docASTNodeCount="144" docActiveCodeLength="1131" docExpressionCount="79" docLength="1131" length="1" offset="291" starttimestamp="1576666505112" timestamp="1016927622">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="177621" _type="Delete" date="Mon Dec 30 00:23:56 EST 2019" docASTNodeCount="118" docActiveCodeLength="1130" docExpressionCount="67" docLength="1130" endLine="9" length="1" offset="316" startLine="9" starttimestamp="1576666505112" timestamp="1016931085">
    <text><![CDATA[;]]></text>
  </DocumentChange>
  <DocumentChange __id="177623" _type="Delete" date="Mon Dec 30 00:23:56 EST 2019" docASTNodeCount="127" docActiveCodeLength="1129" docExpressionCount="71" docLength="1129" endLine="9" length="1" offset="315" startLine="9" starttimestamp="1576666505112" timestamp="1016931252">
    <text><![CDATA[)]]></text>
  </DocumentChange>
  <DocumentChange __id="177625" _type="Delete" date="Mon Dec 30 00:23:57 EST 2019" docASTNodeCount="145" docActiveCodeLength="1128" docExpressionCount="79" docLength="1128" endLine="9" length="1" offset="314" startLine="9" starttimestamp="1576666505112" timestamp="1016931907">
    <text><![CDATA[(]]></text>
  </DocumentChange>
  <DocumentChange __id="177627" _type="Insert" date="Mon Dec 30 00:23:57 EST 2019" docASTNodeCount="145" docActiveCodeLength="1129" docExpressionCount="79" docLength="1129" length="1" offset="314" starttimestamp="1576666505112" timestamp="1016932622">
    <text><![CDATA[;]]></text>
  </DocumentChange>
  <Command __id="177629" _type="EclipseCommand" commandID="" date="Mon Dec 30 00:24:11 EST 2019" starttimestamp="1576666505112" timestamp="1016945986" />
  <Command __id="177630" _type="EclipseCommand" commandID="" date="Mon Dec 30 00:24:11 EST 2019" starttimestamp="1576666505112" timestamp="1016946658" />
  <Command __id="182041" _type="DiffBasedFileOpenCommand" date="Mon Dec 30 08:23:59 EST 2019" docASTNodeCount="3827" docActiveCodeLength="27193" docExpressionCount="2434" docLength="31379" projectName="GraderBasics" starttimestamp="1576666505112" timestamp="1045734660">
    <filePath><![CDATA[D:\dewan_backup\Java\GraderBasics\src\gradingTools\shared\testcases\openmp\scannedTree\OMPSNodeUtils.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package gradingTools.shared.testcases.openmp.scannedTree;¬∂¬∂import java.util.ArrayList;¬∂import java.util.Arrays;¬∂import java.util.HashMap;¬∂import java.util.List;¬∂import java.util.Map;¬∂import java.util.Stack;¬∂import java.util.regex.Matcher;¬∂import java.util.regex.Pattern;¬∂¬∂import org.apache.commons.lang.StringUtils;¬∂¬∂import grader.basics.project.source.ABasicTextManager;¬∂import gradingTools.shared.testcases.openmp.OpenMPKeywordEnum;¬∂import gradingTools.shared.testcases.openmp.OpenMPParallelPragma;¬∂import gradingTools.shared.testcases.openmp.OpenMPUtils;¬∂import gradingTools.shared.testcases.openmp.scannedTree.ADeclarationSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.ADeclaringAssignmentSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.AForSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.ATextSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.AnAssignmentSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.AnOMPCriticalSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.AnOMPForSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.AnOMPParallelSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.AnOMPSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.AnSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.AssignmentSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.DeclarationSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.DeclaringAssignmentSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.ForSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.OMPForSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.OMPSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.SNode;¬∂¬∂public class OMPSNodeUtils extends OpenMPUtils {¬∂¬∂	public static RootOfFileSNode getSNode(String aFileName, StringBuffer aFileBuffer) {¬∂		String[] aFileLines = aFileBuffer.toString().split("\n");¬∂		return getSNode(aFileName, aFileLines);¬∂	}¬∂¬∂	public static AssignmentSNode getAssignmentSNode(int aLineNumber, String aString) {¬∂		if (aString == null) {¬∂			return null;¬∂		}¬∂		String[] aTokens = aString.split("=");¬∂		if (aTokens.length == 1) {¬∂			return new AnAssignmentSNode(aLineNumber, aTokens[0], null);¬∂		} else {¬∂		return new AnAssignmentSNode(aLineNumber, aTokens[0], aTokens[1]);¬∂		}¬∂	}¬∂¬∂	public static DeclarationSNode getDeclarationSNode(int aLineNumber, String aString) {¬∂		String[] aTokens = aString.split(" ");¬∂		return new ADeclarationSNode(aLineNumber, aTokens[0], aTokens[1]);¬∂	}¬∂¬∂	public static DeclaringAssignmentSNode getDeclaringAssignmentSNode(int aLineNumber, String aString) {¬∂		String[] anLHSAndRHS = aString.split("=");¬∂		String[] aTypeAndVariable = anLHSAndRHS[0].split(" ");¬∂		return new ADeclaringAssignmentSNode(aLineNumber, aTypeAndVariable[0], aTypeAndVariable[1], anLHSAndRHS[1]);¬∂	}¬∂¬∂	public static boolean isDeclaringAssignment(String aFileLine) {¬∂		return startsWithTypeName(aFileLine) && aFileLine.contains("=");¬∂	}¬∂	public static boolean isMethodDeclaration(String aFileLine) {¬∂		return startsWithTypeName(aFileLine) && ¬∂				aFileLine.contains("(") &&¬∂				!aFileLine.contains("=");¬∂	}¬∂	public static boolean isExternalMethodDeclaration(String aFileLine) {¬∂		return isMethodDeclaration(aFileLine) && aFileLine.endsWith(";");¬∂	}¬∂¬∂¬∂	public static boolean isVariableDeclaration(String aFileLine) {¬∂¬∂		return startsWithTypeName(aFileLine) && !aFileLine.contains("(");¬∂	}¬∂¬∂	public static boolean isAssignment(String aFileLine) {¬∂		return aFileLine.contains("=");¬∂	}¬∂¬∂	public static boolean isForNode(String aFileLine) {¬∂		return aFileLine.startsWith("for");¬∂	}¬∂¬∂	public static ForSNode getForSNode(int aLineNumber, String aFileLine) {¬∂¬∂		int aLeftParenIndex = aFileLine.indexOf("(");¬∂		int aRightParenIndex = aFileLine.indexOf(")");¬∂		if (aLeftParenIndex < 0 || aRightParenIndex < 0) {¬∂			return null;¬∂		}¬∂		String aHeaderString = aFileLine.substring(aLeftParenIndex + 1, aRightParenIndex);¬∂		String[] aForComponents = aHeaderString.split(";");¬∂		AssignmentSNode anAssignmentSNode = null;¬∂		String aForInitializaton = aForComponents[0];¬∂		if (!aForInitializaton.isEmpty() && aForInitializaton.contains("=")) {¬∂			if (isDeclaringAssignment(aForInitializaton)) {¬∂				anAssignmentSNode = getDeclaringAssignmentSNode(aLineNumber, aForInitializaton);¬∂			} else {¬∂				anAssignmentSNode = getAssignmentSNode(aLineNumber, aForInitializaton);¬∂			}¬∂¬∂		}		¬∂		return new AForSNode(aLineNumber, anAssignmentSNode, aForComponents[1], getAssignmentSNode(aLineNumber, aForComponents[2]));¬∂	}¬∂	static String[] emptyArray = {};¬∂	public static MethodSNode getMethodSNode(int aLineNumber, String aFileLine, boolean isInternal) {¬∂¬∂		int aLeftParenIndex = aFileLine.indexOf("(");¬∂		int aRightParenIndex = aFileLine.indexOf(")");¬∂		if (aLeftParenIndex < 0 || aRightParenIndex < 0) {¬∂			return null;¬∂		}¬∂		String aMethodNameAndType = aFileLine.substring(0, aLeftParenIndex);¬∂		String[] aMethodNameAndTypeTokens = aMethodNameAndType.split("\\s+"); ¬∂		¬∂		String aMethodParameters = aFileLine.substring(aLeftParenIndex +1 , aRightParenIndex);¬∂		String[] aMethodParameterTokens = aMethodParameters.isEmpty()?emptyArray:¬∂		 aMethodParameters.split(",");¬∂		¬∂//		String[] aMethodParameterTypes = new String[aMethodParameterTokens.length];¬∂//		String[] aMethodParameterNames = new String[aMethodParameterTokens.length];¬∂		List<DeclarationSNode> aDeclarationSNodeList = new ArrayList();¬∂		for (int i = 0; i < aMethodParameterTokens.length; i++ ) {¬∂			String[] aTypeAndName = aMethodParameterTokens[i].trim().split("\\s+");¬∂			if (aTypeAndName.length < 2) {¬∂				continue;¬∂			}¬∂			aDeclarationSNodeList.add(new ADeclarationSNode(aLineNumber, aTypeAndName[0].trim(), aTypeAndName[1].trim()));¬∂//			aMethodParameterTypes[i] = aTypeAndName[0].trim();¬∂//			aMethodParameterNames[i] = aTypeAndName[1].trim();¬∂		}¬∂		if (isInternal)¬∂//		return new AMethodSNode(aLineNumber, aMethodNameAndTypeTokens[0], aMethodNameAndTypeTokens[1], aMethodParameterTypes,aMethodParameterNames );¬∂			return new AMethodSNode(aLineNumber, aMethodNameAndTypeTokens[0], aMethodNameAndTypeTokens[1], aDeclarationSNodeList );¬∂		else¬∂			return new AnExternalMethodSNode(aLineNumber, aMethodNameAndTypeTokens[0], aMethodNameAndTypeTokens[1], aDeclarationSNodeList );¬∂	}¬∂¬∂	public static void setReductionData(OMPForSNode lastChild, String aStoredToken, int aLeftParenIndex,¬∂			int aRightParenIndex) {¬∂		int aColonIndex = aStoredToken.indexOf(":");¬∂		if (aLeftParenIndex != -1 && aRightParenIndex != -1 && aColonIndex != -1) {¬∂			String anOperationString = aStoredToken.substring(aLeftParenIndex + 1, aColonIndex).trim();¬∂			String aVariableString = aStoredToken.substring(aColonIndex + 1, aRightParenIndex).trim();¬∂			((OMPForSNode) lastChild).setReductionVariable(aVariableString);¬∂			((OMPForSNode) lastChild).setReductionOperation(anOperationString);¬∂		}¬∂	}¬∂¬∂	public static void setSharedOrPrivateData(OMPSNode lastChild, String aStoredToken, int aLeftParenIndex,¬∂			int aRightParenIndex, boolean isShared) {¬∂//		int aColonIndex = aStoredToken.indexOf(":");¬∂		if (aLeftParenIndex != -1 && aRightParenIndex != -1) {¬∂			String aVariableDeclarations = aStoredToken.substring(aLeftParenIndex + 1, aRightParenIndex);¬∂			String[] aVariables = aVariableDeclarations.split(",");¬∂			if (isShared) {¬∂				lastChild.setSharedVariables(aVariables);¬∂			} else {¬∂				lastChild.setPrivateVariables(aVariables);¬∂			}¬∂		}¬∂	}¬∂¬∂	public static RootOfFileSNode getSNode(String aFileName, String[] aFileLines) {¬∂		Stack<SNode> anSNodes = new Stack();¬∂¬∂		RootOfFileSNode retVal = new ARootOfFileSNode(aFileName);¬∂		anSNodes.add(retVal);¬∂		SNode previousHeaderNode = null;¬∂		for (int i = 0; i < aFileLines.length; i++) {¬∂			String aFileLine = aFileLines[i].trim();¬∂			if (!isCodeLine(aFileLine)) {¬∂				continue;¬∂			}¬∂			if (isForNode(aFileLine)) {¬∂				ForSNode aForSNode = getForSNode(i, aFileLine);¬∂				aForSNode.setParent(anSNodes.peek());¬∂//				anSNodes.push(aForSNode);¬∂				previousHeaderNode = aForSNode;¬∂				if (aFileLine.endsWith(")")) {¬∂					continue;¬∂				}¬∂			}¬∂			if (isExternalMethodDeclaration(aFileLine)) {¬∂				MethodSNode aMethodSNode = getMethodSNode(i, aFileLine, false);¬∂				aMethodSNode.setParent(anSNodes.peek());¬∂//				anSNodes.push(aForSNode);¬∂				previousHeaderNode = aMethodSNode;¬∂				if (aFileLine.endsWith(")")) {¬∂					continue;¬∂				}¬∂			}¬∂			if (isMethodDeclaration(aFileLine)) {¬∂				MethodSNode aMethodSNode = getMethodSNode(i, aFileLine, true);¬∂				aMethodSNode.setParent(anSNodes.peek());¬∂//				anSNodes.push(aForSNode);¬∂				previousHeaderNode = aMethodSNode;¬∂				if (aFileLine.endsWith(")")) {¬∂					continue;¬∂				}¬∂			}¬∂			if (isPragmaStart(aFileLine)) {¬∂				OMPSNode anOMPSNode = getOMPSNode(i, anSNodes.peek(), aFileLine);¬∂//				anSNodes.push(anOMPSNode);¬∂				previousHeaderNode = anOMPSNode;¬∂				continue;¬∂			}¬∂			if (isBlockStart(aFileLine)) {¬∂				SNode aBlockSNode = new AnSNode(i);¬∂				if (previousHeaderNode != null) {¬∂					aBlockSNode.setParent(previousHeaderNode);¬∂				} else {¬∂					aBlockSNode.setParent(anSNodes.peek());¬∂				}¬∂				anSNodes.push(aBlockSNode);¬∂				previousHeaderNode = null;¬∂				continue;¬∂			}¬∂//			} else ¬∂			if (isBlockEnd(aFileLine)) {¬∂				anSNodes.pop();¬∂				continue;¬∂			}¬∂			SNode aNewLeafNode = null;¬∂			if (isDeclaringAssignment(aFileLine)) {¬∂				aNewLeafNode = getDeclaringAssignmentSNode(i, aFileLine);¬∂¬∂			} else if (isAssignment(aFileLine)) {¬∂				aNewLeafNode = getAssignmentSNode(i, aFileLine);¬∂			} else if (isVariableDeclaration(aFileLine)) {¬∂				aNewLeafNode = getDeclarationSNode(i, aFileLine);¬∂			} else {¬∂				List<MethodCall> aCalls = callsIn(i, aFileLine, null); // parent will be assigned below¬∂				if (aCalls != null && aCalls.size() == 1) {¬∂					aNewLeafNode = aCalls.get(0);¬∂				} else {¬∂					aNewLeafNode = new ATextSNode(i, aFileLine);¬∂				}¬∂			}¬∂//			else {¬∂//				aNewLeafNode = new ATextSNode(i, aFileLine);¬∂//			}¬∂			if (previousHeaderNode != null) {¬∂				aNewLeafNode.setParent(previousHeaderNode);¬∂			} else {¬∂				aNewLeafNode.setParent(anSNodes.peek());¬∂			}¬∂¬∂		}¬∂¬∂		return retVal;¬∂	}¬∂¬∂	public static OMPSNode getOMPSNode(int aLineIndex, SNode aParentNode, String aFileLine) {¬∂		String[] aTokens = aFileLine.split("\\s+");¬∂		if (aTokens.length <= 2) {¬∂			return null;¬∂		}¬∂		if (!aTokens[1].equals("omp")) {¬∂			return null;¬∂		}¬∂		if (aTokens.length < 3) {¬∂			return null;¬∂		}¬∂		String aFirstToken = aTokens[2];¬∂		OpenMPKeywordEnum anOpenMPKeyword = stringToOpenMPKeyword.get(aFirstToken);¬∂//		List<OpenMPPragma> retVal = new ArrayList();¬∂		OMPSNode lastChild = null;¬∂		int aStartIndex = 2;¬∂		OMPSNode aNewNode = null;¬∂		OMPForSNode aForChild = null;¬∂		switch (anOpenMPKeyword) {¬∂		case PARALLEL:¬∂			aNewNode = new AnOMPParallelSNode(aLineIndex);¬∂¬∂			if (aTokens.length > 3 && aTokens[3].equals("for")) {¬∂				aForChild = new AnOMPForSNode(aLineIndex);¬∂				aForChild.setParent(aNewNode);¬∂¬∂				aStartIndex++;¬∂			}¬∂			break;¬∂		case FOR:¬∂			aNewNode = new AnOMPForSNode(aLineIndex);¬∂			;¬∂			break;¬∂		case CRITICAL:¬∂			aNewNode = new AnOMPCriticalSNode(aLineIndex);¬∂//			retVal.add (lastChild);¬∂			break;¬∂		default:¬∂			aNewNode = new AnOMPSNode(aLineIndex);¬∂¬∂		}¬∂¬∂		if (lastChild != null) {¬∂			aNewNode.setParent(lastChild);¬∂		} else {¬∂			aNewNode.setParent(aParentNode);¬∂		}¬∂		lastChild = aForChild == null ? aNewNode : aForChild;¬∂¬∂		for (int i = aStartIndex; i < aTokens.length; i++) {¬∂			String aStoredToken = aTokens[i].trim();¬∂			if (aStoredToken.isEmpty()) {¬∂				continue;¬∂			}¬∂			if (aStoredToken.startsWith("reduction") || aStoredToken.startsWith("shared")¬∂					|| aStoredToken.startsWith("private")) {¬∂				// combine all tokens until ")" into one for normalization¬∂				while (!aStoredToken.endsWith(")")) {¬∂					i++;¬∂					if (i >= aTokens.length) {¬∂						break;¬∂					}¬∂					String aNewToken = aTokens[i].trim();¬∂					aStoredToken += aNewToken;¬∂				}¬∂				int aLeftParenIndex = aStoredToken.indexOf("(");¬∂				int aRightParenIndex = aStoredToken.indexOf(")");¬∂				if (aStoredToken.startsWith("reduction")) {¬∂					setReductionData((OMPForSNode) lastChild, aStoredToken, aLeftParenIndex, aRightParenIndex);¬∂				} else if (aStoredToken.startsWith("private")) {¬∂					setSharedOrPrivateData((OMPSNode) lastChild, aStoredToken, aLeftParenIndex, aRightParenIndex,¬∂							false);¬∂¬∂				} else if (aStoredToken.startsWith("shared")) {¬∂					setSharedOrPrivateData(lastChild, aStoredToken, aLeftParenIndex, aRightParenIndex, true);¬∂¬∂				}¬∂¬∂			}¬∂¬∂			lastChild.getOpenMPTokens().add(aStoredToken);¬∂		}¬∂¬∂		return lastChild;¬∂¬∂	}¬∂¬∂	public static boolean hasParallelAncestor(SNode anSNode) {¬∂		if (anSNode == null) {¬∂			return false;¬∂		}¬∂		if (anSNode instanceof OMPParallelSNode) {¬∂			return true;¬∂		}¬∂		return hasParallelAncestor(anSNode.getParent());¬∂	}¬∂¬∂	public static Boolean isDeclaredShared(OMPSNode anOMPSNode, String anLHS) {¬∂		if (Arrays.asList(anOMPSNode.getSharedVariables()).contains(anLHS)) {¬∂			return true;¬∂		}¬∂		if (Arrays.asList(anOMPSNode.getPrivateVariables()).contains(anLHS)) {¬∂			return false;¬∂		}¬∂		return null;¬∂¬∂	}¬∂¬∂	public static boolean isSharedVariable(SNode anSNode, String anLHS) {¬∂		if (anSNode == null) {¬∂			return false;¬∂		}¬∂		if (anSNode.getLocalVariables().contains(anLHS)) {¬∂			if (!(anSNode instanceof OMPSNode)) { // no shared and private declarations¬∂				return !hasParallelAncestor(anSNode); // shared if not inParallel¬∂			}¬∂			OMPSNode anOMPSNode = (OMPSNode) anSNode;¬∂			return (Arrays.asList(anOMPSNode.getSharedVariables()).contains(anLHS)); // private unless declared shared¬∂		}¬∂		if (anSNode instanceof OMPSNode) {¬∂			OMPSNode anOMPSNode = (OMPSNode) anSNode;¬∂			// the variable is global to this scope, check if it has have been made shared¬∂			// or private by this scope¬∂			Boolean isDeclaredShared = isDeclaredShared(anOMPSNode, anLHS);¬∂			if (isDeclaredShared != null) {¬∂				return isDeclaredShared;¬∂			}¬∂		}¬∂		// check the parent¬∂		return isSharedVariable(anSNode.getParent(), anLHS);¬∂	}¬∂¬∂	public static List<SNode> getAllLeafNodes(SNode aTopNode) {¬∂		List<SNode> retVal = new ArrayList();¬∂		addLeafNodes(aTopNode, retVal);¬∂		return retVal;¬∂	}¬∂¬∂	public static void addLeafNodes(SNode aTopNode, List<SNode> retVal) {¬∂		for (SNode aChild : aTopNode.getChildren()) {¬∂			if (aChild.isLeaf()) {¬∂				retVal.add(aChild);¬∂			} else {¬∂				addLeafNodes(aChild, retVal);¬∂			}¬∂		}¬∂	}¬∂¬∂	public static List<SNode> getNonParallelLeafNodes(SNode aTopNode) {¬∂		List<SNode> retVal = new ArrayList();¬∂		addNonParallelLeafNodes(aTopNode, retVal);¬∂		return retVal;¬∂	}¬∂¬∂	public static void addNonParallelLeafNodes(SNode aTopNode, List<SNode> retVal) {¬∂		if (aTopNode.isInParallel()) {¬∂			return;¬∂		}¬∂		for (SNode aChild : aTopNode.getChildren()) {¬∂			if (aChild.isLeaf()) {¬∂				retVal.add(aChild);¬∂			} else {¬∂				addLeafNodes(aChild, retVal);¬∂			}¬∂		}¬∂	}¬∂	static String callRegex = "([a-zA-Z_$][a-zA-Z_$0-9]*)\\(.*?\\)";¬∂	static Pattern callPattern = Pattern.compile(callRegex);¬∂¬∂	static String identifierRegex = "[a-zA-Z_$][a-zA-Z_$0-9]*";¬∂	static Pattern identifierPattern = Pattern.compile(identifierRegex);¬∂	public static List<String> identifiersIn(String aString) {¬∂		if (aString == null)¬∂			return null;¬∂//		Pattern mypattern = Pattern.compile("[a-zA-Z_$][a-zA-Z_$0-9]*");¬∂//		Matcher mymatcher = mypattern.matcher(aString);¬∂		Matcher mymatcher = identifierPattern.matcher(aString);¬∂		List<String> retVal = new ArrayList();¬∂		while (mymatcher.find()) {¬∂			String find = mymatcher.group(0);¬∂			retVal.add(find);¬∂		}¬∂		return retVal;¬∂	}¬∂	public static List<MethodCall> callsIn(int aLineNumber, String aString, SNode aParent) {¬∂		if (aString == null)¬∂			return null;¬∂//		Pattern mypattern = Pattern.compile("[a-zA-Z_$][a-zA-Z_$0-9]*");¬∂//		Matcher mymatcher = mypattern.matcher(aString);¬∂		Matcher mymatcher = callPattern.matcher(aString);¬∂		List<MethodCall> retVal = new ArrayList();¬∂		while (mymatcher.find()) {¬∂			String find = mymatcher.group(0);¬∂			int aLeftParenIndex = find.indexOf("(");¬∂			int aRightParenIndex = find.indexOf(")");¬∂			String aMethodName = find.substring(0, aLeftParenIndex).trim();¬∂			String aParameters = find.substring(aLeftParenIndex + 1, aRightParenIndex);¬∂			List<String> aParameterList = new ArrayList();¬∂			String[] aParameterTokens = aParameters.split(",");¬∂			for (String aParameter:aParameterTokens) {¬∂				String aParameterTrimmed = aParameter.trim();¬∂				if (!aParameterTrimmed.isEmpty())¬∂				aParameterList.add(aParameterTrimmed);¬∂			}¬∂			retVal.add(new AMethodCall(aLineNumber, aMethodName, aParameterList, aParent));¬∂¬∂//			aCallStrings.add(find);¬∂		}¬∂		return retVal;¬∂	}¬∂	static String numberRegex = "(\\d+\\.\\d+)|(\\d+)";¬∂	static Pattern numberPattern = Pattern.compile(numberRegex);¬∂	public static List<String> numbersIn(String aString) {¬∂		if (aString == null)¬∂			return null;¬∂//		String regex = "(\\d+\\.\\d+)|(\\d+)";¬∂//¬∂//		Matcher m = Pattern.compile(regex).matcher(aString);¬∂		Matcher m =numberPattern.matcher(aString);¬∂¬∂¬∂		List<String> retVal = new ArrayList();¬∂¬∂		while (m.find()) {¬∂			retVal.add(m.group());¬∂		}¬∂		return retVal;¬∂	}¬∂¬∂	public static String subscriptIn(String aString) {¬∂		if (aString == null)¬∂			return null;¬∂		return StringUtils.substringBetween(aString, "[", "]");¬∂	}¬∂	public static String[] subscriptsIn(String aString) {¬∂		if (aString == null)¬∂			return null;¬∂		return StringUtils.substringsBetween(aString, "[", "]");¬∂	}¬∂	static  String operatorRegex = "([+-/*///^])|([/(/)])";¬∂	static Pattern operatorPattern = Pattern.compile(operatorRegex);¬∂¬∂	public static List<String> operatorsIn(String aString) {¬∂		if (aString == null)¬∂			return null;¬∂//		String operatorRegex = "([+-/*///^])|([/(/)])";¬∂//¬∂//		Matcher m = Pattern.compile(operatorRegex).matcher(aString);¬∂		¬∂		Matcher m = operatorPattern.matcher(aString);¬∂¬∂¬∂		List<String> retVal = new ArrayList();¬∂¬∂		while (m.find()) {¬∂			retVal.add(m.group());¬∂		}¬∂		return retVal;¬∂	}¬∂	¬∂	public static int numberOfNestingFors (SNode anSNode) {¬∂		if (anSNode == null) {¬∂			return 0;¬∂		}¬∂		int retVal = numberOfNestingFors (anSNode.getParent()) ;¬∂¬∂		if (anSNode instanceof ForSNode) {¬∂			retVal++;¬∂		} else if (anSNode instanceof MethodSNode) {¬∂			List<MethodCall> aMethodCalls = ((MethodSNode) anSNode).getCalls();¬∂			int aMaxNestingLevel = 0;¬∂			for (MethodCall aMethodCall:aMethodCalls) {¬∂				MethodSNode aCallerMethodSNode = getDeclarationOfCalledMethod(anSNode, aMethodCall);¬∂				int aCallerNumberOfNestingFors = numberOfNestingFors(aCallerMethodSNode);¬∂				aMaxNestingLevel = Math.max(aCallerNumberOfNestingFors, aMaxNestingLevel);				¬∂			}¬∂			return retVal + aMaxNestingLevel;¬∂		}¬∂		return retVal;¬∂	}¬∂	public static boolean hasOperator (SNode anSNode, String anOperator) {¬∂		boolean retVal = false;¬∂		if (anSNode instanceof AssignmentSNode) {¬∂			AssignmentSNode anAssignmentSNode = (AssignmentSNode) anSNode;¬∂			 retVal = (anAssignmentSNode.getLhsOperators().contains(anOperator) || ¬∂					anAssignmentSNode.getRhsOperators().contains(anOperator)) ;¬∂			if (retVal) {¬∂				return retVal;¬∂			} else {¬∂				List<MethodCall> aMethodCalls = anAssignmentSNode.getRhsCalls();¬∂				for (MethodCall aMethodCall:aMethodCalls) {¬∂					MethodSNode aMethodSNode = getDeclarationOfCalledMethod(anSNode, aMethodCall);¬∂					retVal = hasOperator(aMethodSNode, anOperator);¬∂					if (retVal) {¬∂						return retVal;¬∂					}¬∂					¬∂				}¬∂				return false;¬∂			}¬∂			¬∂		}¬∂		for (SNode aChild:anSNode.getChildren()) {¬∂			retVal = hasOperator(aChild, anOperator);¬∂			if (retVal) {¬∂				return retVal;¬∂			}¬∂		}¬∂		return false;¬∂	}¬∂	public static boolean hasMethodCall (SNode anSNode, String anOperator) {¬∂		boolean retVal = false;¬∂		if (anSNode instanceof AssignmentSNode) {¬∂			AssignmentSNode anAssignmentSNode = (AssignmentSNode) anSNode;¬∂			 retVal = (anAssignmentSNode.getLhsOperators().contains(anOperator) || ¬∂					anAssignmentSNode.getRhsOperators().contains(anOperator)) ;¬∂			if (retVal) {¬∂				return retVal;¬∂			} else {¬∂				List<MethodCall> aMethodCalls = anAssignmentSNode.getRhsCalls();¬∂				for (MethodCall aMethodCall:aMethodCalls) {¬∂					MethodSNode aMethodSNode = getDeclarationOfCalledMethod(anSNode, aMethodCall);¬∂					retVal = hasOperator(aMethodSNode, anOperator);¬∂					if (retVal) {¬∂						return retVal;¬∂					}¬∂					¬∂				}¬∂				return false;¬∂			}¬∂			¬∂		}¬∂		for (SNode aChild:anSNode.getChildren()) {¬∂			retVal = hasOperator(aChild, anOperator);¬∂			if (retVal) {¬∂				return retVal;¬∂			}¬∂		}¬∂		return false;¬∂	}¬∂	public static boolean dependsOn (AssignmentSNode anAssignmentSNode, String aVariable, String aCallIdentifier) {¬∂		// This assignment does not change aVariable¬∂		if (!aVariable.equals(anAssignmentSNode.getLhsVariable())) {¬∂			return false;¬∂		}¬∂		return dependsOn(anAssignmentSNode.getExpressionSNode(), aCallIdentifier);¬∂//		List<String> aCallIdentifiers = anAssignmentSNode.getRhsCallIdentifiers();¬∂//		boolean retVal = false;¬∂//		if (aCallIdentifiers != null && aCallIdentifiers.contains(aCallIdentifier)) {¬∂//			return true; // this assignment has aCallIdentifier in the rhs¬∂//		}¬∂//		// check if some referenced rhs variable depends on aCallIdentifier¬∂//		List<String> aReferencedVariableIdentifiers = anAssignmentSNode.getRhsVariableIdentifiers();¬∂//		SNode anAssignmentParent = anAssignmentSNode.getParent();¬∂//		if (anAssignmentParent == null) { // should never be trye¬∂//			return false;¬∂//		}¬∂//		int aLineNumber = anAssignmentSNode.getLineNumber();¬∂//		for (String aReferencedVariableIdentifier:aReferencedVariableIdentifiers ) {¬∂//			if (dependsOn (anAssignmentParent, aLineNumber, aReferencedVariableIdentifier, aCallIdentifier)) {¬∂//				return true;¬∂//			}¬∂//		}¬∂//		return false;¬∂	}¬∂	public static boolean dependsOn (ExpressionSNode anExpressionSNode, String aCallIdentifier) {¬∂		// This assignment does not change aVariable¬∂		¬∂		List<String> aCallIdentifiers = anExpressionSNode.getRhsCallIdentifiers();¬∂		boolean retVal = false;¬∂		if (aCallIdentifiers != null && aCallIdentifiers.contains(aCallIdentifier)) {¬∂			return true; // this assignment has aCallIdentifier in the rhs¬∂		}¬∂		// check if some referenced rhs variable depends on aCallIdentifier¬∂		List<String> aReferencedVariableIdentifiers = anExpressionSNode.getRhsVariableIdentifiers();¬∂		SNode anAssignmentParent = anExpressionSNode.getParent().getParent();¬∂		if (anAssignmentParent == null) { // should never be trye¬∂			return false;¬∂		}¬∂		int aLineNumber = anExpressionSNode.getLineNumber();¬∂		for (String aReferencedVariableIdentifier:aReferencedVariableIdentifiers ) {¬∂			if (dependsOn (anAssignmentParent, aLineNumber, aReferencedVariableIdentifier, aCallIdentifier)) {¬∂				return true;¬∂			}¬∂		}¬∂		return false;¬∂	}¬∂	public static List<AssignmentSNode> assignmentsToShared(SNode anSNode) {¬∂		List<AssignmentSNode> retVal =  new ArrayList();¬∂		fillAssignmentsToShared(anSNode, retVal);¬∂		return retVal;¬∂		¬∂	}¬∂    public static void fillAssignmentsToShared(SNode anSNode, List<AssignmentSNode> retVal) {¬∂    	if (anSNode instanceof AssignmentSNode) {¬∂			AssignmentSNode anAssignmentSNode = (AssignmentSNode) anSNode;¬∂			String anLHS = anAssignmentSNode.getLhsVariable();¬∂			if (isSharedVariable(anSNode, anLHS)) {¬∂				retVal.add(anAssignmentSNode);¬∂				return;¬∂			}¬∂		}¬∂    	for (SNode aChild:anSNode.getChildren()) {¬∂    		fillAssignmentsToShared(aChild, retVal);¬∂    	}¬∂		¬∂	}¬∂	public static boolean dependsOn (SNode anSNode, int aVariableLineNumber, String aVariable, String aCallIdentifier) {¬∂		List<SNode> aListSNodes = anSNode.getChildren();¬∂		boolean retVal = false;¬∂		/*¬∂		 * Should probably ignore line number as it assumes straight line code¬∂		 */¬∂		for (int i = aVariableLineNumber; i >= 0; i--) {¬∂			SNode anSNodeChild = aListSNodes.get(i);¬∂			if (anSNodeChild instanceof AssignmentSNode) {¬∂				// does this statement in anSNode directly invoke aCallIdentifier ¬∂				if (dependsOn((AssignmentSNode) anSNodeChild, aVariable, aCallIdentifier))¬∂					return true;¬∂			} else if (!anSNode.isLeaf()) {¬∂					// child is overriding the variable so forget checking its assignment statements¬∂					if (anSNodeChild.getLocalVariables().contains(aVariable)) {¬∂						continue;¬∂					}¬∂					// some subblock of anSNode that has access to aVariable changes variable¬∂¬∂					if (dependsOn(anSNodeChild, anSNodeChild.getChildren().size() - 1, aVariable, aCallIdentifier)) {¬∂						return true;¬∂					}¬∂			}¬∂			¬∂		}¬∂		// none of the statements in anSNode or its descendents  have the required call¬∂		// is the variable a  method parameter ¬∂		if (anSNode instanceof MethodSNode) {¬∂			MethodSNode aMethodSNode = (MethodSNode) anSNode;¬∂			¬∂			int aParameterNumber = aMethodSNode.getLocalVariables().indexOf(aVariable);¬∂			if (aParameterNumber != -1) {¬∂				List <MethodCall> aCalls = aMethodSNode.getCalls();¬∂				for (MethodCall aCall:aCalls) {¬∂					MethodSNode aCallerSNode = getDeclarationOfCalledMethod(aMethodSNode, aCall);¬∂					boolean aCallerDepends = dependsOn(aMethodSNode, aCallerSNode.getLineNumber(), aVariable, aCallIdentifier);¬∂				    if (aCallerDepends) {¬∂				    	return true;¬∂				    }¬∂				}¬∂				return false;¬∂				// need to find all callers of method and see if any of the aliases for the variable in these¬∂				// calls depend on aCallIndentifier¬∂			}			¬∂			¬∂		} else if (anSNode.getLocalVariables().contains(aVariable)) {¬∂			// before going to the parent node, let us see if aVariable is declared here as a non  parameter ¬∂¬∂			return false; // no point going to parent¬∂		}¬∂		// not a local variable (parameter or declarated variable)¬∂		SNode anSNodeParent = anSNode.getParent() ;¬∂		if (anSNodeParent == null)  {¬∂			return false;¬∂		}¬∂		int anSNodeLineNumber = anSNodeParent.getChildren().indexOf(anSNode);¬∂		return dependsOn(anSNodeParent, anSNodeLineNumber, aVariable, aCallIdentifier);¬∂		¬∂	}¬∂	public static RootOfFileSNode getRootOfFileNode(SNode aCurrentSNode ) {¬∂		if (aCurrentSNode instanceof RootOfFileSNode) {¬∂			return (RootOfFileSNode) aCurrentSNode;¬∂		}¬∂		SNode aParentSNode = aCurrentSNode.getParent() ;¬∂		¬∂		if (aParentSNode == null) {¬∂			return null;¬∂		}¬∂		¬∂		return getRootOfFileNode(aParentSNode);¬∂		¬∂	}¬∂	public static boolean match (MethodSNode aMethodSNode, MethodCall aMethodCall) {¬∂		return aMethodSNode.getMethodName().equals(aMethodCall.getMethodName()) ¬∂				&& aMethodSNode.getLocalVariables().size() == aMethodCall.getMethodActuals().size();¬∂	}¬∂	¬∂	public static MethodSNode getDeclarationOfCalledMethod(SNode aCurrentSNode, MethodCall aMethodCall ) {¬∂		SNode aRootNode = getRootOfFileNode(aCurrentSNode);¬∂		for (SNode aChild:aRootNode.getChildren()) {¬∂			if (aChild instanceof MethodSNode) {¬∂				MethodSNode aMethodSNode = (MethodSNode) aChild;¬∂				if (match (aMethodSNode, aMethodCall)) {¬∂					return aMethodSNode;¬∂				}¬∂			}¬∂		}¬∂		return null; // this should never happen;¬∂	}¬∂	¬∂	public static RootOfProgramSNode getRootOfProgramSNode(String aSource) {¬∂		RootOfProgramSNode retVal = new ARootOfProgramSNode();¬∂		Map<String, StringBuffer> aFileNameToContents = ABasicTextManager.extractFileContents(aSource);¬∂		for (String aFileName:aFileNameToContents.keySet()) {¬∂			StringBuffer aFileContents = aFileNameToContents.get(aFileName);¬∂//			List<OpenMPPragma> anOpenMPPragmas = OpenMPUtils.getOpemMPPragmas(aFileContents);¬∂			RootOfFileSNode anSNode = OMPSNodeUtils.getSNode(aFileName, aFileContents);¬∂			retVal.getFileNameToSNode().put(aFileName, anSNode);¬∂			anSNode.setParent(retVal);¬∂//			System.out.println("file name:" + aFileName);¬∂//			System.out.println("pragmas:" + anSNode);¬∂		}¬∂		processExternalMethodSNodes(retVal);¬∂		return retVal;¬∂	}¬∂	public static void processExternalMethodSNodes (RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode) {¬∂		for (SNode anSNode:aRootOfFileSNode.getChildren()) {¬∂			if (anSNode instanceof ExternalMethodSNode) {¬∂				processExternalMethodSNode(aRootOfProgramSNode, aRootOfFileSNode, (ExternalMethodSNode) anSNode);¬∂			}¬∂		}¬∂	}¬∂	public static void processExternalMethodSNode (RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode, ExternalMethodSNode anExternalMethodSNode) {¬∂		MethodSNode aMethodSNode = aRootOfProgramSNode.getExternalToInternalMethod().get(anExternalMethodSNode.toString());¬∂		if (aMethodSNode == null) {¬∂			aMethodSNode = findMethodSNode(aRootOfProgramSNode, aRootOfFileSNode, anExternalMethodSNode);¬∂			if (aMethodSNode != null) {¬∂				aRootOfProgramSNode.getExternalToInternalMethod().put(anExternalMethodSNode.toString(),aMethodSNode );¬∂			}¬∂		}¬∂		if (aMethodSNode != null) {¬∂			anExternalMethodSNode.setActualMethodSNode(aMethodSNode);¬∂			aMethodSNode.getCalls().addAll(anExternalMethodSNode.getLocalCalls());¬∂		}¬∂	}¬∂	public static MethodSNode findMethodSNode (RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode, ExternalMethodSNode anExternalMethodSNode) {¬∂//		MethodSNode foundMethodSNode = null;¬∂		for (String aFileName:aRootOfProgramSNode.getFileNameToSNode().keySet()) {¬∂			if (aFileName.equals(aRootOfFileSNode.getFileName()))¬∂				continue;¬∂			¬∂			RootOfFileSNode aSearchedRootOfFileSNode = aRootOfProgramSNode.getFileNameToSNode().get(aFileName);¬∂			 for (SNode anSNode:aSearchedRootOfFileSNode.getChildren()) {¬∂				if (anSNode instanceof MethodSNode && !(anSNode instanceof ExternalMethodSNode)) {¬∂					if (anSNode.toString().equals(anExternalMethodSNode.toString())) {¬∂						return (MethodSNode) anSNode;¬∂						¬∂					}¬∂//					processExternalMethodSNode(aRootOfProgramSNode, aRootOfFileSNode, (ExternalMethodSNode) anSNode);¬∂				}¬∂			}¬∂		}¬∂		return null;¬∂	}¬∂	public static void processExternalMethodSNodes (RootOfProgramSNode aRootOfProgramSNode) {¬∂		for (String aFileName:aRootOfProgramSNode.getFileNameToSNode().keySet()) {¬∂			RootOfFileSNode aRootOfFileSNode = aRootOfProgramSNode.getFileNameToSNode().get(aFileName);¬∂			processExternalMethodSNodes(aRootOfProgramSNode, aRootOfFileSNode);¬∂			aRootOfFileSNode.getOmp_get_num_threads_SNode().¬∂				setActualMethodSNode(aRootOfProgramSNode.getOmp_get_num_threads_SNode());¬∂			aRootOfFileSNode.getOmp_get_thread_num_SNode().¬∂				setActualMethodSNode(aRootOfProgramSNode.getOmp_get_thread_num_SNode());¬∂			aRootOfFileSNode.getOmp_get_wtime_SNode().¬∂			setActualMethodSNode(aRootOfProgramSNode.getOmp_get_wtime_SNode());¬∂		}¬∂¬∂	}¬∂	¬∂¬∂//	public static void main(String[] args) {¬∂//		List<MethodCall> aTokens = callsIn("foo(bar, hgf)/foo2()*foo3(b, a c,)");¬∂//		System.out.println(aTokens);¬∂//		¬∂//		¬∂////		List<String> aTokens = identifiersIn("a[i] + b*2/3");¬∂////		System.out.println(aTokens);¬∂////		aTokens = numbersIn("a[i] + b*2/3");¬∂////		System.out.println(aTokens);¬∂////		aTokens = operatorsIn("a[i] + b*2/3");¬∂////		System.out.println(aTokens);¬∂////¬∂////		System.out.println(StringUtils.substringBetween("a", "[", "]"));¬∂//	}¬∂¬∂}¬∂")]]]></diff>
  </Command>
  <Command __id="182053" _type="EclipseCommand" commandID="org.eclipse.jdt.ui.edit.text.java.open.editor" date="Mon Dec 30 08:25:11 EST 2019" starttimestamp="1576666505112" timestamp="1045806674" />
  <Command __id="182054" _type="DiffBasedFileOpenCommand" date="Mon Dec 30 08:25:32 EST 2019" docASTNodeCount="1" docActiveCodeLength="453" docExpressionCount="0" docLength="453" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="1045827813">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\my_sum_sequential.cpp]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"#include <iostream>¬∂#include <omp.h>¬∂¬∂using namespace std;¬∂void printSumWithTimes(int sum, int start, int end);¬∂void printNumThreads();¬∂void recordThreadIndex(int index);¬∂void sum_sequential(double* array, int size) {¬∂¬∂	cout << "sum_sequential\n";¬∂¬∂	double start = omp_get_wtime();¬∂¬∂	double sum = 0;¬∂¬∂	for (int i = 0; i < size; i++) {¬∂		sum += array[i];¬∂		recordThreadIndex(i);¬∂	}¬∂¬∂	double end = omp_get_wtime();¬∂¬∂	printSumWithTimes(sum, start, end);¬∂}¬∂")]]]></diff>
  </Command>
  <Command __id="182055" _type="SelectTextCommand" caretOffset="280" date="Mon Dec 30 08:25:33 EST 2019" end="280" start="265" starttimestamp="1576666505112" timestamp="1045828022" />
  <Command __id="182057" _type="MoveCaretCommand" caretOffset="1165" date="Mon Dec 30 08:25:46 EST 2019" docOffset="1165" starttimestamp="1576666505112" timestamp="1045841709" />
  <Command __id="182071" _type="RunCommand" date="Mon Dec 30 08:26:07 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="1045862115" type="Run" />
  <Command __id="182072" _type="RunCommand" date="Mon Dec 30 08:26:07 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="1045862150" type="Run" />
  <Command __id="182073" _type="RunCommand" date="Mon Dec 30 08:26:07 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="1045862152" type="Run" />
  <Command __id="182074" _type="EHExceptionCommand" date="Mon Dec 30 08:26:07 EST 2019" starttimestamp="1576666505112" timestamp="1045862154" type="Exception">
    <outputString><![CDATA[I***(TestCaseResult) ### SequentialSumTestCase: 1.0
I***(BasicProcessRunner) Running command:D:\dewan_backup\C\MyOpenMPTraining\Debug\MyOpenMPTraining.exe
I***(BasicProcessRunner) Running in folder: D:\dewan_backup\C\MyOpenMPTraining\Debug
I***(BasicProcessRunner)  Process started: D:\dewan_backup\C\MyOpenMPTraining\Debug\MyOpenMPTraining.exe folder: D:\dewan_backup\C\MyOpenMPTraining\Debug entry point: null class path: D:\dewan_backup\Java\PLTeaching\PL_Java\bin;D:\dewan_backup\Java\lib\oeall22.jar;C:\Users\dewan\.p2\pool\plugins\org.junit_4.12.0.v201504281640\junit.jar;C:\Users\dewan\.p2\pool\plugins\org.hamcrest.core_1.3.0.v20180420-1519.jar;D:\dewan_backup\Java\GraderBasics\lib\commons-configuration-1.9.jar;D:\dewan_backup\Java\GraderBasics\lib\commons-lang-2.6.jar;D:\dewan_backup\Java\GraderBasics\lib\commons-logging-1.1.1.jar;G:\My Drive\Java\lib\Herrmes\lib\weka3_6.jar;D:\dewan_backup\Java\GraderBasics\target\classes;D:\dewan_backup\Java\DemoCourseLocalBasicChecks\bin
I***(ARunnerInputStreamProcessor) Provided Input:
]]></outputString>
  </Command>
  <Command __id="182075" _type="EHExceptionCommand" date="Mon Dec 30 08:26:07 EST 2019" starttimestamp="1576666505112" timestamp="1045862213" type="Exception">
    <outputString><![CDATA[I***(BasicRunningProject) 1577712367274:Received output from main: sum_sequential
I***(BasicRunningProject) 1577712367275:Processing line from main: sum_sequential
I***(BasicRunningProject) 1577712367275:Received output from main: Sum: 499500
I***(BasicRunningProject) 1577712367275:Processing line from main: Sum: 499500
I***(BasicRunningProject) 1577712367276:Received output from main: Took: 0
I***(BasicRunningProject) 1577712367276:Processing line from main: Took: 0
I***(BasicRunningProject) 1577712367276:Received output from main: thread:0 lastIndex:999
I***(BasicRunningProject) 1577712367276:Processing line from main: thread:0 lastIndex:999
I***(BasicRunningProject) 1577712367276:Received output from main: _____________________________
I***(BasicRunningProject) 1577712367276:Processing line from main: _____________________________
I***(BasicRunningProject) 1577712367277:Received output from main: sum_parallel_for_reduction
I***(BasicRunningProject) 1577712367277:Processing line from main: sum_parallel_for_reduction
I***(BasicRunningProject) 1577712367277:Received output from main: Sum: 499500
I***(BasicRunningProject) 1577712367277:Processing line from main: Sum: 499500
I***(BasicRunningProject) 1577712367278:Received output from main: Took: 0
I***(BasicRunningProject) 1577712367278:Processing line from main: Took: 0
I***(BasicRunningProject) 1577712367278:Received output from main: thread:0 lastIndex:124
I***(BasicRunningProject) 1577712367278:Processing line from main: thread:0 lastIndex:124
I***(BasicRunningProject) 1577712367278:Received output from main: thread:1 lastIndex:249
I***(BasicRunningProject) 1577712367278:Processing line from main: thread:1 lastIndex:249
I***(BasicRunningProject) 1577712367278:Received output from main: thread:2 lastIndex:374
I***(BasicRunningProject) 1577712367278:Processing line from main: thread:2 lastIndex:374
I***(BasicRunningProject) 1577712367278:Received output from main: thread:3 lastIndex:499
I***(BasicRunningProject) 1577712367278:Processing line from main: thread:3 lastIndex:499
I***(BasicRunningProject) 1577712367279:Received output from main: thread:4 lastIndex:624
I***(BasicRunningProject) 1577712367279:Processing line from main: thread:4 lastIndex:624
I***(BasicRunningProject) 1577712367279:Received output from main: thread:5 lastIndex:749
I***(BasicRunningProject) 1577712367279:Processing line from main: thread:5 lastIndex:749
I***(BasicRunningProject) 1577712367279:Received output from main: thread:6 lastIndex:874
I***(BasicProcessRunner)  Process finished; folder: D:\dewan_backup\C\MyOpenMPTraining\Debug entry point: null class path: D:\dewan_backup\Java\PLTeaching\PL_Java\bin;D:\dewan_backup\Java\lib\oeall22.jar;C:\Users\dewan\.p2\pool\plugins\org.junit_4.12.0.v201504281640\junit.jar;C:\Users\dewan\.p2\pool\plugins\org.hamcrest.core_1.3.0.v20180420-1519.jar;D:\dewan_backup\Java\GraderBasics\lib\commons-configuration-1.9.jar;D:\dewan_backup\Java\GraderBasics\lib\commons-lang-2.6.jar;D:\dewan_backup\Java\GraderBasics\lib\commons-logging-1.1.1.jar;G:\My Drive\Java\lib\Herrmes\lib\weka3_6.jar;D:\dewan_backup\Java\GraderBasics\target\classes;D:\dewan_backup\Java\DemoCourseLocalBasicChecks\bin
I***(BasicRunningProject) 1577712367279:Processing line from main: thread:6 lastIndex:874
I***(BasicRunningProject) 1577712367279:Received output from main: thread:7 lastIndex:999
I***(BasicRunningProject) 1577712367280:Processing line from main: thread:7 lastIndex:999
I***(BasicRunningProject) 1577712367280:Received output from main: _____________________________
I***(BasicRunningProject) 1577712367280:Processing line from main: _____________________________
I***(BasicRunningProject) 1577712367280:Received output from main: sum_parallel_for_local_var
I***(BasicRunningProject) 1577712367280:Processing line from main: sum_parallel_for_local_var
I***(BasicRunningProject) 1577712367280:Received output from main: Sum: 499500
I***(BasicRunningProject) 1577712367280:Processing line from main: Sum: 499500
I***(BasicRunningProject) 1577712367280:Received output from main: Took: 0
I***(BasicRunningProject) 1577712367280:Processing line from main: Took: 0
I***(BasicRunningProject) 1577712367280:Received output from main: thread:0 lastIndex:124
I***(BasicRunningProject) 1577712367281:Processing line from main: thread:0 lastIndex:124
I***(BasicRunningProject) 1577712367281:Received output from main: thread:1 lastIndex:249
I***(BasicRunningProject) 1577712367281:Processing line from main: thread:1 lastIndex:249
I***(BasicRunningProject) 1577712367281:Received output from main: thread:2 lastIndex:374
I***(BasicRunningProject) 1577712367281:Processing line from main: thread:2 lastIndex:374
I***(BasicRunningProject) 1577712367281:Received output from main: thread:3 lastIndex:499
I***(BasicRunningProject) 1577712367281:Processing line from main: thread:3 lastIndex:499
I***(BasicRunningProject) 1577712367281:Received output from main: thread:4 lastIndex:624
I***(BasicRunningProject) 1577712367281:Processing line from main: thread:4 lastIndex:624
I***(BasicRunningProject) 1577712367282:Received output from main: thread:5 lastIndex:749
I***(BasicRunningProject) 1577712367282:Processing line from main: thread:5 lastIndex:749
I***(BasicRunningProject) 1577712367282:Received output from main: thread:6 lastIndex:874
I***(BasicRunningProject) 1577712367282:Processing line from main: thread:6 lastIndex:874
I***(BasicRunningProject) 1577712367282:Received output from main: thread:7 lastIndex:999
I***(BasicRunningProject) 1577712367282:Processing line from main: thread:7 lastIndex:999
I***(BasicRunningProject) 1577712367282:Received output from main: _____________________________
I***(BasicRunningProject) 1577712367282:Processing line from main: _____________________________
I***(BasicRunningProject) 1577712367283:Received output from main: sum_parallel
I***(BasicRunningProject) 1577712367283:Processing line from main: sum_parallel
I***(BasicRunningProject) 1577712367283:Received output from main: Sum: 499500
I***(BasicRunningProject) 1577712367283:Processing line from main: Sum: 499500
I***(BasicRunningProject) 1577712367283:Received output from main: Took: 0
I***(BasicRunningProject) 1577712367283:Processing line from main: Took: 0
I***(BasicRunningProject) 1577712367283:Received output from main: _____________________________
I***(BasicRunningProject) 1577712367283:Processing line from main: _____________________________
I***(BasicRunningProject) Thread[AWT-EventQueue-0,6,main] sleeping for ms:2000 waiting for pending output from threads 
]]></outputString>
  </Command>
  <DocumentChange __id="184470" _type="Insert" date="Mon Dec 30 10:04:12 EST 2019" docASTNodeCount="403" docActiveCodeLength="2907" docExpressionCount="311" docLength="5658" length="1" offset="3010" starttimestamp="1576666505112" timestamp="1051747811">
    <text><![CDATA[t]]></text>
  </DocumentChange>
  <DocumentChange __id="184472" _type="Insert" date="Mon Dec 30 10:04:13 EST 2019" docASTNodeCount="403" docActiveCodeLength="2908" docExpressionCount="311" docLength="5659" length="1" offset="3011" starttimestamp="1576666505112" timestamp="1051748079">
    <text><![CDATA[i]]></text>
  </DocumentChange>
  <DocumentChange __id="184475" _type="Replace" date="Mon Dec 30 10:04:13 EST 2019" docASTNodeCount="406" docActiveCodeLength="2928" docExpressionCount="314" docLength="5679" endLine="58" insertionLength="44" int_docASTNodeCount="403" int_docActiveCodeLength="2884" int_docExpressionCount="311" int_docLength="5635" length="24" offset="2988" startLine="58" starttimestamp="1576666505112" timestamp="1051748777">
    <deletedText><![CDATA[assignmentsToSharedCriti]]></deletedText>
    <insertedText><![CDATA[assignmentsToParallelSharedCritical(anSNode)]]></insertedText>
  </DocumentChange>
  <DocumentChange __id="184480" _type="Delete" date="Mon Dec 30 10:04:17 EST 2019" docASTNodeCount="405" docActiveCodeLength="2927" docExpressionCount="313" docLength="5678" endLine="58" length="1" offset="3031" startLine="58" starttimestamp="1576666505112" timestamp="1051752472">
    <text><![CDATA[)]]></text>
  </DocumentChange>
  <DocumentChange __id="184482" _type="Delete" date="Mon Dec 30 10:04:17 EST 2019" docASTNodeCount="405" docActiveCodeLength="2926" docExpressionCount="313" docLength="5677" endLine="58" length="1" offset="3030" startLine="58" starttimestamp="1576666505112" timestamp="1051752649">
    <text><![CDATA[e]]></text>
  </DocumentChange>
  <DocumentChange __id="184484" _type="Delete" date="Mon Dec 30 10:04:17 EST 2019" docASTNodeCount="405" docActiveCodeLength="2925" docExpressionCount="313" docLength="5676" endLine="58" length="1" offset="3029" startLine="58" starttimestamp="1576666505112" timestamp="1051752836">
    <text><![CDATA[d]]></text>
  </DocumentChange>
  <DocumentChange __id="184486" _type="Delete" date="Mon Dec 30 10:04:18 EST 2019" docASTNodeCount="405" docActiveCodeLength="2924" docExpressionCount="313" docLength="5675" endLine="58" length="1" offset="3028" startLine="58" starttimestamp="1576666505112" timestamp="1051753012">
    <text><![CDATA[o]]></text>
  </DocumentChange>
  <DocumentChange __id="184488" _type="Delete" date="Mon Dec 30 10:04:18 EST 2019" docASTNodeCount="405" docActiveCodeLength="2923" docExpressionCount="313" docLength="5674" endLine="58" length="1" offset="3027" startLine="58" starttimestamp="1576666505112" timestamp="1051753189">
    <text><![CDATA[N]]></text>
  </DocumentChange>
  <DocumentChange __id="184490" _type="Delete" date="Mon Dec 30 10:04:18 EST 2019" docASTNodeCount="405" docActiveCodeLength="2922" docExpressionCount="313" docLength="5673" endLine="58" length="1" offset="3026" startLine="58" starttimestamp="1576666505112" timestamp="1051753371">
    <text><![CDATA[S]]></text>
  </DocumentChange>
  <DocumentChange __id="184492" _type="Delete" date="Mon Dec 30 10:04:18 EST 2019" docASTNodeCount="405" docActiveCodeLength="2921" docExpressionCount="313" docLength="5672" endLine="58" length="1" offset="3025" startLine="58" starttimestamp="1576666505112" timestamp="1051753548">
    <text><![CDATA[n]]></text>
  </DocumentChange>
  <DocumentChange __id="184494" _type="Delete" date="Mon Dec 30 10:04:18 EST 2019" docASTNodeCount="404" docActiveCodeLength="2920" docExpressionCount="312" docLength="5671" endLine="58" length="1" offset="3024" startLine="58" starttimestamp="1576666505112" timestamp="1051753722">
    <text><![CDATA[a]]></text>
  </DocumentChange>
  <DocumentChange __id="184496" _type="Delete" date="Mon Dec 30 10:04:19 EST 2019" docASTNodeCount="403" docActiveCodeLength="2919" docExpressionCount="311" docLength="5670" endLine="58" length="1" offset="3023" startLine="58" starttimestamp="1576666505112" timestamp="1051753939">
    <text><![CDATA[(]]></text>
  </DocumentChange>
  <Command __id="184526" _type="DiffBasedFileOpenCommand" date="Mon Dec 30 10:04:51 EST 2019" docASTNodeCount="3984" docActiveCodeLength="28378" docExpressionCount="2515" docLength="32564" projectName="GraderBasics" starttimestamp="1576666505112" timestamp="1051786641">
    <filePath><![CDATA[D:\dewan_backup\Java\GraderBasics\src\gradingTools\shared\testcases\openmp\scannedTree\OMPSNodeUtils.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package gradingTools.shared.testcases.openmp.scannedTree;¬∂¬∂import java.util.ArrayList;¬∂import java.util.Arrays;¬∂import java.util.HashMap;¬∂import java.util.List;¬∂import java.util.Map;¬∂import java.util.Stack;¬∂import java.util.regex.Matcher;¬∂import java.util.regex.Pattern;¬∂¬∂import org.apache.commons.lang.StringUtils;¬∂¬∂import grader.basics.project.source.ABasicTextManager;¬∂import gradingTools.shared.testcases.openmp.OpenMPKeywordEnum;¬∂import gradingTools.shared.testcases.openmp.OpenMPParallelPragma;¬∂import gradingTools.shared.testcases.openmp.OpenMPUtils;¬∂import gradingTools.shared.testcases.openmp.scannedTree.ADeclarationSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.ADeclaringAssignmentSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.AForSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.ATextSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.AnAssignmentSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.AnOMPCriticalSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.AnOMPForSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.AnOMPParallelSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.AnOMPSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.AnSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.AssignmentSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.DeclarationSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.DeclaringAssignmentSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.ForSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.OMPForSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.OMPSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.SNode;¬∂¬∂public class OMPSNodeUtils extends OpenMPUtils {¬∂¬∂	public static RootOfFileSNode getSNode(String aFileName, StringBuffer aFileBuffer) {¬∂		String[] aFileLines = aFileBuffer.toString().split("\n");¬∂		return getSNode(aFileName, aFileLines);¬∂	}¬∂¬∂	public static AssignmentSNode getAssignmentSNode(int aLineNumber, String aString) {¬∂		if (aString == null) {¬∂			return null;¬∂		}¬∂		String[] aTokens = aString.split("=");¬∂		if (aTokens.length == 1) {¬∂			return new AnAssignmentSNode(aLineNumber, aTokens[0], null);¬∂		} else {¬∂		return new AnAssignmentSNode(aLineNumber, aTokens[0], aTokens[1]);¬∂		}¬∂	}¬∂¬∂	public static DeclarationSNode getDeclarationSNode(int aLineNumber, String aString) {¬∂		String[] aTokens = aString.split(" ");¬∂		return new ADeclarationSNode(aLineNumber, aTokens[0], aTokens[1]);¬∂	}¬∂¬∂	public static DeclaringAssignmentSNode getDeclaringAssignmentSNode(int aLineNumber, String aString) {¬∂		String[] anLHSAndRHS = aString.split("=");¬∂		String[] aTypeAndVariable = anLHSAndRHS[0].split(" ");¬∂		return new ADeclaringAssignmentSNode(aLineNumber, aTypeAndVariable[0], aTypeAndVariable[1], anLHSAndRHS[1]);¬∂	}¬∂¬∂	public static boolean isDeclaringAssignment(String aFileLine) {¬∂		return startsWithTypeName(aFileLine) && aFileLine.contains("=");¬∂	}¬∂	public static boolean isMethodDeclaration(String aFileLine) {¬∂		return startsWithTypeName(aFileLine) && ¬∂				aFileLine.contains("(") &&¬∂				!aFileLine.contains("=");¬∂	}¬∂	public static boolean isExternalMethodDeclaration(String aFileLine) {¬∂		return isMethodDeclaration(aFileLine) && aFileLine.endsWith(";");¬∂	}¬∂¬∂¬∂	public static boolean isVariableDeclaration(String aFileLine) {¬∂¬∂		return startsWithTypeName(aFileLine) && !aFileLine.contains("(");¬∂	}¬∂¬∂	public static boolean isAssignment(String aFileLine) {¬∂		return aFileLine.contains("=");¬∂	}¬∂¬∂	public static boolean isForNode(String aFileLine) {¬∂		return aFileLine.startsWith("for");¬∂	}¬∂¬∂	public static ForSNode getForSNode(int aLineNumber, String aFileLine) {¬∂¬∂		int aLeftParenIndex = aFileLine.indexOf("(");¬∂		int aRightParenIndex = aFileLine.indexOf(")");¬∂		if (aLeftParenIndex < 0 || aRightParenIndex < 0) {¬∂			return null;¬∂		}¬∂		String aHeaderString = aFileLine.substring(aLeftParenIndex + 1, aRightParenIndex);¬∂		String[] aForComponents = aHeaderString.split(";");¬∂		AssignmentSNode anAssignmentSNode = null;¬∂		String aForInitializaton = aForComponents[0];¬∂		if (!aForInitializaton.isEmpty() && aForInitializaton.contains("=")) {¬∂			if (isDeclaringAssignment(aForInitializaton)) {¬∂				anAssignmentSNode = getDeclaringAssignmentSNode(aLineNumber, aForInitializaton);¬∂			} else {¬∂				anAssignmentSNode = getAssignmentSNode(aLineNumber, aForInitializaton);¬∂			}¬∂¬∂		}		¬∂		return new AForSNode(aLineNumber, anAssignmentSNode, aForComponents[1], getAssignmentSNode(aLineNumber, aForComponents[2]));¬∂	}¬∂	static String[] emptyArray = {};¬∂	public static MethodSNode getMethodSNode(int aLineNumber, String aFileLine, boolean isInternal) {¬∂¬∂		int aLeftParenIndex = aFileLine.indexOf("(");¬∂		int aRightParenIndex = aFileLine.indexOf(")");¬∂		if (aLeftParenIndex < 0 || aRightParenIndex < 0) {¬∂			return null;¬∂		}¬∂		String aMethodNameAndType = aFileLine.substring(0, aLeftParenIndex);¬∂		String[] aMethodNameAndTypeTokens = aMethodNameAndType.split("\\s+"); ¬∂		¬∂		String aMethodParameters = aFileLine.substring(aLeftParenIndex +1 , aRightParenIndex);¬∂		String[] aMethodParameterTokens = aMethodParameters.isEmpty()?emptyArray:¬∂		 aMethodParameters.split(",");¬∂		¬∂//		String[] aMethodParameterTypes = new String[aMethodParameterTokens.length];¬∂//		String[] aMethodParameterNames = new String[aMethodParameterTokens.length];¬∂		List<DeclarationSNode> aDeclarationSNodeList = new ArrayList();¬∂		for (int i = 0; i < aMethodParameterTokens.length; i++ ) {¬∂			String[] aTypeAndName = aMethodParameterTokens[i].trim().split("\\s+");¬∂			if (aTypeAndName.length < 2) {¬∂				continue;¬∂			}¬∂			aDeclarationSNodeList.add(new ADeclarationSNode(aLineNumber, aTypeAndName[0].trim(), aTypeAndName[1].trim()));¬∂//			aMethodParameterTypes[i] = aTypeAndName[0].trim();¬∂//			aMethodParameterNames[i] = aTypeAndName[1].trim();¬∂		}¬∂		if (isInternal)¬∂//		return new AMethodSNode(aLineNumber, aMethodNameAndTypeTokens[0], aMethodNameAndTypeTokens[1], aMethodParameterTypes,aMethodParameterNames );¬∂			return new AMethodSNode(aLineNumber, aMethodNameAndTypeTokens[0], aMethodNameAndTypeTokens[1], aDeclarationSNodeList );¬∂		else¬∂			return new AnExternalMethodSNode(aLineNumber, aMethodNameAndTypeTokens[0], aMethodNameAndTypeTokens[1], aDeclarationSNodeList );¬∂	}¬∂¬∂	public static void setReductionData(OMPForSNode lastChild, String aStoredToken, int aLeftParenIndex,¬∂			int aRightParenIndex) {¬∂		int aColonIndex = aStoredToken.indexOf(":");¬∂		if (aLeftParenIndex != -1 && aRightParenIndex != -1 && aColonIndex != -1) {¬∂			String anOperationString = aStoredToken.substring(aLeftParenIndex + 1, aColonIndex).trim();¬∂			String aVariableString = aStoredToken.substring(aColonIndex + 1, aRightParenIndex).trim();¬∂			((OMPForSNode) lastChild).setReductionVariable(aVariableString);¬∂			((OMPForSNode) lastChild).setReductionOperation(anOperationString);¬∂		}¬∂	}¬∂¬∂	public static void setSharedOrPrivateData(OMPSNode lastChild, String aStoredToken, int aLeftParenIndex,¬∂			int aRightParenIndex, boolean isShared) {¬∂//		int aColonIndex = aStoredToken.indexOf(":");¬∂		if (aLeftParenIndex != -1 && aRightParenIndex != -1) {¬∂			String aVariableDeclarations = aStoredToken.substring(aLeftParenIndex + 1, aRightParenIndex);¬∂			String[] aVariables = aVariableDeclarations.split(",");¬∂			if (isShared) {¬∂				lastChild.setSharedVariables(aVariables);¬∂			} else {¬∂				lastChild.setPrivateVariables(aVariables);¬∂			}¬∂		}¬∂	}¬∂¬∂	public static RootOfFileSNode getSNode(String aFileName, String[] aFileLines) {¬∂		Stack<SNode> anSNodes = new Stack();¬∂¬∂		RootOfFileSNode retVal = new ARootOfFileSNode(aFileName);¬∂		anSNodes.add(retVal);¬∂		SNode previousHeaderNode = null;¬∂		for (int i = 0; i < aFileLines.length; i++) {¬∂			String aFileLine = aFileLines[i].trim();¬∂			if (!isCodeLine(aFileLine)) {¬∂				continue;¬∂			}¬∂			if (isForNode(aFileLine)) {¬∂				ForSNode aForSNode = getForSNode(i, aFileLine);¬∂				aForSNode.setParent(anSNodes.peek());¬∂//				anSNodes.push(aForSNode);¬∂				previousHeaderNode = aForSNode;¬∂				if (aFileLine.endsWith(")")) {¬∂					continue;¬∂				}¬∂			}¬∂			if (isExternalMethodDeclaration(aFileLine)) {¬∂				MethodSNode aMethodSNode = getMethodSNode(i, aFileLine, false);¬∂				aMethodSNode.setParent(anSNodes.peek());¬∂//				anSNodes.push(aForSNode);¬∂				previousHeaderNode = aMethodSNode;¬∂				if (aFileLine.endsWith(")")) {¬∂					continue;¬∂				}¬∂			}¬∂			if (isMethodDeclaration(aFileLine)) {¬∂				MethodSNode aMethodSNode = getMethodSNode(i, aFileLine, true);¬∂				aMethodSNode.setParent(anSNodes.peek());¬∂//				anSNodes.push(aForSNode);¬∂				previousHeaderNode = aMethodSNode;¬∂				if (aFileLine.endsWith(")")) {¬∂					continue;¬∂				}¬∂			}¬∂			if (isPragmaStart(aFileLine)) {¬∂				OMPSNode anOMPSNode = getOMPSNode(i, anSNodes.peek(), aFileLine);¬∂//				anSNodes.push(anOMPSNode);¬∂				previousHeaderNode = anOMPSNode;¬∂				continue;¬∂			}¬∂			if (isBlockStart(aFileLine)) {¬∂				SNode aBlockSNode = new AnSNode(i);¬∂				if (previousHeaderNode != null) {¬∂					aBlockSNode.setParent(previousHeaderNode);¬∂				} else {¬∂					aBlockSNode.setParent(anSNodes.peek());¬∂				}¬∂				anSNodes.push(aBlockSNode);¬∂				previousHeaderNode = null;¬∂				continue;¬∂			}¬∂//			} else ¬∂			if (isBlockEnd(aFileLine)) {¬∂				anSNodes.pop();¬∂				continue;¬∂			}¬∂			SNode aNewLeafNode = null;¬∂			if (isDeclaringAssignment(aFileLine)) {¬∂				aNewLeafNode = getDeclaringAssignmentSNode(i, aFileLine);¬∂¬∂			} else if (isAssignment(aFileLine)) {¬∂				aNewLeafNode = getAssignmentSNode(i, aFileLine);¬∂			} else if (isVariableDeclaration(aFileLine)) {¬∂				aNewLeafNode = getDeclarationSNode(i, aFileLine);¬∂			} else {¬∂				List<MethodCall> aCalls = callsIn(i, aFileLine, null); // parent will be assigned below¬∂				if (aCalls != null && aCalls.size() == 1) {¬∂					aNewLeafNode = aCalls.get(0);¬∂				} else {¬∂					aNewLeafNode = new ATextSNode(i, aFileLine);¬∂				}¬∂			}¬∂//			else {¬∂//				aNewLeafNode = new ATextSNode(i, aFileLine);¬∂//			}¬∂			if (previousHeaderNode != null) {¬∂				aNewLeafNode.setParent(previousHeaderNode);¬∂			} else {¬∂				aNewLeafNode.setParent(anSNodes.peek());¬∂			}¬∂¬∂		}¬∂¬∂		return retVal;¬∂	}¬∂¬∂	public static OMPSNode getOMPSNode(int aLineIndex, SNode aParentNode, String aFileLine) {¬∂		String[] aTokens = aFileLine.split("\\s+");¬∂		if (aTokens.length <= 2) {¬∂			return null;¬∂		}¬∂		if (!aTokens[1].equals("omp")) {¬∂			return null;¬∂		}¬∂		if (aTokens.length < 3) {¬∂			return null;¬∂		}¬∂		String aFirstToken = aTokens[2];¬∂		OpenMPKeywordEnum anOpenMPKeyword = stringToOpenMPKeyword.get(aFirstToken);¬∂//		List<OpenMPPragma> retVal = new ArrayList();¬∂		OMPSNode lastChild = null;¬∂		int aStartIndex = 2;¬∂		OMPSNode aNewNode = null;¬∂		OMPForSNode aForChild = null;¬∂		switch (anOpenMPKeyword) {¬∂		case PARALLEL:¬∂			aNewNode = new AnOMPParallelSNode(aLineIndex);¬∂¬∂			if (aTokens.length > 3 && aTokens[3].equals("for")) {¬∂				aForChild = new AnOMPForSNode(aLineIndex);¬∂				aForChild.setParent(aNewNode);¬∂¬∂				aStartIndex++;¬∂			}¬∂			break;¬∂		case FOR:¬∂			aNewNode = new AnOMPForSNode(aLineIndex);¬∂			;¬∂			break;¬∂		case CRITICAL:¬∂			aNewNode = new AnOMPCriticalSNode(aLineIndex);¬∂//			retVal.add (lastChild);¬∂			break;¬∂		default:¬∂			aNewNode = new AnOMPSNode(aLineIndex);¬∂¬∂		}¬∂¬∂		if (lastChild != null) {¬∂			aNewNode.setParent(lastChild);¬∂		} else {¬∂			aNewNode.setParent(aParentNode);¬∂		}¬∂		lastChild = aForChild == null ? aNewNode : aForChild;¬∂¬∂		for (int i = aStartIndex; i < aTokens.length; i++) {¬∂			String aStoredToken = aTokens[i].trim();¬∂			if (aStoredToken.isEmpty()) {¬∂				continue;¬∂			}¬∂			if (aStoredToken.startsWith("reduction") || aStoredToken.startsWith("shared")¬∂					|| aStoredToken.startsWith("private")) {¬∂				// combine all tokens until ")" into one for normalization¬∂				while (!aStoredToken.endsWith(")")) {¬∂					i++;¬∂					if (i >= aTokens.length) {¬∂						break;¬∂					}¬∂					String aNewToken = aTokens[i].trim();¬∂					aStoredToken += aNewToken;¬∂				}¬∂				int aLeftParenIndex = aStoredToken.indexOf("(");¬∂				int aRightParenIndex = aStoredToken.indexOf(")");¬∂				if (aStoredToken.startsWith("reduction")) {¬∂					setReductionData((OMPForSNode) lastChild, aStoredToken, aLeftParenIndex, aRightParenIndex);¬∂				} else if (aStoredToken.startsWith("private")) {¬∂					setSharedOrPrivateData((OMPSNode) lastChild, aStoredToken, aLeftParenIndex, aRightParenIndex,¬∂							false);¬∂¬∂				} else if (aStoredToken.startsWith("shared")) {¬∂					setSharedOrPrivateData(lastChild, aStoredToken, aLeftParenIndex, aRightParenIndex, true);¬∂¬∂				}¬∂¬∂			}¬∂¬∂			lastChild.getOpenMPTokens().add(aStoredToken);¬∂		}¬∂¬∂		return lastChild;¬∂¬∂	}¬∂¬∂	public static boolean hasParallelAncestor(SNode anSNode) {¬∂		if (anSNode == null) {¬∂			return false;¬∂		}¬∂		if (anSNode instanceof OMPParallelSNode) {¬∂			return true;¬∂		}¬∂		return hasParallelAncestor(anSNode.getParent());¬∂	}¬∂	public static boolean hasCriticalAncestor(SNode anSNode) {¬∂		if (anSNode == null) {¬∂			return false;¬∂		}¬∂		if (anSNode instanceof OMPCriticalSNode) {¬∂			return true;¬∂		}¬∂		return hasCriticalAncestor(anSNode.getParent());¬∂	}¬∂¬∂¬∂	public static Boolean isDeclaredShared(OMPSNode anOMPSNode, String anLHS) {¬∂		if (Arrays.asList(anOMPSNode.getSharedVariables()).contains(anLHS)) {¬∂			return true;¬∂		}¬∂		if (Arrays.asList(anOMPSNode.getPrivateVariables()).contains(anLHS)) {¬∂			return false;¬∂		}¬∂		return null;¬∂¬∂	}¬∂¬∂	public static boolean isSharedVariable(SNode anSNode, String anLHS) {¬∂		if (anSNode == null) {¬∂			return false;¬∂		}¬∂		if (anSNode.getLocalVariables().contains(anLHS)) {¬∂			if (!(anSNode instanceof OMPSNode)) { // no shared and private declarations¬∂				return !hasParallelAncestor(anSNode); // shared if not inParallel¬∂			}¬∂			OMPSNode anOMPSNode = (OMPSNode) anSNode;¬∂			return (Arrays.asList(anOMPSNode.getSharedVariables()).contains(anLHS)); // private unless declared shared¬∂		}¬∂		if (anSNode instanceof OMPSNode) {¬∂			OMPSNode anOMPSNode = (OMPSNode) anSNode;¬∂			// the variable is global to this scope, check if it has have been made shared¬∂			// or private by this scope¬∂			Boolean isDeclaredShared = isDeclaredShared(anOMPSNode, anLHS);¬∂			if (isDeclaredShared != null) {¬∂				return isDeclaredShared;¬∂			}¬∂		}¬∂		// check the parent¬∂		return isSharedVariable(anSNode.getParent(), anLHS);¬∂	}¬∂¬∂	public static List<SNode> getAllLeafNodes(SNode aTopNode) {¬∂		List<SNode> retVal = new ArrayList();¬∂		addLeafNodes(aTopNode, retVal);¬∂		return retVal;¬∂	}¬∂¬∂	public static void addLeafNodes(SNode aTopNode, List<SNode> retVal) {¬∂		for (SNode aChild : aTopNode.getChildren()) {¬∂			if (aChild.isLeaf()) {¬∂				retVal.add(aChild);¬∂			} else {¬∂				addLeafNodes(aChild, retVal);¬∂			}¬∂		}¬∂	}¬∂¬∂	public static List<SNode> getNonParallelLeafNodes(SNode aTopNode) {¬∂		List<SNode> retVal = new ArrayList();¬∂		addNonParallelLeafNodes(aTopNode, retVal);¬∂		return retVal;¬∂	}¬∂¬∂	public static void addNonParallelLeafNodes(SNode aTopNode, List<SNode> retVal) {¬∂		if (aTopNode.isInParallel()) {¬∂			return;¬∂		}¬∂		for (SNode aChild : aTopNode.getChildren()) {¬∂			if (aChild.isLeaf()) {¬∂				retVal.add(aChild);¬∂			} else {¬∂				addLeafNodes(aChild, retVal);¬∂			}¬∂		}¬∂	}¬∂	static String callRegex = "([a-zA-Z_$][a-zA-Z_$0-9]*)\\(.*?\\)";¬∂	static Pattern callPattern = Pattern.compile(callRegex);¬∂¬∂	static String identifierRegex = "[a-zA-Z_$][a-zA-Z_$0-9]*";¬∂	static Pattern identifierPattern = Pattern.compile(identifierRegex);¬∂	public static List<String> identifiersIn(String aString) {¬∂		if (aString == null)¬∂			return null;¬∂//		Pattern mypattern = Pattern.compile("[a-zA-Z_$][a-zA-Z_$0-9]*");¬∂//		Matcher mymatcher = mypattern.matcher(aString);¬∂		Matcher mymatcher = identifierPattern.matcher(aString);¬∂		List<String> retVal = new ArrayList();¬∂		while (mymatcher.find()) {¬∂			String find = mymatcher.group(0);¬∂			retVal.add(find);¬∂		}¬∂		return retVal;¬∂	}¬∂	public static List<MethodCall> callsIn(int aLineNumber, String aString, SNode aParent) {¬∂		if (aString == null)¬∂			return null;¬∂//		Pattern mypattern = Pattern.compile("[a-zA-Z_$][a-zA-Z_$0-9]*");¬∂//		Matcher mymatcher = mypattern.matcher(aString);¬∂		Matcher mymatcher = callPattern.matcher(aString);¬∂		List<MethodCall> retVal = new ArrayList();¬∂		while (mymatcher.find()) {¬∂			String find = mymatcher.group(0);¬∂			int aLeftParenIndex = find.indexOf("(");¬∂			int aRightParenIndex = find.indexOf(")");¬∂			String aMethodName = find.substring(0, aLeftParenIndex).trim();¬∂			String aParameters = find.substring(aLeftParenIndex + 1, aRightParenIndex);¬∂			List<String> aParameterList = new ArrayList();¬∂			String[] aParameterTokens = aParameters.split(",");¬∂			for (String aParameter:aParameterTokens) {¬∂				String aParameterTrimmed = aParameter.trim();¬∂				if (!aParameterTrimmed.isEmpty())¬∂				aParameterList.add(aParameterTrimmed);¬∂			}¬∂			retVal.add(new AMethodCall(aLineNumber, aMethodName, aParameterList, aParent));¬∂¬∂//			aCallStrings.add(find);¬∂		}¬∂		return retVal;¬∂	}¬∂	static String numberRegex = "(\\d+\\.\\d+)|(\\d+)";¬∂	static Pattern numberPattern = Pattern.compile(numberRegex);¬∂	public static List<String> numbersIn(String aString) {¬∂		if (aString == null)¬∂			return null;¬∂//		String regex = "(\\d+\\.\\d+)|(\\d+)";¬∂//¬∂//		Matcher m = Pattern.compile(regex).matcher(aString);¬∂		Matcher m =numberPattern.matcher(aString);¬∂¬∂¬∂		List<String> retVal = new ArrayList();¬∂¬∂		while (m.find()) {¬∂			retVal.add(m.group());¬∂		}¬∂		return retVal;¬∂	}¬∂¬∂	public static String subscriptIn(String aString) {¬∂		if (aString == null)¬∂			return null;¬∂		return StringUtils.substringBetween(aString, "[", "]");¬∂	}¬∂	static String[] emptyStringArray = {};¬∂	public static String[] subscriptsIn(String aString) {¬∂		if (aString == null)¬∂			return emptyStringArray;¬∂		return StringUtils.substringsBetween(aString, "[", "]");¬∂	}¬∂	static  String operatorRegex = "([+-/*///^])|([/(/)])";¬∂	static Pattern operatorPattern = Pattern.compile(operatorRegex);¬∂¬∂	public static List<String> operatorsIn(String aString) {¬∂		if (aString == null)¬∂			return null;¬∂//		String operatorRegex = "([+-/*///^])|([/(/)])";¬∂//¬∂//		Matcher m = Pattern.compile(operatorRegex).matcher(aString);¬∂		¬∂		Matcher m = operatorPattern.matcher(aString);¬∂¬∂¬∂		List<String> retVal = new ArrayList();¬∂¬∂		while (m.find()) {¬∂			retVal.add(m.group());¬∂		}¬∂		return retVal;¬∂	}¬∂	¬∂	public static int numberOfNestingFors (SNode anSNode) {¬∂		if (anSNode == null) {¬∂			return 0;¬∂		}¬∂		int retVal = numberOfNestingFors (anSNode.getParent()) ;¬∂¬∂		if (anSNode instanceof ForSNode) {¬∂			retVal++;¬∂		} else if (anSNode instanceof MethodSNode) {¬∂			List<MethodCall> aMethodCalls = ((MethodSNode) anSNode).getCalls();¬∂			int aMaxNestingLevel = 0;¬∂			for (MethodCall aMethodCall:aMethodCalls) {¬∂				MethodSNode aCallerMethodSNode = getDeclarationOfCalledMethod(anSNode, aMethodCall);¬∂				int aCallerNumberOfNestingFors = numberOfNestingFors(aCallerMethodSNode);¬∂				aMaxNestingLevel = Math.max(aCallerNumberOfNestingFors, aMaxNestingLevel);				¬∂			}¬∂			return retVal + aMaxNestingLevel;¬∂		}¬∂		return retVal;¬∂	}¬∂	public static boolean hasOperator (SNode anSNode, String anOperator) {¬∂		boolean retVal = false;¬∂		if (anSNode instanceof AssignmentSNode) {¬∂			AssignmentSNode anAssignmentSNode = (AssignmentSNode) anSNode;¬∂			 retVal = (anAssignmentSNode.getLhsOperators().contains(anOperator) || ¬∂					anAssignmentSNode.getRhsOperators().contains(anOperator)) ;¬∂			if (retVal) {¬∂				return retVal;¬∂			} else {¬∂				List<MethodCall> aMethodCalls = anAssignmentSNode.getRhsCalls();¬∂				for (MethodCall aMethodCall:aMethodCalls) {¬∂					MethodSNode aMethodSNode = getDeclarationOfCalledMethod(anSNode, aMethodCall);¬∂					retVal = hasOperator(aMethodSNode, anOperator);¬∂					if (retVal) {¬∂						return retVal;¬∂					}¬∂					¬∂				}¬∂				return false;¬∂			}¬∂			¬∂		}¬∂		for (SNode aChild:anSNode.getChildren()) {¬∂			retVal = hasOperator(aChild, anOperator);¬∂			if (retVal) {¬∂				return retVal;¬∂			}¬∂		}¬∂		return false;¬∂	}¬∂	public static boolean hasMethodCall (SNode anSNode, String anOperator) {¬∂		boolean retVal = false;¬∂		if (anSNode instanceof AssignmentSNode) {¬∂			AssignmentSNode anAssignmentSNode = (AssignmentSNode) anSNode;¬∂			 retVal = (anAssignmentSNode.getLhsOperators().contains(anOperator) || ¬∂					anAssignmentSNode.getRhsOperators().contains(anOperator)) ;¬∂			if (retVal) {¬∂				return retVal;¬∂			} else {¬∂				List<MethodCall> aMethodCalls = anAssignmentSNode.getRhsCalls();¬∂				for (MethodCall aMethodCall:aMethodCalls) {¬∂					MethodSNode aMethodSNode = getDeclarationOfCalledMethod(anSNode, aMethodCall);¬∂					retVal = hasOperator(aMethodSNode, anOperator);¬∂					if (retVal) {¬∂						return retVal;¬∂					}¬∂					¬∂				}¬∂				return false;¬∂			}¬∂			¬∂		}¬∂		for (SNode aChild:anSNode.getChildren()) {¬∂			retVal = hasOperator(aChild, anOperator);¬∂			if (retVal) {¬∂				return retVal;¬∂			}¬∂		}¬∂		return false;¬∂	}¬∂	public static boolean dependsOn (AssignmentSNode anAssignmentSNode, String aVariable, String aCallIdentifier) {¬∂		// This assignment does not change aVariable¬∂		if (!aVariable.equals(anAssignmentSNode.getLhsVariable())) {¬∂			return false;¬∂		}¬∂		return dependsOn(anAssignmentSNode.getExpressionSNode(), aCallIdentifier);¬∂//		List<String> aCallIdentifiers = anAssignmentSNode.getRhsCallIdentifiers();¬∂//		boolean retVal = false;¬∂//		if (aCallIdentifiers != null && aCallIdentifiers.contains(aCallIdentifier)) {¬∂//			return true; // this assignment has aCallIdentifier in the rhs¬∂//		}¬∂//		// check if some referenced rhs variable depends on aCallIdentifier¬∂//		List<String> aReferencedVariableIdentifiers = anAssignmentSNode.getRhsVariableIdentifiers();¬∂//		SNode anAssignmentParent = anAssignmentSNode.getParent();¬∂//		if (anAssignmentParent == null) { // should never be trye¬∂//			return false;¬∂//		}¬∂//		int aLineNumber = anAssignmentSNode.getLineNumber();¬∂//		for (String aReferencedVariableIdentifier:aReferencedVariableIdentifiers ) {¬∂//			if (dependsOn (anAssignmentParent, aLineNumber, aReferencedVariableIdentifier, aCallIdentifier)) {¬∂//				return true;¬∂//			}¬∂//		}¬∂//		return false;¬∂	}¬∂	public static boolean dependsOn (ExpressionSNode anExpressionSNode, String aCallIdentifier) {¬∂		// This assignment does not change aVariable¬∂		¬∂		List<String> aCallIdentifiers = anExpressionSNode.getRhsCallIdentifiers();¬∂		boolean retVal = false;¬∂		if (aCallIdentifiers != null && aCallIdentifiers.contains(aCallIdentifier)) {¬∂			return true; // this assignment has aCallIdentifier in the rhs¬∂		}¬∂		// check if some referenced rhs variable depends on aCallIdentifier¬∂		List<String> aReferencedVariableIdentifiers = anExpressionSNode.getRhsVariableIdentifiers();¬∂		SNode anAssignmentParent = anExpressionSNode.getParent().getParent();¬∂		if (anAssignmentParent == null) { // should never be trye¬∂			return false;¬∂		}¬∂		int aLineNumber = anExpressionSNode.getLineNumber();¬∂		for (String aReferencedVariableIdentifier:aReferencedVariableIdentifiers ) {¬∂			if (dependsOn (anAssignmentParent, aLineNumber, aReferencedVariableIdentifier, aCallIdentifier)) {¬∂				return true;¬∂			}¬∂		}¬∂		return false;¬∂	}¬∂	public static List<AssignmentSNode> assignmentsToSharedVariables(SNode anSNode) {¬∂		List<AssignmentSNode> retVal =  new ArrayList();¬∂		fillAssignmentsToShared(anSNode, retVal);¬∂		return retVal;¬∂		¬∂	}¬∂	public static List<AssignmentSNode> assignmentsToSharedArrays(SNode anSNode) {¬∂		List<AssignmentSNode> anAllSharedAssignments =  assignmentsToSharedVariables(anSNode);¬∂		List<AssignmentSNode> aRetVal = new ArrayList();¬∂		for (AssignmentSNode anAssignmentSNode:anAllSharedAssignments) {¬∂			if (anAssignmentSNode.getLhsSubscripts().length > 0) {¬∂				aRetVal.add(anAssignmentSNode);¬∂			}¬∂		}¬∂		return aRetVal;¬∂		¬∂	}¬∂	public static List<AssignmentSNode> assignmentsToParallelSharedCritical(SNode anSNode) {¬∂		List<AssignmentSNode> anAllSharedAssignments =  assignmentsToSharedVariables(anSNode);¬∂		List<AssignmentSNode> aRetVal = new ArrayList();¬∂		for (AssignmentSNode anAssignmentSNode:anAllSharedAssignments) {¬∂			if (anAssignmentSNode.isInParallel() &&¬∂					anAssignmentSNode.isInC"), Diff(INSERT,"ritical()"), Diff(EQUAL,") {¬∂				aRetVal.add(anAssignmentSNode);¬∂			}¬∂		}¬∂		return aRetVal;¬∂		¬∂	}¬∂    public static void fillAssignmentsToShared(SNode anSNode, List<AssignmentSNode> retVal) {¬∂    	if (anSNode instanceof AssignmentSNode) {¬∂			AssignmentSNode anAssignmentSNode = (AssignmentSNode) anSNode;¬∂			String anLHS = anAssignmentSNode.getLhsVariable();¬∂			if (isSharedVariable(anSNode, anLHS)) {¬∂				retVal.add(anAssignmentSNode);¬∂				return;¬∂			}¬∂		}¬∂    	for (SNode aChild:anSNode.getChildren()) {¬∂    		fillAssignmentsToShared(aChild, retVal);¬∂    	}¬∂		¬∂	}¬∂	public static boolean dependsOn (SNode anSNode, int aVariableLineNumber, String aVariable, String aCallIdentifier) {¬∂		List<SNode> aListSNodes = anSNode.getChildren();¬∂		boolean retVal = false;¬∂		/*¬∂		 * Should probably ignore line number as it assumes straight line code¬∂		 */¬∂		for (int i = aVariableLineNumber; i >= 0; i--) {¬∂			SNode anSNodeChild = aListSNodes.get(i);¬∂			if (anSNodeChild instanceof AssignmentSNode) {¬∂				// does this statement in anSNode directly invoke aCallIdentifier ¬∂				if (dependsOn((AssignmentSNode) anSNodeChild, aVariable, aCallIdentifier))¬∂					return true;¬∂			} else if (!anSNode.isLeaf()) {¬∂					// child is overriding the variable so forget checking its assignment statements¬∂					if (anSNodeChild.getLocalVariables().contains(aVariable)) {¬∂						continue;¬∂					}¬∂					// some subblock of anSNode that has access to aVariable changes variable¬∂¬∂					if (dependsOn(anSNodeChild, anSNodeChild.getChildren().size() - 1, aVariable, aCallIdentifier)) {¬∂						return true;¬∂					}¬∂			}¬∂			¬∂		}¬∂		// none of the statements in anSNode or its descendents  have the required call¬∂		// is the variable a  method parameter ¬∂		if (anSNode instanceof MethodSNode) {¬∂			MethodSNode aMethodSNode = (MethodSNode) anSNode;¬∂			¬∂			int aParameterNumber = aMethodSNode.getLocalVariables().indexOf(aVariable);¬∂			if (aParameterNumber != -1) {¬∂				List <MethodCall> aCalls = aMethodSNode.getCalls();¬∂				for (MethodCall aCall:aCalls) {¬∂					MethodSNode aCallerSNode = getDeclarationOfCalledMethod(aMethodSNode, aCall);¬∂					boolean aCallerDepends = dependsOn(aMethodSNode, aCallerSNode.getLineNumber(), aVariable, aCallIdentifier);¬∂				    if (aCallerDepends) {¬∂				    	return true;¬∂				    }¬∂				}¬∂				return false;¬∂				// need to find all callers of method and see if any of the aliases for the variable in these¬∂				// calls depend on aCallIndentifier¬∂			}			¬∂			¬∂		} else if (anSNode.getLocalVariables().contains(aVariable)) {¬∂			// before going to the parent node, let us see if aVariable is declared here as a non  parameter ¬∂¬∂			return false; // no point going to parent¬∂		}¬∂		// not a local variable (parameter or declarated variable)¬∂		SNode anSNodeParent = anSNode.getParent() ;¬∂		if (anSNodeParent == null)  {¬∂			return false;¬∂		}¬∂		int anSNodeLineNumber = anSNodeParent.getChildren().indexOf(anSNode);¬∂		return dependsOn(anSNodeParent, anSNodeLineNumber, aVariable, aCallIdentifier);¬∂		¬∂	}¬∂	public static RootOfFileSNode getRootOfFileNode(SNode aCurrentSNode ) {¬∂		if (aCurrentSNode instanceof RootOfFileSNode) {¬∂			return (RootOfFileSNode) aCurrentSNode;¬∂		}¬∂		SNode aParentSNode = aCurrentSNode.getParent() ;¬∂		¬∂		if (aParentSNode == null) {¬∂			return null;¬∂		}¬∂		¬∂		return getRootOfFileNode(aParentSNode);¬∂		¬∂	}¬∂	public static boolean match (MethodSNode aMethodSNode, MethodCall aMethodCall) {¬∂		return aMethodSNode.getMethodName().equals(aMethodCall.getMethodName()) ¬∂				&& aMethodSNode.getLocalVariables().size() == aMethodCall.getMethodActuals().size();¬∂	}¬∂	¬∂	public static MethodSNode getDeclarationOfCalledMethod(SNode aCurrentSNode, MethodCall aMethodCall ) {¬∂		SNode aRootNode = getRootOfFileNode(aCurrentSNode);¬∂		for (SNode aChild:aRootNode.getChildren()) {¬∂			if (aChild instanceof MethodSNode) {¬∂				MethodSNode aMethodSNode = (MethodSNode) aChild;¬∂				if (match (aMethodSNode, aMethodCall)) {¬∂					return aMethodSNode;¬∂				}¬∂			}¬∂		}¬∂		return null; // this should never happen;¬∂	}¬∂	¬∂	public static RootOfProgramSNode getRootOfProgramSNode(String aSource) {¬∂		RootOfProgramSNode retVal = new ARootOfProgramSNode();¬∂		Map<String, StringBuffer> aFileNameToContents = ABasicTextManager.extractFileContents(aSource);¬∂		for (String aFileName:aFileNameToContents.keySet()) {¬∂			StringBuffer aFileContents = aFileNameToContents.get(aFileName);¬∂//			List<OpenMPPragma> anOpenMPPragmas = OpenMPUtils.getOpemMPPragmas(aFileContents);¬∂			RootOfFileSNode anSNode = OMPSNodeUtils.getSNode(aFileName, aFileContents);¬∂			retVal.getFileNameToSNode().put(aFileName, anSNode);¬∂			anSNode.setParent(retVal);¬∂//			System.out.println("file name:" + aFileName);¬∂//			System.out.println("pragmas:" + anSNode);¬∂		}¬∂		processExternalMethodSNodes(retVal);¬∂		return retVal;¬∂	}¬∂	public static void processExternalMethodSNodes (RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode) {¬∂		for (SNode anSNode:aRootOfFileSNode.getChildren()) {¬∂			if (anSNode instanceof ExternalMethodSNode) {¬∂				processExternalMethodSNode(aRootOfProgramSNode, aRootOfFileSNode, (ExternalMethodSNode) anSNode);¬∂			}¬∂		}¬∂	}¬∂	public static void processExternalMethodSNode (RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode, ExternalMethodSNode anExternalMethodSNode) {¬∂		MethodSNode aMethodSNode = aRootOfProgramSNode.getExternalToInternalMethod().get(anExternalMethodSNode.toString());¬∂		if (aMethodSNode == null) {¬∂			aMethodSNode = findMethodSNode(aRootOfProgramSNode, aRootOfFileSNode, anExternalMethodSNode);¬∂			if (aMethodSNode != null) {¬∂				aRootOfProgramSNode.getExternalToInternalMethod().put(anExternalMethodSNode.toString(),aMethodSNode );¬∂			}¬∂		}¬∂		if (aMethodSNode != null) {¬∂			anExternalMethodSNode.setActualMethodSNode(aMethodSNode);¬∂			aMethodSNode.getCalls().addAll(anExternalMethodSNode.getLocalCalls());¬∂		}¬∂	}¬∂	public static MethodSNode findMethodSNode (RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode, ExternalMethodSNode anExternalMethodSNode) {¬∂//		MethodSNode foundMethodSNode = null;¬∂		for (String aFileName:aRootOfProgramSNode.getFileNameToSNode().keySet()) {¬∂			if (aFileName.equals(aRootOfFileSNode.getFileName()))¬∂				continue;¬∂			¬∂			RootOfFileSNode aSearchedRootOfFileSNode = aRootOfProgramSNode.getFileNameToSNode().get(aFileName);¬∂			 for (SNode anSNode:aSearchedRootOfFileSNode.getChildren()) {¬∂				if (anSNode instanceof MethodSNode && !(anSNode instanceof ExternalMethodSNode)) {¬∂					if (anSNode.toString().equals(anExternalMethodSNode.toString())) {¬∂						return (MethodSNode) anSNode;¬∂						¬∂					}¬∂//					processExternalMethodSNode(aRootOfProgramSNode, aRootOfFileSNode, (ExternalMethodSNode) anSNode);¬∂				}¬∂			}¬∂		}¬∂		return null;¬∂	}¬∂	public static void processExternalMethodSNodes (RootOfProgramSNode aRootOfProgramSNode) {¬∂		for (String aFileName:aRootOfProgramSNode.getFileNameToSNode().keySet()) {¬∂			RootOfFileSNode aRootOfFileSNode = aRootOfProgramSNode.getFileNameToSNode().get(aFileName);¬∂			processExternalMethodSNodes(aRootOfProgramSNode, aRootOfFileSNode);¬∂			aRootOfFileSNode.getOmp_get_num_threads_SNode().¬∂				setActualMethodSNode(aRootOfProgramSNode.getOmp_get_num_threads_SNode());¬∂			aRootOfFileSNode.getOmp_get_thread_num_SNode().¬∂				setActualMethodSNode(aRootOfProgramSNode.getOmp_get_thread_num_SNode());¬∂			aRootOfFileSNode.getOmp_get_wtime_SNode().¬∂			setActualMethodSNode(aRootOfProgramSNode.getOmp_get_wtime_SNode());¬∂		}¬∂¬∂	}¬∂	¬∂¬∂//	public static void main(String[] args) {¬∂//		List<MethodCall> aTokens = callsIn("foo(bar, hgf)/foo2()*foo3(b, a c,)");¬∂//		System.out.println(aTokens);¬∂//		¬∂//		¬∂////		List<String> aTokens = identifiersIn("a[i] + b*2/3");¬∂////		System.out.println(aTokens);¬∂////		aTokens = numbersIn("a[i] + b*2/3");¬∂////		System.out.println(aTokens);¬∂////		aTokens = operatorsIn("a[i] + b*2/3");¬∂////		System.out.println(aTokens);¬∂////¬∂////		System.out.println(StringUtils.substringBetween("a", "[", "]"));¬∂//	}¬∂¬∂}¬∂")]]]></diff>
    <snapshot><![CDATA[package gradingTools.shared.testcases.openmp.scannedTree;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Stack;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.apache.commons.lang.StringUtils;

import grader.basics.project.source.ABasicTextManager;
import gradingTools.shared.testcases.openmp.OpenMPKeywordEnum;
import gradingTools.shared.testcases.openmp.OpenMPParallelPragma;
import gradingTools.shared.testcases.openmp.OpenMPUtils;
import gradingTools.shared.testcases.openmp.scannedTree.ADeclarationSNode;
import gradingTools.shared.testcases.openmp.scannedTree.ADeclaringAssignmentSNode;
import gradingTools.shared.testcases.openmp.scannedTree.AForSNode;
import gradingTools.shared.testcases.openmp.scannedTree.ATextSNode;
import gradingTools.shared.testcases.openmp.scannedTree.AnAssignmentSNode;
import gradingTools.shared.testcases.openmp.scannedTree.AnOMPCriticalSNode;
import gradingTools.shared.testcases.openmp.scannedTree.AnOMPForSNode;
import gradingTools.shared.testcases.openmp.scannedTree.AnOMPParallelSNode;
import gradingTools.shared.testcases.openmp.scannedTree.AnOMPSNode;
import gradingTools.shared.testcases.openmp.scannedTree.AnSNode;
import gradingTools.shared.testcases.openmp.scannedTree.AssignmentSNode;
import gradingTools.shared.testcases.openmp.scannedTree.DeclarationSNode;
import gradingTools.shared.testcases.openmp.scannedTree.DeclaringAssignmentSNode;
import gradingTools.shared.testcases.openmp.scannedTree.ForSNode;
import gradingTools.shared.testcases.openmp.scannedTree.OMPForSNode;
import gradingTools.shared.testcases.openmp.scannedTree.OMPSNode;
import gradingTools.shared.testcases.openmp.scannedTree.SNode;

public class OMPSNodeUtils extends OpenMPUtils {

	public static RootOfFileSNode getSNode(String aFileName, StringBuffer aFileBuffer) {
		String[] aFileLines = aFileBuffer.toString().split("\n");
		return getSNode(aFileName, aFileLines);
	}

	public static AssignmentSNode getAssignmentSNode(int aLineNumber, String aString) {
		if (aString == null) {
			return null;
		}
		String[] aTokens = aString.split("=");
		if (aTokens.length == 1) {
			return new AnAssignmentSNode(aLineNumber, aTokens[0], null);
		} else {
		return new AnAssignmentSNode(aLineNumber, aTokens[0], aTokens[1]);
		}
	}

	public static DeclarationSNode getDeclarationSNode(int aLineNumber, String aString) {
		String[] aTokens = aString.split(" ");
		return new ADeclarationSNode(aLineNumber, aTokens[0], aTokens[1]);
	}

	public static DeclaringAssignmentSNode getDeclaringAssignmentSNode(int aLineNumber, String aString) {
		String[] anLHSAndRHS = aString.split("=");
		String[] aTypeAndVariable = anLHSAndRHS[0].split(" ");
		return new ADeclaringAssignmentSNode(aLineNumber, aTypeAndVariable[0], aTypeAndVariable[1], anLHSAndRHS[1]);
	}

	public static boolean isDeclaringAssignment(String aFileLine) {
		return startsWithTypeName(aFileLine) && aFileLine.contains("=");
	}
	public static boolean isMethodDeclaration(String aFileLine) {
		return startsWithTypeName(aFileLine) && 
				aFileLine.contains("(") &&
				!aFileLine.contains("=");
	}
	public static boolean isExternalMethodDeclaration(String aFileLine) {
		return isMethodDeclaration(aFileLine) && aFileLine.endsWith(";");
	}


	public static boolean isVariableDeclaration(String aFileLine) {

		return startsWithTypeName(aFileLine) && !aFileLine.contains("(");
	}

	public static boolean isAssignment(String aFileLine) {
		return aFileLine.contains("=");
	}

	public static boolean isForNode(String aFileLine) {
		return aFileLine.startsWith("for");
	}

	public static ForSNode getForSNode(int aLineNumber, String aFileLine) {

		int aLeftParenIndex = aFileLine.indexOf("(");
		int aRightParenIndex = aFileLine.indexOf(")");
		if (aLeftParenIndex < 0 || aRightParenIndex < 0) {
			return null;
		}
		String aHeaderString = aFileLine.substring(aLeftParenIndex + 1, aRightParenIndex);
		String[] aForComponents = aHeaderString.split(";");
		AssignmentSNode anAssignmentSNode = null;
		String aForInitializaton = aForComponents[0];
		if (!aForInitializaton.isEmpty() && aForInitializaton.contains("=")) {
			if (isDeclaringAssignment(aForInitializaton)) {
				anAssignmentSNode = getDeclaringAssignmentSNode(aLineNumber, aForInitializaton);
			} else {
				anAssignmentSNode = getAssignmentSNode(aLineNumber, aForInitializaton);
			}

		}		
		return new AForSNode(aLineNumber, anAssignmentSNode, aForComponents[1], getAssignmentSNode(aLineNumber, aForComponents[2]));
	}
	static String[] emptyArray = {};
	public static MethodSNode getMethodSNode(int aLineNumber, String aFileLine, boolean isInternal) {

		int aLeftParenIndex = aFileLine.indexOf("(");
		int aRightParenIndex = aFileLine.indexOf(")");
		if (aLeftParenIndex < 0 || aRightParenIndex < 0) {
			return null;
		}
		String aMethodNameAndType = aFileLine.substring(0, aLeftParenIndex);
		String[] aMethodNameAndTypeTokens = aMethodNameAndType.split("\\s+"); 
		
		String aMethodParameters = aFileLine.substring(aLeftParenIndex +1 , aRightParenIndex);
		String[] aMethodParameterTokens = aMethodParameters.isEmpty()?emptyArray:
		 aMethodParameters.split(",");
		
//		String[] aMethodParameterTypes = new String[aMethodParameterTokens.length];
//		String[] aMethodParameterNames = new String[aMethodParameterTokens.length];
		List<DeclarationSNode> aDeclarationSNodeList = new ArrayList();
		for (int i = 0; i < aMethodParameterTokens.length; i++ ) {
			String[] aTypeAndName = aMethodParameterTokens[i].trim().split("\\s+");
			if (aTypeAndName.length < 2) {
				continue;
			}
			aDeclarationSNodeList.add(new ADeclarationSNode(aLineNumber, aTypeAndName[0].trim(), aTypeAndName[1].trim()));
//			aMethodParameterTypes[i] = aTypeAndName[0].trim();
//			aMethodParameterNames[i] = aTypeAndName[1].trim();
		}
		if (isInternal)
//		return new AMethodSNode(aLineNumber, aMethodNameAndTypeTokens[0], aMethodNameAndTypeTokens[1], aMethodParameterTypes,aMethodParameterNames );
			return new AMethodSNode(aLineNumber, aMethodNameAndTypeTokens[0], aMethodNameAndTypeTokens[1], aDeclarationSNodeList );
		else
			return new AnExternalMethodSNode(aLineNumber, aMethodNameAndTypeTokens[0], aMethodNameAndTypeTokens[1], aDeclarationSNodeList );
	}

	public static void setReductionData(OMPForSNode lastChild, String aStoredToken, int aLeftParenIndex,
			int aRightParenIndex) {
		int aColonIndex = aStoredToken.indexOf(":");
		if (aLeftParenIndex != -1 && aRightParenIndex != -1 && aColonIndex != -1) {
			String anOperationString = aStoredToken.substring(aLeftParenIndex + 1, aColonIndex).trim();
			String aVariableString = aStoredToken.substring(aColonIndex + 1, aRightParenIndex).trim();
			((OMPForSNode) lastChild).setReductionVariable(aVariableString);
			((OMPForSNode) lastChild).setReductionOperation(anOperationString);
		}
	}

	public static void setSharedOrPrivateData(OMPSNode lastChild, String aStoredToken, int aLeftParenIndex,
			int aRightParenIndex, boolean isShared) {
//		int aColonIndex = aStoredToken.indexOf(":");
		if (aLeftParenIndex != -1 && aRightParenIndex != -1) {
			String aVariableDeclarations = aStoredToken.substring(aLeftParenIndex + 1, aRightParenIndex);
			String[] aVariables = aVariableDeclarations.split(",");
			if (isShared) {
				lastChild.setSharedVariables(aVariables);
			} else {
				lastChild.setPrivateVariables(aVariables);
			}
		}
	}

	public static RootOfFileSNode getSNode(String aFileName, String[] aFileLines) {
		Stack<SNode> anSNodes = new Stack();

		RootOfFileSNode retVal = new ARootOfFileSNode(aFileName);
		anSNodes.add(retVal);
		SNode previousHeaderNode = null;
		for (int i = 0; i < aFileLines.length; i++) {
			String aFileLine = aFileLines[i].trim();
			if (!isCodeLine(aFileLine)) {
				continue;
			}
			if (isForNode(aFileLine)) {
				ForSNode aForSNode = getForSNode(i, aFileLine);
				aForSNode.setParent(anSNodes.peek());
//				anSNodes.push(aForSNode);
				previousHeaderNode = aForSNode;
				if (aFileLine.endsWith(")")) {
					continue;
				}
			}
			if (isExternalMethodDeclaration(aFileLine)) {
				MethodSNode aMethodSNode = getMethodSNode(i, aFileLine, false);
				aMethodSNode.setParent(anSNodes.peek());
//				anSNodes.push(aForSNode);
				previousHeaderNode = aMethodSNode;
				if (aFileLine.endsWith(")")) {
					continue;
				}
			}
			if (isMethodDeclaration(aFileLine)) {
				MethodSNode aMethodSNode = getMethodSNode(i, aFileLine, true);
				aMethodSNode.setParent(anSNodes.peek());
//				anSNodes.push(aForSNode);
				previousHeaderNode = aMethodSNode;
				if (aFileLine.endsWith(")")) {
					continue;
				}
			}
			if (isPragmaStart(aFileLine)) {
				OMPSNode anOMPSNode = getOMPSNode(i, anSNodes.peek(), aFileLine);
//				anSNodes.push(anOMPSNode);
				previousHeaderNode = anOMPSNode;
				continue;
			}
			if (isBlockStart(aFileLine)) {
				SNode aBlockSNode = new AnSNode(i);
				if (previousHeaderNode != null) {
					aBlockSNode.setParent(previousHeaderNode);
				} else {
					aBlockSNode.setParent(anSNodes.peek());
				}
				anSNodes.push(aBlockSNode);
				previousHeaderNode = null;
				continue;
			}
//			} else 
			if (isBlockEnd(aFileLine)) {
				anSNodes.pop();
				continue;
			}
			SNode aNewLeafNode = null;
			if (isDeclaringAssignment(aFileLine)) {
				aNewLeafNode = getDeclaringAssignmentSNode(i, aFileLine);

			} else if (isAssignment(aFileLine)) {
				aNewLeafNode = getAssignmentSNode(i, aFileLine);
			} else if (isVariableDeclaration(aFileLine)) {
				aNewLeafNode = getDeclarationSNode(i, aFileLine);
			} else {
				List<MethodCall> aCalls = callsIn(i, aFileLine, null); // parent will be assigned below
				if (aCalls != null && aCalls.size() == 1) {
					aNewLeafNode = aCalls.get(0);
				} else {
					aNewLeafNode = new ATextSNode(i, aFileLine);
				}
			}
//			else {
//				aNewLeafNode = new ATextSNode(i, aFileLine);
//			}
			if (previousHeaderNode != null) {
				aNewLeafNode.setParent(previousHeaderNode);
			} else {
				aNewLeafNode.setParent(anSNodes.peek());
			}

		}

		return retVal;
	}

	public static OMPSNode getOMPSNode(int aLineIndex, SNode aParentNode, String aFileLine) {
		String[] aTokens = aFileLine.split("\\s+");
		if (aTokens.length <= 2) {
			return null;
		}
		if (!aTokens[1].equals("omp")) {
			return null;
		}
		if (aTokens.length < 3) {
			return null;
		}
		String aFirstToken = aTokens[2];
		OpenMPKeywordEnum anOpenMPKeyword = stringToOpenMPKeyword.get(aFirstToken);
//		List<OpenMPPragma> retVal = new ArrayList();
		OMPSNode lastChild = null;
		int aStartIndex = 2;
		OMPSNode aNewNode = null;
		OMPForSNode aForChild = null;
		switch (anOpenMPKeyword) {
		case PARALLEL:
			aNewNode = new AnOMPParallelSNode(aLineIndex);

			if (aTokens.length > 3 && aTokens[3].equals("for")) {
				aForChild = new AnOMPForSNode(aLineIndex);
				aForChild.setParent(aNewNode);

				aStartIndex++;
			}
			break;
		case FOR:
			aNewNode = new AnOMPForSNode(aLineIndex);
			;
			break;
		case CRITICAL:
			aNewNode = new AnOMPCriticalSNode(aLineIndex);
//			retVal.add (lastChild);
			break;
		default:
			aNewNode = new AnOMPSNode(aLineIndex);

		}

		if (lastChild != null) {
			aNewNode.setParent(lastChild);
		} else {
			aNewNode.setParent(aParentNode);
		}
		lastChild = aForChild == null ? aNewNode : aForChild;

		for (int i = aStartIndex; i < aTokens.length; i++) {
			String aStoredToken = aTokens[i].trim();
			if (aStoredToken.isEmpty()) {
				continue;
			}
			if (aStoredToken.startsWith("reduction") || aStoredToken.startsWith("shared")
					|| aStoredToken.startsWith("private")) {
				// combine all tokens until ")" into one for normalization
				while (!aStoredToken.endsWith(")")) {
					i++;
					if (i >= aTokens.length) {
						break;
					}
					String aNewToken = aTokens[i].trim();
					aStoredToken += aNewToken;
				}
				int aLeftParenIndex = aStoredToken.indexOf("(");
				int aRightParenIndex = aStoredToken.indexOf(")");
				if (aStoredToken.startsWith("reduction")) {
					setReductionData((OMPForSNode) lastChild, aStoredToken, aLeftParenIndex, aRightParenIndex);
				} else if (aStoredToken.startsWith("private")) {
					setSharedOrPrivateData((OMPSNode) lastChild, aStoredToken, aLeftParenIndex, aRightParenIndex,
							false);

				} else if (aStoredToken.startsWith("shared")) {
					setSharedOrPrivateData(lastChild, aStoredToken, aLeftParenIndex, aRightParenIndex, true);

				}

			}

			lastChild.getOpenMPTokens().add(aStoredToken);
		}

		return lastChild;

	}

	public static boolean hasParallelAncestor(SNode anSNode) {
		if (anSNode == null) {
			return false;
		}
		if (anSNode instanceof OMPParallelSNode) {
			return true;
		}
		return hasParallelAncestor(anSNode.getParent());
	}
	public static boolean hasCriticalAncestor(SNode anSNode) {
		if (anSNode == null) {
			return false;
		}
		if (anSNode instanceof OMPCriticalSNode) {
			return true;
		}
		return hasCriticalAncestor(anSNode.getParent());
	}


	public static Boolean isDeclaredShared(OMPSNode anOMPSNode, String anLHS) {
		if (Arrays.asList(anOMPSNode.getSharedVariables()).contains(anLHS)) {
			return true;
		}
		if (Arrays.asList(anOMPSNode.getPrivateVariables()).contains(anLHS)) {
			return false;
		}
		return null;

	}

	public static boolean isSharedVariable(SNode anSNode, String anLHS) {
		if (anSNode == null) {
			return false;
		}
		if (anSNode.getLocalVariables().contains(anLHS)) {
			if (!(anSNode instanceof OMPSNode)) { // no shared and private declarations
				return !hasParallelAncestor(anSNode); // shared if not inParallel
			}
			OMPSNode anOMPSNode = (OMPSNode) anSNode;
			return (Arrays.asList(anOMPSNode.getSharedVariables()).contains(anLHS)); // private unless declared shared
		}
		if (anSNode instanceof OMPSNode) {
			OMPSNode anOMPSNode = (OMPSNode) anSNode;
			// the variable is global to this scope, check if it has have been made shared
			// or private by this scope
			Boolean isDeclaredShared = isDeclaredShared(anOMPSNode, anLHS);
			if (isDeclaredShared != null) {
				return isDeclaredShared;
			}
		}
		// check the parent
		return isSharedVariable(anSNode.getParent(), anLHS);
	}

	public static List<SNode> getAllLeafNodes(SNode aTopNode) {
		List<SNode> retVal = new ArrayList();
		addLeafNodes(aTopNode, retVal);
		return retVal;
	}

	public static void addLeafNodes(SNode aTopNode, List<SNode> retVal) {
		for (SNode aChild : aTopNode.getChildren()) {
			if (aChild.isLeaf()) {
				retVal.add(aChild);
			} else {
				addLeafNodes(aChild, retVal);
			}
		}
	}

	public static List<SNode> getNonParallelLeafNodes(SNode aTopNode) {
		List<SNode> retVal = new ArrayList();
		addNonParallelLeafNodes(aTopNode, retVal);
		return retVal;
	}

	public static void addNonParallelLeafNodes(SNode aTopNode, List<SNode> retVal) {
		if (aTopNode.isInParallel()) {
			return;
		}
		for (SNode aChild : aTopNode.getChildren()) {
			if (aChild.isLeaf()) {
				retVal.add(aChild);
			} else {
				addLeafNodes(aChild, retVal);
			}
		}
	}
	static String callRegex = "([a-zA-Z_$][a-zA-Z_$0-9]*)\\(.*?\\)";
	static Pattern callPattern = Pattern.compile(callRegex);

	static String identifierRegex = "[a-zA-Z_$][a-zA-Z_$0-9]*";
	static Pattern identifierPattern = Pattern.compile(identifierRegex);
	public static List<String> identifiersIn(String aString) {
		if (aString == null)
			return null;
//		Pattern mypattern = Pattern.compile("[a-zA-Z_$][a-zA-Z_$0-9]*");
//		Matcher mymatcher = mypattern.matcher(aString);
		Matcher mymatcher = identifierPattern.matcher(aString);
		List<String> retVal = new ArrayList();
		while (mymatcher.find()) {
			String find = mymatcher.group(0);
			retVal.add(find);
		}
		return retVal;
	}
	public static List<MethodCall> callsIn(int aLineNumber, String aString, SNode aParent) {
		if (aString == null)
			return null;
//		Pattern mypattern = Pattern.compile("[a-zA-Z_$][a-zA-Z_$0-9]*");
//		Matcher mymatcher = mypattern.matcher(aString);
		Matcher mymatcher = callPattern.matcher(aString);
		List<MethodCall> retVal = new ArrayList();
		while (mymatcher.find()) {
			String find = mymatcher.group(0);
			int aLeftParenIndex = find.indexOf("(");
			int aRightParenIndex = find.indexOf(")");
			String aMethodName = find.substring(0, aLeftParenIndex).trim();
			String aParameters = find.substring(aLeftParenIndex + 1, aRightParenIndex);
			List<String> aParameterList = new ArrayList();
			String[] aParameterTokens = aParameters.split(",");
			for (String aParameter:aParameterTokens) {
				String aParameterTrimmed = aParameter.trim();
				if (!aParameterTrimmed.isEmpty())
				aParameterList.add(aParameterTrimmed);
			}
			retVal.add(new AMethodCall(aLineNumber, aMethodName, aParameterList, aParent));

//			aCallStrings.add(find);
		}
		return retVal;
	}
	static String numberRegex = "(\\d+\\.\\d+)|(\\d+)";
	static Pattern numberPattern = Pattern.compile(numberRegex);
	public static List<String> numbersIn(String aString) {
		if (aString == null)
			return null;
//		String regex = "(\\d+\\.\\d+)|(\\d+)";
//
//		Matcher m = Pattern.compile(regex).matcher(aString);
		Matcher m =numberPattern.matcher(aString);


		List<String> retVal = new ArrayList();

		while (m.find()) {
			retVal.add(m.group());
		}
		return retVal;
	}

	public static String subscriptIn(String aString) {
		if (aString == null)
			return null;
		return StringUtils.substringBetween(aString, "[", "]");
	}
	static String[] emptyStringArray = {};
	public static String[] subscriptsIn(String aString) {
		if (aString == null)
			return emptyStringArray;
		return StringUtils.substringsBetween(aString, "[", "]");
	}
	static  String operatorRegex = "([+-/*///^])|([/(/)])";
	static Pattern operatorPattern = Pattern.compile(operatorRegex);

	public static List<String> operatorsIn(String aString) {
		if (aString == null)
			return null;
//		String operatorRegex = "([+-/*///^])|([/(/)])";
//
//		Matcher m = Pattern.compile(operatorRegex).matcher(aString);
		
		Matcher m = operatorPattern.matcher(aString);


		List<String> retVal = new ArrayList();

		while (m.find()) {
			retVal.add(m.group());
		}
		return retVal;
	}
	
	public static int numberOfNestingFors (SNode anSNode) {
		if (anSNode == null) {
			return 0;
		}
		int retVal = numberOfNestingFors (anSNode.getParent()) ;

		if (anSNode instanceof ForSNode) {
			retVal++;
		} else if (anSNode instanceof MethodSNode) {
			List<MethodCall> aMethodCalls = ((MethodSNode) anSNode).getCalls();
			int aMaxNestingLevel = 0;
			for (MethodCall aMethodCall:aMethodCalls) {
				MethodSNode aCallerMethodSNode = getDeclarationOfCalledMethod(anSNode, aMethodCall);
				int aCallerNumberOfNestingFors = numberOfNestingFors(aCallerMethodSNode);
				aMaxNestingLevel = Math.max(aCallerNumberOfNestingFors, aMaxNestingLevel);				
			}
			return retVal + aMaxNestingLevel;
		}
		return retVal;
	}
	public static boolean hasOperator (SNode anSNode, String anOperator) {
		boolean retVal = false;
		if (anSNode instanceof AssignmentSNode) {
			AssignmentSNode anAssignmentSNode = (AssignmentSNode) anSNode;
			 retVal = (anAssignmentSNode.getLhsOperators().contains(anOperator) || 
					anAssignmentSNode.getRhsOperators().contains(anOperator)) ;
			if (retVal) {
				return retVal;
			} else {
				List<MethodCall> aMethodCalls = anAssignmentSNode.getRhsCalls();
				for (MethodCall aMethodCall:aMethodCalls) {
					MethodSNode aMethodSNode = getDeclarationOfCalledMethod(anSNode, aMethodCall);
					retVal = hasOperator(aMethodSNode, anOperator);
					if (retVal) {
						return retVal;
					}
					
				}
				return false;
			}
			
		}
		for (SNode aChild:anSNode.getChildren()) {
			retVal = hasOperator(aChild, anOperator);
			if (retVal) {
				return retVal;
			}
		}
		return false;
	}
	public static boolean hasMethodCall (SNode anSNode, String anOperator) {
		boolean retVal = false;
		if (anSNode instanceof AssignmentSNode) {
			AssignmentSNode anAssignmentSNode = (AssignmentSNode) anSNode;
			 retVal = (anAssignmentSNode.getLhsOperators().contains(anOperator) || 
					anAssignmentSNode.getRhsOperators().contains(anOperator)) ;
			if (retVal) {
				return retVal;
			} else {
				List<MethodCall> aMethodCalls = anAssignmentSNode.getRhsCalls();
				for (MethodCall aMethodCall:aMethodCalls) {
					MethodSNode aMethodSNode = getDeclarationOfCalledMethod(anSNode, aMethodCall);
					retVal = hasOperator(aMethodSNode, anOperator);
					if (retVal) {
						return retVal;
					}
					
				}
				return false;
			}
			
		}
		for (SNode aChild:anSNode.getChildren()) {
			retVal = hasOperator(aChild, anOperator);
			if (retVal) {
				return retVal;
			}
		}
		return false;
	}
	public static boolean dependsOn (AssignmentSNode anAssignmentSNode, String aVariable, String aCallIdentifier) {
		// This assignment does not change aVariable
		if (!aVariable.equals(anAssignmentSNode.getLhsVariable())) {
			return false;
		}
		return dependsOn(anAssignmentSNode.getExpressionSNode(), aCallIdentifier);
//		List<String> aCallIdentifiers = anAssignmentSNode.getRhsCallIdentifiers();
//		boolean retVal = false;
//		if (aCallIdentifiers != null && aCallIdentifiers.contains(aCallIdentifier)) {
//			return true; // this assignment has aCallIdentifier in the rhs
//		}
//		// check if some referenced rhs variable depends on aCallIdentifier
//		List<String> aReferencedVariableIdentifiers = anAssignmentSNode.getRhsVariableIdentifiers();
//		SNode anAssignmentParent = anAssignmentSNode.getParent();
//		if (anAssignmentParent == null) { // should never be trye
//			return false;
//		}
//		int aLineNumber = anAssignmentSNode.getLineNumber();
//		for (String aReferencedVariableIdentifier:aReferencedVariableIdentifiers ) {
//			if (dependsOn (anAssignmentParent, aLineNumber, aReferencedVariableIdentifier, aCallIdentifier)) {
//				return true;
//			}
//		}
//		return false;
	}
	public static boolean dependsOn (ExpressionSNode anExpressionSNode, String aCallIdentifier) {
		// This assignment does not change aVariable
		
		List<String> aCallIdentifiers = anExpressionSNode.getRhsCallIdentifiers();
		boolean retVal = false;
		if (aCallIdentifiers != null && aCallIdentifiers.contains(aCallIdentifier)) {
			return true; // this assignment has aCallIdentifier in the rhs
		}
		// check if some referenced rhs variable depends on aCallIdentifier
		List<String> aReferencedVariableIdentifiers = anExpressionSNode.getRhsVariableIdentifiers();
		SNode anAssignmentParent = anExpressionSNode.getParent().getParent();
		if (anAssignmentParent == null) { // should never be trye
			return false;
		}
		int aLineNumber = anExpressionSNode.getLineNumber();
		for (String aReferencedVariableIdentifier:aReferencedVariableIdentifiers ) {
			if (dependsOn (anAssignmentParent, aLineNumber, aReferencedVariableIdentifier, aCallIdentifier)) {
				return true;
			}
		}
		return false;
	}
	public static List<AssignmentSNode> assignmentsToSharedVariables(SNode anSNode) {
		List<AssignmentSNode> retVal =  new ArrayList();
		fillAssignmentsToShared(anSNode, retVal);
		return retVal;
		
	}
	public static List<AssignmentSNode> assignmentsToSharedArrays(SNode anSNode) {
		List<AssignmentSNode> anAllSharedAssignments =  assignmentsToSharedVariables(anSNode);
		List<AssignmentSNode> aRetVal = new ArrayList();
		for (AssignmentSNode anAssignmentSNode:anAllSharedAssignments) {
			if (anAssignmentSNode.getLhsSubscripts().length > 0) {
				aRetVal.add(anAssignmentSNode);
			}
		}
		return aRetVal;
		
	}
	public static List<AssignmentSNode> assignmentsToParallelSharedCritical(SNode anSNode) {
		List<AssignmentSNode> anAllSharedAssignments =  assignmentsToSharedVariables(anSNode);
		List<AssignmentSNode> aRetVal = new ArrayList();
		for (AssignmentSNode anAssignmentSNode:anAllSharedAssignments) {
			if (anAssignmentSNode.isInParallel() &&
					anAssignmentSNode.isInCritical()) {
				aRetVal.add(anAssignmentSNode);
			}
		}
		return aRetVal;
		
	}
    public static void fillAssignmentsToShared(SNode anSNode, List<AssignmentSNode> retVal) {
    	if (anSNode instanceof AssignmentSNode) {
			AssignmentSNode anAssignmentSNode = (AssignmentSNode) anSNode;
			String anLHS = anAssignmentSNode.getLhsVariable();
			if (isSharedVariable(anSNode, anLHS)) {
				retVal.add(anAssignmentSNode);
				return;
			}
		}
    	for (SNode aChild:anSNode.getChildren()) {
    		fillAssignmentsToShared(aChild, retVal);
    	}
		
	}
	public static boolean dependsOn (SNode anSNode, int aVariableLineNumber, String aVariable, String aCallIdentifier) {
		List<SNode> aListSNodes = anSNode.getChildren();
		boolean retVal = false;
		/*
		 * Should probably ignore line number as it assumes straight line code
		 */
		for (int i = aVariableLineNumber; i >= 0; i--) {
			SNode anSNodeChild = aListSNodes.get(i);
			if (anSNodeChild instanceof AssignmentSNode) {
				// does this statement in anSNode directly invoke aCallIdentifier 
				if (dependsOn((AssignmentSNode) anSNodeChild, aVariable, aCallIdentifier))
					return true;
			} else if (!anSNode.isLeaf()) {
					// child is overriding the variable so forget checking its assignment statements
					if (anSNodeChild.getLocalVariables().contains(aVariable)) {
						continue;
					}
					// some subblock of anSNode that has access to aVariable changes variable

					if (dependsOn(anSNodeChild, anSNodeChild.getChildren().size() - 1, aVariable, aCallIdentifier)) {
						return true;
					}
			}
			
		}
		// none of the statements in anSNode or its descendents  have the required call
		// is the variable a  method parameter 
		if (anSNode instanceof MethodSNode) {
			MethodSNode aMethodSNode = (MethodSNode) anSNode;
			
			int aParameterNumber = aMethodSNode.getLocalVariables().indexOf(aVariable);
			if (aParameterNumber != -1) {
				List <MethodCall> aCalls = aMethodSNode.getCalls();
				for (MethodCall aCall:aCalls) {
					MethodSNode aCallerSNode = getDeclarationOfCalledMethod(aMethodSNode, aCall);
					boolean aCallerDepends = dependsOn(aMethodSNode, aCallerSNode.getLineNumber(), aVariable, aCallIdentifier);
				    if (aCallerDepends) {
				    	return true;
				    }
				}
				return false;
				// need to find all callers of method and see if any of the aliases for the variable in these
				// calls depend on aCallIndentifier
			}			
			
		} else if (anSNode.getLocalVariables().contains(aVariable)) {
			// before going to the parent node, let us see if aVariable is declared here as a non  parameter 

			return false; // no point going to parent
		}
		// not a local variable (parameter or declarated variable)
		SNode anSNodeParent = anSNode.getParent() ;
		if (anSNodeParent == null)  {
			return false;
		}
		int anSNodeLineNumber = anSNodeParent.getChildren().indexOf(anSNode);
		return dependsOn(anSNodeParent, anSNodeLineNumber, aVariable, aCallIdentifier);
		
	}
	public static RootOfFileSNode getRootOfFileNode(SNode aCurrentSNode ) {
		if (aCurrentSNode instanceof RootOfFileSNode) {
			return (RootOfFileSNode) aCurrentSNode;
		}
		SNode aParentSNode = aCurrentSNode.getParent() ;
		
		if (aParentSNode == null) {
			return null;
		}
		
		return getRootOfFileNode(aParentSNode);
		
	}
	public static boolean match (MethodSNode aMethodSNode, MethodCall aMethodCall) {
		return aMethodSNode.getMethodName().equals(aMethodCall.getMethodName()) 
				&& aMethodSNode.getLocalVariables().size() == aMethodCall.getMethodActuals().size();
	}
	
	public static MethodSNode getDeclarationOfCalledMethod(SNode aCurrentSNode, MethodCall aMethodCall ) {
		SNode aRootNode = getRootOfFileNode(aCurrentSNode);
		for (SNode aChild:aRootNode.getChildren()) {
			if (aChild instanceof MethodSNode) {
				MethodSNode aMethodSNode = (MethodSNode) aChild;
				if (match (aMethodSNode, aMethodCall)) {
					return aMethodSNode;
				}
			}
		}
		return null; // this should never happen;
	}
	
	public static RootOfProgramSNode getRootOfProgramSNode(String aSource) {
		RootOfProgramSNode retVal = new ARootOfProgramSNode();
		Map<String, StringBuffer> aFileNameToContents = ABasicTextManager.extractFileContents(aSource);
		for (String aFileName:aFileNameToContents.keySet()) {
			StringBuffer aFileContents = aFileNameToContents.get(aFileName);
//			List<OpenMPPragma> anOpenMPPragmas = OpenMPUtils.getOpemMPPragmas(aFileContents);
			RootOfFileSNode anSNode = OMPSNodeUtils.getSNode(aFileName, aFileContents);
			retVal.getFileNameToSNode().put(aFileName, anSNode);
			anSNode.setParent(retVal);
//			System.out.println("file name:" + aFileName);
//			System.out.println("pragmas:" + anSNode);
		}
		processExternalMethodSNodes(retVal);
		return retVal;
	}
	public static void processExternalMethodSNodes (RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode) {
		for (SNode anSNode:aRootOfFileSNode.getChildren()) {
			if (anSNode instanceof ExternalMethodSNode) {
				processExternalMethodSNode(aRootOfProgramSNode, aRootOfFileSNode, (ExternalMethodSNode) anSNode);
			}
		}
	}
	public static void processExternalMethodSNode (RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode, ExternalMethodSNode anExternalMethodSNode) {
		MethodSNode aMethodSNode = aRootOfProgramSNode.getExternalToInternalMethod().get(anExternalMethodSNode.toString());
		if (aMethodSNode == null) {
			aMethodSNode = findMethodSNode(aRootOfProgramSNode, aRootOfFileSNode, anExternalMethodSNode);
			if (aMethodSNode != null) {
				aRootOfProgramSNode.getExternalToInternalMethod().put(anExternalMethodSNode.toString(),aMethodSNode );
			}
		}
		if (aMethodSNode != null) {
			anExternalMethodSNode.setActualMethodSNode(aMethodSNode);
			aMethodSNode.getCalls().addAll(anExternalMethodSNode.getLocalCalls());
		}
	}
	public static MethodSNode findMethodSNode (RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode, ExternalMethodSNode anExternalMethodSNode) {
//		MethodSNode foundMethodSNode = null;
		for (String aFileName:aRootOfProgramSNode.getFileNameToSNode().keySet()) {
			if (aFileName.equals(aRootOfFileSNode.getFileName()))
				continue;
			
			RootOfFileSNode aSearchedRootOfFileSNode = aRootOfProgramSNode.getFileNameToSNode().get(aFileName);
			 for (SNode anSNode:aSearchedRootOfFileSNode.getChildren()) {
				if (anSNode instanceof MethodSNode && !(anSNode instanceof ExternalMethodSNode)) {
					if (anSNode.toString().equals(anExternalMethodSNode.toString())) {
						return (MethodSNode) anSNode;
						
					}
//					processExternalMethodSNode(aRootOfProgramSNode, aRootOfFileSNode, (ExternalMethodSNode) anSNode);
				}
			}
		}
		return null;
	}
	public static void processExternalMethodSNodes (RootOfProgramSNode aRootOfProgramSNode) {
		for (String aFileName:aRootOfProgramSNode.getFileNameToSNode().keySet()) {
			RootOfFileSNode aRootOfFileSNode = aRootOfProgramSNode.getFileNameToSNode().get(aFileName);
			processExternalMethodSNodes(aRootOfProgramSNode, aRootOfFileSNode);
			aRootOfFileSNode.getOmp_get_num_threads_SNode().
				setActualMethodSNode(aRootOfProgramSNode.getOmp_get_num_threads_SNode());
			aRootOfFileSNode.getOmp_get_thread_num_SNode().
				setActualMethodSNode(aRootOfProgramSNode.getOmp_get_thread_num_SNode());
			aRootOfFileSNode.getOmp_get_wtime_SNode().
			setActualMethodSNode(aRootOfProgramSNode.getOmp_get_wtime_SNode());
		}

	}
	

//	public static void main(String[] args) {
//		List<MethodCall> aTokens = callsIn("foo(bar, hgf)/foo2()*foo3(b, a c,)");
//		System.out.println(aTokens);
//		
//		
////		List<String> aTokens = identifiersIn("a[i] + b*2/3");
////		System.out.println(aTokens);
////		aTokens = numbersIn("a[i] + b*2/3");
////		System.out.println(aTokens);
////		aTokens = operatorsIn("a[i] + b*2/3");
////		System.out.println(aTokens);
////
////		System.out.println(StringUtils.substringBetween("a", "[", "]"));
//	}

}
]]></snapshot>
  </Command>
  <Command __id="184556" _type="DiffBasedFileOpenCommand" date="Mon Dec 30 10:05:34 EST 2019" docASTNodeCount="403" docActiveCodeLength="2919" docExpressionCount="311" docLength="5670" projectName="DemoCourseLocalBasicChecks" starttimestamp="1576666505112" timestamp="1051829193">
    <filePath><![CDATA[D:\dewan_backup\Java\DemoCourseLocalBasicChecks\src\gradingTools\comp123\assignment1\openmp\testcases\SequentialSumTestCase.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package gradingTools.comp123.assignment1.openmp.testcases;¬∂¬∂import java.util.Arrays;¬∂import java.util.List;¬∂import java.util.Map;¬∂import java.util.regex.Pattern;¬∂¬∂import grader.basics.execution.NotRunnableException;¬∂import grader.basics.execution.RunningProject;¬∂import grader.basics.junit.NotAutomatableException;¬∂import grader.basics.junit.TestCaseResult;¬∂import grader.basics.project.NotGradableException;¬∂import grader.basics.project.Project;¬∂import grader.basics.project.source.ABasicTextManager;¬∂import grader.basics.testcase.PassFailJUnitTestCase;¬∂import gradingTools.shared.testcases.SubstringSequenceChecker;¬∂import gradingTools.shared.testcases.openmp.OpenMPPragma;¬∂import gradingTools.shared.testcases.openmp.OpenMPUtils;¬∂import gradingTools.shared.testcases.openmp.scannedTree.AssignmentSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.ExternalMethodSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.MethodSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.OMPSNodeUtils;¬∂import gradingTools.shared.testcases.openmp.scannedTree.RootOfFileSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.RootOfProgramSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.SNode;¬∂import gradingTools.shared.testcases.utils.LinesMatchKind;¬∂import gradingTools.shared.testcases.utils.LinesMatcher;¬∂import gradingTools.utils.RunningProjectUtils;¬∂¬∂public class SequentialSumTestCase extends PassFailJUnitTestCase {¬∂	public static final int TIME_OUT_SECS = 1; // secs¬∂	protected SubstringSequenceChecker checker = new ASequentialSumChecker();	¬∂¬∂	public SequentialSumTestCase() {¬∂	}¬∂¬∂	¬∂¬∂	@Override¬∂	public TestCaseResult test(Project project, boolean autoGrade) throws NotAutomatableException,¬∂			NotGradableException {¬∂		try {¬∂			RunningProject aRunningProject = RunningProjectUtils.runProject(project, TIME_OUT_SECS);¬∂			String anOutput = aRunningProject.await();¬∂			LinesMatcher aLinesMatcher = aRunningProject.getLinesMatcher();¬∂			boolean aRetval = checker.check(aLinesMatcher, LinesMatchKind.ONE_TIME_LINE, Pattern.DOTALL);¬∂			String aSource = project.getSource();¬∂//			Map<String, StringBuffer> aFileNameToContents = ABasicTextManager.extractFileContents(aSource);¬∂//			for (String aFileName:aFileNameToContents.keySet()) {¬∂//				StringBuffer aFileContents = aFileNameToContents.get(aFileName);¬∂////				List<OpenMPPragma> anOpenMPPragmas = OpenMPUtils.getOpemMPPragmas(aFileContents);¬∂//				SNode anSNode = OMPSNodeUtils.getSNode(aFileName, aFileContents);¬∂//				System.out.println("file name:" + aFileName);¬∂//				System.out.println("pragmas:" + anSNode);¬∂//			}¬∂			RootOfProgramSNode aRootOfProgramSNode = OMPSNodeUtils.getRootOfProgramSNode(aSource);¬∂			List<AssignmentSNode> anAssignments = OMPSNodeUtils.assignmentsToSharedVariables(aRootOfProgramSNode);¬∂			anAssignments = OMPSNodeUtils.assignmentsToSharedArrays(aRootOfProgramSNode);¬∂"), Diff(INSERT,"			anAssignments = OMPSNodeUtils.assignmentsToParallelSharedCritical(aRootOfProgramSNode);¬∂¬∂"), Diff(EQUAL,"			String anExpectedLines = Arrays.toString(checker.getSubstrings());¬∂¬∂			if (!aRetval) {¬∂				return fail("Output  did not match:" + anExpectedLines);¬∂¬∂			}¬∂			return pass();¬∂			¬∂¬∂		} catch (NotRunnableException e) {¬∂			throw new NotGradableException();¬∂		}¬∂	}¬∂//	public static void processExternalMethodSNodes (RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode) {¬∂//		for (SNode anSNode:aRootOfFileSNode.getChildren()) {¬∂//			if (anSNode instanceof ExternalMethodSNode) {¬∂//				processExternalMethodSNode(aRootOfProgramSNode, aRootOfFileSNode, (ExternalMethodSNode) anSNode);¬∂//			}¬∂//		}¬∂//	}¬∂//	public static void processExternalMethodSNode (RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode, ExternalMethodSNode anExternalMethodSNode) {¬∂//		MethodSNode aMethodSNode = aRootOfProgramSNode.getExternalToInternalMethod().get(anExternalMethodSNode.toString());¬∂//		if (aMethodSNode == null) {¬∂//			aMethodSNode = findMethodSNode(aRootOfProgramSNode, aRootOfFileSNode, anExternalMethodSNode);¬∂//			if (aMethodSNode != null) {¬∂//				aRootOfProgramSNode.getExternalToInternalMethod().put(anExternalMethodSNode.toString(),aMethodSNode );¬∂//			}¬∂//		}¬∂//		if (aMethodSNode != null) {¬∂//			anExternalMethodSNode.setActualMethodSNode(aMethodSNode);¬∂//		}¬∂//	}¬∂//	public static MethodSNode findMethodSNode (RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode, ExternalMethodSNode anExternalMethodSNode) {¬∂////		MethodSNode foundMethodSNode = null;¬∂//		for (String aFileName:aRootOfProgramSNode.getFileNameToSNode().keySet()) {¬∂//			if (aFileName.equals(aRootOfFileSNode.getFileName()))¬∂//				continue;¬∂//			¬∂//			RootOfFileSNode aSearchedRootOfFileSNode = aRootOfProgramSNode.getFileNameToSNode().get(aFileName);¬∂//			 for (SNode anSNode:aSearchedRootOfFileSNode.getChildren()) {¬∂//				if (anSNode instanceof MethodSNode && !(anSNode instanceof ExternalMethodSNode)) {¬∂//					if (anSNode.toString().equals(anExternalMethodSNode)) {¬∂//						return (MethodSNode) anSNode;¬∂//						¬∂//					}¬∂////					processExternalMethodSNode(aRootOfProgramSNode, aRootOfFileSNode, (ExternalMethodSNode) anSNode);¬∂//				}¬∂//			}¬∂//		}¬∂//		return null;¬∂//	}¬∂//	public static void processExternalMethodSNodes (RootOfProgramSNode aRootOfProgramSNode) {¬∂//		for (String aFileName:aRootOfProgramSNode.getFileNameToSNode().keySet()) {¬∂//			RootOfFileSNode aRootOfFileSNode = aRootOfProgramSNode.getFileNameToSNode().get(aFileName);¬∂//			processExternalMethodSNodes(aRootOfProgramSNode, aRootOfFileSNode);¬∂//			¬∂//		}¬∂//¬∂//	}¬∂}¬∂")]]]></diff>
    <snapshot><![CDATA[package gradingTools.comp123.assignment1.openmp.testcases;

import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.regex.Pattern;

import grader.basics.execution.NotRunnableException;
import grader.basics.execution.RunningProject;
import grader.basics.junit.NotAutomatableException;
import grader.basics.junit.TestCaseResult;
import grader.basics.project.NotGradableException;
import grader.basics.project.Project;
import grader.basics.project.source.ABasicTextManager;
import grader.basics.testcase.PassFailJUnitTestCase;
import gradingTools.shared.testcases.SubstringSequenceChecker;
import gradingTools.shared.testcases.openmp.OpenMPPragma;
import gradingTools.shared.testcases.openmp.OpenMPUtils;
import gradingTools.shared.testcases.openmp.scannedTree.AssignmentSNode;
import gradingTools.shared.testcases.openmp.scannedTree.ExternalMethodSNode;
import gradingTools.shared.testcases.openmp.scannedTree.MethodSNode;
import gradingTools.shared.testcases.openmp.scannedTree.OMPSNodeUtils;
import gradingTools.shared.testcases.openmp.scannedTree.RootOfFileSNode;
import gradingTools.shared.testcases.openmp.scannedTree.RootOfProgramSNode;
import gradingTools.shared.testcases.openmp.scannedTree.SNode;
import gradingTools.shared.testcases.utils.LinesMatchKind;
import gradingTools.shared.testcases.utils.LinesMatcher;
import gradingTools.utils.RunningProjectUtils;

public class SequentialSumTestCase extends PassFailJUnitTestCase {
	public static final int TIME_OUT_SECS = 1; // secs
	protected SubstringSequenceChecker checker = new ASequentialSumChecker();	

	public SequentialSumTestCase() {
	}

	

	@Override
	public TestCaseResult test(Project project, boolean autoGrade) throws NotAutomatableException,
			NotGradableException {
		try {
			RunningProject aRunningProject = RunningProjectUtils.runProject(project, TIME_OUT_SECS);
			String anOutput = aRunningProject.await();
			LinesMatcher aLinesMatcher = aRunningProject.getLinesMatcher();
			boolean aRetval = checker.check(aLinesMatcher, LinesMatchKind.ONE_TIME_LINE, Pattern.DOTALL);
			String aSource = project.getSource();
//			Map<String, StringBuffer> aFileNameToContents = ABasicTextManager.extractFileContents(aSource);
//			for (String aFileName:aFileNameToContents.keySet()) {
//				StringBuffer aFileContents = aFileNameToContents.get(aFileName);
////				List<OpenMPPragma> anOpenMPPragmas = OpenMPUtils.getOpemMPPragmas(aFileContents);
//				SNode anSNode = OMPSNodeUtils.getSNode(aFileName, aFileContents);
//				System.out.println("file name:" + aFileName);
//				System.out.println("pragmas:" + anSNode);
//			}
			RootOfProgramSNode aRootOfProgramSNode = OMPSNodeUtils.getRootOfProgramSNode(aSource);
			List<AssignmentSNode> anAssignments = OMPSNodeUtils.assignmentsToSharedVariables(aRootOfProgramSNode);
			anAssignments = OMPSNodeUtils.assignmentsToSharedArrays(aRootOfProgramSNode);
			anAssignments = OMPSNodeUtils.assignmentsToParallelSharedCritical(aRootOfProgramSNode);

			String anExpectedLines = Arrays.toString(checker.getSubstrings());

			if (!aRetval) {
				return fail("Output  did not match:" + anExpectedLines);

			}
			return pass();
			

		} catch (NotRunnableException e) {
			throw new NotGradableException();
		}
	}
//	public static void processExternalMethodSNodes (RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode) {
//		for (SNode anSNode:aRootOfFileSNode.getChildren()) {
//			if (anSNode instanceof ExternalMethodSNode) {
//				processExternalMethodSNode(aRootOfProgramSNode, aRootOfFileSNode, (ExternalMethodSNode) anSNode);
//			}
//		}
//	}
//	public static void processExternalMethodSNode (RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode, ExternalMethodSNode anExternalMethodSNode) {
//		MethodSNode aMethodSNode = aRootOfProgramSNode.getExternalToInternalMethod().get(anExternalMethodSNode.toString());
//		if (aMethodSNode == null) {
//			aMethodSNode = findMethodSNode(aRootOfProgramSNode, aRootOfFileSNode, anExternalMethodSNode);
//			if (aMethodSNode != null) {
//				aRootOfProgramSNode.getExternalToInternalMethod().put(anExternalMethodSNode.toString(),aMethodSNode );
//			}
//		}
//		if (aMethodSNode != null) {
//			anExternalMethodSNode.setActualMethodSNode(aMethodSNode);
//		}
//	}
//	public static MethodSNode findMethodSNode (RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode, ExternalMethodSNode anExternalMethodSNode) {
////		MethodSNode foundMethodSNode = null;
//		for (String aFileName:aRootOfProgramSNode.getFileNameToSNode().keySet()) {
//			if (aFileName.equals(aRootOfFileSNode.getFileName()))
//				continue;
//			
//			RootOfFileSNode aSearchedRootOfFileSNode = aRootOfProgramSNode.getFileNameToSNode().get(aFileName);
//			 for (SNode anSNode:aSearchedRootOfFileSNode.getChildren()) {
//				if (anSNode instanceof MethodSNode && !(anSNode instanceof ExternalMethodSNode)) {
//					if (anSNode.toString().equals(anExternalMethodSNode)) {
//						return (MethodSNode) anSNode;
//						
//					}
////					processExternalMethodSNode(aRootOfProgramSNode, aRootOfFileSNode, (ExternalMethodSNode) anSNode);
//				}
//			}
//		}
//		return null;
//	}
//	public static void processExternalMethodSNodes (RootOfProgramSNode aRootOfProgramSNode) {
//		for (String aFileName:aRootOfProgramSNode.getFileNameToSNode().keySet()) {
//			RootOfFileSNode aRootOfFileSNode = aRootOfProgramSNode.getFileNameToSNode().get(aFileName);
//			processExternalMethodSNodes(aRootOfProgramSNode, aRootOfFileSNode);
//			
//		}
//
//	}
}
]]></snapshot>
  </Command>
  <Command __id="184558" _type="RunCommand" date="Mon Dec 30 10:05:37 EST 2019" kind="StepInto" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="1051832380" type="Run" />
  <Command __id="184559" _type="RunCommand" date="Mon Dec 30 10:05:37 EST 2019" kind="StepInto" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="1051832391" type="Run" />
  <Command __id="184560" _type="DiffBasedFileOpenCommand" date="Mon Dec 30 10:05:59 EST 2019" docASTNodeCount="1" docActiveCodeLength="659" docExpressionCount="0" docLength="747" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="1051854749">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\my_sum_parallel_for_local_var.cpp]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"#include <iostream>¬∂#include <omp.h>¬∂¬∂using namespace std;¬∂¬∂void printSumWithTimes (int sum, int start, int end);¬∂void printNumThreads();¬∂void recordThreadIndex(int index);¬∂void sum_parallel_for_local_var(double* array, int size)¬∂{¬∂	cout << "sum_parallel_for_local_var\n";¬∂¬∂	double start = omp_get_wtime();¬∂¬∂	double sum = 0;¬∂¬∂	int a, b;¬∂//¬∂//	for (int i = 0; i < size; i++) {¬∂//			sum += array[i];¬∂//			recordThreadIndex(i);¬∂//	}¬∂¬∂    #pragma omp parallel shared (sum, start) private (a, b)¬∂	{¬∂		double local_sum = 0;¬∂¬∂		#pragma omp for¬∂		for(int i = 0; i < size; i++) {¬∂			local_sum += array[i];¬∂			recordThreadIndex(i);¬∂		}¬∂¬∂		#pragma omp critical¬∂		sum += local_sum;¬∂	}¬∂¬∂	double end = omp_get_wtime();¬∂¬∂	printSumWithTimes(sum, start, end);¬∂	¬∂}¬∂")]]]></diff>
  </Command>
  <Command __id="184561" _type="SelectTextCommand" caretOffset="493" date="Mon Dec 30 10:06:00 EST 2019" end="493" start="468" starttimestamp="1576666505112" timestamp="1051854950" />
  <Command __id="184562" _type="DiffBasedFileOpenCommand" date="Mon Dec 30 10:06:03 EST 2019" docASTNodeCount="1" docActiveCodeLength="453" docExpressionCount="0" docLength="453" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="1051858421">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\my_sum_sequential.cpp]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"#include <iostream>¬∂#include <omp.h>¬∂¬∂using namespace std;¬∂void printSumWithTimes(int sum, int start, int end);¬∂void printNumThreads();¬∂void recordThreadIndex(int index);¬∂void sum_sequential(double* array, int size) {¬∂¬∂	cout << "sum_sequential\n";¬∂¬∂	double start = omp_get_wtime();¬∂¬∂	double sum = 0;¬∂¬∂	for (int i = 0; i < size; i++) {¬∂		sum += array[i];¬∂		recordThreadIndex(i);¬∂	}¬∂¬∂	double end = omp_get_wtime();¬∂¬∂	printSumWithTimes(sum, start, end);¬∂}¬∂")]]]></diff>
  </Command>
  <Command __id="184563" _type="SelectTextCommand" caretOffset="280" date="Mon Dec 30 10:06:03 EST 2019" end="280" start="265" starttimestamp="1576666505112" timestamp="1051858608" />
  <Command __id="184564" _type="DiffBasedFileOpenCommand" date="Mon Dec 30 10:06:10 EST 2019" docASTNodeCount="1" docActiveCodeLength="795" docExpressionCount="0" docLength="795" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="1051865707">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\my_sum_parallel.cpp]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"#include <iostream>¬∂#include <omp.h>¬∂¬∂using namespace std;¬∂¬∂void printSumWithTimes(int sum, int start, int end);¬∂void printNumThreads();¬∂void recordThreadIndex(int index);¬∂void sum_parallel(double* array, int size) {¬∂	cout << "sum_parallel\n";¬∂¬∂	double start = omp_get_wtime();¬∂¬∂	double sum = 0;¬∂¬∂¬∂    #pragma omp critical¬∂	{¬∂	double sum = 0;¬∂	}¬∂    #pragma omp parallel¬∂	{¬∂		double local_sum = 0;¬∂¬∂		int rank = omp_get_thread_num();¬∂		int threads = omp_get_num_threads();¬∂¬∂		int start_index = (size/threads)*rank;¬∂		int end_index = (size/threads)*(rank+1);¬∂¬∂		if(rank==threads-1)¬∂			end_index=size;¬∂¬∂		for(int i = start_index; i < end_index; i++)¬∂			local_sum += array[i];¬∂¬∂		#pragma omp critical¬∂		sum += local_sum;¬∂	}¬∂¬∂	double end = omp_get_wtime();¬∂¬∂	printSumWithTimes(sum, start, end);¬∂¬∂¬∂}¬∂")]]]></diff>
  </Command>
  <Command __id="184565" _type="SelectTextCommand" caretOffset="471" date="Mon Dec 30 10:06:11 EST 2019" end="471" start="450" starttimestamp="1576666505112" timestamp="1051865905" />
  <Command __id="184566" _type="DiffBasedFileOpenCommand" date="Mon Dec 30 10:06:31 EST 2019" docASTNodeCount="1" docActiveCodeLength="532" docExpressionCount="0" docLength="575" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="1051886444">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\my_sum_parallel_for_reduction.cpp]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"#include <iostream>¬∂#include <omp.h>¬∂¬∂using namespace std;¬∂¬∂//const int SIZE = 1000;¬∂void printSumWithTimes(int sum, int start, int end);¬∂void printNumThreads();¬∂void recordThreadIndex(int index);¬∂void sum_parallel_for_reduction(double* array, int size) {¬∂	cout << "sum_parallel_for_reduction\n";¬∂¬∂	double start = omp_get_wtime();¬∂¬∂	double sum = 0;¬∂    #pragma omp  parallel for reduction ( + : sum )¬∂//	#pragma omp  for¬∂¬∂	for (int i = 0; i < size; i++) {¬∂		sum += array[i];¬∂		recordThreadIndex(i);¬∂	}¬∂¬∂	double end = omp_get_wtime();¬∂¬∂	printSumWithTimes(sum, start, end);¬∂¬∂}¬∂")]]]></diff>
  </Command>
  <Command __id="184567" _type="MoveCaretCommand" caretOffset="379" date="Mon Dec 30 10:06:31 EST 2019" docOffset="379" starttimestamp="1576666505112" timestamp="1051886654" />
  <Command __id="184568" _type="DiffBasedFileOpenCommand" date="Mon Dec 30 10:06:41 EST 2019" docASTNodeCount="1" docActiveCodeLength="659" docExpressionCount="0" docLength="747" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="1051896471">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\my_sum_parallel_for_local_var.cpp]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"#include <iostream>¬∂#include <omp.h>¬∂¬∂using namespace std;¬∂¬∂void printSumWithTimes (int sum, int start, int end);¬∂void printNumThreads();¬∂void recordThreadIndex(int index);¬∂void sum_parallel_for_local_var(double* array, int size)¬∂{¬∂	cout << "sum_parallel_for_local_var\n";¬∂¬∂	double start = omp_get_wtime();¬∂¬∂	double sum = 0;¬∂¬∂	int a, b;¬∂//¬∂//	for (int i = 0; i < size; i++) {¬∂//			sum += array[i];¬∂//			recordThreadIndex(i);¬∂//	}¬∂¬∂    #pragma omp parallel shared (sum, start) private (a, b)¬∂	{¬∂		double local_sum = 0;¬∂¬∂		#pragma omp for¬∂		for(int i = 0; i < size; i++) {¬∂			local_sum += array[i];¬∂			recordThreadIndex(i);¬∂		}¬∂¬∂		#pragma omp critical¬∂		sum += local_sum;¬∂	}¬∂¬∂	double end = omp_get_wtime();¬∂¬∂	printSumWithTimes(sum, start, end);¬∂	¬∂}¬∂")]]]></diff>
  </Command>
  <Command __id="184569" _type="SelectTextCommand" caretOffset="493" date="Mon Dec 30 10:06:41 EST 2019" end="493" start="468" starttimestamp="1576666505112" timestamp="1051896642" />
  <Command __id="184570" _type="DiffBasedFileOpenCommand" date="Mon Dec 30 10:06:52 EST 2019" docASTNodeCount="1" docActiveCodeLength="453" docExpressionCount="0" docLength="453" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="1051907794">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\my_sum_sequential.cpp]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"#include <iostream>¬∂#include <omp.h>¬∂¬∂using namespace std;¬∂void printSumWithTimes(int sum, int start, int end);¬∂void printNumThreads();¬∂void recordThreadIndex(int index);¬∂void sum_sequential(double* array, int size) {¬∂¬∂	cout << "sum_sequential\n";¬∂¬∂	double start = omp_get_wtime();¬∂¬∂	double sum = 0;¬∂¬∂	for (int i = 0; i < size; i++) {¬∂		sum += array[i];¬∂		recordThreadIndex(i);¬∂	}¬∂¬∂	double end = omp_get_wtime();¬∂¬∂	printSumWithTimes(sum, start, end);¬∂}¬∂")]]]></diff>
  </Command>
  <Command __id="184571" _type="SelectTextCommand" caretOffset="280" date="Mon Dec 30 10:06:53 EST 2019" end="280" start="265" starttimestamp="1576666505112" timestamp="1051907956" />
  <Command __id="184572" _type="DiffBasedFileOpenCommand" date="Mon Dec 30 10:06:58 EST 2019" docASTNodeCount="1" docActiveCodeLength="795" docExpressionCount="0" docLength="795" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="1051913834">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\my_sum_parallel.cpp]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"#include <iostream>¬∂#include <omp.h>¬∂¬∂using namespace std;¬∂¬∂void printSumWithTimes(int sum, int start, int end);¬∂void printNumThreads();¬∂void recordThreadIndex(int index);¬∂void sum_parallel(double* array, int size) {¬∂	cout << "sum_parallel\n";¬∂¬∂	double start = omp_get_wtime();¬∂¬∂	double sum = 0;¬∂¬∂¬∂    #pragma omp critical¬∂	{¬∂	double sum = 0;¬∂	}¬∂    #pragma omp parallel¬∂	{¬∂		double local_sum = 0;¬∂¬∂		int rank = omp_get_thread_num();¬∂		int threads = omp_get_num_threads();¬∂¬∂		int start_index = (size/threads)*rank;¬∂		int end_index = (size/threads)*(rank+1);¬∂¬∂		if(rank==threads-1)¬∂			end_index=size;¬∂¬∂		for(int i = start_index; i < end_index; i++)¬∂			local_sum += array[i];¬∂¬∂		#pragma omp critical¬∂		sum += local_sum;¬∂	}¬∂¬∂	double end = omp_get_wtime();¬∂¬∂	printSumWithTimes(sum, start, end);¬∂¬∂¬∂}¬∂")]]]></diff>
  </Command>
  <Command __id="184573" _type="MoveCaretCommand" caretOffset="297" date="Mon Dec 30 10:06:59 EST 2019" docOffset="297" starttimestamp="1576666505112" timestamp="1051914005" />
  <Command __id="184574" _type="DiffBasedFileOpenCommand" date="Mon Dec 30 10:07:19 EST 2019" docASTNodeCount="1" docActiveCodeLength="532" docExpressionCount="0" docLength="575" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="1051933970">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\my_sum_parallel_for_reduction.cpp]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"#include <iostream>¬∂#include <omp.h>¬∂¬∂using namespace std;¬∂¬∂//const int SIZE = 1000;¬∂void printSumWithTimes(int sum, int start, int end);¬∂void printNumThreads();¬∂void recordThreadIndex(int index);¬∂void sum_parallel_for_reduction(double* array, int size) {¬∂	cout << "sum_parallel_for_reduction\n";¬∂¬∂	double start = omp_get_wtime();¬∂¬∂	double sum = 0;¬∂    #pragma omp  parallel for reduction ( + : sum )¬∂//	#pragma omp  for¬∂¬∂	for (int i = 0; i < size; i++) {¬∂		sum += array[i];¬∂		recordThreadIndex(i);¬∂	}¬∂¬∂	double end = omp_get_wtime();¬∂¬∂	printSumWithTimes(sum, start, end);¬∂¬∂}¬∂")]]]></diff>
  </Command>
  <Command __id="184575" _type="MoveCaretCommand" caretOffset="379" date="Mon Dec 30 10:07:19 EST 2019" docOffset="379" starttimestamp="1576666505112" timestamp="1051934139" />
  <Command __id="184577" _type="SelectTextCommand" caretOffset="493" date="Mon Dec 30 10:07:50 EST 2019" end="493" start="468" starttimestamp="1576666505112" timestamp="1051965111" />
  <DocumentChange __id="185648" _type="Replace" date="Mon Dec 30 10:17:50 EST 2019" docASTNodeCount="423" docActiveCodeLength="3162" docExpressionCount="328" docLength="5913" endLine="61" insertionLength="47" int_docASTNodeCount="423" int_docActiveCodeLength="3115" int_docExpressionCount="328" int_docLength="5866" length="38" offset="3215" startLine="61" starttimestamp="1576666505112" timestamp="1052565661">
    <deletedText><![CDATA[assignmentsToParallelSharedNonCritical]]></deletedText>
    <insertedText><![CDATA[assignmentsToParallelNonCriticalSharedVariables]]></insertedText>
  </DocumentChange>
  <Command __id="185710" _type="RunCommand" date="Mon Dec 30 10:18:41 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="1052616506" type="Debug" />
  <Command __id="185711" _type="RunCommand" date="Mon Dec 30 10:18:41 EST 2019" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="1052616506" type="Debug" />
  <Command __id="185712" _type="RunCommand" date="Mon Dec 30 10:18:41 EST 2019" kind="HitBreakPoint" projectName="PL_Java" starttimestamp="1576666505112" timestamp="1052616506" type="Run" />
  <Command __id="185713" _type="DiffBasedFileOpenCommand" date="Mon Dec 30 10:18:44 EST 2019" docASTNodeCount="1" docActiveCodeLength="532" docExpressionCount="0" docLength="575" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="1052619204">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\my_sum_parallel_for_reduction.cpp]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"#include <iostream>¬∂#include <omp.h>¬∂¬∂using namespace std;¬∂¬∂//const int SIZE = 1000;¬∂void printSumWithTimes(int sum, int start, int end);¬∂void printNumThreads();¬∂void recordThreadIndex(int index);¬∂void sum_parallel_for_reduction(double* array, int size) {¬∂	cout << "sum_parallel_for_reduction\n";¬∂¬∂	double start = omp_get_wtime();¬∂¬∂	double sum = 0;¬∂    #pragma omp  parallel for reduction ( + : sum )¬∂//	#pragma omp  for¬∂¬∂	for (int i = 0; i < size; i++) {¬∂		sum += array[i];¬∂		recordThreadIndex(i);¬∂	}¬∂¬∂	double end = omp_get_wtime();¬∂¬∂	printSumWithTimes(sum, start, end);¬∂¬∂}¬∂")]]]></diff>
  </Command>
  <Command __id="185714" _type="MoveCaretCommand" caretOffset="379" date="Mon Dec 30 10:18:44 EST 2019" docOffset="379" starttimestamp="1576666505112" timestamp="1052619366" />
  <Command __id="185715" _type="DiffBasedFileOpenCommand" date="Mon Dec 30 10:18:57 EST 2019" docASTNodeCount="1" docActiveCodeLength="659" docExpressionCount="0" docLength="747" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="1052632557">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\my_sum_parallel_for_local_var.cpp]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"#include <iostream>¬∂#include <omp.h>¬∂¬∂using namespace std;¬∂¬∂void printSumWithTimes (int sum, int start, int end);¬∂void printNumThreads();¬∂void recordThreadIndex(int index);¬∂void sum_parallel_for_local_var(double* array, int size)¬∂{¬∂	cout << "sum_parallel_for_local_var\n";¬∂¬∂	double start = omp_get_wtime();¬∂¬∂	double sum = 0;¬∂¬∂	int a, b;¬∂//¬∂//	for (int i = 0; i < size; i++) {¬∂//			sum += array[i];¬∂//			recordThreadIndex(i);¬∂//	}¬∂¬∂    #pragma omp parallel shared (sum, start) private (a, b)¬∂	{¬∂		double local_sum = 0;¬∂¬∂		#pragma omp for¬∂		for(int i = 0; i < size; i++) {¬∂			local_sum += array[i];¬∂			recordThreadIndex(i);¬∂		}¬∂¬∂		#pragma omp critical¬∂		sum += local_sum;¬∂	}¬∂¬∂	double end = omp_get_wtime();¬∂¬∂	printSumWithTimes(sum, start, end);¬∂	¬∂}¬∂")]]]></diff>
  </Command>
  <Command __id="185716" _type="MoveCaretCommand" caretOffset="621" date="Mon Dec 30 10:18:57 EST 2019" docOffset="621" starttimestamp="1576666505112" timestamp="1052632683" />
  <Command __id="185717" _type="DiffBasedFileOpenCommand" date="Mon Dec 30 10:19:12 EST 2019" docASTNodeCount="1" docActiveCodeLength="795" docExpressionCount="0" docLength="795" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="1052647749">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\my_sum_parallel.cpp]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"#include <iostream>¬∂#include <omp.h>¬∂¬∂using namespace std;¬∂¬∂void printSumWithTimes(int sum, int start, int end);¬∂void printNumThreads();¬∂void recordThreadIndex(int index);¬∂void sum_parallel(double* array, int size) {¬∂	cout << "sum_parallel\n";¬∂¬∂	double start = omp_get_wtime();¬∂¬∂	double sum = 0;¬∂¬∂¬∂    #pragma omp critical¬∂	{¬∂	double sum = 0;¬∂	}¬∂    #pragma omp parallel¬∂	{¬∂		double local_sum = 0;¬∂¬∂		int rank = omp_get_thread_num();¬∂		int threads = omp_get_num_threads();¬∂¬∂		int start_index = (size/threads)*rank;¬∂		int end_index = (size/threads)*(rank+1);¬∂¬∂		if(rank==threads-1)¬∂			end_index=size;¬∂¬∂		for(int i = start_index; i < end_index; i++)¬∂			local_sum += array[i];¬∂¬∂		#pragma omp critical¬∂		sum += local_sum;¬∂	}¬∂¬∂	double end = omp_get_wtime();¬∂¬∂	printSumWithTimes(sum, start, end);¬∂¬∂¬∂}¬∂")]]]></diff>
  </Command>
  <Command __id="185718" _type="MoveCaretCommand" caretOffset="297" date="Mon Dec 30 10:19:13 EST 2019" docOffset="297" starttimestamp="1576666505112" timestamp="1052647922" />
  <Command __id="185719" _type="DiffBasedFileOpenCommand" date="Mon Dec 30 10:19:59 EST 2019" docASTNodeCount="1" docActiveCodeLength="659" docExpressionCount="0" docLength="747" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="1052694677">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\my_sum_parallel_for_local_var.cpp]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"#include <iostream>¬∂#include <omp.h>¬∂¬∂using namespace std;¬∂¬∂void printSumWithTimes (int sum, int start, int end);¬∂void printNumThreads();¬∂void recordThreadIndex(int index);¬∂void sum_parallel_for_local_var(double* array, int size)¬∂{¬∂	cout << "sum_parallel_for_local_var\n";¬∂¬∂	double start = omp_get_wtime();¬∂¬∂	double sum = 0;¬∂¬∂	int a, b;¬∂//¬∂//	for (int i = 0; i < size; i++) {¬∂//			sum += array[i];¬∂//			recordThreadIndex(i);¬∂//	}¬∂¬∂    #pragma omp parallel shared (sum, start) private (a, b)¬∂	{¬∂		double local_sum = 0;¬∂¬∂		#pragma omp for¬∂		for(int i = 0; i < size; i++) {¬∂			local_sum += array[i];¬∂			recordThreadIndex(i);¬∂		}¬∂¬∂		#pragma omp critical¬∂		sum += local_sum;¬∂	}¬∂¬∂	double end = omp_get_wtime();¬∂¬∂	printSumWithTimes(sum, start, end);¬∂	¬∂}¬∂")]]]></diff>
  </Command>
  <Command __id="185720" _type="MoveCaretCommand" caretOffset="621" date="Mon Dec 30 10:19:59 EST 2019" docOffset="621" starttimestamp="1576666505112" timestamp="1052694794" />
  <Command __id="185723" _type="DiffBasedFileOpenCommand" date="Mon Dec 30 10:20:14 EST 2019" docASTNodeCount="4116" docActiveCodeLength="29362" docExpressionCount="2589" docLength="33548" projectName="GraderBasics" starttimestamp="1576666505112" timestamp="1052709391">
    <filePath><![CDATA[D:\dewan_backup\Java\GraderBasics\src\gradingTools\shared\testcases\openmp\scannedTree\OMPSNodeUtils.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package gradingTools.shared.testcases.openmp.scannedTree;¬∂¬∂import java.util.ArrayList;¬∂import java.util.Arrays;¬∂import java.util.HashMap;¬∂import java.util.HashSet;¬∂import java.util.List;¬∂import java.util.Map;¬∂import java.util.Set;¬∂import java.util.Stack;¬∂import java.util.regex.Matcher;¬∂import java.util.regex.Pattern;¬∂¬∂import org.apache.commons.lang.StringUtils;¬∂¬∂import grader.basics.project.source.ABasicTextManager;¬∂import gradingTools.shared.testcases.openmp.OpenMPKeywordEnum;¬∂import gradingTools.shared.testcases.openmp.OpenMPParallelPragma;¬∂import gradingTools.shared.testcases.openmp.OpenMPUtils;¬∂import gradingTools.shared.testcases.openmp.scannedTree.ADeclarationSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.ADeclaringAssignmentSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.AForSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.ATextSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.AnAssignmentSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.AnOMPCriticalSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.AnOMPForSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.AnOMPParallelSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.AnOMPSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.AnSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.AssignmentSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.DeclarationSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.DeclaringAssignmentSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.ForSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.OMPForSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.OMPSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.SNode;¬∂¬∂public class OMPSNodeUtils extends OpenMPUtils {¬∂¬∂	public static RootOfFileSNode getSNode(String aFileName, StringBuffer aFileBuffer) {¬∂		String[] aFileLines = aFileBuffer.toString().split("\n");¬∂		return getSNode(aFileName, aFileLines);¬∂	}¬∂¬∂	public static AssignmentSNode getAssignmentSNode(int aLineNumber, String aString) {¬∂		if (aString == null) {¬∂			return null;¬∂		}¬∂		String[] aTokens = aString.split("=");¬∂		if (aTokens.length == 1) {¬∂			return new AnAssignmentSNode(aLineNumber, aTokens[0], null);¬∂		} else {¬∂		return new AnAssignmentSNode(aLineNumber, aTokens[0], aTokens[1]);¬∂		}¬∂	}¬∂¬∂	public static DeclarationSNode getDeclarationSNode(int aLineNumber, String aString) {¬∂		String[] aTokens = aString.split(" ");¬∂		return new ADeclarationSNode(aLineNumber, aTokens[0], aTokens[1]);¬∂	}¬∂¬∂	public static DeclaringAssignmentSNode getDeclaringAssignmentSNode(int aLineNumber, String aString) {¬∂		String[] anLHSAndRHS = aString.split("=");¬∂		String[] aTypeAndVariable = anLHSAndRHS[0].split(" ");¬∂		return new ADeclaringAssignmentSNode(aLineNumber, aTypeAndVariable[0], aTypeAndVariable[1], anLHSAndRHS[1]);¬∂	}¬∂¬∂	public static boolean isDeclaringAssignment(String aFileLine) {¬∂		return startsWithTypeName(aFileLine) && aFileLine.contains("=");¬∂	}¬∂	public static boolean isMethodDeclaration(String aFileLine) {¬∂		return startsWithTypeName(aFileLine) && ¬∂				aFileLine.contains("(") &&¬∂				!aFileLine.contains("=");¬∂	}¬∂	public static boolean isExternalMethodDeclaration(String aFileLine) {¬∂		return isMethodDeclaration(aFileLine) && aFileLine.endsWith(";");¬∂	}¬∂¬∂¬∂	public static boolean isVariableDeclaration(String aFileLine) {¬∂¬∂		return startsWithTypeName(aFileLine) && !aFileLine.contains("(");¬∂	}¬∂¬∂	public static boolean isAssignment(String aFileLine) {¬∂		return aFileLine.contains("=");¬∂	}¬∂¬∂	public static boolean isForNode(String aFileLine) {¬∂		return aFileLine.startsWith("for");¬∂	}¬∂¬∂	public static ForSNode getForSNode(int aLineNumber, String aFileLine) {¬∂¬∂		int aLeftParenIndex = aFileLine.indexOf("(");¬∂		int aRightParenIndex = aFileLine.indexOf(")");¬∂		if (aLeftParenIndex < 0 || aRightParenIndex < 0) {¬∂			return null;¬∂		}¬∂		String aHeaderString = aFileLine.substring(aLeftParenIndex + 1, aRightParenIndex);¬∂		String[] aForComponents = aHeaderString.split(";");¬∂		AssignmentSNode anAssignmentSNode = null;¬∂		String aForInitializaton = aForComponents[0];¬∂		if (!aForInitializaton.isEmpty() && aForInitializaton.contains("=")) {¬∂			if (isDeclaringAssignment(aForInitializaton)) {¬∂				anAssignmentSNode = getDeclaringAssignmentSNode(aLineNumber, aForInitializaton);¬∂			} else {¬∂				anAssignmentSNode = getAssignmentSNode(aLineNumber, aForInitializaton);¬∂			}¬∂¬∂		}		¬∂		return new AForSNode(aLineNumber, anAssignmentSNode, aForComponents[1], getAssignmentSNode(aLineNumber, aForComponents[2]));¬∂	}¬∂	static String[] emptyArray = {};¬∂	public static MethodSNode getMethodSNode(int aLineNumber, String aFileLine, boolean isInternal) {¬∂¬∂		int aLeftParenIndex = aFileLine.indexOf("(");¬∂		int aRightParenIndex = aFileLine.indexOf(")");¬∂		if (aLeftParenIndex < 0 || aRightParenIndex < 0) {¬∂			return null;¬∂		}¬∂		String aMethodNameAndType = aFileLine.substring(0, aLeftParenIndex);¬∂		String[] aMethodNameAndTypeTokens = aMethodNameAndType.split("\\s+"); ¬∂		¬∂		String aMethodParameters = aFileLine.substring(aLeftParenIndex +1 , aRightParenIndex);¬∂		String[] aMethodParameterTokens = aMethodParameters.isEmpty()?emptyArray:¬∂		 aMethodParameters.split(",");¬∂		¬∂//		String[] aMethodParameterTypes = new String[aMethodParameterTokens.length];¬∂//		String[] aMethodParameterNames = new String[aMethodParameterTokens.length];¬∂		List<DeclarationSNode> aDeclarationSNodeList = new ArrayList();¬∂		for (int i = 0; i < aMethodParameterTokens.length; i++ ) {¬∂			String[] aTypeAndName = aMethodParameterTokens[i].trim().split("\\s+");¬∂			if (aTypeAndName.length < 2) {¬∂				continue;¬∂			}¬∂			aDeclarationSNodeList.add(new ADeclarationSNode(aLineNumber, aTypeAndName[0].trim(), aTypeAndName[1].trim()));¬∂//			aMethodParameterTypes[i] = aTypeAndName[0].trim();¬∂//			aMethodParameterNames[i] = aTypeAndName[1].trim();¬∂		}¬∂		if (isInternal)¬∂//		return new AMethodSNode(aLineNumber, aMethodNameAndTypeTokens[0], aMethodNameAndTypeTokens[1], aMethodParameterTypes,aMethodParameterNames );¬∂			return new AMethodSNode(aLineNumber, aMethodNameAndTypeTokens[0], aMethodNameAndTypeTokens[1], aDeclarationSNodeList );¬∂		else¬∂			return new AnExternalMethodSNode(aLineNumber, aMethodNameAndTypeTokens[0], aMethodNameAndTypeTokens[1], aDeclarationSNodeList );¬∂	}¬∂¬∂	public static void setReductionData(OMPForSNode lastChild, String aStoredToken, int aLeftParenIndex,¬∂			int aRightParenIndex) {¬∂		int aColonIndex = aStoredToken.indexOf(":");¬∂		if (aLeftParenIndex != -1 && aRightParenIndex != -1 && aColonIndex != -1) {¬∂			String anOperationString = aStoredToken.substring(aLeftParenIndex + 1, aColonIndex).trim();¬∂			String aVariableString = aStoredToken.substring(aColonIndex + 1, aRightParenIndex).trim();¬∂			((OMPForSNode) lastChild).setReductionVariable(aVariableString);¬∂			((OMPForSNode) lastChild).setReductionOperation(anOperationString);¬∂		}¬∂	}¬∂¬∂	public static void setSharedOrPrivateData(OMPSNode lastChild, String aStoredToken, int aLeftParenIndex,¬∂			int aRightParenIndex, boolean isShared) {¬∂//		int aColonIndex = aStoredToken.indexOf(":");¬∂		if (aLeftParenIndex != -1 && aRightParenIndex != -1) {¬∂			String aVariableDeclarations = aStoredToken.substring(aLeftParenIndex + 1, aRightParenIndex);¬∂			String[] aVariables = aVariableDeclarations.split(",");¬∂			if (isShared) {¬∂				lastChild.setSharedVariables(aVariables);¬∂			} else {¬∂				lastChild.setPrivateVariables(aVariables);¬∂			}¬∂		}¬∂	}¬∂¬∂	public static RootOfFileSNode getSNode(String aFileName, String[] aFileLines) {¬∂		Stack<SNode> anSNodes = new Stack();¬∂¬∂		RootOfFileSNode retVal = new ARootOfFileSNode(aFileName);¬∂		anSNodes.add(retVal);¬∂		SNode previousHeaderNode = null;¬∂		for (int i = 0; i < aFileLines.length; i++) {¬∂			String aFileLine = aFileLines[i].trim();¬∂			if (!isCodeLine(aFileLine)) {¬∂				continue;¬∂			}¬∂			if (isForNode(aFileLine)) {¬∂				ForSNode aForSNode = getForSNode(i, aFileLine);¬∂				aForSNode.setParent(anSNodes.peek());¬∂//				anSNodes.push(aForSNode);¬∂				previousHeaderNode = aForSNode;¬∂				if (aFileLine.endsWith(")")) {¬∂					continue;¬∂				}¬∂			}¬∂			if (isExternalMethodDeclaration(aFileLine)) {¬∂				MethodSNode aMethodSNode = getMethodSNode(i, aFileLine, false);¬∂				aMethodSNode.setParent(anSNodes.peek());¬∂//				anSNodes.push(aForSNode);¬∂				previousHeaderNode = aMethodSNode;¬∂				if (aFileLine.endsWith(")")) {¬∂					continue;¬∂				}¬∂			}¬∂			if (isMethodDeclaration(aFileLine)) {¬∂				MethodSNode aMethodSNode = getMethodSNode(i, aFileLine, true);¬∂				aMethodSNode.setParent(anSNodes.peek());¬∂//				anSNodes.push(aForSNode);¬∂				previousHeaderNode = aMethodSNode;¬∂				if (aFileLine.endsWith(")")) {¬∂					continue;¬∂				}¬∂			}¬∂			if (isPragmaStart(aFileLine)) {¬∂				OMPSNode anOMPSNode = getOMPSNode(i, anSNodes.peek(), aFileLine);¬∂//				anSNodes.push(anOMPSNode);¬∂				previousHeaderNode = anOMPSNode;¬∂				continue;¬∂			}¬∂			if (isBlockStart(aFileLine)) {¬∂				SNode aBlockSNode = new AnSNode(i);¬∂				if (previousHeaderNode != null) {¬∂					aBlockSNode.setParent(previousHeaderNode);¬∂				} else {¬∂					aBlockSNode.setParent(anSNodes.peek());¬∂				}¬∂				anSNodes.push(aBlockSNode);¬∂				previousHeaderNode = null;¬∂				continue;¬∂			}¬∂//			} else ¬∂			if (isBlockEnd(aFileLine)) {¬∂				anSNodes.pop();¬∂				continue;¬∂			}¬∂			SNode aNewLeafNode = null;¬∂			if (isDeclaringAssignment(aFileLine)) {¬∂				aNewLeafNode = getDeclaringAssignmentSNode(i, aFileLine);¬∂¬∂			} else if (isAssignment(aFileLine)) {¬∂				aNewLeafNode = getAssignmentSNode(i, aFileLine);¬∂			} else if (isVariableDeclaration(aFileLine)) {¬∂				aNewLeafNode = getDeclarationSNode(i, aFileLine);¬∂			} else {¬∂				List<MethodCall> aCalls = callsIn(i, aFileLine, null); // parent will be assigned below¬∂				if (aCalls != null && aCalls.size() == 1) {¬∂					aNewLeafNode = aCalls.get(0);¬∂				} else {¬∂					aNewLeafNode = new ATextSNode(i, aFileLine);¬∂				}¬∂			}¬∂//			else {¬∂//				aNewLeafNode = new ATextSNode(i, aFileLine);¬∂//			}¬∂			if (previousHeaderNode != null) {¬∂				aNewLeafNode.setParent(previousHeaderNode);¬∂			} else {¬∂				aNewLeafNode.setParent(anSNodes.peek());¬∂			}¬∂¬∂		}¬∂¬∂		return retVal;¬∂	}¬∂¬∂	public static OMPSNode getOMPSNode(int aLineIndex, SNode aParentNode, String aFileLine) {¬∂		String[] aTokens = aFileLine.split("\\s+");¬∂		if (aTokens.length <= 2) {¬∂			return null;¬∂		}¬∂		if (!aTokens[1].equals("omp")) {¬∂			return null;¬∂		}¬∂		if (aTokens.length < 3) {¬∂			return null;¬∂		}¬∂		String aFirstToken = aTokens[2];¬∂		OpenMPKeywordEnum anOpenMPKeyword = stringToOpenMPKeyword.get(aFirstToken);¬∂//		List<OpenMPPragma> retVal = new ArrayList();¬∂		OMPSNode lastChild = null;¬∂		int aStartIndex = 2;¬∂		OMPSNode aNewNode = null;¬∂		OMPForSNode aForChild = null;¬∂		switch (anOpenMPKeyword) {¬∂		case PARALLEL:¬∂			aNewNode = new AnOMPParallelSNode(aLineIndex);¬∂¬∂			if (aTokens.length > 3 && aTokens[3].equals("for")) {¬∂				aForChild = new AnOMPForSNode(aLineIndex);¬∂				aForChild.setParent(aNewNode);¬∂¬∂				aStartIndex++;¬∂			}¬∂			break;¬∂		case FOR:¬∂			aNewNode = new AnOMPForSNode(aLineIndex);¬∂			;¬∂			break;¬∂		case CRITICAL:¬∂			aNewNode = new AnOMPCriticalSNode(aLineIndex);¬∂//			retVal.add (lastChild);¬∂			break;¬∂		default:¬∂			aNewNode = new AnOMPSNode(aLineIndex);¬∂¬∂		}¬∂¬∂		if (lastChild != null) {¬∂			aNewNode.setParent(lastChild);¬∂		} else {¬∂			aNewNode.setParent(aParentNode);¬∂		}¬∂		lastChild = aForChild == null ? aNewNode : aForChild;¬∂¬∂		for (int i = aStartIndex; i < aTokens.length; i++) {¬∂			String aStoredToken = aTokens[i].trim();¬∂			if (aStoredToken.isEmpty()) {¬∂				continue;¬∂			}¬∂			if (aStoredToken.startsWith("reduction") || aStoredToken.startsWith("shared")¬∂					|| aStoredToken.startsWith("private")) {¬∂				// combine all tokens until ")" into one for normalization¬∂				while (!aStoredToken.endsWith(")")) {¬∂					i++;¬∂					if (i >= aTokens.length) {¬∂						break;¬∂					}¬∂					String aNewToken = aTokens[i].trim();¬∂					aStoredToken += aNewToken;¬∂				}¬∂				int aLeftParenIndex = aStoredToken.indexOf("(");¬∂				int aRightParenIndex = aStoredToken.indexOf(")");¬∂				if (aStoredToken.startsWith("reduction")) {¬∂					setReductionData((OMPForSNode) lastChild, aStoredToken, aLeftParenIndex, aRightParenIndex);¬∂				} else if (aStoredToken.startsWith("private")) {¬∂					setSharedOrPrivateData((OMPSNode) lastChild, aStoredToken, aLeftParenIndex, aRightParenIndex,¬∂							false);¬∂¬∂				} else if (aStoredToken.startsWith("shared")) {¬∂					setSharedOrPrivateData(lastChild, aStoredToken, aLeftParenIndex, aRightParenIndex, true);¬∂¬∂				}¬∂¬∂			}¬∂¬∂			lastChild.getOpenMPTokens().add(aStoredToken);¬∂		}¬∂¬∂		return lastChild;¬∂¬∂	}¬∂¬∂	public static boolean hasParallelAncestor(SNode anSNode) {¬∂		if (anSNode == null) {¬∂			return false;¬∂		}¬∂		if (anSNode instanceof OMPParallelSNode) {¬∂			return true;¬∂		}¬∂		return hasParallelAncestor(anSNode.getParent());¬∂	}¬∂	public static boolean hasCriticalAncestor(SNode anSNode) {¬∂		if (anSNode == null) {¬∂			return false;¬∂		}¬∂		if (anSNode instanceof OMPCriticalSNode) {¬∂			return true;¬∂		}¬∂		return hasCriticalAncestor(anSNode.getParent());¬∂	}¬∂¬∂¬∂	public static Boolean isDeclaredShared(OMPSNode anOMPSNode, String anLHS) {¬∂		if (Arrays.asList(anOMPSNode.getSharedVariables()).contains(anLHS)) {¬∂			return true;¬∂		}¬∂		if (Arrays.asList(anOMPSNode.getPrivateVariables()).contains(anLHS)) {¬∂			return false;¬∂		}¬∂		return null;¬∂¬∂	}¬∂¬∂	public static boolean isSharedVariable(SNode anSNode, String anLHS) {¬∂		if (anSNode == null) {¬∂			return false;¬∂		}¬∂		if (anSNode.getLocalVariables().contains(anLHS)) {¬∂			if (!(anSNode instanceof OMPSNode)) { // no shared and private declarations¬∂				return !hasParallelAncestor(anSNode); // shared if not inParallel¬∂			}¬∂			OMPSNode anOMPSNode = (OMPSNode) anSNode;¬∂			return (Arrays.asList(anOMPSNode.getSharedVariables()).contains(anLHS)); // private unless declared shared¬∂		}¬∂		if (anSNode instanceof OMPSNode) {¬∂			OMPSNode anOMPSNode = (OMPSNode) anSNode;¬∂			// the variable is global to this scope, check if it has have been made shared¬∂			// or private by this scope¬∂			Boolean isDeclaredShared = isDeclaredShared(anOMPSNode, anLHS);¬∂			if (isDeclaredShared != null) {¬∂				return isDeclaredShared;¬∂			}¬∂		}¬∂		// check the parent¬∂		return isSharedVariable(anSNode.getParent(), anLHS);¬∂	}¬∂¬∂	public static List<SNode> getAllLeafNodes(SNode aTopNode) {¬∂		List<SNode> retVal = new ArrayList();¬∂		addLeafNodes(aTopNode, retVal);¬∂		return retVal;¬∂	}¬∂¬∂	public static void addLeafNodes(SNode aTopNode, List<SNode> retVal) {¬∂		for (SNode aChild : aTopNode.getChildren()) {¬∂			if (aChild.isLeaf()) {¬∂				retVal.add(aChild);¬∂			} else {¬∂				addLeafNodes(aChild, retVal);¬∂			}¬∂		}¬∂	}¬∂¬∂	public static List<SNode> getNonParallelLeafNodes(SNode aTopNode) {¬∂		List<SNode> retVal = new ArrayList();¬∂		addNonParallelLeafNodes(aTopNode, retVal);¬∂		return retVal;¬∂	}¬∂¬∂	public static void addNonParallelLeafNodes(SNode aTopNode, List<SNode> retVal) {¬∂		if (aTopNode.isInParallel()) {¬∂			return;¬∂		}¬∂		for (SNode aChild : aTopNode.getChildren()) {¬∂			if (aChild.isLeaf()) {¬∂				retVal.add(aChild);¬∂			} else {¬∂				addLeafNodes(aChild, retVal);¬∂			}¬∂		}¬∂	}¬∂	static String callRegex = "([a-zA-Z_$][a-zA-Z_$0-9]*)\\(.*?\\)";¬∂	static Pattern callPattern = Pattern.compile(callRegex);¬∂¬∂	static String identifierRegex = "[a-zA-Z_$][a-zA-Z_$0-9]*";¬∂	static Pattern identifierPattern = Pattern.compile(identifierRegex);¬∂	public static List<String> identifiersIn(String aString) {¬∂		if (aString == null)¬∂			return null;¬∂//		Pattern mypattern = Pattern.compile("[a-zA-Z_$][a-zA-Z_$0-9]*");¬∂//		Matcher mymatcher = mypattern.matcher(aString);¬∂		Matcher mymatcher = identifierPattern.matcher(aString);¬∂		List<String> retVal = new ArrayList();¬∂		while (mymatcher.find()) {¬∂			String find = mymatcher.group(0);¬∂			retVal.add(find);¬∂		}¬∂		return retVal;¬∂	}¬∂	public static List<MethodCall> callsIn(int aLineNumber, String aString, SNode aParent) {¬∂		if (aString == null)¬∂			return null;¬∂//		Pattern mypattern = Pattern.compile("[a-zA-Z_$][a-zA-Z_$0-9]*");¬∂//		Matcher mymatcher = mypattern.matcher(aString);¬∂		Matcher mymatcher = callPattern.matcher(aString);¬∂		List<MethodCall> retVal = new ArrayList();¬∂		while (mymatcher.find()) {¬∂			String find = mymatcher.group(0);¬∂			int aLeftParenIndex = find.indexOf("(");¬∂			int aRightParenIndex = find.indexOf(")");¬∂			String aMethodName = find.substring(0, aLeftParenIndex).trim();¬∂			String aParameters = find.substring(aLeftParenIndex + 1, aRightParenIndex);¬∂			List<String> aParameterList = new ArrayList();¬∂			String[] aParameterTokens = aParameters.split(",");¬∂			for (String aParameter:aParameterTokens) {¬∂				String aParameterTrimmed = aParameter.trim();¬∂				if (!aParameterTrimmed.isEmpty())¬∂				aParameterList.add(aParameterTrimmed);¬∂			}¬∂			retVal.add(new AMethodCall(aLineNumber, aMethodName, aParameterList, aParent));¬∂¬∂//			aCallStrings.add(find);¬∂		}¬∂		return retVal;¬∂	}¬∂	static String numberRegex = "(\\d+\\.\\d+)|(\\d+)";¬∂	static Pattern numberPattern = Pattern.compile(numberRegex);¬∂	public static List<String> numbersIn(String aString) {¬∂		if (aString == null)¬∂			return null;¬∂//		String regex = "(\\d+\\.\\d+)|(\\d+)";¬∂//¬∂//		Matcher m = Pattern.compile(regex).matcher(aString);¬∂		Matcher m =numberPattern.matcher(aString);¬∂¬∂¬∂		List<String> retVal = new ArrayList();¬∂¬∂		while (m.find()) {¬∂			retVal.add(m.group());¬∂		}¬∂		return retVal;¬∂	}¬∂¬∂	public static String subscriptIn(String aString) {¬∂		if (aString == null)¬∂			return null;¬∂		return StringUtils.substringBetween(aString, "[", "]");¬∂	}¬∂	static String[] emptyStringArray = {};¬∂	public static String[] subscriptsIn(String aString) {¬∂		if (aString == null)¬∂			return emptyStringArray;¬∂		return StringUtils.substringsBetween(aString, "[", "]");¬∂	}¬∂	static  String operatorRegex = "([+-/*///^])|([/(/)])";¬∂	static Pattern operatorPattern = Pattern.compile(operatorRegex);¬∂¬∂	public static List<String> operatorsIn(String aString) {¬∂		if (aString == null)¬∂			return null;¬∂//		String operatorRegex = "([+-/*///^])|([/(/)])";¬∂//¬∂//		Matcher m = Pattern.compile(operatorRegex).matcher(aString);¬∂		¬∂		Matcher m = operatorPattern.matcher(aString);¬∂¬∂¬∂		List<String> retVal = new ArrayList();¬∂¬∂		while (m.find()) {¬∂			retVal.add(m.group());¬∂		}¬∂		return retVal;¬∂	}¬∂	¬∂	public static int numberOfNestingFors (SNode anSNode) {¬∂		if (anSNode == null) {¬∂			return 0;¬∂		}¬∂		int retVal = numberOfNestingFors (anSNode.getParent()) ;¬∂¬∂		if (anSNode instanceof ForSNode) {¬∂			retVal++;¬∂		} else if (anSNode instanceof MethodSNode) {¬∂			List<MethodCall> aMethodCalls = ((MethodSNode) anSNode).getCalls();¬∂			int aMaxNestingLevel = 0;¬∂			for (MethodCall aMethodCall:aMethodCalls) {¬∂				MethodSNode aCallerMethodSNode = getDeclarationOfCalledMethod(anSNode, aMethodCall);¬∂				int aCallerNumberOfNestingFors = numberOfNestingFors(aCallerMethodSNode);¬∂				aMaxNestingLevel = Math.max(aCallerNumberOfNestingFors, aMaxNestingLevel);				¬∂			}¬∂			return retVal + aMaxNestingLevel;¬∂		}¬∂		return retVal;¬∂	}¬∂	public static boolean hasOperator (SNode anSNode, String anOperator) {¬∂		boolean retVal = false;¬∂		if (anSNode instanceof AssignmentSNode) {¬∂			AssignmentSNode anAssignmentSNode = (AssignmentSNode) anSNode;¬∂			 retVal = (anAssignmentSNode.getLhsOperators().contains(anOperator) || ¬∂					anAssignmentSNode.getRhsOperators().contains(anOperator)) ;¬∂			if (retVal) {¬∂				return retVal;¬∂			} else {¬∂				List<MethodCall> aMethodCalls = anAssignmentSNode.getRhsCalls();¬∂				for (MethodCall aMethodCall:aMethodCalls) {¬∂					MethodSNode aMethodSNode = getDeclarationOfCalledMethod(anSNode, aMethodCall);¬∂					retVal = hasOperator(aMethodSNode, anOperator);¬∂					if (retVal) {¬∂						return retVal;¬∂					}¬∂					¬∂				}¬∂				return false;¬∂			}¬∂			¬∂		}¬∂		for (SNode aChild:anSNode.getChildren()) {¬∂			retVal = hasOperator(aChild, anOperator);¬∂			if (retVal) {¬∂				return retVal;¬∂			}¬∂		}¬∂		return false;¬∂	}¬∂	public static boolean hasMethodCall (SNode anSNode, String anOperator) {¬∂		boolean retVal = false;¬∂		if (anSNode instanceof AssignmentSNode) {¬∂			AssignmentSNode anAssignmentSNode = (AssignmentSNode) anSNode;¬∂			 retVal = (anAssignmentSNode.getLhsOperators().contains(anOperator) || ¬∂					anAssignmentSNode.getRhsOperators().contains(anOperator)) ;¬∂			if (retVal) {¬∂				return retVal;¬∂			} else {¬∂				List<MethodCall> aMethodCalls = anAssignmentSNode.getRhsCalls();¬∂				for (MethodCall aMethodCall:aMethodCalls) {¬∂					MethodSNode aMethodSNode = getDeclarationOfCalledMethod(anSNode, aMethodCall);¬∂					retVal = hasOperator(aMethodSNode, anOperator);¬∂					if (retVal) {¬∂						return retVal;¬∂					}¬∂					¬∂				}¬∂				return false;¬∂			}¬∂			¬∂		}¬∂		for (SNode aChild:anSNode.getChildren()) {¬∂			retVal = hasOperator(aChild, anOperator);¬∂			if (retVal) {¬∂				return retVal;¬∂			}¬∂		}¬∂		return false;¬∂	}¬∂	public static boolean dependsOn (AssignmentSNode anAssignmentSNode, String aVariable, String aCallIdentifier) {¬∂		// This assignment does not change aVariable¬∂		if (!aVariable.equals(anAssignmentSNode.getLhsVariable())) {¬∂			return false;¬∂		}¬∂		return dependsOn(anAssignmentSNode.getExpressionSNode(), aCallIdentifier);¬∂//		List<String> aCallIdentifiers = anAssignmentSNode.getRhsCallIdentifiers();¬∂//		boolean retVal = false;¬∂//		if (aCallIdentifiers != null && aCallIdentifiers.contains(aCallIdentifier)) {¬∂//			return true; // this assignment has aCallIdentifier in the rhs¬∂//		}¬∂//		// check if some referenced rhs variable depends on aCallIdentifier¬∂//		List<String> aReferencedVariableIdentifiers = anAssignmentSNode.getRhsVariableIdentifiers();¬∂//		SNode anAssignmentParent = anAssignmentSNode.getParent();¬∂//		if (anAssignmentParent == null) { // should never be trye¬∂//			return false;¬∂//		}¬∂//		int aLineNumber = anAssignmentSNode.getLineNumber();¬∂//		for (String aReferencedVariableIdentifier:aReferencedVariableIdentifiers ) {¬∂//			if (dependsOn (anAssignmentParent, aLineNumber, aReferencedVariableIdentifier, aCallIdentifier)) {¬∂//				return true;¬∂//			}¬∂//		}¬∂//		return false;¬∂	}¬∂	public static boolean dependsOn (ExpressionSNode anExpressionSNode, String aCallIdentifier) {¬∂		// This assignment does not change aVariable¬∂		¬∂		List<String> aCallIdentifiers = anExpressionSNode.getRhsCallIdentifiers();¬∂		boolean retVal = false;¬∂		if (aCallIdentifiers != null && aCallIdentifiers.contains(aCallIdentifier)) {¬∂			return true; // this assignment has aCallIdentifier in the rhs¬∂		}¬∂		// check if some referenced rhs variable depends on aCallIdentifier¬∂		List<String> aReferencedVariableIdentifiers = anExpressionSNode.getRhsVariableIdentifiers();¬∂		SNode anAssignmentParent = anExpressionSNode.getParent().getParent();¬∂		if (anAssignmentParent == null) { // should never be trye¬∂			return false;¬∂		}¬∂		int aLineNumber = anExpressionSNode.getLineNumber();¬∂		for (String aReferencedVariableIdentifier:aReferencedVariableIdentifiers ) {¬∂			if (dependsOn (anAssignmentParent, aLineNumber, aReferencedVariableIdentifier, aCallIdentifier)) {¬∂				return true;¬∂			}¬∂		}¬∂		return false;¬∂	}¬∂	public static Set<AssignmentSNode> assignmentsToSharedVariables(SNode anSNode) {¬∂		Set<AssignmentSNode> retVal =  new HashSet();¬∂		fillAssignmentsToShared(anSNode, retVal);¬∂		return retVal;¬∂		¬∂	}¬∂	public static Set<AssignmentSNode> assignmentsToSharedArrays(SNode anSNode) {¬∂		Set<AssignmentSNode> anAllSharedAssignments =  assignmentsToSharedVariables(anSNode);¬∂		Set<AssignmentSNode> aRetVal = new HashSet();¬∂		for (AssignmentSNode anAssignmentSNode:anAllSharedAssignments) {¬∂			if (anAssignmentSNode.getLhsSubscripts().length > 0) {¬∂				aRetVal.add(anAssignmentSNode);¬∂			}¬∂		}¬∂		return aRetVal;¬∂		¬∂	}¬∂	public static Set<AssignmentSNode> assignmentsToParallel"), Diff(DELETE,"Shared"), Diff(EQUAL,"Critical"), Diff(INSERT,"SharedVariables"), Diff(EQUAL,"(SNode anSNode) {¬∂		Set<AssignmentSNode> anAllSharedAssignments =  assignmentsToSharedVariables(anSNode);¬∂		Set<AssignmentSNode> aRetVal = new HashSet();¬∂		for (AssignmentSNode anAssignmentSNode:anAllSharedAssignments) {¬∂			if (anAssignmentSNode.isInParallel() &&¬∂					anAssignmentSNode.isInCritical()) {¬∂				aRetVal.add(anAssignmentSNode);¬∂			}¬∂		}¬∂		return aRetVal;¬∂		¬∂	}¬∂	public static Set<AssignmentSNode> assignmentsToNonParallel"), Diff(DELETE,"Shared"), Diff(EQUAL,"Critical"), Diff(INSERT,"SharedVariables"), Diff(EQUAL,"(SNode anSNode) {¬∂		Set<AssignmentSNode> anAllSharedAssignments =  assignmentsToSharedVariables(anSNode);¬∂		Set<AssignmentSNode> aRetVal = new HashSet();¬∂		for (AssignmentSNode anAssignmentSNode:anAllSharedAssignments) {¬∂			if (!anAssignmentSNode.isInParallel() &&¬∂"), Diff(DELETE,""), Diff(EQUAL,"					anAssignmentSNode.isInCritical()) {¬∂				aRetVal.add(anAssignmentSNode);¬∂			}¬∂		}¬∂		return aRetVal;¬∂		¬∂	}¬∂"), Diff(INSERT,"	public static Set<AssignmentSNode> assignmentsToParallelNonCriticalSharedVariables(SNode anSNode) {¬∂		Set<AssignmentSNode> anAllSharedAssignments =  assignmentsToSharedVariables(anSNode);¬∂		Set<AssignmentSNode> aRetVal = new HashSet();¬∂		for (AssignmentSNode anAssignmentSNode:anAllSharedAssignments) {¬∂			if (anAssignmentSNode.isInParallel() &&¬∂					!anAssignmentSNode.isInCritical()) {¬∂				aRetVal.add(anAssignmentSNode);¬∂			}¬∂		}¬∂		return aRetVal;¬∂		¬∂	}¬∂"), Diff(EQUAL,"    public static void fillAssignmentsToShared(SNode anSNode, Set<AssignmentSNode> retVal) {¬∂    	if (anSNode instanceof AssignmentSNode) {¬∂			AssignmentSNode anAssignmentSNode = (AssignmentSNode) anSNode;¬∂			String anLHS = anAssignmentSNode.getLhsVariable();¬∂			if (isSharedVariable(anSNode, anLHS)) {¬∂				retVal.add(anAssignmentSNode);¬∂				return;¬∂			}¬∂		}¬∂    	for (SNode aChild:anSNode.getChildren()) {¬∂    		fillAssignmentsToShared(aChild, retVal);¬∂    	}¬∂		¬∂	}¬∂	public static boolean dependsOn (SNode anSNode, int aVariableLineNumber, String aVariable, String aCallIdentifier) {¬∂		List<SNode> aListSNodes = anSNode.getChildren();¬∂		boolean retVal = false;¬∂		/*¬∂		 * Should probably ignore line number as it assumes straight line code¬∂		 */¬∂		for (int i = aVariableLineNumber; i >= 0; i--) {¬∂			SNode anSNodeChild = aListSNodes.get(i);¬∂			if (anSNodeChild instanceof AssignmentSNode) {¬∂				// does this statement in anSNode directly invoke aCallIdentifier ¬∂				if (dependsOn((AssignmentSNode) anSNodeChild, aVariable, aCallIdentifier))¬∂					return true;¬∂			} else if (!anSNode.isLeaf()) {¬∂					// child is overriding the variable so forget checking its assignment statements¬∂					if (anSNodeChild.getLocalVariables().contains(aVariable)) {¬∂						continue;¬∂					}¬∂					// some subblock of anSNode that has access to aVariable changes variable¬∂¬∂					if (dependsOn(anSNodeChild, anSNodeChild.getChildren().size() - 1, aVariable, aCallIdentifier)) {¬∂						return true;¬∂					}¬∂			}¬∂			¬∂		}¬∂		// none of the statements in anSNode or its descendents  have the required call¬∂		// is the variable a  method parameter ¬∂		if (anSNode instanceof MethodSNode) {¬∂			MethodSNode aMethodSNode = (MethodSNode) anSNode;¬∂			¬∂			int aParameterNumber = aMethodSNode.getLocalVariables().indexOf(aVariable);¬∂			if (aParameterNumber != -1) {¬∂				List <MethodCall> aCalls = aMethodSNode.getCalls();¬∂				for (MethodCall aCall:aCalls) {¬∂					MethodSNode aCallerSNode = getDeclarationOfCalledMethod(aMethodSNode, aCall);¬∂					boolean aCallerDepends = dependsOn(aMethodSNode, aCallerSNode.getLineNumber(), aVariable, aCallIdentifier);¬∂				    if (aCallerDepends) {¬∂				    	return true;¬∂				    }¬∂				}¬∂				return false;¬∂				// need to find all callers of method and see if any of the aliases for the variable in these¬∂				// calls depend on aCallIndentifier¬∂			}			¬∂			¬∂		} else if (anSNode.getLocalVariables().contains(aVariable)) {¬∂			// before going to the parent node, let us see if aVariable is declared here as a non  parameter ¬∂¬∂			return false; // no point going to parent¬∂		}¬∂		// not a local variable (parameter or declarated variable)¬∂		SNode anSNodeParent = anSNode.getParent() ;¬∂		if (anSNodeParent == null)  {¬∂			return false;¬∂		}¬∂		int anSNodeLineNumber = anSNodeParent.getChildren().indexOf(anSNode);¬∂		return dependsOn(anSNodeParent, anSNodeLineNumber, aVariable, aCallIdentifier);¬∂		¬∂	}¬∂	public static RootOfFileSNode getRootOfFileNode(SNode aCurrentSNode ) {¬∂		if (aCurrentSNode instanceof RootOfFileSNode) {¬∂			return (RootOfFileSNode) aCurrentSNode;¬∂		}¬∂		SNode aParentSNode = aCurrentSNode.getParent() ;¬∂		¬∂		if (aParentSNode == null) {¬∂			return null;¬∂		}¬∂		¬∂		return getRootOfFileNode(aParentSNode);¬∂		¬∂	}¬∂	public static boolean match (MethodSNode aMethodSNode, MethodCall aMethodCall) {¬∂		return aMethodSNode.getMethodName().equals(aMethodCall.getMethodName()) ¬∂				&& aMethodSNode.getLocalVariables().size() == aMethodCall.getMethodActuals().size();¬∂	}¬∂	¬∂	public static MethodSNode getDeclarationOfCalledMethod(SNode aCurrentSNode, MethodCall aMethodCall ) {¬∂		SNode aRootNode = getRootOfFileNode(aCurrentSNode);¬∂		for (SNode aChild:aRootNode.getChildren()) {¬∂			if (aChild instanceof MethodSNode) {¬∂				MethodSNode aMethodSNode = (MethodSNode) aChild;¬∂				if (match (aMethodSNode, aMethodCall)) {¬∂					return aMethodSNode;¬∂				}¬∂			}¬∂		}¬∂		return null; // this should never happen;¬∂	}¬∂	¬∂	public static RootOfProgramSNode getRootOfProgramSNode(String aSource) {¬∂		RootOfProgramSNode retVal = new ARootOfProgramSNode();¬∂		Map<String, StringBuffer> aFileNameToContents = ABasicTextManager.extractFileContents(aSource);¬∂		for (String aFileName:aFileNameToContents.keySet()) {¬∂			StringBuffer aFileContents = aFileNameToContents.get(aFileName);¬∂//			List<OpenMPPragma> anOpenMPPragmas = OpenMPUtils.getOpemMPPragmas(aFileContents);¬∂			RootOfFileSNode anSNode = OMPSNodeUtils.getSNode(aFileName, aFileContents);¬∂			retVal.getFileNameToSNode().put(aFileName, anSNode);¬∂			anSNode.setParent(retVal);¬∂//			System.out.println("file name:" + aFileName);¬∂//			System.out.println("pragmas:" + anSNode);¬∂		}¬∂		processExternalMethodSNodes(retVal);¬∂		return retVal;¬∂	}¬∂	public static void processExternalMethodSNodes (RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode) {¬∂		for (SNode anSNode:aRootOfFileSNode.getChildren()) {¬∂			if (anSNode instanceof ExternalMethodSNode) {¬∂				processExternalMethodSNode(aRootOfProgramSNode, aRootOfFileSNode, (ExternalMethodSNode) anSNode);¬∂			}¬∂		}¬∂	}¬∂	public static void processExternalMethodSNode (RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode, ExternalMethodSNode anExternalMethodSNode) {¬∂		MethodSNode aMethodSNode = aRootOfProgramSNode.getExternalToInternalMethod().get(anExternalMethodSNode.toString());¬∂		if (aMethodSNode == null) {¬∂			aMethodSNode = findMethodSNode(aRootOfProgramSNode, aRootOfFileSNode, anExternalMethodSNode);¬∂			if (aMethodSNode != null) {¬∂				aRootOfProgramSNode.getExternalToInternalMethod().put(anExternalMethodSNode.toString(),aMethodSNode );¬∂			}¬∂		}¬∂		if (aMethodSNode != null) {¬∂			anExternalMethodSNode.setActualMethodSNode(aMethodSNode);¬∂			aMethodSNode.getCalls().addAll(anExternalMethodSNode.getLocalCalls());¬∂		}¬∂	}¬∂	public static MethodSNode findMethodSNode (RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode, ExternalMethodSNode anExternalMethodSNode) {¬∂//		MethodSNode foundMethodSNode = null;¬∂		for (String aFileName:aRootOfProgramSNode.getFileNameToSNode().keySet()) {¬∂			if (aFileName.equals(aRootOfFileSNode.getFileName()))¬∂				continue;¬∂			¬∂			RootOfFileSNode aSearchedRootOfFileSNode = aRootOfProgramSNode.getFileNameToSNode().get(aFileName);¬∂			 for (SNode anSNode:aSearchedRootOfFileSNode.getChildren()) {¬∂				if (anSNode instanceof MethodSNode && !(anSNode instanceof ExternalMethodSNode)) {¬∂					if (anSNode.toString().equals(anExternalMethodSNode.toString())) {¬∂						return (MethodSNode) anSNode;¬∂						¬∂					}¬∂//					processExternalMethodSNode(aRootOfProgramSNode, aRootOfFileSNode, (ExternalMethodSNode) anSNode);¬∂				}¬∂			}¬∂		}¬∂		return null;¬∂	}¬∂	public static void processExternalMethodSNodes (RootOfProgramSNode aRootOfProgramSNode) {¬∂		for (String aFileName:aRootOfProgramSNode.getFileNameToSNode().keySet()) {¬∂			RootOfFileSNode aRootOfFileSNode = aRootOfProgramSNode.getFileNameToSNode().get(aFileName);¬∂			processExternalMethodSNodes(aRootOfProgramSNode, aRootOfFileSNode);¬∂			aRootOfFileSNode.getOmp_get_num_threads_SNode().¬∂				setActualMethodSNode(aRootOfProgramSNode.getOmp_get_num_threads_SNode());¬∂			aRootOfFileSNode.getOmp_get_thread_num_SNode().¬∂				setActualMethodSNode(aRootOfProgramSNode.getOmp_get_thread_num_SNode());¬∂			aRootOfFileSNode.getOmp_get_wtime_SNode().¬∂			setActualMethodSNode(aRootOfProgramSNode.getOmp_get_wtime_SNode());¬∂		}¬∂¬∂	}¬∂	¬∂¬∂//	public static void main(String[] args) {¬∂//		List<MethodCall> aTokens = callsIn("foo(bar, hgf)/foo2()*foo3(b, a c,)");¬∂//		System.out.println(aTokens);¬∂//		¬∂//		¬∂////		List<String> aTokens = identifiersIn("a[i] + b*2/3");¬∂////		System.out.println(aTokens);¬∂////		aTokens = numbersIn("a[i] + b*2/3");¬∂////		System.out.println(aTokens);¬∂////		aTokens = operatorsIn("a[i] + b*2/3");¬∂////		System.out.println(aTokens);¬∂////¬∂////		System.out.println(StringUtils.substringBetween("a", "[", "]"));¬∂//	}¬∂¬∂}¬∂")]]]></diff>
    <snapshot><![CDATA[package gradingTools.shared.testcases.openmp.scannedTree;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Stack;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.apache.commons.lang.StringUtils;

import grader.basics.project.source.ABasicTextManager;
import gradingTools.shared.testcases.openmp.OpenMPKeywordEnum;
import gradingTools.shared.testcases.openmp.OpenMPParallelPragma;
import gradingTools.shared.testcases.openmp.OpenMPUtils;
import gradingTools.shared.testcases.openmp.scannedTree.ADeclarationSNode;
import gradingTools.shared.testcases.openmp.scannedTree.ADeclaringAssignmentSNode;
import gradingTools.shared.testcases.openmp.scannedTree.AForSNode;
import gradingTools.shared.testcases.openmp.scannedTree.ATextSNode;
import gradingTools.shared.testcases.openmp.scannedTree.AnAssignmentSNode;
import gradingTools.shared.testcases.openmp.scannedTree.AnOMPCriticalSNode;
import gradingTools.shared.testcases.openmp.scannedTree.AnOMPForSNode;
import gradingTools.shared.testcases.openmp.scannedTree.AnOMPParallelSNode;
import gradingTools.shared.testcases.openmp.scannedTree.AnOMPSNode;
import gradingTools.shared.testcases.openmp.scannedTree.AnSNode;
import gradingTools.shared.testcases.openmp.scannedTree.AssignmentSNode;
import gradingTools.shared.testcases.openmp.scannedTree.DeclarationSNode;
import gradingTools.shared.testcases.openmp.scannedTree.DeclaringAssignmentSNode;
import gradingTools.shared.testcases.openmp.scannedTree.ForSNode;
import gradingTools.shared.testcases.openmp.scannedTree.OMPForSNode;
import gradingTools.shared.testcases.openmp.scannedTree.OMPSNode;
import gradingTools.shared.testcases.openmp.scannedTree.SNode;

public class OMPSNodeUtils extends OpenMPUtils {

	public static RootOfFileSNode getSNode(String aFileName, StringBuffer aFileBuffer) {
		String[] aFileLines = aFileBuffer.toString().split("\n");
		return getSNode(aFileName, aFileLines);
	}

	public static AssignmentSNode getAssignmentSNode(int aLineNumber, String aString) {
		if (aString == null) {
			return null;
		}
		String[] aTokens = aString.split("=");
		if (aTokens.length == 1) {
			return new AnAssignmentSNode(aLineNumber, aTokens[0], null);
		} else {
		return new AnAssignmentSNode(aLineNumber, aTokens[0], aTokens[1]);
		}
	}

	public static DeclarationSNode getDeclarationSNode(int aLineNumber, String aString) {
		String[] aTokens = aString.split(" ");
		return new ADeclarationSNode(aLineNumber, aTokens[0], aTokens[1]);
	}

	public static DeclaringAssignmentSNode getDeclaringAssignmentSNode(int aLineNumber, String aString) {
		String[] anLHSAndRHS = aString.split("=");
		String[] aTypeAndVariable = anLHSAndRHS[0].split(" ");
		return new ADeclaringAssignmentSNode(aLineNumber, aTypeAndVariable[0], aTypeAndVariable[1], anLHSAndRHS[1]);
	}

	public static boolean isDeclaringAssignment(String aFileLine) {
		return startsWithTypeName(aFileLine) && aFileLine.contains("=");
	}
	public static boolean isMethodDeclaration(String aFileLine) {
		return startsWithTypeName(aFileLine) && 
				aFileLine.contains("(") &&
				!aFileLine.contains("=");
	}
	public static boolean isExternalMethodDeclaration(String aFileLine) {
		return isMethodDeclaration(aFileLine) && aFileLine.endsWith(";");
	}


	public static boolean isVariableDeclaration(String aFileLine) {

		return startsWithTypeName(aFileLine) && !aFileLine.contains("(");
	}

	public static boolean isAssignment(String aFileLine) {
		return aFileLine.contains("=");
	}

	public static boolean isForNode(String aFileLine) {
		return aFileLine.startsWith("for");
	}

	public static ForSNode getForSNode(int aLineNumber, String aFileLine) {

		int aLeftParenIndex = aFileLine.indexOf("(");
		int aRightParenIndex = aFileLine.indexOf(")");
		if (aLeftParenIndex < 0 || aRightParenIndex < 0) {
			return null;
		}
		String aHeaderString = aFileLine.substring(aLeftParenIndex + 1, aRightParenIndex);
		String[] aForComponents = aHeaderString.split(";");
		AssignmentSNode anAssignmentSNode = null;
		String aForInitializaton = aForComponents[0];
		if (!aForInitializaton.isEmpty() && aForInitializaton.contains("=")) {
			if (isDeclaringAssignment(aForInitializaton)) {
				anAssignmentSNode = getDeclaringAssignmentSNode(aLineNumber, aForInitializaton);
			} else {
				anAssignmentSNode = getAssignmentSNode(aLineNumber, aForInitializaton);
			}

		}		
		return new AForSNode(aLineNumber, anAssignmentSNode, aForComponents[1], getAssignmentSNode(aLineNumber, aForComponents[2]));
	}
	static String[] emptyArray = {};
	public static MethodSNode getMethodSNode(int aLineNumber, String aFileLine, boolean isInternal) {

		int aLeftParenIndex = aFileLine.indexOf("(");
		int aRightParenIndex = aFileLine.indexOf(")");
		if (aLeftParenIndex < 0 || aRightParenIndex < 0) {
			return null;
		}
		String aMethodNameAndType = aFileLine.substring(0, aLeftParenIndex);
		String[] aMethodNameAndTypeTokens = aMethodNameAndType.split("\\s+"); 
		
		String aMethodParameters = aFileLine.substring(aLeftParenIndex +1 , aRightParenIndex);
		String[] aMethodParameterTokens = aMethodParameters.isEmpty()?emptyArray:
		 aMethodParameters.split(",");
		
//		String[] aMethodParameterTypes = new String[aMethodParameterTokens.length];
//		String[] aMethodParameterNames = new String[aMethodParameterTokens.length];
		List<DeclarationSNode> aDeclarationSNodeList = new ArrayList();
		for (int i = 0; i < aMethodParameterTokens.length; i++ ) {
			String[] aTypeAndName = aMethodParameterTokens[i].trim().split("\\s+");
			if (aTypeAndName.length < 2) {
				continue;
			}
			aDeclarationSNodeList.add(new ADeclarationSNode(aLineNumber, aTypeAndName[0].trim(), aTypeAndName[1].trim()));
//			aMethodParameterTypes[i] = aTypeAndName[0].trim();
//			aMethodParameterNames[i] = aTypeAndName[1].trim();
		}
		if (isInternal)
//		return new AMethodSNode(aLineNumber, aMethodNameAndTypeTokens[0], aMethodNameAndTypeTokens[1], aMethodParameterTypes,aMethodParameterNames );
			return new AMethodSNode(aLineNumber, aMethodNameAndTypeTokens[0], aMethodNameAndTypeTokens[1], aDeclarationSNodeList );
		else
			return new AnExternalMethodSNode(aLineNumber, aMethodNameAndTypeTokens[0], aMethodNameAndTypeTokens[1], aDeclarationSNodeList );
	}

	public static void setReductionData(OMPForSNode lastChild, String aStoredToken, int aLeftParenIndex,
			int aRightParenIndex) {
		int aColonIndex = aStoredToken.indexOf(":");
		if (aLeftParenIndex != -1 && aRightParenIndex != -1 && aColonIndex != -1) {
			String anOperationString = aStoredToken.substring(aLeftParenIndex + 1, aColonIndex).trim();
			String aVariableString = aStoredToken.substring(aColonIndex + 1, aRightParenIndex).trim();
			((OMPForSNode) lastChild).setReductionVariable(aVariableString);
			((OMPForSNode) lastChild).setReductionOperation(anOperationString);
		}
	}

	public static void setSharedOrPrivateData(OMPSNode lastChild, String aStoredToken, int aLeftParenIndex,
			int aRightParenIndex, boolean isShared) {
//		int aColonIndex = aStoredToken.indexOf(":");
		if (aLeftParenIndex != -1 && aRightParenIndex != -1) {
			String aVariableDeclarations = aStoredToken.substring(aLeftParenIndex + 1, aRightParenIndex);
			String[] aVariables = aVariableDeclarations.split(",");
			if (isShared) {
				lastChild.setSharedVariables(aVariables);
			} else {
				lastChild.setPrivateVariables(aVariables);
			}
		}
	}

	public static RootOfFileSNode getSNode(String aFileName, String[] aFileLines) {
		Stack<SNode> anSNodes = new Stack();

		RootOfFileSNode retVal = new ARootOfFileSNode(aFileName);
		anSNodes.add(retVal);
		SNode previousHeaderNode = null;
		for (int i = 0; i < aFileLines.length; i++) {
			String aFileLine = aFileLines[i].trim();
			if (!isCodeLine(aFileLine)) {
				continue;
			}
			if (isForNode(aFileLine)) {
				ForSNode aForSNode = getForSNode(i, aFileLine);
				aForSNode.setParent(anSNodes.peek());
//				anSNodes.push(aForSNode);
				previousHeaderNode = aForSNode;
				if (aFileLine.endsWith(")")) {
					continue;
				}
			}
			if (isExternalMethodDeclaration(aFileLine)) {
				MethodSNode aMethodSNode = getMethodSNode(i, aFileLine, false);
				aMethodSNode.setParent(anSNodes.peek());
//				anSNodes.push(aForSNode);
				previousHeaderNode = aMethodSNode;
				if (aFileLine.endsWith(")")) {
					continue;
				}
			}
			if (isMethodDeclaration(aFileLine)) {
				MethodSNode aMethodSNode = getMethodSNode(i, aFileLine, true);
				aMethodSNode.setParent(anSNodes.peek());
//				anSNodes.push(aForSNode);
				previousHeaderNode = aMethodSNode;
				if (aFileLine.endsWith(")")) {
					continue;
				}
			}
			if (isPragmaStart(aFileLine)) {
				OMPSNode anOMPSNode = getOMPSNode(i, anSNodes.peek(), aFileLine);
//				anSNodes.push(anOMPSNode);
				previousHeaderNode = anOMPSNode;
				continue;
			}
			if (isBlockStart(aFileLine)) {
				SNode aBlockSNode = new AnSNode(i);
				if (previousHeaderNode != null) {
					aBlockSNode.setParent(previousHeaderNode);
				} else {
					aBlockSNode.setParent(anSNodes.peek());
				}
				anSNodes.push(aBlockSNode);
				previousHeaderNode = null;
				continue;
			}
//			} else 
			if (isBlockEnd(aFileLine)) {
				anSNodes.pop();
				continue;
			}
			SNode aNewLeafNode = null;
			if (isDeclaringAssignment(aFileLine)) {
				aNewLeafNode = getDeclaringAssignmentSNode(i, aFileLine);

			} else if (isAssignment(aFileLine)) {
				aNewLeafNode = getAssignmentSNode(i, aFileLine);
			} else if (isVariableDeclaration(aFileLine)) {
				aNewLeafNode = getDeclarationSNode(i, aFileLine);
			} else {
				List<MethodCall> aCalls = callsIn(i, aFileLine, null); // parent will be assigned below
				if (aCalls != null && aCalls.size() == 1) {
					aNewLeafNode = aCalls.get(0);
				} else {
					aNewLeafNode = new ATextSNode(i, aFileLine);
				}
			}
//			else {
//				aNewLeafNode = new ATextSNode(i, aFileLine);
//			}
			if (previousHeaderNode != null) {
				aNewLeafNode.setParent(previousHeaderNode);
			} else {
				aNewLeafNode.setParent(anSNodes.peek());
			}

		}

		return retVal;
	}

	public static OMPSNode getOMPSNode(int aLineIndex, SNode aParentNode, String aFileLine) {
		String[] aTokens = aFileLine.split("\\s+");
		if (aTokens.length <= 2) {
			return null;
		}
		if (!aTokens[1].equals("omp")) {
			return null;
		}
		if (aTokens.length < 3) {
			return null;
		}
		String aFirstToken = aTokens[2];
		OpenMPKeywordEnum anOpenMPKeyword = stringToOpenMPKeyword.get(aFirstToken);
//		List<OpenMPPragma> retVal = new ArrayList();
		OMPSNode lastChild = null;
		int aStartIndex = 2;
		OMPSNode aNewNode = null;
		OMPForSNode aForChild = null;
		switch (anOpenMPKeyword) {
		case PARALLEL:
			aNewNode = new AnOMPParallelSNode(aLineIndex);

			if (aTokens.length > 3 && aTokens[3].equals("for")) {
				aForChild = new AnOMPForSNode(aLineIndex);
				aForChild.setParent(aNewNode);

				aStartIndex++;
			}
			break;
		case FOR:
			aNewNode = new AnOMPForSNode(aLineIndex);
			;
			break;
		case CRITICAL:
			aNewNode = new AnOMPCriticalSNode(aLineIndex);
//			retVal.add (lastChild);
			break;
		default:
			aNewNode = new AnOMPSNode(aLineIndex);

		}

		if (lastChild != null) {
			aNewNode.setParent(lastChild);
		} else {
			aNewNode.setParent(aParentNode);
		}
		lastChild = aForChild == null ? aNewNode : aForChild;

		for (int i = aStartIndex; i < aTokens.length; i++) {
			String aStoredToken = aTokens[i].trim();
			if (aStoredToken.isEmpty()) {
				continue;
			}
			if (aStoredToken.startsWith("reduction") || aStoredToken.startsWith("shared")
					|| aStoredToken.startsWith("private")) {
				// combine all tokens until ")" into one for normalization
				while (!aStoredToken.endsWith(")")) {
					i++;
					if (i >= aTokens.length) {
						break;
					}
					String aNewToken = aTokens[i].trim();
					aStoredToken += aNewToken;
				}
				int aLeftParenIndex = aStoredToken.indexOf("(");
				int aRightParenIndex = aStoredToken.indexOf(")");
				if (aStoredToken.startsWith("reduction")) {
					setReductionData((OMPForSNode) lastChild, aStoredToken, aLeftParenIndex, aRightParenIndex);
				} else if (aStoredToken.startsWith("private")) {
					setSharedOrPrivateData((OMPSNode) lastChild, aStoredToken, aLeftParenIndex, aRightParenIndex,
							false);

				} else if (aStoredToken.startsWith("shared")) {
					setSharedOrPrivateData(lastChild, aStoredToken, aLeftParenIndex, aRightParenIndex, true);

				}

			}

			lastChild.getOpenMPTokens().add(aStoredToken);
		}

		return lastChild;

	}

	public static boolean hasParallelAncestor(SNode anSNode) {
		if (anSNode == null) {
			return false;
		}
		if (anSNode instanceof OMPParallelSNode) {
			return true;
		}
		return hasParallelAncestor(anSNode.getParent());
	}
	public static boolean hasCriticalAncestor(SNode anSNode) {
		if (anSNode == null) {
			return false;
		}
		if (anSNode instanceof OMPCriticalSNode) {
			return true;
		}
		return hasCriticalAncestor(anSNode.getParent());
	}


	public static Boolean isDeclaredShared(OMPSNode anOMPSNode, String anLHS) {
		if (Arrays.asList(anOMPSNode.getSharedVariables()).contains(anLHS)) {
			return true;
		}
		if (Arrays.asList(anOMPSNode.getPrivateVariables()).contains(anLHS)) {
			return false;
		}
		return null;

	}

	public static boolean isSharedVariable(SNode anSNode, String anLHS) {
		if (anSNode == null) {
			return false;
		}
		if (anSNode.getLocalVariables().contains(anLHS)) {
			if (!(anSNode instanceof OMPSNode)) { // no shared and private declarations
				return !hasParallelAncestor(anSNode); // shared if not inParallel
			}
			OMPSNode anOMPSNode = (OMPSNode) anSNode;
			return (Arrays.asList(anOMPSNode.getSharedVariables()).contains(anLHS)); // private unless declared shared
		}
		if (anSNode instanceof OMPSNode) {
			OMPSNode anOMPSNode = (OMPSNode) anSNode;
			// the variable is global to this scope, check if it has have been made shared
			// or private by this scope
			Boolean isDeclaredShared = isDeclaredShared(anOMPSNode, anLHS);
			if (isDeclaredShared != null) {
				return isDeclaredShared;
			}
		}
		// check the parent
		return isSharedVariable(anSNode.getParent(), anLHS);
	}

	public static List<SNode> getAllLeafNodes(SNode aTopNode) {
		List<SNode> retVal = new ArrayList();
		addLeafNodes(aTopNode, retVal);
		return retVal;
	}

	public static void addLeafNodes(SNode aTopNode, List<SNode> retVal) {
		for (SNode aChild : aTopNode.getChildren()) {
			if (aChild.isLeaf()) {
				retVal.add(aChild);
			} else {
				addLeafNodes(aChild, retVal);
			}
		}
	}

	public static List<SNode> getNonParallelLeafNodes(SNode aTopNode) {
		List<SNode> retVal = new ArrayList();
		addNonParallelLeafNodes(aTopNode, retVal);
		return retVal;
	}

	public static void addNonParallelLeafNodes(SNode aTopNode, List<SNode> retVal) {
		if (aTopNode.isInParallel()) {
			return;
		}
		for (SNode aChild : aTopNode.getChildren()) {
			if (aChild.isLeaf()) {
				retVal.add(aChild);
			} else {
				addLeafNodes(aChild, retVal);
			}
		}
	}
	static String callRegex = "([a-zA-Z_$][a-zA-Z_$0-9]*)\\(.*?\\)";
	static Pattern callPattern = Pattern.compile(callRegex);

	static String identifierRegex = "[a-zA-Z_$][a-zA-Z_$0-9]*";
	static Pattern identifierPattern = Pattern.compile(identifierRegex);
	public static List<String> identifiersIn(String aString) {
		if (aString == null)
			return null;
//		Pattern mypattern = Pattern.compile("[a-zA-Z_$][a-zA-Z_$0-9]*");
//		Matcher mymatcher = mypattern.matcher(aString);
		Matcher mymatcher = identifierPattern.matcher(aString);
		List<String> retVal = new ArrayList();
		while (mymatcher.find()) {
			String find = mymatcher.group(0);
			retVal.add(find);
		}
		return retVal;
	}
	public static List<MethodCall> callsIn(int aLineNumber, String aString, SNode aParent) {
		if (aString == null)
			return null;
//		Pattern mypattern = Pattern.compile("[a-zA-Z_$][a-zA-Z_$0-9]*");
//		Matcher mymatcher = mypattern.matcher(aString);
		Matcher mymatcher = callPattern.matcher(aString);
		List<MethodCall> retVal = new ArrayList();
		while (mymatcher.find()) {
			String find = mymatcher.group(0);
			int aLeftParenIndex = find.indexOf("(");
			int aRightParenIndex = find.indexOf(")");
			String aMethodName = find.substring(0, aLeftParenIndex).trim();
			String aParameters = find.substring(aLeftParenIndex + 1, aRightParenIndex);
			List<String> aParameterList = new ArrayList();
			String[] aParameterTokens = aParameters.split(",");
			for (String aParameter:aParameterTokens) {
				String aParameterTrimmed = aParameter.trim();
				if (!aParameterTrimmed.isEmpty())
				aParameterList.add(aParameterTrimmed);
			}
			retVal.add(new AMethodCall(aLineNumber, aMethodName, aParameterList, aParent));

//			aCallStrings.add(find);
		}
		return retVal;
	}
	static String numberRegex = "(\\d+\\.\\d+)|(\\d+)";
	static Pattern numberPattern = Pattern.compile(numberRegex);
	public static List<String> numbersIn(String aString) {
		if (aString == null)
			return null;
//		String regex = "(\\d+\\.\\d+)|(\\d+)";
//
//		Matcher m = Pattern.compile(regex).matcher(aString);
		Matcher m =numberPattern.matcher(aString);


		List<String> retVal = new ArrayList();

		while (m.find()) {
			retVal.add(m.group());
		}
		return retVal;
	}

	public static String subscriptIn(String aString) {
		if (aString == null)
			return null;
		return StringUtils.substringBetween(aString, "[", "]");
	}
	static String[] emptyStringArray = {};
	public static String[] subscriptsIn(String aString) {
		if (aString == null)
			return emptyStringArray;
		return StringUtils.substringsBetween(aString, "[", "]");
	}
	static  String operatorRegex = "([+-/*///^])|([/(/)])";
	static Pattern operatorPattern = Pattern.compile(operatorRegex);

	public static List<String> operatorsIn(String aString) {
		if (aString == null)
			return null;
//		String operatorRegex = "([+-/*///^])|([/(/)])";
//
//		Matcher m = Pattern.compile(operatorRegex).matcher(aString);
		
		Matcher m = operatorPattern.matcher(aString);


		List<String> retVal = new ArrayList();

		while (m.find()) {
			retVal.add(m.group());
		}
		return retVal;
	}
	
	public static int numberOfNestingFors (SNode anSNode) {
		if (anSNode == null) {
			return 0;
		}
		int retVal = numberOfNestingFors (anSNode.getParent()) ;

		if (anSNode instanceof ForSNode) {
			retVal++;
		} else if (anSNode instanceof MethodSNode) {
			List<MethodCall> aMethodCalls = ((MethodSNode) anSNode).getCalls();
			int aMaxNestingLevel = 0;
			for (MethodCall aMethodCall:aMethodCalls) {
				MethodSNode aCallerMethodSNode = getDeclarationOfCalledMethod(anSNode, aMethodCall);
				int aCallerNumberOfNestingFors = numberOfNestingFors(aCallerMethodSNode);
				aMaxNestingLevel = Math.max(aCallerNumberOfNestingFors, aMaxNestingLevel);				
			}
			return retVal + aMaxNestingLevel;
		}
		return retVal;
	}
	public static boolean hasOperator (SNode anSNode, String anOperator) {
		boolean retVal = false;
		if (anSNode instanceof AssignmentSNode) {
			AssignmentSNode anAssignmentSNode = (AssignmentSNode) anSNode;
			 retVal = (anAssignmentSNode.getLhsOperators().contains(anOperator) || 
					anAssignmentSNode.getRhsOperators().contains(anOperator)) ;
			if (retVal) {
				return retVal;
			} else {
				List<MethodCall> aMethodCalls = anAssignmentSNode.getRhsCalls();
				for (MethodCall aMethodCall:aMethodCalls) {
					MethodSNode aMethodSNode = getDeclarationOfCalledMethod(anSNode, aMethodCall);
					retVal = hasOperator(aMethodSNode, anOperator);
					if (retVal) {
						return retVal;
					}
					
				}
				return false;
			}
			
		}
		for (SNode aChild:anSNode.getChildren()) {
			retVal = hasOperator(aChild, anOperator);
			if (retVal) {
				return retVal;
			}
		}
		return false;
	}
	public static boolean hasMethodCall (SNode anSNode, String anOperator) {
		boolean retVal = false;
		if (anSNode instanceof AssignmentSNode) {
			AssignmentSNode anAssignmentSNode = (AssignmentSNode) anSNode;
			 retVal = (anAssignmentSNode.getLhsOperators().contains(anOperator) || 
					anAssignmentSNode.getRhsOperators().contains(anOperator)) ;
			if (retVal) {
				return retVal;
			} else {
				List<MethodCall> aMethodCalls = anAssignmentSNode.getRhsCalls();
				for (MethodCall aMethodCall:aMethodCalls) {
					MethodSNode aMethodSNode = getDeclarationOfCalledMethod(anSNode, aMethodCall);
					retVal = hasOperator(aMethodSNode, anOperator);
					if (retVal) {
						return retVal;
					}
					
				}
				return false;
			}
			
		}
		for (SNode aChild:anSNode.getChildren()) {
			retVal = hasOperator(aChild, anOperator);
			if (retVal) {
				return retVal;
			}
		}
		return false;
	}
	public static boolean dependsOn (AssignmentSNode anAssignmentSNode, String aVariable, String aCallIdentifier) {
		// This assignment does not change aVariable
		if (!aVariable.equals(anAssignmentSNode.getLhsVariable())) {
			return false;
		}
		return dependsOn(anAssignmentSNode.getExpressionSNode(), aCallIdentifier);
//		List<String> aCallIdentifiers = anAssignmentSNode.getRhsCallIdentifiers();
//		boolean retVal = false;
//		if (aCallIdentifiers != null && aCallIdentifiers.contains(aCallIdentifier)) {
//			return true; // this assignment has aCallIdentifier in the rhs
//		}
//		// check if some referenced rhs variable depends on aCallIdentifier
//		List<String> aReferencedVariableIdentifiers = anAssignmentSNode.getRhsVariableIdentifiers();
//		SNode anAssignmentParent = anAssignmentSNode.getParent();
//		if (anAssignmentParent == null) { // should never be trye
//			return false;
//		}
//		int aLineNumber = anAssignmentSNode.getLineNumber();
//		for (String aReferencedVariableIdentifier:aReferencedVariableIdentifiers ) {
//			if (dependsOn (anAssignmentParent, aLineNumber, aReferencedVariableIdentifier, aCallIdentifier)) {
//				return true;
//			}
//		}
//		return false;
	}
	public static boolean dependsOn (ExpressionSNode anExpressionSNode, String aCallIdentifier) {
		// This assignment does not change aVariable
		
		List<String> aCallIdentifiers = anExpressionSNode.getRhsCallIdentifiers();
		boolean retVal = false;
		if (aCallIdentifiers != null && aCallIdentifiers.contains(aCallIdentifier)) {
			return true; // this assignment has aCallIdentifier in the rhs
		}
		// check if some referenced rhs variable depends on aCallIdentifier
		List<String> aReferencedVariableIdentifiers = anExpressionSNode.getRhsVariableIdentifiers();
		SNode anAssignmentParent = anExpressionSNode.getParent().getParent();
		if (anAssignmentParent == null) { // should never be trye
			return false;
		}
		int aLineNumber = anExpressionSNode.getLineNumber();
		for (String aReferencedVariableIdentifier:aReferencedVariableIdentifiers ) {
			if (dependsOn (anAssignmentParent, aLineNumber, aReferencedVariableIdentifier, aCallIdentifier)) {
				return true;
			}
		}
		return false;
	}
	public static Set<AssignmentSNode> assignmentsToSharedVariables(SNode anSNode) {
		Set<AssignmentSNode> retVal =  new HashSet();
		fillAssignmentsToShared(anSNode, retVal);
		return retVal;
		
	}
	public static Set<AssignmentSNode> assignmentsToSharedArrays(SNode anSNode) {
		Set<AssignmentSNode> anAllSharedAssignments =  assignmentsToSharedVariables(anSNode);
		Set<AssignmentSNode> aRetVal = new HashSet();
		for (AssignmentSNode anAssignmentSNode:anAllSharedAssignments) {
			if (anAssignmentSNode.getLhsSubscripts().length > 0) {
				aRetVal.add(anAssignmentSNode);
			}
		}
		return aRetVal;
		
	}
	public static Set<AssignmentSNode> assignmentsToParallelCriticalSharedVariables(SNode anSNode) {
		Set<AssignmentSNode> anAllSharedAssignments =  assignmentsToSharedVariables(anSNode);
		Set<AssignmentSNode> aRetVal = new HashSet();
		for (AssignmentSNode anAssignmentSNode:anAllSharedAssignments) {
			if (anAssignmentSNode.isInParallel() &&
					anAssignmentSNode.isInCritical()) {
				aRetVal.add(anAssignmentSNode);
			}
		}
		return aRetVal;
		
	}
	public static Set<AssignmentSNode> assignmentsToNonParallelCriticalSharedVariables(SNode anSNode) {
		Set<AssignmentSNode> anAllSharedAssignments =  assignmentsToSharedVariables(anSNode);
		Set<AssignmentSNode> aRetVal = new HashSet();
		for (AssignmentSNode anAssignmentSNode:anAllSharedAssignments) {
			if (!anAssignmentSNode.isInParallel() &&
					anAssignmentSNode.isInCritical()) {
				aRetVal.add(anAssignmentSNode);
			}
		}
		return aRetVal;
		
	}
	public static Set<AssignmentSNode> assignmentsToParallelNonCriticalSharedVariables(SNode anSNode) {
		Set<AssignmentSNode> anAllSharedAssignments =  assignmentsToSharedVariables(anSNode);
		Set<AssignmentSNode> aRetVal = new HashSet();
		for (AssignmentSNode anAssignmentSNode:anAllSharedAssignments) {
			if (anAssignmentSNode.isInParallel() &&
					!anAssignmentSNode.isInCritical()) {
				aRetVal.add(anAssignmentSNode);
			}
		}
		return aRetVal;
		
	}
    public static void fillAssignmentsToShared(SNode anSNode, Set<AssignmentSNode> retVal) {
    	if (anSNode instanceof AssignmentSNode) {
			AssignmentSNode anAssignmentSNode = (AssignmentSNode) anSNode;
			String anLHS = anAssignmentSNode.getLhsVariable();
			if (isSharedVariable(anSNode, anLHS)) {
				retVal.add(anAssignmentSNode);
				return;
			}
		}
    	for (SNode aChild:anSNode.getChildren()) {
    		fillAssignmentsToShared(aChild, retVal);
    	}
		
	}
	public static boolean dependsOn (SNode anSNode, int aVariableLineNumber, String aVariable, String aCallIdentifier) {
		List<SNode> aListSNodes = anSNode.getChildren();
		boolean retVal = false;
		/*
		 * Should probably ignore line number as it assumes straight line code
		 */
		for (int i = aVariableLineNumber; i >= 0; i--) {
			SNode anSNodeChild = aListSNodes.get(i);
			if (anSNodeChild instanceof AssignmentSNode) {
				// does this statement in anSNode directly invoke aCallIdentifier 
				if (dependsOn((AssignmentSNode) anSNodeChild, aVariable, aCallIdentifier))
					return true;
			} else if (!anSNode.isLeaf()) {
					// child is overriding the variable so forget checking its assignment statements
					if (anSNodeChild.getLocalVariables().contains(aVariable)) {
						continue;
					}
					// some subblock of anSNode that has access to aVariable changes variable

					if (dependsOn(anSNodeChild, anSNodeChild.getChildren().size() - 1, aVariable, aCallIdentifier)) {
						return true;
					}
			}
			
		}
		// none of the statements in anSNode or its descendents  have the required call
		// is the variable a  method parameter 
		if (anSNode instanceof MethodSNode) {
			MethodSNode aMethodSNode = (MethodSNode) anSNode;
			
			int aParameterNumber = aMethodSNode.getLocalVariables().indexOf(aVariable);
			if (aParameterNumber != -1) {
				List <MethodCall> aCalls = aMethodSNode.getCalls();
				for (MethodCall aCall:aCalls) {
					MethodSNode aCallerSNode = getDeclarationOfCalledMethod(aMethodSNode, aCall);
					boolean aCallerDepends = dependsOn(aMethodSNode, aCallerSNode.getLineNumber(), aVariable, aCallIdentifier);
				    if (aCallerDepends) {
				    	return true;
				    }
				}
				return false;
				// need to find all callers of method and see if any of the aliases for the variable in these
				// calls depend on aCallIndentifier
			}			
			
		} else if (anSNode.getLocalVariables().contains(aVariable)) {
			// before going to the parent node, let us see if aVariable is declared here as a non  parameter 

			return false; // no point going to parent
		}
		// not a local variable (parameter or declarated variable)
		SNode anSNodeParent = anSNode.getParent() ;
		if (anSNodeParent == null)  {
			return false;
		}
		int anSNodeLineNumber = anSNodeParent.getChildren().indexOf(anSNode);
		return dependsOn(anSNodeParent, anSNodeLineNumber, aVariable, aCallIdentifier);
		
	}
	public static RootOfFileSNode getRootOfFileNode(SNode aCurrentSNode ) {
		if (aCurrentSNode instanceof RootOfFileSNode) {
			return (RootOfFileSNode) aCurrentSNode;
		}
		SNode aParentSNode = aCurrentSNode.getParent() ;
		
		if (aParentSNode == null) {
			return null;
		}
		
		return getRootOfFileNode(aParentSNode);
		
	}
	public static boolean match (MethodSNode aMethodSNode, MethodCall aMethodCall) {
		return aMethodSNode.getMethodName().equals(aMethodCall.getMethodName()) 
				&& aMethodSNode.getLocalVariables().size() == aMethodCall.getMethodActuals().size();
	}
	
	public static MethodSNode getDeclarationOfCalledMethod(SNode aCurrentSNode, MethodCall aMethodCall ) {
		SNode aRootNode = getRootOfFileNode(aCurrentSNode);
		for (SNode aChild:aRootNode.getChildren()) {
			if (aChild instanceof MethodSNode) {
				MethodSNode aMethodSNode = (MethodSNode) aChild;
				if (match (aMethodSNode, aMethodCall)) {
					return aMethodSNode;
				}
			}
		}
		return null; // this should never happen;
	}
	
	public static RootOfProgramSNode getRootOfProgramSNode(String aSource) {
		RootOfProgramSNode retVal = new ARootOfProgramSNode();
		Map<String, StringBuffer> aFileNameToContents = ABasicTextManager.extractFileContents(aSource);
		for (String aFileName:aFileNameToContents.keySet()) {
			StringBuffer aFileContents = aFileNameToContents.get(aFileName);
//			List<OpenMPPragma> anOpenMPPragmas = OpenMPUtils.getOpemMPPragmas(aFileContents);
			RootOfFileSNode anSNode = OMPSNodeUtils.getSNode(aFileName, aFileContents);
			retVal.getFileNameToSNode().put(aFileName, anSNode);
			anSNode.setParent(retVal);
//			System.out.println("file name:" + aFileName);
//			System.out.println("pragmas:" + anSNode);
		}
		processExternalMethodSNodes(retVal);
		return retVal;
	}
	public static void processExternalMethodSNodes (RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode) {
		for (SNode anSNode:aRootOfFileSNode.getChildren()) {
			if (anSNode instanceof ExternalMethodSNode) {
				processExternalMethodSNode(aRootOfProgramSNode, aRootOfFileSNode, (ExternalMethodSNode) anSNode);
			}
		}
	}
	public static void processExternalMethodSNode (RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode, ExternalMethodSNode anExternalMethodSNode) {
		MethodSNode aMethodSNode = aRootOfProgramSNode.getExternalToInternalMethod().get(anExternalMethodSNode.toString());
		if (aMethodSNode == null) {
			aMethodSNode = findMethodSNode(aRootOfProgramSNode, aRootOfFileSNode, anExternalMethodSNode);
			if (aMethodSNode != null) {
				aRootOfProgramSNode.getExternalToInternalMethod().put(anExternalMethodSNode.toString(),aMethodSNode );
			}
		}
		if (aMethodSNode != null) {
			anExternalMethodSNode.setActualMethodSNode(aMethodSNode);
			aMethodSNode.getCalls().addAll(anExternalMethodSNode.getLocalCalls());
		}
	}
	public static MethodSNode findMethodSNode (RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode, ExternalMethodSNode anExternalMethodSNode) {
//		MethodSNode foundMethodSNode = null;
		for (String aFileName:aRootOfProgramSNode.getFileNameToSNode().keySet()) {
			if (aFileName.equals(aRootOfFileSNode.getFileName()))
				continue;
			
			RootOfFileSNode aSearchedRootOfFileSNode = aRootOfProgramSNode.getFileNameToSNode().get(aFileName);
			 for (SNode anSNode:aSearchedRootOfFileSNode.getChildren()) {
				if (anSNode instanceof MethodSNode && !(anSNode instanceof ExternalMethodSNode)) {
					if (anSNode.toString().equals(anExternalMethodSNode.toString())) {
						return (MethodSNode) anSNode;
						
					}
//					processExternalMethodSNode(aRootOfProgramSNode, aRootOfFileSNode, (ExternalMethodSNode) anSNode);
				}
			}
		}
		return null;
	}
	public static void processExternalMethodSNodes (RootOfProgramSNode aRootOfProgramSNode) {
		for (String aFileName:aRootOfProgramSNode.getFileNameToSNode().keySet()) {
			RootOfFileSNode aRootOfFileSNode = aRootOfProgramSNode.getFileNameToSNode().get(aFileName);
			processExternalMethodSNodes(aRootOfProgramSNode, aRootOfFileSNode);
			aRootOfFileSNode.getOmp_get_num_threads_SNode().
				setActualMethodSNode(aRootOfProgramSNode.getOmp_get_num_threads_SNode());
			aRootOfFileSNode.getOmp_get_thread_num_SNode().
				setActualMethodSNode(aRootOfProgramSNode.getOmp_get_thread_num_SNode());
			aRootOfFileSNode.getOmp_get_wtime_SNode().
			setActualMethodSNode(aRootOfProgramSNode.getOmp_get_wtime_SNode());
		}

	}
	

//	public static void main(String[] args) {
//		List<MethodCall> aTokens = callsIn("foo(bar, hgf)/foo2()*foo3(b, a c,)");
//		System.out.println(aTokens);
//		
//		
////		List<String> aTokens = identifiersIn("a[i] + b*2/3");
////		System.out.println(aTokens);
////		aTokens = numbersIn("a[i] + b*2/3");
////		System.out.println(aTokens);
////		aTokens = operatorsIn("a[i] + b*2/3");
////		System.out.println(aTokens);
////
////		System.out.println(StringUtils.substringBetween("a", "[", "]"));
//	}

}
]]></snapshot>
  </Command>
  <Command __id="185749" _type="RunCommand" date="Mon Dec 30 10:20:36 EST 2019" kind="StepInto" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="1052731860" type="Run" />
  <Command __id="185750" _type="DiffBasedFileOpenCommand" date="Mon Dec 30 10:20:51 EST 2019" docASTNodeCount="1" docActiveCodeLength="532" docExpressionCount="0" docLength="575" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="1052745953">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\my_sum_parallel_for_reduction.cpp]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"#include <iostream>¬∂#include <omp.h>¬∂¬∂using namespace std;¬∂¬∂//const int SIZE = 1000;¬∂void printSumWithTimes(int sum, int start, int end);¬∂void printNumThreads();¬∂void recordThreadIndex(int index);¬∂void sum_parallel_for_reduction(double* array, int size) {¬∂	cout << "sum_parallel_for_reduction\n";¬∂¬∂	double start = omp_get_wtime();¬∂¬∂	double sum = 0;¬∂    #pragma omp  parallel for reduction ( + : sum )¬∂//	#pragma omp  for¬∂¬∂	for (int i = 0; i < size; i++) {¬∂		sum += array[i];¬∂		recordThreadIndex(i);¬∂	}¬∂¬∂	double end = omp_get_wtime();¬∂¬∂	printSumWithTimes(sum, start, end);¬∂¬∂}¬∂")]]]></diff>
  </Command>
  <Command __id="185751" _type="MoveCaretCommand" caretOffset="379" date="Mon Dec 30 10:20:51 EST 2019" docOffset="379" starttimestamp="1576666505112" timestamp="1052746101" />
  <Command __id="185752" _type="DiffBasedFileOpenCommand" date="Mon Dec 30 10:20:55 EST 2019" docASTNodeCount="1" docActiveCodeLength="659" docExpressionCount="0" docLength="747" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="1052750814">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\my_sum_parallel_for_local_var.cpp]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"#include <iostream>¬∂#include <omp.h>¬∂¬∂using namespace std;¬∂¬∂void printSumWithTimes (int sum, int start, int end);¬∂void printNumThreads();¬∂void recordThreadIndex(int index);¬∂void sum_parallel_for_local_var(double* array, int size)¬∂{¬∂	cout << "sum_parallel_for_local_var\n";¬∂¬∂	double start = omp_get_wtime();¬∂¬∂	double sum = 0;¬∂¬∂	int a, b;¬∂//¬∂//	for (int i = 0; i < size; i++) {¬∂//			sum += array[i];¬∂//			recordThreadIndex(i);¬∂//	}¬∂¬∂    #pragma omp parallel shared (sum, start) private (a, b)¬∂	{¬∂		double local_sum = 0;¬∂¬∂		#pragma omp for¬∂		for(int i = 0; i < size; i++) {¬∂			local_sum += array[i];¬∂			recordThreadIndex(i);¬∂		}¬∂¬∂		#pragma omp critical¬∂		sum += local_sum;¬∂	}¬∂¬∂	double end = omp_get_wtime();¬∂¬∂	printSumWithTimes(sum, start, end);¬∂	¬∂}¬∂")]]]></diff>
  </Command>
  <Command __id="185753" _type="MoveCaretCommand" caretOffset="621" date="Mon Dec 30 10:20:56 EST 2019" docOffset="621" starttimestamp="1576666505112" timestamp="1052750941" />
  <Command __id="185754" _type="DiffBasedFileOpenCommand" date="Mon Dec 30 10:20:59 EST 2019" docASTNodeCount="1" docActiveCodeLength="532" docExpressionCount="0" docLength="575" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="1052753897">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\my_sum_parallel_for_reduction.cpp]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"#include <iostream>¬∂#include <omp.h>¬∂¬∂using namespace std;¬∂¬∂//const int SIZE = 1000;¬∂void printSumWithTimes(int sum, int start, int end);¬∂void printNumThreads();¬∂void recordThreadIndex(int index);¬∂void sum_parallel_for_reduction(double* array, int size) {¬∂	cout << "sum_parallel_for_reduction\n";¬∂¬∂	double start = omp_get_wtime();¬∂¬∂	double sum = 0;¬∂    #pragma omp  parallel for reduction ( + : sum )¬∂//	#pragma omp  for¬∂¬∂	for (int i = 0; i < size; i++) {¬∂		sum += array[i];¬∂		recordThreadIndex(i);¬∂	}¬∂¬∂	double end = omp_get_wtime();¬∂¬∂	printSumWithTimes(sum, start, end);¬∂¬∂}¬∂")]]]></diff>
  </Command>
  <Command __id="185755" _type="MoveCaretCommand" caretOffset="379" date="Mon Dec 30 10:20:59 EST 2019" docOffset="379" starttimestamp="1576666505112" timestamp="1052754035" />
  <Command __id="185925" _type="DiffBasedFileOpenCommand" date="Mon Dec 30 10:27:41 EST 2019" docASTNodeCount="4116" docActiveCodeLength="29362" docExpressionCount="2589" docLength="33548" projectName="GraderBasics" starttimestamp="1576666505112" timestamp="1053156132">
    <filePath><![CDATA[D:\dewan_backup\Java\GraderBasics\src\gradingTools\shared\testcases\openmp\scannedTree\OMPSNodeUtils.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package gradingTools.shared.testcases.openmp.scannedTree;¬∂¬∂import java.util.ArrayList;¬∂import java.util.Arrays;¬∂import java.util.HashMap;¬∂import java.util.HashSet;¬∂import java.util.List;¬∂import java.util.Map;¬∂import java.util.Set;¬∂import java.util.Stack;¬∂import java.util.regex.Matcher;¬∂import java.util.regex.Pattern;¬∂¬∂import org.apache.commons.lang.StringUtils;¬∂¬∂import grader.basics.project.source.ABasicTextManager;¬∂import gradingTools.shared.testcases.openmp.OpenMPKeywordEnum;¬∂import gradingTools.shared.testcases.openmp.OpenMPParallelPragma;¬∂import gradingTools.shared.testcases.openmp.OpenMPUtils;¬∂import gradingTools.shared.testcases.openmp.scannedTree.ADeclarationSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.ADeclaringAssignmentSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.AForSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.ATextSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.AnAssignmentSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.AnOMPCriticalSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.AnOMPForSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.AnOMPParallelSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.AnOMPSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.AnSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.AssignmentSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.DeclarationSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.DeclaringAssignmentSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.ForSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.OMPForSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.OMPSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.SNode;¬∂¬∂public class OMPSNodeUtils extends OpenMPUtils {¬∂¬∂	public static RootOfFileSNode getSNode(String aFileName, StringBuffer aFileBuffer) {¬∂		String[] aFileLines = aFileBuffer.toString().split("\n");¬∂		return getSNode(aFileName, aFileLines);¬∂	}¬∂¬∂	public static AssignmentSNode getAssignmentSNode(int aLineNumber, String aString) {¬∂		if (aString == null) {¬∂			return null;¬∂		}¬∂		String[] aTokens = aString.split("=");¬∂		if (aTokens.length == 1) {¬∂			return new AnAssignmentSNode(aLineNumber, aTokens[0], null);¬∂		} else {¬∂		return new AnAssignmentSNode(aLineNumber, aTokens[0], aTokens[1]);¬∂		}¬∂	}¬∂¬∂	public static DeclarationSNode getDeclarationSNode(int aLineNumber, String aString) {¬∂		String[] aTokens = aString.split(" ");¬∂		return new ADeclarationSNode(aLineNumber, aTokens[0], aTokens[1]);¬∂	}¬∂¬∂	public static DeclaringAssignmentSNode getDeclaringAssignmentSNode(int aLineNumber, String aString) {¬∂		String[] anLHSAndRHS = aString.split("=");¬∂		String[] aTypeAndVariable = anLHSAndRHS[0].split(" ");¬∂		return new ADeclaringAssignmentSNode(aLineNumber, aTypeAndVariable[0], aTypeAndVariable[1], anLHSAndRHS[1]);¬∂	}¬∂¬∂	public static boolean isDeclaringAssignment(String aFileLine) {¬∂		return startsWithTypeName(aFileLine) && aFileLine.contains("=");¬∂	}¬∂	public static boolean isMethodDeclaration(String aFileLine) {¬∂		return startsWithTypeName(aFileLine) && ¬∂				aFileLine.contains("(") &&¬∂				!aFileLine.contains("=");¬∂	}¬∂	public static boolean isExternalMethodDeclaration(String aFileLine) {¬∂		return isMethodDeclaration(aFileLine) && aFileLine.endsWith(";");¬∂	}¬∂¬∂¬∂	public static boolean isVariableDeclaration(String aFileLine) {¬∂¬∂		return startsWithTypeName(aFileLine) && !aFileLine.contains("(");¬∂	}¬∂¬∂	public static boolean isAssignment(String aFileLine) {¬∂		return aFileLine.contains("=");¬∂	}¬∂¬∂	public static boolean isForNode(String aFileLine) {¬∂		return aFileLine.startsWith("for");¬∂	}¬∂¬∂	public static ForSNode getForSNode(int aLineNumber, String aFileLine) {¬∂¬∂		int aLeftParenIndex = aFileLine.indexOf("(");¬∂		int aRightParenIndex = aFileLine.indexOf(")");¬∂		if (aLeftParenIndex < 0 || aRightParenIndex < 0) {¬∂			return null;¬∂		}¬∂		String aHeaderString = aFileLine.substring(aLeftParenIndex + 1, aRightParenIndex);¬∂		String[] aForComponents = aHeaderString.split(";");¬∂		AssignmentSNode anAssignmentSNode = null;¬∂		String aForInitializaton = aForComponents[0];¬∂		if (!aForInitializaton.isEmpty() && aForInitializaton.contains("=")) {¬∂			if (isDeclaringAssignment(aForInitializaton)) {¬∂				anAssignmentSNode = getDeclaringAssignmentSNode(aLineNumber, aForInitializaton);¬∂			} else {¬∂				anAssignmentSNode = getAssignmentSNode(aLineNumber, aForInitializaton);¬∂			}¬∂¬∂		}		¬∂		return new AForSNode(aLineNumber, anAssignmentSNode, aForComponents[1], getAssignmentSNode(aLineNumber, aForComponents[2]));¬∂	}¬∂	static String[] emptyArray = {};¬∂	public static MethodSNode getMethodSNode(int aLineNumber, String aFileLine, boolean isInternal) {¬∂¬∂		int aLeftParenIndex = aFileLine.indexOf("(");¬∂		int aRightParenIndex = aFileLine.indexOf(")");¬∂		if (aLeftParenIndex < 0 || aRightParenIndex < 0) {¬∂			return null;¬∂		}¬∂		String aMethodNameAndType = aFileLine.substring(0, aLeftParenIndex);¬∂		String[] aMethodNameAndTypeTokens = aMethodNameAndType.split("\\s+"); ¬∂		¬∂		String aMethodParameters = aFileLine.substring(aLeftParenIndex +1 , aRightParenIndex);¬∂		String[] aMethodParameterTokens = aMethodParameters.isEmpty()?emptyArray:¬∂		 aMethodParameters.split(",");¬∂		¬∂//		String[] aMethodParameterTypes = new String[aMethodParameterTokens.length];¬∂//		String[] aMethodParameterNames = new String[aMethodParameterTokens.length];¬∂		List<DeclarationSNode> aDeclarationSNodeList = new ArrayList();¬∂		for (int i = 0; i < aMethodParameterTokens.length; i++ ) {¬∂			String[] aTypeAndName = aMethodParameterTokens[i].trim().split("\\s+");¬∂			if (aTypeAndName.length < 2) {¬∂				continue;¬∂			}¬∂			aDeclarationSNodeList.add(new ADeclarationSNode(aLineNumber, aTypeAndName[0].trim(), aTypeAndName[1].trim()));¬∂//			aMethodParameterTypes[i] = aTypeAndName[0].trim();¬∂//			aMethodParameterNames[i] = aTypeAndName[1].trim();¬∂		}¬∂		if (isInternal)¬∂//		return new AMethodSNode(aLineNumber, aMethodNameAndTypeTokens[0], aMethodNameAndTypeTokens[1], aMethodParameterTypes,aMethodParameterNames );¬∂			return new AMethodSNode(aLineNumber, aMethodNameAndTypeTokens[0], aMethodNameAndTypeTokens[1], aDeclarationSNodeList );¬∂		else¬∂			return new AnExternalMethodSNode(aLineNumber, aMethodNameAndTypeTokens[0], aMethodNameAndTypeTokens[1], aDeclarationSNodeList );¬∂	}¬∂¬∂	public static void setReductionData(OMPForSNode lastChild, String aStoredToken, int aLeftParenIndex,¬∂			int aRightParenIndex) {¬∂		int aColonIndex = aStoredToken.indexOf(":");¬∂		if (aLeftParenIndex != -1 && aRightParenIndex != -1 && aColonIndex != -1) {¬∂			String anOperationString = aStoredToken.substring(aLeftParenIndex + 1, aColonIndex).trim();¬∂			String aVariableString = aStoredToken.substring(aColonIndex + 1, aRightParenIndex).trim();¬∂			((OMPForSNode) lastChild).setReductionVariable(aVariableString);¬∂			((OMPForSNode) lastChild).setReductionOperation(anOperationString);¬∂		}¬∂	}¬∂¬∂	public static void setSharedOrPrivateData(OMPSNode lastChild, String aStoredToken, int aLeftParenIndex,¬∂			int aRightParenIndex, boolean isShared) {¬∂//		int aColonIndex = aStoredToken.indexOf(":");¬∂		if (aLeftParenIndex != -1 && aRightParenIndex != -1) {¬∂			String aVariableDeclarations = aStoredToken.substring(aLeftParenIndex + 1, aRightParenIndex);¬∂			String[] aVariables = aVariableDeclarations.split(",");¬∂			if (isShared) {¬∂				lastChild.setSharedVariables(aVariables);¬∂			} else {¬∂				lastChild.setPrivateVariables(aVariables);¬∂			}¬∂		}¬∂	}¬∂¬∂	public static RootOfFileSNode getSNode(String aFileName, String[] aFileLines) {¬∂		Stack<SNode> anSNodes = new Stack();¬∂¬∂		RootOfFileSNode retVal = new ARootOfFileSNode(aFileName);¬∂		anSNodes.add(retVal);¬∂		SNode previousHeaderNode = null;¬∂		for (int i = 0; i < aFileLines.length; i++) {¬∂			String aFileLine = aFileLines[i].trim();¬∂			if (!isCodeLine(aFileLine)) {¬∂				continue;¬∂			}¬∂			if (isForNode(aFileLine)) {¬∂				ForSNode aForSNode = getForSNode(i, aFileLine);¬∂				aForSNode.setParent(anSNodes.peek());¬∂//				anSNodes.push(aForSNode);¬∂				previousHeaderNode = aForSNode;¬∂				if (aFileLine.endsWith(")")) {¬∂					continue;¬∂				}¬∂			}¬∂			if (isExternalMethodDeclaration(aFileLine)) {¬∂				MethodSNode aMethodSNode = getMethodSNode(i, aFileLine, false);¬∂				aMethodSNode.setParent(anSNodes.peek());¬∂//				anSNodes.push(aForSNode);¬∂				previousHeaderNode = aMethodSNode;¬∂				if (aFileLine.endsWith(")")) {¬∂					continue;¬∂				}¬∂			}¬∂			if (isMethodDeclaration(aFileLine)) {¬∂				MethodSNode aMethodSNode = getMethodSNode(i, aFileLine, true);¬∂				aMethodSNode.setParent(anSNodes.peek());¬∂//				anSNodes.push(aForSNode);¬∂				previousHeaderNode = aMethodSNode;¬∂				if (aFileLine.endsWith(")")) {¬∂					continue;¬∂				}¬∂			}¬∂			if (isPragmaStart(aFileLine)) {¬∂				OMPSNode anOMPSNode = getOMPSNode(i, anSNodes.peek(), aFileLine);¬∂//				anSNodes.push(anOMPSNode);¬∂				previousHeaderNode = anOMPSNode;¬∂				continue;¬∂			}¬∂			if (isBlockStart(aFileLine)) {¬∂				SNode aBlockSNode = new AnSNode(i);¬∂				if (previousHeaderNode != null) {¬∂					aBlockSNode.setParent(previousHeaderNode);¬∂				} else {¬∂					aBlockSNode.setParent(anSNodes.peek());¬∂				}¬∂				anSNodes.push(aBlockSNode);¬∂				previousHeaderNode = null;¬∂				continue;¬∂			}¬∂//			} else ¬∂			if (isBlockEnd(aFileLine)) {¬∂				anSNodes.pop();¬∂				continue;¬∂			}¬∂			SNode aNewLeafNode = null;¬∂			if (isDeclaringAssignment(aFileLine)) {¬∂				aNewLeafNode = getDeclaringAssignmentSNode(i, aFileLine);¬∂¬∂			} else if (isAssignment(aFileLine)) {¬∂				aNewLeafNode = getAssignmentSNode(i, aFileLine);¬∂			} else if (isVariableDeclaration(aFileLine)) {¬∂				aNewLeafNode = getDeclarationSNode(i, aFileLine);¬∂			} else {¬∂				List<MethodCall> aCalls = callsIn(i, aFileLine, null); // parent will be assigned below¬∂				if (aCalls != null && aCalls.size() == 1) {¬∂					aNewLeafNode = aCalls.get(0);¬∂				} else {¬∂					aNewLeafNode = new ATextSNode(i, aFileLine);¬∂				}¬∂			}¬∂//			else {¬∂//				aNewLeafNode = new ATextSNode(i, aFileLine);¬∂//			}¬∂			if (previousHeaderNode != null) {¬∂				aNewLeafNode.setParent(previousHeaderNode);¬∂			} else {¬∂				aNewLeafNode.setParent(anSNodes.peek());¬∂			}¬∂¬∂		}¬∂¬∂		return retVal;¬∂	}¬∂¬∂	public static OMPSNode getOMPSNode(int aLineIndex, SNode aParentNode, String aFileLine) {¬∂		String[] aTokens = aFileLine.split("\\s+");¬∂		if (aTokens.length <= 2) {¬∂			return null;¬∂		}¬∂		if (!aTokens[1].equals("omp")) {¬∂			return null;¬∂		}¬∂		if (aTokens.length < 3) {¬∂			return null;¬∂		}¬∂		String aFirstToken = aTokens[2];¬∂		OpenMPKeywordEnum anOpenMPKeyword = stringToOpenMPKeyword.get(aFirstToken);¬∂//		List<OpenMPPragma> retVal = new ArrayList();¬∂		OMPSNode lastChild = null;¬∂		int aStartIndex = 2;¬∂		OMPSNode aNewNode = null;¬∂		OMPForSNode aForChild = null;¬∂		switch (anOpenMPKeyword) {¬∂		case PARALLEL:¬∂			aNewNode = new AnOMPParallelSNode(aLineIndex);¬∂¬∂			if (aTokens.length > 3 && aTokens[3].equals("for")) {¬∂				aForChild = new AnOMPForSNode(aLineIndex);¬∂				aForChild.setParent(aNewNode);¬∂¬∂				aStartIndex++;¬∂			}¬∂			break;¬∂		case FOR:¬∂			aNewNode = new AnOMPForSNode(aLineIndex);¬∂			;¬∂			break;¬∂		case CRITICAL:¬∂			aNewNode = new AnOMPCriticalSNode(aLineIndex);¬∂//			retVal.add (lastChild);¬∂			break;¬∂		default:¬∂			aNewNode = new AnOMPSNode(aLineIndex);¬∂¬∂		}¬∂¬∂		if (lastChild != null) {¬∂			aNewNode.setParent(lastChild);¬∂		} else {¬∂			aNewNode.setParent(aParentNode);¬∂		}¬∂		lastChild = aForChild == null ? aNewNode : aForChild;¬∂¬∂		for (int i = aStartIndex; i < aTokens.length; i++) {¬∂			String aStoredToken = aTokens[i].trim();¬∂			if (aStoredToken.isEmpty()) {¬∂				continue;¬∂			}¬∂			if (aStoredToken.startsWith("reduction") || aStoredToken.startsWith("shared")¬∂					|| aStoredToken.startsWith("private")) {¬∂				// combine all tokens until ")" into one for normalization¬∂				while (!aStoredToken.endsWith(")")) {¬∂					i++;¬∂					if (i >= aTokens.length) {¬∂						break;¬∂					}¬∂					String aNewToken = aTokens[i].trim();¬∂					aStoredToken += aNewToken;¬∂				}¬∂				int aLeftParenIndex = aStoredToken.indexOf("(");¬∂				int aRightParenIndex = aStoredToken.indexOf(")");¬∂				if (aStoredToken.startsWith("reduction")) {¬∂					setReductionData((OMPForSNode) lastChild, aStoredToken, aLeftParenIndex, aRightParenIndex);¬∂				} else if (aStoredToken.startsWith("private")) {¬∂					setSharedOrPrivateData((OMPSNode) lastChild, aStoredToken, aLeftParenIndex, aRightParenIndex,¬∂							false);¬∂¬∂				} else if (aStoredToken.startsWith("shared")) {¬∂					setSharedOrPrivateData(lastChild, aStoredToken, aLeftParenIndex, aRightParenIndex, true);¬∂¬∂				}¬∂¬∂			}¬∂¬∂			lastChild.getOpenMPTokens().add(aStoredToken);¬∂		}¬∂¬∂		return lastChild;¬∂¬∂	}¬∂¬∂	public static boolean hasParallelAncestor(SNode anSNode) {¬∂		if (anSNode == null) {¬∂			return false;¬∂		}¬∂		if (anSNode instanceof OMPParallelSNode) {¬∂			return true;¬∂		}¬∂		return hasParallelAncestor(anSNode.getParent());¬∂	}¬∂	public static boolean hasCriticalAncestor(SNode anSNode) {¬∂		if (anSNode == null) {¬∂			return false;¬∂		}¬∂		if (anSNode instanceof OMPCriticalSNode) {¬∂			return true;¬∂		}¬∂		return hasCriticalAncestor(anSNode.getParent());¬∂	}¬∂¬∂¬∂	public static Boolean isDeclaredShared(OMPSNode anOMPSNode, String anLHS) {¬∂		if (Arrays.asList(anOMPSNode.getSharedVariables()).contains(anLHS)) {¬∂			return true;¬∂		}¬∂		if (Arrays.asList(anOMPSNode.getPrivateVariables()).contains(anLHS)) {¬∂			return false;¬∂		}¬∂		return null;¬∂¬∂	}¬∂¬∂	public static boolean isSharedVariable(SNode anSNode, String anLHS) {¬∂		if (anSNode == null) {¬∂			return false;¬∂		}¬∂		if (anSNode.getLocalVariables().contains(anLHS)) {¬∂			if (!(anSNode instanceof OMPSNode)) { // no shared and private declarations¬∂				return !hasParallelAncestor(anSNode); // shared if not inParallel¬∂			}¬∂			OMPSNode anOMPSNode = (OMPSNode) anSNode;¬∂			return (Arrays.asList(anOMPSNode.getSharedVariables()).contains(anLHS)); // private unless declared shared¬∂		}¬∂		if (anSNode instanceof OMPSNode) {¬∂			OMPSNode anOMPSNode = (OMPSNode) anSNode;¬∂			// the variable is global to this scope, check if it has have been made shared¬∂			// or private by this scope¬∂			Boolean isDeclaredShared = isDeclaredShared(anOMPSNode, anLHS);¬∂			if (isDeclaredShared != null) {¬∂				return isDeclaredShared;¬∂			}¬∂		}¬∂		// check the parent¬∂		return isSharedVariable(anSNode.getParent(), anLHS);¬∂	}¬∂¬∂	public static List<SNode> getAllLeafNodes(SNode aTopNode) {¬∂		List<SNode> retVal = new ArrayList();¬∂		addLeafNodes(aTopNode, retVal);¬∂		return retVal;¬∂	}¬∂¬∂	public static void addLeafNodes(SNode aTopNode, List<SNode> retVal) {¬∂		for (SNode aChild : aTopNode.getChildren()) {¬∂			if (aChild.isLeaf()) {¬∂				retVal.add(aChild);¬∂			} else {¬∂				addLeafNodes(aChild, retVal);¬∂			}¬∂		}¬∂	}¬∂¬∂	public static List<SNode> getNonParallelLeafNodes(SNode aTopNode) {¬∂		List<SNode> retVal = new ArrayList();¬∂		addNonParallelLeafNodes(aTopNode, retVal);¬∂		return retVal;¬∂	}¬∂¬∂	public static void addNonParallelLeafNodes(SNode aTopNode, List<SNode> retVal) {¬∂		if (aTopNode.isInParallel()) {¬∂			return;¬∂		}¬∂		for (SNode aChild : aTopNode.getChildren()) {¬∂			if (aChild.isLeaf()) {¬∂				retVal.add(aChild);¬∂			} else {¬∂				addLeafNodes(aChild, retVal);¬∂			}¬∂		}¬∂	}¬∂	static String callRegex = "([a-zA-Z_$][a-zA-Z_$0-9]*)\\(.*?\\)";¬∂	static Pattern callPattern = Pattern.compile(callRegex);¬∂¬∂	static String identifierRegex = "[a-zA-Z_$][a-zA-Z_$0-9]*";¬∂	static Pattern identifierPattern = Pattern.compile(identifierRegex);¬∂	public static List<String> identifiersIn(String aString) {¬∂		if (aString == null)¬∂			return null;¬∂//		Pattern mypattern = Pattern.compile("[a-zA-Z_$][a-zA-Z_$0-9]*");¬∂//		Matcher mymatcher = mypattern.matcher(aString);¬∂		Matcher mymatcher = identifierPattern.matcher(aString);¬∂		List<String> retVal = new ArrayList();¬∂		while (mymatcher.find()) {¬∂			String find = mymatcher.group(0);¬∂			retVal.add(find);¬∂		}¬∂		return retVal;¬∂	}¬∂	public static List<MethodCall> callsIn(int aLineNumber, String aString, SNode aParent) {¬∂		if (aString == null)¬∂			return null;¬∂//		Pattern mypattern = Pattern.compile("[a-zA-Z_$][a-zA-Z_$0-9]*");¬∂//		Matcher mymatcher = mypattern.matcher(aString);¬∂		Matcher mymatcher = callPattern.matcher(aString);¬∂		List<MethodCall> retVal = new ArrayList();¬∂		while (mymatcher.find()) {¬∂			String find = mymatcher.group(0);¬∂			int aLeftParenIndex = find.indexOf("(");¬∂			int aRightParenIndex = find.indexOf(")");¬∂			String aMethodName = find.substring(0, aLeftParenIndex).trim();¬∂			String aParameters = find.substring(aLeftParenIndex + 1, aRightParenIndex);¬∂			List<String> aParameterList = new ArrayList();¬∂			String[] aParameterTokens = aParameters.split(",");¬∂			for (String aParameter:aParameterTokens) {¬∂				String aParameterTrimmed = aParameter.trim();¬∂				if (!aParameterTrimmed.isEmpty())¬∂				aParameterList.add(aParameterTrimmed);¬∂			}¬∂			retVal.add(new AMethodCall(aLineNumber, aMethodName, aParameterList, aParent));¬∂¬∂//			aCallStrings.add(find);¬∂		}¬∂		return retVal;¬∂	}¬∂	static String numberRegex = "(\\d+\\.\\d+)|(\\d+)";¬∂	static Pattern numberPattern = Pattern.compile(numberRegex);¬∂	public static List<String> numbersIn(String aString) {¬∂		if (aString == null)¬∂			return null;¬∂//		String regex = "(\\d+\\.\\d+)|(\\d+)";¬∂//¬∂//		Matcher m = Pattern.compile(regex).matcher(aString);¬∂		Matcher m =numberPattern.matcher(aString);¬∂¬∂¬∂		List<String> retVal = new ArrayList();¬∂¬∂		while (m.find()) {¬∂			retVal.add(m.group());¬∂		}¬∂		return retVal;¬∂	}¬∂¬∂	public static String subscriptIn(String aString) {¬∂		if (aString == null)¬∂			return null;¬∂		return StringUtils.substringBetween(aString, "[", "]");¬∂	}¬∂	static String[] emptyStringArray = {};¬∂	public static String[] subscriptsIn(String aString) {¬∂		if (aString == null)¬∂			return emptyStringArray;¬∂		return StringUtils.substringsBetween(aString, "[", "]");¬∂	}¬∂	static  String operatorRegex = "([+-/*///^])|([/(/)])";¬∂	static Pattern operatorPattern = Pattern.compile(operatorRegex);¬∂¬∂	public static List<String> operatorsIn(String aString) {¬∂		if (aString == null)¬∂			return null;¬∂//		String operatorRegex = "([+-/*///^])|([/(/)])";¬∂//¬∂//		Matcher m = Pattern.compile(operatorRegex).matcher(aString);¬∂		¬∂		Matcher m = operatorPattern.matcher(aString);¬∂¬∂¬∂		List<String> retVal = new ArrayList();¬∂¬∂		while (m.find()) {¬∂			retVal.add(m.group());¬∂		}¬∂		return retVal;¬∂	}¬∂	¬∂	public static int numberOfNestingFors (SNode anSNode) {¬∂		if (anSNode == null) {¬∂			return 0;¬∂		}¬∂		int retVal = numberOfNestingFors (anSNode.getParent()) ;¬∂¬∂		if (anSNode instanceof ForSNode) {¬∂			retVal++;¬∂		} else if (anSNode instanceof MethodSNode) {¬∂			List<MethodCall> aMethodCalls = ((MethodSNode) anSNode).getCalls();¬∂			int aMaxNestingLevel = 0;¬∂			for (MethodCall aMethodCall:aMethodCalls) {¬∂				MethodSNode aCallerMethodSNode = getDeclarationOfCalledMethod(anSNode, aMethodCall);¬∂				int aCallerNumberOfNestingFors = numberOfNestingFors(aCallerMethodSNode);¬∂				aMaxNestingLevel = Math.max(aCallerNumberOfNestingFors, aMaxNestingLevel);				¬∂			}¬∂			return retVal + aMaxNestingLevel;¬∂		}¬∂		return retVal;¬∂	}¬∂	public static boolean hasOperator (SNode anSNode, String anOperator) {¬∂		boolean retVal = false;¬∂		if (anSNode instanceof AssignmentSNode) {¬∂			AssignmentSNode anAssignmentSNode = (AssignmentSNode) anSNode;¬∂			 retVal = (anAssignmentSNode.getLhsOperators().contains(anOperator) || ¬∂					anAssignmentSNode.getRhsOperators().contains(anOperator)) ;¬∂			if (retVal) {¬∂				return retVal;¬∂			} else {¬∂				List<MethodCall> aMethodCalls = anAssignmentSNode.getRhsCalls();¬∂				for (MethodCall aMethodCall:aMethodCalls) {¬∂					MethodSNode aMethodSNode = getDeclarationOfCalledMethod(anSNode, aMethodCall);¬∂					retVal = hasOperator(aMethodSNode, anOperator);¬∂					if (retVal) {¬∂						return retVal;¬∂					}¬∂					¬∂				}¬∂				return false;¬∂			}¬∂			¬∂		}¬∂		for (SNode aChild:anSNode.getChildren()) {¬∂			retVal = hasOperator(aChild, anOperator);¬∂			if (retVal) {¬∂				return retVal;¬∂			}¬∂		}¬∂		return false;¬∂	}¬∂	public static boolean hasMethodCall (SNode anSNode, String anOperator) {¬∂		boolean retVal = false;¬∂		if (anSNode instanceof AssignmentSNode) {¬∂			AssignmentSNode anAssignmentSNode = (AssignmentSNode) anSNode;¬∂			 retVal = (anAssignmentSNode.getLhsOperators().contains(anOperator) || ¬∂					anAssignmentSNode.getRhsOperators().contains(anOperator)) ;¬∂			if (retVal) {¬∂				return retVal;¬∂			} else {¬∂				List<MethodCall> aMethodCalls = anAssignmentSNode.getRhsCalls();¬∂				for (MethodCall aMethodCall:aMethodCalls) {¬∂					MethodSNode aMethodSNode = getDeclarationOfCalledMethod(anSNode, aMethodCall);¬∂					retVal = hasOperator(aMethodSNode, anOperator);¬∂					if (retVal) {¬∂						return retVal;¬∂					}¬∂					¬∂				}¬∂				return false;¬∂			}¬∂			¬∂		}¬∂		for (SNode aChild:anSNode.getChildren()) {¬∂			retVal = hasOperator(aChild, anOperator);¬∂			if (retVal) {¬∂				return retVal;¬∂			}¬∂		}¬∂		return false;¬∂	}¬∂	public static boolean dependsOn (AssignmentSNode anAssignmentSNode, String aVariable, String aCallIdentifier) {¬∂		// This assignment does not change aVariable¬∂		if (!aVariable.equals(anAssignmentSNode.getLhsVariable())) {¬∂			return false;¬∂		}¬∂		return dependsOn(anAssignmentSNode.getExpressionSNode(), aCallIdentifier);¬∂//		List<String> aCallIdentifiers = anAssignmentSNode.getRhsCallIdentifiers();¬∂//		boolean retVal = false;¬∂//		if (aCallIdentifiers != null && aCallIdentifiers.contains(aCallIdentifier)) {¬∂//			return true; // this assignment has aCallIdentifier in the rhs¬∂//		}¬∂//		// check if some referenced rhs variable depends on aCallIdentifier¬∂//		List<String> aReferencedVariableIdentifiers = anAssignmentSNode.getRhsVariableIdentifiers();¬∂//		SNode anAssignmentParent = anAssignmentSNode.getParent();¬∂//		if (anAssignmentParent == null) { // should never be trye¬∂//			return false;¬∂//		}¬∂//		int aLineNumber = anAssignmentSNode.getLineNumber();¬∂//		for (String aReferencedVariableIdentifier:aReferencedVariableIdentifiers ) {¬∂//			if (dependsOn (anAssignmentParent, aLineNumber, aReferencedVariableIdentifier, aCallIdentifier)) {¬∂//				return true;¬∂//			}¬∂//		}¬∂//		return false;¬∂	}¬∂	public static boolean dependsOn (ExpressionSNode anExpressionSNode, String aCallIdentifier) {¬∂		// This assignment does not change aVariable¬∂		¬∂		List<String> aCallIdentifiers = anExpressionSNode.getRhsCallIdentifiers();¬∂		boolean retVal = false;¬∂		if (aCallIdentifiers != null && aCallIdentifiers.contains(aCallIdentifier)) {¬∂			return true; // this assignment has aCallIdentifier in the rhs¬∂		}¬∂		// check if some referenced rhs variable depends on aCallIdentifier¬∂		List<String> aReferencedVariableIdentifiers = anExpressionSNode.getRhsVariableIdentifiers();¬∂		SNode anAssignmentParent = anExpressionSNode.getParent().getParent();¬∂		if (anAssignmentParent == null) { // should never be trye¬∂			return false;¬∂		}¬∂		int aLineNumber = anExpressionSNode.getLineNumber();¬∂		for (String aReferencedVariableIdentifier:aReferencedVariableIdentifiers ) {¬∂			if (dependsOn (anAssignmentParent, aLineNumber, aReferencedVariableIdentifier, aCallIdentifier)) {¬∂				return true;¬∂			}¬∂		}¬∂		return false;¬∂	}¬∂	public static Set<AssignmentSNode> assignmentsToSharedVariables(SNode anSNode) {¬∂		Set<AssignmentSNode> retVal =  new HashSet();¬∂		fillAssignmentsToShared(anSNode, retVal);¬∂		return retVal;¬∂		¬∂	}¬∂	public static Set<AssignmentSNode> assignmentsToSharedArrays(SNode anSNode) {¬∂		Set<AssignmentSNode> anAllSharedAssignments =  assignmentsToSharedVariables(anSNode);¬∂		Set<AssignmentSNode> aRetVal = new HashSet();¬∂		for (AssignmentSNode anAssignmentSNode:anAllSharedAssignments) {¬∂			if (anAssignmentSNode.getLhsSubscripts().length > 0) {¬∂				aRetVal.add(anAssignmentSNode);¬∂			}¬∂		}¬∂		return aRetVal;¬∂		¬∂	}¬∂	public static Set<AssignmentSNode> assignmentsToParallelCriticalSharedVariables(SNode anSNode) {¬∂		Set<AssignmentSNode> anAllSharedAssignments =  assignmentsToSharedVariables(anSNode);¬∂		Set<AssignmentSNode> aRetVal = new HashSet();¬∂		for (AssignmentSNode anAssignmentSNode:anAllSharedAssignments) {¬∂			if (anAssignmentSNode.isInParallel() &&¬∂					anAssignmentSNode.isInCritical()) {¬∂				aRetVal.add(anAssignmentSNode);¬∂			}¬∂		}¬∂		return aRetVal;¬∂		¬∂	}¬∂	public static Set<AssignmentSNode> assignmentsToNonParallelCriticalSharedVariables(SNode anSNode) {¬∂		Set<AssignmentSNode> anAllSharedAssignments =  assignmentsToSharedVariables(anSNode);¬∂		Set<AssignmentSNode> aRetVal = new HashSet();¬∂		for (AssignmentSNode anAssignmentSNode:anAllSharedAssignments) {¬∂			if (!anAssignmentSNode.isInParallel() &&¬∂					anAssignmentSNode.isInCritical()) {¬∂				aRetVal.add(anAssignmentSNode);¬∂			}¬∂		}¬∂		return aRetVal;¬∂		¬∂	}¬∂	public static Set<AssignmentSNode> assignmentsToParallelNonCriticalSharedVariables(SNode anSNode) {¬∂		Set<AssignmentSNode> anAllSharedAssignments =  assignmentsToSharedVariables(anSNode);¬∂		Set<AssignmentSNode> aRetVal = new HashSet();¬∂		for (AssignmentSNode anAssignmentSNode:anAllSharedAssignments) {¬∂			if (anAssignmentSNode.isInParallel() &&¬∂					!anAssignmentSNode.isInCritical()) {¬∂				aRetVal.add(anAssignmentSNode);¬∂			}¬∂		}¬∂		return aRetVal;¬∂		¬∂	}¬∂    public static void fillAssignmentsToShared(SNode anSNode, Set<AssignmentSNode> retVal) {¬∂    	if (anSNode instanceof AssignmentSNode) {¬∂			AssignmentSNode anAssignmentSNode = (AssignmentSNode) anSNode;¬∂			String anLHS = anAssignmentSNode.getLhsVariable();¬∂			if (isSharedVariable(anSNode, anLHS)) {¬∂				retVal.add(anAssignmentSNode);¬∂				return;¬∂			}¬∂		}¬∂    	for (SNode aChild:anSNode.getChildren()) {¬∂    		fillAssignmentsToShared(aChild, retVal);¬∂    	}¬∂		¬∂	}¬∂	public static boolean dependsOn (SNode anSNode, int aVariableLineNumber, String aVariable, String aCallIdentifier) {¬∂		List<SNode> aListSNodes = anSNode.getChildren();¬∂		boolean retVal = false;¬∂		/*¬∂		 * Should probably ignore line number as it assumes straight line code¬∂		 */¬∂		for (int i = aVariableLineNumber; i >= 0; i--) {¬∂			SNode anSNodeChild = aListSNodes.get(i);¬∂			if (anSNodeChild instanceof AssignmentSNode) {¬∂				// does this statement in anSNode directly invoke aCallIdentifier ¬∂				if (dependsOn((AssignmentSNode) anSNodeChild, aVariable, aCallIdentifier))¬∂					return true;¬∂			} else if (!anSNode.isLeaf()) {¬∂					// child is overriding the variable so forget checking its assignment statements¬∂					if (anSNodeChild.getLocalVariables().contains(aVariable)) {¬∂						continue;¬∂					}¬∂					// some subblock of anSNode that has access to aVariable changes variable¬∂¬∂					if (dependsOn(anSNodeChild, anSNodeChild.getChildren().size() - 1, aVariable, aCallIdentifier)) {¬∂						return true;¬∂					}¬∂			}¬∂			¬∂		}¬∂		// none of the statements in anSNode or its descendents  have the required call¬∂		// is the variable a  method parameter ¬∂		if (anSNode instanceof MethodSNode) {¬∂			MethodSNode aMethodSNode = (MethodSNode) anSNode;¬∂			¬∂			int aParameterNumber = aMethodSNode.getLocalVariables().indexOf(aVariable);¬∂			if (aParameterNumber != -1) {¬∂				List <MethodCall> aCalls = aMethodSNode.getCalls();¬∂				for (MethodCall aCall:aCalls) {¬∂					MethodSNode aCallerSNode = getDeclarationOfCalledMethod(aMethodSNode, aCall);¬∂					boolean aCallerDepends = dependsOn(aMethodSNode, aCallerSNode.getLineNumber(), aVariable, aCallIdentifier);¬∂				    if (aCallerDepends) {¬∂				    	return true;¬∂				    }¬∂				}¬∂				return false;¬∂				// need to find all callers of method and see if any of the aliases for the variable in these¬∂				// calls depend on aCallIndentifier¬∂			}			¬∂			¬∂		} else if (anSNode.getLocalVariables().contains(aVariable)) {¬∂			// before going to the parent node, let us see if aVariable is declared here as a non  parameter ¬∂¬∂			return false; // no point going to parent¬∂		}¬∂		// not a local variable (parameter or declarated variable)¬∂		SNode anSNodeParent = anSNode.getParent() ;¬∂		if (anSNodeParent == null)  {¬∂			return false;¬∂		}¬∂		int anSNodeLineNumber = anSNodeParent.getChildren().indexOf(anSNode);¬∂		return dependsOn(anSNodeParent, anSNodeLineNumber, aVariable, aCallIdentifier);¬∂		¬∂	}¬∂	public static RootOfFileSNode getRootOfFileNode(SNode aCurrentSNode ) {¬∂		if (aCurrentSNode instanceof RootOfFileSNode) {¬∂			return (RootOfFileSNode) aCurrentSNode;¬∂		}¬∂		SNode aParentSNode = aCurrentSNode.getParent() ;¬∂		¬∂		if (aParentSNode == null) {¬∂			return null;¬∂		}¬∂		¬∂		return getRootOfFileNode(aParentSNode);¬∂		¬∂	}¬∂	public static boolean match (MethodSNode aMethodSNode, MethodCall aMethodCall) {¬∂		return aMethodSNode.getMethodName().equals(aMethodCall.getMethodName()) ¬∂				&& aMethodSNode.getLocalVariables().size() == aMethodCall.getMethodActuals().size();¬∂	}¬∂	¬∂	public static MethodSNode getDeclarationOfCalledMethod(SNode aCurrentSNode, MethodCall aMethodCall ) {¬∂		SNode aRootNode = getRootOfFileNode(aCurrentSNode);¬∂		for (SNode aChild:aRootNode.getChildren()) {¬∂			if (aChild instanceof MethodSNode) {¬∂				MethodSNode aMethodSNode = (MethodSNode) aChild;¬∂				if (match (aMethodSNode, aMethodCall)) {¬∂					return aMethodSNode;¬∂				}¬∂			}¬∂		}¬∂		return null; // this should never happen;¬∂	}¬∂	¬∂	public static RootOfProgramSNode getRootOfProgramSNode(String aSource) {¬∂		RootOfProgramSNode retVal = new ARootOfProgramSNode();¬∂		Map<String, StringBuffer> aFileNameToContents = ABasicTextManager.extractFileContents(aSource);¬∂		for (String aFileName:aFileNameToContents.keySet()) {¬∂			StringBuffer aFileContents = aFileNameToContents.get(aFileName);¬∂//			List<OpenMPPragma> anOpenMPPragmas = OpenMPUtils.getOpemMPPragmas(aFileContents);¬∂			RootOfFileSNode anSNode = OMPSNodeUtils.getSNode(aFileName, aFileContents);¬∂			retVal.getFileNameToSNode().put(aFileName, anSNode);¬∂			anSNode.setParent(retVal);¬∂//			System.out.println("file name:" + aFileName);¬∂//			System.out.println("pragmas:" + anSNode);¬∂		}¬∂		processExternalMethodSNodes(retVal);¬∂		return retVal;¬∂	}¬∂	public static void processExternalMethodSNodes (RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode) {¬∂		for (SNode anSNode:aRootOfFileSNode.getChildren()) {¬∂			if (anSNode instanceof ExternalMethodSNode) {¬∂				processExternalMethodSNode(aRootOfProgramSNode, aRootOfFileSNode, (ExternalMethodSNode) anSNode);¬∂			}¬∂		}¬∂	}¬∂	public static void processExternalMethodSNode (RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode, ExternalMethodSNode anExternalMethodSNode) {¬∂		MethodSNode aMethodSNode = aRootOfProgramSNode.getExternalToInternalMethod().get(anExternalMethodSNode.toString());¬∂		if (aMethodSNode == null) {¬∂			aMethodSNode = findMethodSNode(aRootOfProgramSNode, aRootOfFileSNode, anExternalMethodSNode);¬∂			if (aMethodSNode != null) {¬∂				aRootOfProgramSNode.getExternalToInternalMethod().put(anExternalMethodSNode.toString(),aMethodSNode );¬∂			}¬∂		}¬∂		if (aMethodSNode != null) {¬∂			anExternalMethodSNode.setActualMethodSNode(aMethodSNode);¬∂			aMethodSNode.getCalls().addAll(anExternalMethodSNode.getLocalCalls());¬∂		}¬∂	}¬∂	public static MethodSNode findMethodSNode (RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode, ExternalMethodSNode anExternalMethodSNode) {¬∂//		MethodSNode foundMethodSNode = null;¬∂		for (String aFileName:aRootOfProgramSNode.getFileNameToSNode().keySet()) {¬∂			if (aFileName.equals(aRootOfFileSNode.getFileName()))¬∂				continue;¬∂			¬∂			RootOfFileSNode aSearchedRootOfFileSNode = aRootOfProgramSNode.getFileNameToSNode().get(aFileName);¬∂			 for (SNode anSNode:aSearchedRootOfFileSNode.getChildren()) {¬∂				if (anSNode instanceof MethodSNode && !(anSNode instanceof ExternalMethodSNode)) {¬∂					if (anSNode.toString().equals(anExternalMethodSNode.toString())) {¬∂						return (MethodSNode) anSNode;¬∂						¬∂					}¬∂//					processExternalMethodSNode(aRootOfProgramSNode, aRootOfFileSNode, (ExternalMethodSNode) anSNode);¬∂				}¬∂			}¬∂		}¬∂		return null;¬∂	}¬∂	public static void processExternalMethodSNodes (RootOfProgramSNode aRootOfProgramSNode) {¬∂		for (String aFileName:aRootOfProgramSNode.getFileNameToSNode().keySet()) {¬∂			RootOfFileSNode aRootOfFileSNode = aRootOfProgramSNode.getFileNameToSNode().get(aFileName);¬∂			processExternalMethodSNodes(aRootOfProgramSNode, aRootOfFileSNode);¬∂			aRootOfFileSNode.getOmp_get_num_threads_SNode().¬∂				setActualMethodSNode(aRootOfProgramSNode.getOmp_get_num_threads_SNode());¬∂			aRootOfFileSNode.getOmp_get_thread_num_SNode().¬∂				setActualMethodSNode(aRootOfProgramSNode.getOmp_get_thread_num_SNode());¬∂			aRootOfFileSNode.getOmp_get_wtime_SNode().¬∂			setActualMethodSNode(aRootOfProgramSNode.getOmp_get_wtime_SNode());¬∂		}¬∂¬∂	}¬∂	¬∂¬∂//	public static void main(String[] args) {¬∂//		List<MethodCall> aTokens = callsIn("foo(bar, hgf)/foo2()*foo3(b, a c,)");¬∂//		System.out.println(aTokens);¬∂//		¬∂//		¬∂////		List<String> aTokens = identifiersIn("a[i] + b*2/3");¬∂////		System.out.println(aTokens);¬∂////		aTokens = numbersIn("a[i] + b*2/3");¬∂////		System.out.println(aTokens);¬∂////		aTokens = operatorsIn("a[i] + b*2/3");¬∂////		System.out.println(aTokens);¬∂////¬∂////		System.out.println(StringUtils.substringBetween("a", "[", "]"));¬∂//	}¬∂¬∂}¬∂")]]]></diff>
  </Command>
  <Command __id="186069" _type="DiffBasedFileOpenCommand" date="Mon Dec 30 10:46:57 EST 2019" docASTNodeCount="423" docActiveCodeLength="3162" docExpressionCount="328" docLength="5913" projectName="DemoCourseLocalBasicChecks" starttimestamp="1576666505112" timestamp="1054312808">
    <filePath><![CDATA[D:\dewan_backup\Java\DemoCourseLocalBasicChecks\src\gradingTools\comp123\assignment1\openmp\testcases\SequentialSumTestCase.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package gradingTools.comp123.assignment1.openmp.testcases;¬∂¬∂import java.util.Arrays;¬∂import java.util.List;¬∂import java.util.Map;¬∂import java.util.Set;¬∂import java.util.regex.Pattern;¬∂¬∂import grader.basics.execution.NotRunnableException;¬∂import grader.basics.execution.RunningProject;¬∂import grader.basics.junit.NotAutomatableException;¬∂import grader.basics.junit.TestCaseResult;¬∂import grader.basics.project.NotGradableException;¬∂import grader.basics.project.Project;¬∂import grader.basics.project.source.ABasicTextManager;¬∂import grader.basics.testcase.PassFailJUnitTestCase;¬∂import gradingTools.shared.testcases.SubstringSequenceChecker;¬∂import gradingTools.shared.testcases.openmp.OpenMPPragma;¬∂import gradingTools.shared.testcases.openmp.OpenMPUtils;¬∂import gradingTools.shared.testcases.openmp.scannedTree.AssignmentSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.ExternalMethodSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.MethodSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.OMPSNodeUtils;¬∂import gradingTools.shared.testcases.openmp.scannedTree.RootOfFileSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.RootOfProgramSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.SNode;¬∂import gradingTools.shared.testcases.utils.LinesMatchKind;¬∂import gradingTools.shared.testcases.utils.LinesMatcher;¬∂import gradingTools.utils.RunningProjectUtils;¬∂¬∂public class SequentialSumTestCase extends PassFailJUnitTestCase {¬∂	public static final int TIME_OUT_SECS = 1; // secs¬∂	protected SubstringSequenceChecker checker = new ASequentialSumChecker();	¬∂¬∂	public SequentialSumTestCase() {¬∂	}¬∂¬∂	¬∂¬∂	@Override¬∂	public TestCaseResult test(Project project, boolean autoGrade) throws NotAutomatableException,¬∂			NotGradableException {¬∂		try {¬∂			RunningProject aRunningProject = RunningProjectUtils.runProject(project, TIME_OUT_SECS);¬∂			String anOutput = aRunningProject.await();¬∂			LinesMatcher aLinesMatcher = aRunningProject.getLinesMatcher();¬∂			boolean aRetval = checker.check(aLinesMatcher, LinesMatchKind.ONE_TIME_LINE, Pattern.DOTALL);¬∂			String aSource = project.getSource();¬∂//			Map<String, StringBuffer> aFileNameToContents = ABasicTextManager.extractFileContents(aSource);¬∂//			for (String aFileName:aFileNameToContents.keySet()) {¬∂//				StringBuffer aFileContents = aFileNameToContents.get(aFileName);¬∂////				List<OpenMPPragma> anOpenMPPragmas = OpenMPUtils.getOpemMPPragmas(aFileContents);¬∂//				SNode anSNode = OMPSNodeUtils.getSNode(aFileName, aFileContents);¬∂//				System.out.println("file name:" + aFileName);¬∂//				System.out.println("pragmas:" + anSNode);¬∂//			}¬∂			RootOfProgramSNode aRootOfProgramSNode = OMPSNodeUtils.getRootOfProgramSNode(aSource);¬∂			Set<AssignmentSNode> anAssignments = OMPSNodeUtils.assignmentsToSharedVariables(aRootOfProgramSNode);¬∂			anAssignments = OMPSNodeUtils.assignmentsToSharedArrays(aRootOfProgramSNode);¬∂			anAssignments = OMPSNodeUtils.assignmentsToParallelCriticalSharedVariables(aRootOfProgramSNode);¬∂			anAssignments = OMPSNodeUtils.assignmentsToNonParallelCriticalSharedVariables(aRootOfProgramSNode);¬∂			anAssignments = OMPSNodeUtils.assignmentsToParallelNonCriticalSharedVariables(aRootOfProgramSNode);¬∂¬∂¬∂¬∂			String anExpectedLines = Arrays.toString(checker.getSubstrings());¬∂¬∂			if (!aRetval) {¬∂				return fail("Output  did not match:" + anExpectedLines);¬∂¬∂			}¬∂			return pass();¬∂			¬∂¬∂		} catch (NotRunnableException e) {¬∂			throw new NotGradableException();¬∂		}¬∂	}¬∂//	public static void processExternalMethodSNodes (RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode) {¬∂//		for (SNode anSNode:aRootOfFileSNode.getChildren()) {¬∂//			if (anSNode instanceof ExternalMethodSNode) {¬∂//				processExternalMethodSNode(aRootOfProgramSNode, aRootOfFileSNode, (ExternalMethodSNode) anSNode);¬∂//			}¬∂//		}¬∂//	}¬∂//	public static void processExternalMethodSNode (RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode, ExternalMethodSNode anExternalMethodSNode) {¬∂//		MethodSNode aMethodSNode = aRootOfProgramSNode.getExternalToInternalMethod().get(anExternalMethodSNode.toString());¬∂//		if (aMethodSNode == null) {¬∂//			aMethodSNode = findMethodSNode(aRootOfProgramSNode, aRootOfFileSNode, anExternalMethodSNode);¬∂//			if (aMethodSNode != null) {¬∂//				aRootOfProgramSNode.getExternalToInternalMethod().put(anExternalMethodSNode.toString(),aMethodSNode );¬∂//			}¬∂//		}¬∂//		if (aMethodSNode != null) {¬∂//			anExternalMethodSNode.setActualMethodSNode(aMethodSNode);¬∂//		}¬∂//	}¬∂//	public static MethodSNode findMethodSNode (RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode, ExternalMethodSNode anExternalMethodSNode) {¬∂////		MethodSNode foundMethodSNode = null;¬∂//		for (String aFileName:aRootOfProgramSNode.getFileNameToSNode().keySet()) {¬∂//			if (aFileName.equals(aRootOfFileSNode.getFileName()))¬∂//				continue;¬∂//			¬∂//			RootOfFileSNode aSearchedRootOfFileSNode = aRootOfProgramSNode.getFileNameToSNode().get(aFileName);¬∂//			 for (SNode anSNode:aSearchedRootOfFileSNode.getChildren()) {¬∂//				if (anSNode instanceof MethodSNode && !(anSNode instanceof ExternalMethodSNode)) {¬∂//					if (anSNode.toString().equals(anExternalMethodSNode)) {¬∂//						return (MethodSNode) anSNode;¬∂//						¬∂//					}¬∂////					processExternalMethodSNode(aRootOfProgramSNode, aRootOfFileSNode, (ExternalMethodSNode) anSNode);¬∂//				}¬∂//			}¬∂//		}¬∂//		return null;¬∂//	}¬∂//	public static void processExternalMethodSNodes (RootOfProgramSNode aRootOfProgramSNode) {¬∂//		for (String aFileName:aRootOfProgramSNode.getFileNameToSNode().keySet()) {¬∂//			RootOfFileSNode aRootOfFileSNode = aRootOfProgramSNode.getFileNameToSNode().get(aFileName);¬∂//			processExternalMethodSNodes(aRootOfProgramSNode, aRootOfFileSNode);¬∂//			¬∂//		}¬∂//¬∂//	}¬∂}¬∂")]]]></diff>
  </Command>
  <Command __id="186133" _type="ShellCommand" date="Wed Jan 01 00:02:15 EST 2020" starttimestamp="1576666505112" timestamp="1188430095" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="186134" _type="DiffBasedFileOpenCommand" date="Wed Jan 01 00:02:22 EST 2020" docASTNodeCount="1" docActiveCodeLength="659" docExpressionCount="0" docLength="747" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="1188437556">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\my_sum_parallel_for_local_var.cpp]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"#include <iostream>¬∂#include <omp.h>¬∂¬∂using namespace std;¬∂¬∂void printSumWithTimes (int sum, int start, int end);¬∂void printNumThreads();¬∂void recordThreadIndex(int index);¬∂void sum_parallel_for_local_var(double* array, int size)¬∂{¬∂	cout << "sum_parallel_for_local_var\n";¬∂¬∂	double start = omp_get_wtime();¬∂¬∂	double sum = 0;¬∂¬∂	int a, b;¬∂//¬∂//	for (int i = 0; i < size; i++) {¬∂//			sum += array[i];¬∂//			recordThreadIndex(i);¬∂//	}¬∂¬∂    #pragma omp parallel shared (sum, start) private (a, b)¬∂	{¬∂		double local_sum = 0;¬∂¬∂		#pragma omp for¬∂		for(int i = 0; i < size; i++) {¬∂			local_sum += array[i];¬∂			recordThreadIndex(i);¬∂		}¬∂¬∂		#pragma omp critical¬∂		sum += local_sum;¬∂	}¬∂¬∂	double end = omp_get_wtime();¬∂¬∂	printSumWithTimes(sum, start, end);¬∂	¬∂}¬∂")]]]></diff>
  </Command>
  <Command __id="186135" _type="MoveCaretCommand" caretOffset="621" date="Wed Jan 01 00:02:23 EST 2020" docOffset="621" starttimestamp="1576666505112" timestamp="1188438012" />
  <Command __id="186136" _type="DiffBasedFileOpenCommand" date="Wed Jan 01 00:02:44 EST 2020" docASTNodeCount="1" docActiveCodeLength="453" docExpressionCount="0" docLength="453" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="1188458938">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\my_sum_sequential.cpp]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"#include <iostream>¬∂#include <omp.h>¬∂¬∂using namespace std;¬∂void printSumWithTimes(int sum, int start, int end);¬∂void printNumThreads();¬∂void recordThreadIndex(int index);¬∂void sum_sequential(double* array, int size) {¬∂¬∂	cout << "sum_sequential\n";¬∂¬∂	double start = omp_get_wtime();¬∂¬∂	double sum = 0;¬∂¬∂	for (int i = 0; i < size; i++) {¬∂		sum += array[i];¬∂		recordThreadIndex(i);¬∂	}¬∂¬∂	double end = omp_get_wtime();¬∂¬∂	printSumWithTimes(sum, start, end);¬∂}¬∂")]]]></diff>
  </Command>
  <Command __id="186137" _type="SelectTextCommand" caretOffset="280" date="Wed Jan 01 00:02:44 EST 2020" end="280" start="265" starttimestamp="1576666505112" timestamp="1188459199" />
  <Command __id="186139" _type="MoveCaretCommand" caretOffset="379" date="Wed Jan 01 00:02:58 EST 2020" docOffset="379" starttimestamp="1576666505112" timestamp="1188473563" />
  <Command __id="186138" _type="DiffBasedFileOpenCommand" date="Wed Jan 01 00:02:58 EST 2020" docASTNodeCount="1" docActiveCodeLength="532" docExpressionCount="0" docLength="575" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="1188473301">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\my_sum_parallel_for_reduction.cpp]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"#include <iostream>¬∂#include <omp.h>¬∂¬∂using namespace std;¬∂¬∂//const int SIZE = 1000;¬∂void printSumWithTimes(int sum, int start, int end);¬∂void printNumThreads();¬∂void recordThreadIndex(int index);¬∂void sum_parallel_for_reduction(double* array, int size) {¬∂	cout << "sum_parallel_for_reduction\n";¬∂¬∂	double start = omp_get_wtime();¬∂¬∂	double sum = 0;¬∂    #pragma omp  parallel for reduction ( + : sum )¬∂//	#pragma omp  for¬∂¬∂	for (int i = 0; i < size; i++) {¬∂		sum += array[i];¬∂		recordThreadIndex(i);¬∂	}¬∂¬∂	double end = omp_get_wtime();¬∂¬∂	printSumWithTimes(sum, start, end);¬∂¬∂}¬∂")]]]></diff>
  </Command>
  <Command __id="186140" _type="MoveCaretCommand" caretOffset="458" date="Wed Jan 01 00:03:34 EST 2020" docOffset="458" starttimestamp="1576666505112" timestamp="1188509052" />
  <DocumentChange __id="186141" _type="Insert" date="Wed Jan 01 00:03:35 EST 2020" docASTNodeCount="1" docActiveCodeLength="533" docExpressionCount="0" docLength="576" length="1" offset="458" starttimestamp="1576666505112" timestamp="1188510086">
    <text><![CDATA[i]]></text>
  </DocumentChange>
  <Command __id="186142" _type="InsertStringCommand" date="Wed Jan 01 00:03:35 EST 2020" starttimestamp="1576666505112" timestamp="1188510103" timestamp2="1188510103">
    <data><![CDATA[i]]></data>
  </Command>
  <DocumentChange __id="186143" _type="Insert" date="Wed Jan 01 00:03:35 EST 2020" docASTNodeCount="1" docActiveCodeLength="534" docExpressionCount="0" docLength="577" length="1" offset="459" starttimestamp="1576666505112" timestamp="1188510205">
    <text><![CDATA[n]]></text>
  </DocumentChange>
  <Command __id="186144" _type="InsertStringCommand" date="Wed Jan 01 00:03:35 EST 2020" starttimestamp="1576666505112" timestamp="1188510208" timestamp2="1188510208">
    <data><![CDATA[n]]></data>
  </Command>
  <DocumentChange __id="186145" _type="Insert" date="Wed Jan 01 00:03:35 EST 2020" docASTNodeCount="1" docActiveCodeLength="535" docExpressionCount="0" docLength="578" length="1" offset="460" starttimestamp="1576666505112" timestamp="1188510317">
    <text><![CDATA[t]]></text>
  </DocumentChange>
  <Command __id="186146" _type="InsertStringCommand" date="Wed Jan 01 00:03:35 EST 2020" starttimestamp="1576666505112" timestamp="1188510323" timestamp2="1188510323">
    <data><![CDATA[t]]></data>
  </Command>
  <DocumentChange __id="186147" _type="Insert" date="Wed Jan 01 00:03:36 EST 2020" docASTNodeCount="1" docActiveCodeLength="536" docExpressionCount="0" docLength="579" length="1" offset="461" starttimestamp="1576666505112" timestamp="1188511240">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <Command __id="186148" _type="InsertStringCommand" date="Wed Jan 01 00:03:36 EST 2020" starttimestamp="1576666505112" timestamp="1188511246" timestamp2="1188511246">
    <data><![CDATA[ ]]></data>
  </Command>
  <DocumentChange __id="186149" _type="Delete" date="Wed Jan 01 00:03:37 EST 2020" docASTNodeCount="1" docActiveCodeLength="532" docExpressionCount="0" docLength="575" endLine="19" length="4" offset="458" startLine="19" starttimestamp="1576666505112" timestamp="1188512760">
    <text><![CDATA[int ]]></text>
  </DocumentChange>
  <Command __id="186150" _type="UndoCommand" date="Wed Jan 01 00:03:39 EST 2020" starttimestamp="1576666505112" timestamp="1188513971" />
  <DocumentChange __id="186151" _type="Insert" date="Wed Jan 01 00:03:39 EST 2020" docASTNodeCount="1" docActiveCodeLength="533" docExpressionCount="0" docLength="576" length="1" offset="379" starttimestamp="1576666505112" timestamp="1188514580">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <Command __id="186152" _type="UndoCommand" date="Wed Jan 01 00:03:39 EST 2020" starttimestamp="1576666505112" timestamp="1188514602" />
  <Command __id="186154" _type="RedoCommand" date="Wed Jan 01 00:03:42 EST 2020" starttimestamp="1576666505112" timestamp="1188517148" />
  <Command __id="186155" _type="MoveCaretCommand" caretOffset="463" date="Wed Jan 01 00:03:44 EST 2020" docOffset="463" starttimestamp="1576666505112" timestamp="1188518944" />
  <Command __id="186156" _type="MoveCaretCommand" caretOffset="463" date="Wed Jan 01 00:03:44 EST 2020" docOffset="463" starttimestamp="1576666505112" timestamp="1188519122" />
  <Command __id="186157" _type="SelectTextCommand" caretOffset="475" date="Wed Jan 01 00:03:44 EST 2020" end="475" start="456" starttimestamp="1576666505112" timestamp="1188519384" />
  <Command __id="186158" _type="CopyCommand" date="Wed Jan 01 00:03:45 EST 2020" starttimestamp="1576666505112" timestamp="1188520817" />
  <DocumentChange __id="186153" _type="Delete" date="Wed Jan 01 00:03:42 EST 2020" docASTNodeCount="1" docActiveCodeLength="532" docExpressionCount="0" docLength="575" endLine="15" length="1" offset="379" startLine="15" starttimestamp="1576666505112" timestamp="1188517108">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="186160" _type="Insert" date="Wed Jan 01 00:03:47 EST 2020" docASTNodeCount="1" docActiveCodeLength="535" docExpressionCount="0" docLength="578" length="3" offset="474" starttimestamp="1576666505112" timestamp="1188522539">
    <text><![CDATA[
		]]></text>
  </DocumentChange>
  <Command __id="186159" _type="MoveCaretCommand" caretOffset="474" date="Wed Jan 01 00:03:47 EST 2020" docOffset="474" starttimestamp="1576666505112" timestamp="1188522066" />
  <Command __id="186161" _type="InsertStringCommand" date="Wed Jan 01 00:03:47 EST 2020" starttimestamp="1576666505112" timestamp="1188522549" timestamp2="1188522549">
    <data><![CDATA[]]></data>
  </Command>
  <Command __id="186163" _type="PasteCommand" date="Wed Jan 01 00:03:49 EST 2020" starttimestamp="1576666505112" timestamp="1188524245" />
  <Command __id="186164" _type="MoveCaretCommand" caretOffset="457" date="Wed Jan 01 00:03:50 EST 2020" docOffset="457" starttimestamp="1576666505112" timestamp="1188525628" />
  <Command __id="186166" _type="EclipseCommand" commandID="org.eclipse.cdt.ui.edit.text.c.toggle.comment" date="Wed Jan 01 00:03:51 EST 2020" starttimestamp="1576666505112" timestamp="1188526696" />
  <Command __id="186167" _type="MoveCaretCommand" caretOffset="479" date="Wed Jan 01 00:03:53 EST 2020" docOffset="479" starttimestamp="1576666505112" timestamp="1188528407" />
  <Command __id="186169" _type="InsertStringCommand" date="Wed Jan 01 00:03:53 EST 2020" starttimestamp="1576666505112" timestamp="1188528738" timestamp2="1188528738">
    <data><![CDATA[i]]></data>
  </Command>
  <Command __id="186171" _type="InsertStringCommand" date="Wed Jan 01 00:03:54 EST 2020" starttimestamp="1576666505112" timestamp="1188528998" timestamp2="1188528998">
    <data><![CDATA[n]]></data>
  </Command>
  <Command __id="186173" _type="InsertStringCommand" date="Wed Jan 01 00:03:54 EST 2020" starttimestamp="1576666505112" timestamp="1188529123" timestamp2="1188529123">
    <data><![CDATA[t]]></data>
  </Command>
  <Command __id="186175" _type="InsertStringCommand" date="Wed Jan 01 00:03:54 EST 2020" starttimestamp="1576666505112" timestamp="1188529363" timestamp2="1188529363">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="186176" _type="EclipseCommand" commandID="org.eclipse.ui.file.save" date="Wed Jan 01 00:03:55 EST 2020" starttimestamp="1576666505112" timestamp="1188530498" />
  <DocumentChange __id="186162" _type="Replace" date="Wed Jan 01 00:03:49 EST 2020" docASTNodeCount="1" docActiveCodeLength="552" docExpressionCount="0" docLength="595" endLine="20" insertionLength="19" int_docASTNodeCount="1" int_docActiveCodeLength="533" int_docExpressionCount="0" int_docLength="576" length="2" offset="475" startLine="20" starttimestamp="1576666505112" timestamp="1188524171">
    <deletedText><![CDATA[		]]></deletedText>
    <insertedText><![CDATA[		sum += array[i];
]]></insertedText>
  </DocumentChange>
  <DocumentChange __id="186165" _type="Insert" date="Wed Jan 01 00:03:51 EST 2020" docASTNodeCount="1" docActiveCodeLength="534" docExpressionCount="0" docLength="597" length="2" offset="456" starttimestamp="1576666505112" timestamp="1188526620">
    <text><![CDATA[//]]></text>
  </DocumentChange>
  <DocumentChange __id="186168" _type="Insert" date="Wed Jan 01 00:03:53 EST 2020" docASTNodeCount="1" docActiveCodeLength="535" docExpressionCount="0" docLength="598" length="1" offset="479" starttimestamp="1576666505112" timestamp="1188528727">
    <text><![CDATA[i]]></text>
  </DocumentChange>
  <DocumentChange __id="186170" _type="Insert" date="Wed Jan 01 00:03:54 EST 2020" docASTNodeCount="1" docActiveCodeLength="536" docExpressionCount="0" docLength="599" length="1" offset="480" starttimestamp="1576666505112" timestamp="1188528990">
    <text><![CDATA[n]]></text>
  </DocumentChange>
  <DocumentChange __id="186172" _type="Insert" date="Wed Jan 01 00:03:54 EST 2020" docASTNodeCount="1" docActiveCodeLength="537" docExpressionCount="0" docLength="600" length="1" offset="481" starttimestamp="1576666505112" timestamp="1188529113">
    <text><![CDATA[t]]></text>
  </DocumentChange>
  <DocumentChange __id="186174" _type="Insert" date="Wed Jan 01 00:03:54 EST 2020" docASTNodeCount="1" docActiveCodeLength="538" docExpressionCount="0" docLength="601" length="1" offset="482" starttimestamp="1576666505112" timestamp="1188529358">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <Command __id="186177" _type="MoveCaretCommand" caretOffset="481" date="Wed Jan 01 00:04:11 EST 2020" docOffset="481" starttimestamp="1576666505112" timestamp="1188546580" />
  <Command __id="186178" _type="SelectTextCommand" caretOffset="482" date="Wed Jan 01 00:04:11 EST 2020" end="482" start="479" starttimestamp="1576666505112" timestamp="1188546861" />
  <Command __id="186180" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Wed Jan 01 00:04:13 EST 2020" starttimestamp="1576666505112" timestamp="1188548584" />
  <Command __id="186181" _type="MoveCaretCommand" caretOffset="481" date="Wed Jan 01 00:04:18 EST 2020" docOffset="481" starttimestamp="1576666505112" timestamp="1188553423" />
  <Command __id="186182" _type="SelectTextCommand" caretOffset="483" date="Wed Jan 01 00:04:18 EST 2020" end="483" start="480" starttimestamp="1576666505112" timestamp="1188553607" />
  <Command __id="186183" _type="SelectTextCommand" caretOffset="497" date="Wed Jan 01 00:04:18 EST 2020" end="497" start="477" starttimestamp="1576666505112" timestamp="1188553876" />
  <Command __id="186185" _type="EclipseCommand" commandID="org.eclipse.ui.edit.delete" date="Wed Jan 01 00:04:19 EST 2020" starttimestamp="1576666505112" timestamp="1188554876" />
  <Command __id="186197" _type="RunCommand" date="Wed Jan 01 00:04:56 EST 2020" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="1188591370" type="Run" />
  <Command __id="186198" _type="RunCommand" date="Wed Jan 01 00:04:56 EST 2020" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="1188591370" type="Run" />
  <Command __id="186199" _type="RunCommand" date="Wed Jan 01 00:04:56 EST 2020" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="1188591785" type="Run" />
  <Command __id="186200" _type="EclipseCommand" commandID="org.eclipse.cdt.make.ui.targetBuildLastCommand" date="Wed Jan 01 00:05:03 EST 2020" starttimestamp="1576666505112" timestamp="1188598585" />
  <DocumentChange __id="186179" _type="Delete" date="Wed Jan 01 00:04:13 EST 2020" docASTNodeCount="1" docActiveCodeLength="535" docExpressionCount="0" docLength="598" endLine="20" length="3" offset="479" startLine="20" starttimestamp="1576666505112" timestamp="1188548557">
    <text><![CDATA[int]]></text>
  </DocumentChange>
  <DocumentChange __id="186184" _type="Delete" date="Wed Jan 01 00:04:19 EST 2020" docASTNodeCount="1" docActiveCodeLength="515" docExpressionCount="0" docLength="578" endLine="21" length="20" offset="477" startLine="20" starttimestamp="1576666505112" timestamp="1188554851">
    <text><![CDATA[		 sum += array[i];
]]></text>
  </DocumentChange>
  <Command __id="186201" _type="EclipseCommand" commandID="org.eclipse.debug.ui.commands.Resume" date="Wed Jan 01 00:05:05 EST 2020" starttimestamp="1576666505112" timestamp="1188600688" />
  <Command __id="186202" _type="RunCommand" date="Wed Jan 01 00:05:05 EST 2020" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="1188600709" type="Debug" />
  <Command __id="186203" _type="RunCommand" date="Wed Jan 01 00:05:05 EST 2020" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="1188600709" type="Run" />
  <Command __id="186204" _type="RunCommand" date="Wed Jan 01 00:05:05 EST 2020" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="1188600709" type="Debug" />
  <Command __id="186205" _type="RunCommand" date="Wed Jan 01 00:05:05 EST 2020" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="1188600709" type="Run" />
  <Command __id="186206" _type="EHExceptionCommand" date="Wed Jan 01 00:05:05 EST 2020" starttimestamp="1576666505112" timestamp="1188600803" type="Exception">
    <outputString><![CDATA[sum_sequential
Sum: 499500
Took: 0
thread:0 lastIndex:999
_____________________________
sum_parallel_for_reduction
Sum: 499500
Took: 0
thread:0 lastIndex:124
thread:1 lastIndex:249
thread:2 lastIndex:374
thread:3 lastIndex:499
thread:4 lastIndex:624
thread:5 lastIndex:749
thread:6 lastIndex:874
thread:7 lastIndex:999
_____________________________
sum_parallel_for_local_var
Sum: 499500
Took: 0
thread:0 lastIndex:124
thread:1 lastIndex:249
thread:2 lastIndex:374
thread:3 lastIndex:499
thread:4 lastIndex:624
thread:5 lastIndex:749
thread:6 lastIndex:874
thread:7 lastIndex:999
_____________________________
sum_parallel
Sum: 499500
Took: 0
_____________________________
]]></outputString>
  </Command>
  <Command __id="186207" _type="RunCommand" date="Wed Jan 01 00:05:06 EST 2020" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="1188601239" type="Debug" />
  <Command __id="186208" _type="RunCommand" date="Wed Jan 01 00:05:06 EST 2020" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="1188601239" type="Run" />
  <Command __id="186209" _type="RunCommand" date="Wed Jan 01 00:05:06 EST 2020" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="1188601239" type="Debug" />
  <Command __id="186210" _type="RunCommand" date="Wed Jan 01 00:05:06 EST 2020" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="1188601239" type="Run" />
  <Command __id="186211" _type="DiffBasedFileOpenCommand" date="Wed Jan 01 00:05:20 EST 2020" docASTNodeCount="1" docActiveCodeLength="1642" docExpressionCount="0" docLength="1924" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="1188615210">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\my_sum_main.cpp]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"#include <iostream>¬∂#include <omp.h>¬∂¬∂using namespace std;¬∂//need to declare headers of external functions called¬∂void sum_sequential(double* array, int size);¬∂void sum_parallel_for_reduction(double* array, int size);¬∂void sum_parallel(double* array, int size);¬∂void sum_parallel_for_local_var(double* array, int size);¬∂¬∂// if this main is used to call functions to do other computations¬∂// then those headers should also be declared here¬∂¬∂const int SIZE = 1000;¬∂void initArray (double* array, int size ) {¬∂	for(int i = 0; i < size; i++)¬∂			array[i]=i;¬∂}¬∂/**¬∂ * Called by each of the summing alternatives¬∂ */¬∂void printSumWithTimes (int sum, int start, int end) {¬∂	cout << "Sum: " << sum << endl;¬∂	cout << "Took: " << end - start << endl;¬∂}¬∂void printNumThreads() {¬∂	cout << "threads:" << omp_get_num_threads() << endl;¬∂}¬∂/**¬∂ * an array to learn how much concurrency occcurred¬∂ */¬∂int MAX_THREADS = 100;¬∂double* threadsLastIndex = new double[MAX_THREADS];¬∂int numThreads;¬∂¬∂¬∂void recordThreadIndex(int index) {¬∂	int thread =  omp_get_thread_num();¬∂	if (thread >= MAX_THREADS) {¬∂		return;¬∂	}¬∂	threadsLastIndex[thread] = index;¬∂	numThreads = omp_get_num_threads();¬∂}¬∂void initThreadRecording() {¬∂	numThreads = 0;¬∂	for (int i = 0; i < MAX_THREADS; i++) {¬∂		threadsLastIndex[i] = -1;¬∂	}¬∂}¬∂¬∂void printThreadLastIndex() {¬∂	for (int i = 0; i < numThreads; i++) {¬∂		cout << "thread:" << i << " lastIndex:" << threadsLastIndex[i] << endl;¬∂	}¬∂	cout << "_____________________________" << endl;¬∂}¬∂¬∂¬∂int main()¬∂{¬∂	double* array = new double[SIZE];¬∂	initArray(array, SIZE);¬∂	initThreadRecording();¬∂	sum_sequential(array, SIZE);¬∂	printThreadLastIndex();¬∂	initThreadRecording();¬∂	sum_parallel_for_reduction(array, SIZE);¬∂	printThreadLastIndex();¬∂	initThreadRecording();¬∂	sum_parallel_for_local_var(array, SIZE);¬∂	printThreadLastIndex();¬∂	initThreadRecording();¬∂	sum_parallel(array, SIZE);¬∂	printThreadLastIndex();¬∂	initThreadRecording();¬∂}¬∂")]]]></diff>
  </Command>
  <Command __id="186212" _type="MoveCaretCommand" caretOffset="1500" date="Wed Jan 01 00:05:20 EST 2020" docOffset="1500" starttimestamp="1576666505112" timestamp="1188615333" />
  <Command __id="186213" _type="DiffBasedFileOpenCommand" date="Wed Jan 01 00:05:32 EST 2020" docASTNodeCount="1" docActiveCodeLength="659" docExpressionCount="0" docLength="747" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="1188627637">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\my_sum_parallel_for_local_var.cpp]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"#include <iostream>¬∂#include <omp.h>¬∂¬∂using namespace std;¬∂¬∂void printSumWithTimes (int sum, int start, int end);¬∂void printNumThreads();¬∂void recordThreadIndex(int index);¬∂void sum_parallel_for_local_var(double* array, int size)¬∂{¬∂	cout << "sum_parallel_for_local_var\n";¬∂¬∂	double start = omp_get_wtime();¬∂¬∂	double sum = 0;¬∂¬∂	int a, b;¬∂//¬∂//	for (int i = 0; i < size; i++) {¬∂//			sum += array[i];¬∂//			recordThreadIndex(i);¬∂//	}¬∂¬∂    #pragma omp parallel shared (sum, start) private (a, b)¬∂	{¬∂		double local_sum = 0;¬∂¬∂		#pragma omp for¬∂		for(int i = 0; i < size; i++) {¬∂			local_sum += array[i];¬∂			recordThreadIndex(i);¬∂		}¬∂¬∂		#pragma omp critical¬∂		sum += local_sum;¬∂	}¬∂¬∂	double end = omp_get_wtime();¬∂¬∂	printSumWithTimes(sum, start, end);¬∂	¬∂}¬∂")]]]></diff>
  </Command>
  <Command __id="186215" _type="RunCommand" date="Wed Jan 01 00:05:46 EST 2020" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="1188641824" type="Run" />
  <Command __id="186216" _type="RunCommand" date="Wed Jan 01 00:05:46 EST 2020" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="1188641824" type="Run" />
  <Command __id="186217" _type="RunCommand" date="Wed Jan 01 00:05:46 EST 2020" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="1188641841" type="Debug" />
  <Command __id="186218" _type="RunCommand" date="Wed Jan 01 00:05:46 EST 2020" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="1188641841" type="Run" />
  <Command __id="186219" _type="RunCommand" date="Wed Jan 01 00:05:46 EST 2020" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="1188641841" type="Debug" />
  <Command __id="186220" _type="RunCommand" date="Wed Jan 01 00:05:46 EST 2020" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="1188641841" type="Run" />
  <Command __id="186221" _type="EHExceptionCommand" date="Wed Jan 01 00:05:47 EST 2020" starttimestamp="1576666505112" timestamp="1188642043" type="Exception">
    <outputString><![CDATA[sum_sequential
Sum: 499500
Took: 0
thread:0 lastIndex:999
_____________________________
sum_parallel_for_reduction
Sum: 499500
Took: 0
thread:0 lastIndex:124
thread:1 lastIndex:249
thread:2 lastIndex:374
thread:3 lastIndex:499
thread:4 lastIndex:624
thread:5 lastIndex:749
thread:6 lastIndex:874
thread:7 lastIndex:999
_____________________________
sum_parallel_for_local_var
Sum: 499500
Took: 0
thread:0 lastIndex:124
thread:1 lastIndex:249
thread:2 lastIndex:374
thread:3 lastIndex:499
thread:4 lastIndex:624
thread:5 lastIndex:749
thread:6 lastIndex:874
thread:7 lastIndex:999
_____________________________
sum_parallel
Sum: 499500
Took: 0
_____________________________
]]></outputString>
  </Command>
  <Command __id="186222" _type="DiffBasedFileOpenCommand" date="Wed Jan 01 00:05:52 EST 2020" docASTNodeCount="1" docActiveCodeLength="515" docExpressionCount="0" docLength="578" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="1188647437">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\my_sum_parallel_for_reduction.cpp]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"#include <iostream>¬∂#include <omp.h>¬∂¬∂using namespace std;¬∂¬∂//const int SIZE = 1000;¬∂void printSumWithTimes(int sum, int start, int end);¬∂void printNumThreads();¬∂void recordThreadIndex(int index);¬∂void sum_parallel_for_reduction(double* array, int size) {¬∂	cout << "sum_parallel_for_reduction\n";¬∂¬∂	double start = omp_get_wtime();¬∂¬∂	double sum = 0;¬∂    #pragma omp  parallel for reduction ( + : sum )¬∂//	#pragma omp  for¬∂¬∂	for (int i = 0; i < size; i++) {¬∂"), Diff(INSERT,"//"), Diff(EQUAL,"		sum += array[i];¬∂"), Diff(INSERT,"¬∂"), Diff(EQUAL,"		recordThreadIndex(i);¬∂	}¬∂¬∂	double end = omp_get_wtime();¬∂¬∂	printSumWithTimes(sum, start, end);¬∂¬∂}¬∂")]]]></diff>
    <snapshot><![CDATA[#include <iostream>
#include <omp.h>

using namespace std;

//const int SIZE = 1000;
void printSumWithTimes(int sum, int start, int end);
void printNumThreads();
void recordThreadIndex(int index);
void sum_parallel_for_reduction(double* array, int size) {
	cout << "sum_parallel_for_reduction\n";

	double start = omp_get_wtime();

	double sum = 0;
    #pragma omp  parallel for reduction ( + : sum )
//	#pragma omp  for

	for (int i = 0; i < size; i++) {
//		sum += array[i];

		recordThreadIndex(i);
	}

	double end = omp_get_wtime();

	printSumWithTimes(sum, start, end);

}
]]></snapshot>
  </Command>
  <Command __id="186223" _type="MoveCaretCommand" caretOffset="477" date="Wed Jan 01 00:05:52 EST 2020" docOffset="477" starttimestamp="1576666505112" timestamp="1188647720" />
  <Command __id="186224" _type="DiffBasedFileOpenCommand" date="Wed Jan 01 00:05:57 EST 2020" docASTNodeCount="1" docActiveCodeLength="453" docExpressionCount="0" docLength="453" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="1188652134">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\my_sum_sequential.cpp]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"#include <iostream>¬∂#include <omp.h>¬∂¬∂using namespace std;¬∂void printSumWithTimes(int sum, int start, int end);¬∂void printNumThreads();¬∂void recordThreadIndex(int index);¬∂void sum_sequential(double* array, int size) {¬∂¬∂	cout << "sum_sequential\n";¬∂¬∂	double start = omp_get_wtime();¬∂¬∂	double sum = 0;¬∂¬∂	for (int i = 0; i < size; i++) {¬∂		sum += array[i];¬∂		recordThreadIndex(i);¬∂	}¬∂¬∂	double end = omp_get_wtime();¬∂¬∂	printSumWithTimes(sum, start, end);¬∂}¬∂")]]]></diff>
  </Command>
  <Command __id="186225" _type="SelectTextCommand" caretOffset="280" date="Wed Jan 01 00:05:57 EST 2020" end="280" start="265" starttimestamp="1576666505112" timestamp="1188652302" />
  <Command __id="186226" _type="DiffBasedFileOpenCommand" date="Wed Jan 01 00:06:01 EST 2020" docASTNodeCount="1" docActiveCodeLength="515" docExpressionCount="0" docLength="578" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="1188656877">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\my_sum_parallel_for_reduction.cpp]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"#include <iostream>¬∂#include <omp.h>¬∂¬∂using namespace std;¬∂¬∂//const int SIZE = 1000;¬∂void printSumWithTimes(int sum, int start, int end);¬∂void printNumThreads();¬∂void recordThreadIndex(int index);¬∂void sum_parallel_for_reduction(double* array, int size) {¬∂	cout << "sum_parallel_for_reduction\n";¬∂¬∂	double start = omp_get_wtime();¬∂¬∂	double sum = 0;¬∂    #pragma omp  parallel for reduction ( + : sum )¬∂//	#pragma omp  for¬∂¬∂	for (int i = 0; i < size; i++) {¬∂//		sum += array[i];¬∂¬∂		recordThreadIndex(i);¬∂	}¬∂¬∂	double end = omp_get_wtime();¬∂¬∂	printSumWithTimes(sum, start, end);¬∂¬∂}¬∂")]]]></diff>
  </Command>
  <Command __id="186227" _type="MoveCaretCommand" caretOffset="477" date="Wed Jan 01 00:06:02 EST 2020" docOffset="477" starttimestamp="1576666505112" timestamp="1188657051" />
  <Command __id="186228" _type="DiffBasedFileOpenCommand" date="Wed Jan 01 00:06:06 EST 2020" docASTNodeCount="1" docActiveCodeLength="659" docExpressionCount="0" docLength="747" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="1188660905">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\my_sum_parallel_for_local_var.cpp]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"#include <iostream>¬∂#include <omp.h>¬∂¬∂using namespace std;¬∂¬∂void printSumWithTimes (int sum, int start, int end);¬∂void printNumThreads();¬∂void recordThreadIndex(int index);¬∂void sum_parallel_for_local_var(double* array, int size)¬∂{¬∂	cout << "sum_parallel_for_local_var\n";¬∂¬∂	double start = omp_get_wtime();¬∂¬∂	double sum = 0;¬∂¬∂	int a, b;¬∂//¬∂//	for (int i = 0; i < size; i++) {¬∂//			sum += array[i];¬∂//			recordThreadIndex(i);¬∂//	}¬∂¬∂    #pragma omp parallel shared (sum, start) private (a, b)¬∂	{¬∂		double local_sum = 0;¬∂¬∂		#pragma omp for¬∂		for(int i = 0; i < size; i++) {¬∂			local_sum += array[i];¬∂			recordThreadIndex(i);¬∂		}¬∂¬∂		#pragma omp critical¬∂		sum += local_sum;¬∂	}¬∂¬∂	double end = omp_get_wtime();¬∂¬∂	printSumWithTimes(sum, start, end);¬∂	¬∂}¬∂")]]]></diff>
  </Command>
  <Command __id="186229" _type="MoveCaretCommand" caretOffset="621" date="Wed Jan 01 00:06:06 EST 2020" docOffset="621" starttimestamp="1576666505112" timestamp="1188661069" />
  <Command __id="186231" _type="MoveCaretCommand" caretOffset="477" date="Wed Jan 01 00:06:14 EST 2020" docOffset="477" starttimestamp="1576666505112" timestamp="1188669508" />
  <Command __id="186230" _type="DiffBasedFileOpenCommand" date="Wed Jan 01 00:06:14 EST 2020" docASTNodeCount="1" docActiveCodeLength="515" docExpressionCount="0" docLength="578" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="1188669313">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\my_sum_parallel_for_reduction.cpp]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"#include <iostream>¬∂#include <omp.h>¬∂¬∂using namespace std;¬∂¬∂//const int SIZE = 1000;¬∂void printSumWithTimes(int sum, int start, int end);¬∂void printNumThreads();¬∂void recordThreadIndex(int index);¬∂void sum_parallel_for_reduction(double* array, int size) {¬∂	cout << "sum_parallel_for_reduction\n";¬∂¬∂	double start = omp_get_wtime();¬∂¬∂	double sum = 0;¬∂    #pragma omp  parallel for reduction ( + : sum )¬∂//	#pragma omp  for¬∂¬∂	for (int i = 0; i < size; i++) {¬∂//		sum += array[i];¬∂¬∂		recordThreadIndex(i);¬∂	}¬∂¬∂	double end = omp_get_wtime();¬∂¬∂	printSumWithTimes(sum, start, end);¬∂¬∂}¬∂")]]]></diff>
  </Command>
  <Command __id="186232" _type="MoveCaretCommand" caretOffset="456" date="Wed Jan 01 00:06:19 EST 2020" docOffset="456" starttimestamp="1576666505112" timestamp="1188673984" />
  <Command __id="186234" _type="EclipseCommand" commandID="org.eclipse.cdt.ui.edit.text.c.toggle.comment" date="Wed Jan 01 00:06:21 EST 2020" starttimestamp="1576666505112" timestamp="1188676278" />
  <Command __id="186235" _type="EclipseCommand" commandID="org.eclipse.ui.file.save" date="Wed Jan 01 00:06:22 EST 2020" starttimestamp="1576666505112" timestamp="1188676933" />
  <DocumentChange __id="186233" _type="Delete" date="Wed Jan 01 00:06:21 EST 2020" docASTNodeCount="1" docActiveCodeLength="533" docExpressionCount="0" docLength="576" endLine="19" length="2" offset="456" startLine="19" starttimestamp="1576666505112" timestamp="1188676237">
    <text><![CDATA[//]]></text>
  </DocumentChange>
  <Command __id="186236" _type="MoveCaretCommand" caretOffset="457" date="Wed Jan 01 00:06:52 EST 2020" docOffset="457" starttimestamp="1576666505112" timestamp="1188707347" />
  <Command __id="186238" _type="EclipseCommand" commandID="org.eclipse.cdt.ui.edit.text.c.toggle.comment" date="Wed Jan 01 00:06:53 EST 2020" starttimestamp="1576666505112" timestamp="1188708555" />
  <Command __id="186239" _type="EclipseCommand" commandID="org.eclipse.ui.file.save" date="Wed Jan 01 00:06:54 EST 2020" starttimestamp="1576666505112" timestamp="1188709611" />
  <DocumentChange __id="186237" _type="Insert" date="Wed Jan 01 00:06:53 EST 2020" docASTNodeCount="1" docActiveCodeLength="515" docExpressionCount="0" docLength="578" length="2" offset="456" starttimestamp="1576666505112" timestamp="1188708488">
    <text><![CDATA[//]]></text>
  </DocumentChange>
  <Command __id="186240" _type="MoveCaretCommand" caretOffset="504" date="Wed Jan 01 00:07:08 EST 2020" docOffset="504" starttimestamp="1576666505112" timestamp="1188722979" />
  <DocumentChange __id="186241" _type="Insert" date="Wed Jan 01 00:07:33 EST 2020" docASTNodeCount="1" docActiveCodeLength="517" docExpressionCount="0" docLength="580" length="2" offset="477" starttimestamp="1576666505112" timestamp="1188748531">
    <text><![CDATA[		]]></text>
  </DocumentChange>
  <Command __id="186242" _type="InsertStringCommand" date="Wed Jan 01 00:07:33 EST 2020" starttimestamp="1576666505112" timestamp="1188748538" timestamp2="1188748538">
    <data><![CDATA[	]]></data>
  </Command>
  <Command __id="186245" _type="RunCommand" date="Wed Jan 01 00:07:56 EST 2020" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="1188771585" type="Run" />
  <Command __id="186246" _type="RunCommand" date="Wed Jan 01 00:07:56 EST 2020" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="1188771585" type="Run" />
  <Command __id="186247" _type="RunCommand" date="Wed Jan 01 00:07:56 EST 2020" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="1188771610" type="Debug" />
  <Command __id="186248" _type="RunCommand" date="Wed Jan 01 00:07:56 EST 2020" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="1188771611" type="Run" />
  <Command __id="186249" _type="RunCommand" date="Wed Jan 01 00:07:56 EST 2020" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="1188771611" type="Debug" />
  <Command __id="186250" _type="RunCommand" date="Wed Jan 01 00:07:56 EST 2020" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="1188771611" type="Run" />
  <Command __id="186251" _type="EHExceptionCommand" date="Wed Jan 01 00:07:57 EST 2020" starttimestamp="1576666505112" timestamp="1188771948" type="Exception">
    <outputString><![CDATA[sum_sequential
Sum: 499500
Took: 0
thread:0 lastIndex:999
_____________________________
sum_parallel_for_reduction
Sum: 0
Took: 0
thread:0 lastIndex:124
thread:1 lastIndex:249
thread:2 lastIndex:374
thread:3 lastIndex:499
thread:4 lastIndex:624
thread:5 lastIndex:749
thread:6 lastIndex:874
thread:7 lastIndex:999
_____________________________
sum_parallel_for_local_var
Sum: 499500
Took: 0
thread:0 lastIndex:124
thread:1 lastIndex:249
thread:2 lastIndex:374
thread:3 lastIndex:499
thread:4 lastIndex:624
thread:5 lastIndex:749
thread:6 lastIndex:874
thread:7 lastIndex:999
_____________________________
sum_parallel
Sum: 499500
Took: 0
_____________________________
]]></outputString>
  </Command>
  <Command __id="186252" _type="MoveCaretCommand" caretOffset="367" date="Wed Jan 01 00:09:45 EST 2020" docOffset="367" starttimestamp="1576666505112" timestamp="1188880787" />
  <Command __id="186253" _type="SelectTextCommand" caretOffset="374" date="Wed Jan 01 00:09:46 EST 2020" end="374" start="366" starttimestamp="1576666505112" timestamp="1188881026" />
  <Command __id="186254" _type="SelectTextCommand" caretOffset="349" date="Wed Jan 01 00:09:46 EST 2020" end="401" start="349" starttimestamp="1576666505112" timestamp="1188881336" />
  <Command __id="186255" _type="CopyCommand" date="Wed Jan 01 00:09:49 EST 2020" starttimestamp="1576666505112" timestamp="1188884545" />
  <DocumentChange __id="186243" _type="Delete" date="Wed Jan 01 00:07:42 EST 2020" docASTNodeCount="1" docActiveCodeLength="515" docExpressionCount="0" docLength="578" endLine="20" length="2" offset="477" startLine="20" starttimestamp="1576666505112" timestamp="1188757654">
    <text><![CDATA[		]]></text>
  </DocumentChange>
  <Command __id="186256" _type="MoveCaretCommand" caretOffset="349" date="Wed Jan 01 00:09:53 EST 2020" docOffset="349" starttimestamp="1576666505112" timestamp="1188888194" />
  <Command __id="186258" _type="EclipseCommand" commandID="org.eclipse.cdt.ui.edit.text.c.toggle.comment" date="Wed Jan 01 00:09:55 EST 2020" starttimestamp="1576666505112" timestamp="1188890308" />
  <Command __id="186259" _type="MoveCaretCommand" caretOffset="364" date="Wed Jan 01 00:09:57 EST 2020" docOffset="364" starttimestamp="1576666505112" timestamp="1188892328" />
  <Command __id="186260" _type="SelectTextCommand" caretOffset="366" date="Wed Jan 01 00:09:57 EST 2020" end="366" start="363" starttimestamp="1576666505112" timestamp="1188892562" />
  <Command __id="186261" _type="SelectTextCommand" caretOffset="403" date="Wed Jan 01 00:09:57 EST 2020" end="403" start="349" starttimestamp="1576666505112" timestamp="1188892851" />
  <Command __id="186262" _type="CopyCommand" date="Wed Jan 01 00:09:58 EST 2020" starttimestamp="1576666505112" timestamp="1188893600" />
  <DocumentChange __id="186257" _type="Insert" date="Wed Jan 01 00:09:55 EST 2020" docASTNodeCount="1" docActiveCodeLength="464" docExpressionCount="0" docLength="580" length="2" offset="349" starttimestamp="1576666505112" timestamp="1188890250">
    <text><![CDATA[//]]></text>
  </DocumentChange>
  <DocumentChange __id="186264" _type="Insert" date="Wed Jan 01 00:10:01 EST 2020" docASTNodeCount="1" docActiveCodeLength="466" docExpressionCount="0" docLength="582" length="2" offset="402" starttimestamp="1576666505112" timestamp="1188896331">
    <text><![CDATA[
	]]></text>
  </DocumentChange>
  <Command __id="186263" _type="MoveCaretCommand" caretOffset="402" date="Wed Jan 01 00:10:00 EST 2020" docOffset="402" starttimestamp="1576666505112" timestamp="1188895674" />
  <Command __id="186265" _type="InsertStringCommand" date="Wed Jan 01 00:10:01 EST 2020" starttimestamp="1576666505112" timestamp="1188896336" timestamp2="1188896336">
    <data><![CDATA[]]></data>
  </Command>
  <Command __id="186267" _type="PasteCommand" date="Wed Jan 01 00:10:02 EST 2020" starttimestamp="1576666505112" timestamp="1188897364" />
  <DocumentChange __id="186266" _type="Replace" date="Wed Jan 01 00:10:02 EST 2020" docASTNodeCount="1" docActiveCodeLength="467" docExpressionCount="0" docLength="636" endLine="16" insertionLength="55" int_docASTNodeCount="1" int_docActiveCodeLength="465" int_docExpressionCount="0" int_docLength="581" length="1" offset="403" startLine="16" starttimestamp="1576666505112" timestamp="1188897343">
    <deletedText><![CDATA[	]]></deletedText>
    <insertedText><![CDATA[	//    #pragma omp  parallel for reduction ( + : sum )
]]></insertedText>
  </DocumentChange>
  <DocumentChange __id="186269" _type="Delete" date="Wed Jan 01 00:10:04 EST 2020" docASTNodeCount="1" docActiveCodeLength="467" docExpressionCount="0" docLength="635" endLine="16" length="1" offset="406" startLine="16" starttimestamp="1576666505112" timestamp="1188899856">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="186271" _type="Delete" date="Wed Jan 01 00:10:05 EST 2020" docASTNodeCount="1" docActiveCodeLength="518" docExpressionCount="0" docLength="634" endLine="16" length="1" offset="405" startLine="16" starttimestamp="1576666505112" timestamp="1188900015">
    <text><![CDATA[/]]></text>
  </DocumentChange>
  <DocumentChange __id="186273" _type="Delete" date="Wed Jan 01 00:10:05 EST 2020" docASTNodeCount="1" docActiveCodeLength="517" docExpressionCount="0" docLength="633" endLine="16" length="1" offset="404" startLine="16" starttimestamp="1576666505112" timestamp="1188900166">
    <text><![CDATA[/]]></text>
  </DocumentChange>
  <DocumentChange __id="186275" _type="Delete" date="Wed Jan 01 00:10:07 EST 2020" docASTNodeCount="1" docActiveCodeLength="516" docExpressionCount="0" docLength="632" endLine="16" length="1" offset="403" startLine="16" starttimestamp="1576666505112" timestamp="1188902344">
    <text><![CDATA[	]]></text>
  </DocumentChange>
  <Command __id="186268" _type="MoveCaretCommand" caretOffset="407" date="Wed Jan 01 00:10:04 EST 2020" docOffset="407" starttimestamp="1576666505112" timestamp="1188899487" />
  <Command __id="186270" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Wed Jan 01 00:10:04 EST 2020" starttimestamp="1576666505112" timestamp="1188899861" />
  <Command __id="186272" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Wed Jan 01 00:10:05 EST 2020" starttimestamp="1576666505112" timestamp="1188900020" />
  <Command __id="186274" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Wed Jan 01 00:10:05 EST 2020" starttimestamp="1576666505112" timestamp="1188900177" />
  <Command __id="186276" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Wed Jan 01 00:10:07 EST 2020" starttimestamp="1576666505112" timestamp="1188902346" />
  <Command __id="186278" _type="InsertStringCommand" date="Wed Jan 01 00:10:08 EST 2020" starttimestamp="1576666505112" timestamp="1188903555" timestamp2="1188903555">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="186279" _type="MoveCaretCommand" caretOffset="421" date="Wed Jan 01 00:10:13 EST 2020" docOffset="421" starttimestamp="1576666505112" timestamp="1188907974" />
  <Command __id="186280" _type="SelectTextCommand" caretOffset="428" date="Wed Jan 01 00:10:13 EST 2020" end="428" start="420" starttimestamp="1576666505112" timestamp="1188908251" />
  <Command __id="186282" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Wed Jan 01 00:10:13 EST 2020" starttimestamp="1576666505112" timestamp="1188908779" />
  <Command __id="186284" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Wed Jan 01 00:10:14 EST 2020" starttimestamp="1576666505112" timestamp="1188909166" />
  <Command __id="186285" _type="EclipseCommand" commandID="org.eclipse.ui.file.save" date="Wed Jan 01 00:10:16 EST 2020" starttimestamp="1576666505112" timestamp="1188911107" />
  <Command __id="186286" _type="ShellCommand" date="Wed Jan 01 00:10:25 EST 2020" starttimestamp="1576666505112" timestamp="1188919951" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="186287" _type="ShellCommand" date="Wed Jan 01 00:10:26 EST 2020" starttimestamp="1576666505112" timestamp="1188921836" type="ECLIPSE_GAINED_FOCUS" />
  <DocumentChange __id="186277" _type="Insert" date="Wed Jan 01 00:10:08 EST 2020" docASTNodeCount="1" docActiveCodeLength="517" docExpressionCount="0" docLength="633" length="1" offset="403" starttimestamp="1576666505112" timestamp="1188903549">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="186281" _type="Delete" date="Wed Jan 01 00:10:13 EST 2020" docASTNodeCount="1" docActiveCodeLength="509" docExpressionCount="0" docLength="625" endLine="16" length="8" offset="420" startLine="16" starttimestamp="1576666505112" timestamp="1188908776">
    <text><![CDATA[parallel]]></text>
  </DocumentChange>
  <DocumentChange __id="186283" _type="Delete" date="Wed Jan 01 00:10:14 EST 2020" docASTNodeCount="1" docActiveCodeLength="508" docExpressionCount="0" docLength="624" endLine="16" length="1" offset="419" startLine="16" starttimestamp="1576666505112" timestamp="1188909158">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <Command __id="186288" _type="MoveCaretCommand" caretOffset="403" date="Wed Jan 01 00:10:35 EST 2020" docOffset="403" starttimestamp="1576666505112" timestamp="1188930394" />
  <Command __id="186290" _type="EclipseCommand" commandID="org.eclipse.cdt.ui.edit.text.c.toggle.comment" date="Wed Jan 01 00:10:36 EST 2020" starttimestamp="1576666505112" timestamp="1188931631" />
  <Command __id="186291" _type="MoveCaretCommand" caretOffset="349" date="Wed Jan 01 00:10:39 EST 2020" docOffset="349" starttimestamp="1576666505112" timestamp="1188934556" />
  <Command __id="186293" _type="EclipseCommand" commandID="org.eclipse.cdt.ui.edit.text.c.toggle.comment" date="Wed Jan 01 00:10:40 EST 2020" starttimestamp="1576666505112" timestamp="1188935604" />
  <Command __id="186294" _type="EclipseCommand" commandID="org.eclipse.ui.file.save" date="Wed Jan 01 00:10:41 EST 2020" starttimestamp="1576666505112" timestamp="1188936648" />
  <Command __id="186295" _type="MoveCaretCommand" caretOffset="502" date="Wed Jan 01 00:10:51 EST 2020" docOffset="502" starttimestamp="1576666505112" timestamp="1188946149" />
  <Command __id="186297" _type="EclipseCommand" commandID="org.eclipse.cdt.ui.edit.text.c.toggle.comment" date="Wed Jan 01 00:10:52 EST 2020" starttimestamp="1576666505112" timestamp="1188947146" />
  <Command __id="186298" _type="EclipseCommand" commandID="org.eclipse.ui.file.save" date="Wed Jan 01 00:10:53 EST 2020" starttimestamp="1576666505112" timestamp="1188948235" />
  <Command __id="186299" _type="ShellCommand" date="Wed Jan 01 00:11:13 EST 2020" starttimestamp="1576666505112" timestamp="1188968158" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="186300" _type="ShellCommand" date="Wed Jan 01 00:11:16 EST 2020" starttimestamp="1576666505112" timestamp="1188971577" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="186301" _type="ShellCommand" date="Wed Jan 01 00:11:20 EST 2020" starttimestamp="1576666505112" timestamp="1188974990" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="187858" _type="DiffBasedFileOpenCommand" date="Wed Jan 01 00:45:06 EST 2020" docASTNodeCount="447" docActiveCodeLength="3342" docExpressionCount="346" docLength="6093" projectName="DemoCourseLocalBasicChecks" starttimestamp="1576666505112" timestamp="1191001432">
    <filePath><![CDATA[D:\dewan_backup\Java\DemoCourseLocalBasicChecks\src\gradingTools\comp123\assignment1\openmp\testcases\SequentialSumTestCase.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package gradingTools.comp123.assignment1.openmp.testcases;¬∂¬∂import java.util.Arrays;¬∂import java.util.List;¬∂import java.util.Map;¬∂import java.util.Set;¬∂import java.util.regex.Pattern;¬∂¬∂import grader.basics.execution.NotRunnableException;¬∂import grader.basics.execution.RunningProject;¬∂import grader.basics.junit.NotAutomatableException;¬∂import grader.basics.junit.TestCaseResult;¬∂import grader.basics.project.NotGradableException;¬∂import grader.basics.project.Project;¬∂import grader.basics.project.source.ABasicTextManager;¬∂import grader.basics.testcase.PassFailJUnitTestCase;¬∂import gradingTools.shared.testcases.SubstringSequenceChecker;¬∂import gradingTools.shared.testcases.openmp.OpenMPPragma;¬∂import gradingTools.shared.testcases.openmp.OpenMPUtils;¬∂import gradingTools.shared.testcases.openmp.scannedTree.AssignmentSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.ExternalMethodSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.MethodSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.OMPParallelSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.OMPSNodeUtils;¬∂import gradingTools.shared.testcases.openmp.scannedTree.RootOfFileSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.RootOfProgramSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.SNode;¬∂import gradingTools.shared.testcases.utils.LinesMatchKind;¬∂import gradingTools.shared.testcases.utils.LinesMatcher;¬∂import gradingTools.utils.RunningProjectUtils;¬∂¬∂public class SequentialSumTestCase extends PassFailJUnitTestCase {¬∂	public static final int TIME_OUT_SECS = 1; // secs¬∂	protected SubstringSequenceChecker checker = new ASequentialSumChecker();	¬∂¬∂	public SequentialSumTestCase() {¬∂	}¬∂¬∂	¬∂¬∂	@Override¬∂	public TestCaseResult test(Project project, boolean autoGrade) throws NotAutomatableException,¬∂			NotGradableException {¬∂		try {¬∂			RunningProject aRunningProject = RunningProjectUtils.runProject(project, TIME_OUT_SECS);¬∂			String anOutput = aRunningProject.await();¬∂			LinesMatcher aLinesMatcher = aRunningProject.getLinesMatcher();¬∂			boolean aRetval = checker.check(aLinesMatcher, LinesMatchKind.ONE_TIME_LINE, Pattern.DOTALL);¬∂			String aSource = project.getSource();¬∂//			Map<String, StringBuffer> aFileNameToContents = ABasicTextManager.extractFileContents(aSource);¬∂//			for (String aFileName:aFileNameToContents.keySet()) {¬∂//				StringBuffer aFileContents = aFileNameToContents.get(aFileName);¬∂////				List<OpenMPPragma> anOpenMPPragmas = OpenMPUtils.getOpemMPPragmas(aFileContents);¬∂//				SNode anSNode = OMPSNodeUtils.getSNode(aFileName, aFileContents);¬∂//				System.out.println("file name:" + aFileName);¬∂//				System.out.println("pragmas:" + anSNode);¬∂//			}¬∂			RootOfProgramSNode aRootOfProgramSNode = OMPSNodeUtils.getRootOfProgramSNode(aSource);¬∂			Set<AssignmentSNode> anAssignments = OMPSNodeUtils.assignmentsToSharedVariables(aRootOfProgramSNode);¬∂			anAssignments = OMPSNodeUtils.assignmentsToSharedArrays(aRootOfProgramSNode);¬∂			anAssignments = OMPSNodeUtils.assignmentsToParallelCriticalSharedVariables(aRootOfProgramSNode);¬∂			anAssignments = OMPSNodeUtils.assignmentsToNonParallelCriticalSharedVariables(aRootOfProgramSNode);¬∂			anAssignments = OMPSNodeUtils.assignmentsToParallelNonCriticalSharedVariables(aRootOfProgramSNode);¬∂			Set<OMPParallelSNode> anOMPParallelSNodes = OMPSNodeUtils.ompParallelSNodes(aRootOfProgramSNode);¬∂			¬∂¬∂¬∂			String anExpectedLines = Arrays.toString(checker.getSubstrings());¬∂¬∂			if (!aRetval) {¬∂				return fail("Output  did not match:" + anExpectedLines);¬∂¬∂			}¬∂			return pass();¬∂			¬∂¬∂		} catch (NotRunnableException e) {¬∂			throw new NotGradableException();¬∂		}¬∂	}¬∂//	public static void processExternalMethodSNodes (RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode) {¬∂//		for (SNode anSNode:aRootOfFileSNode.getChildren()) {¬∂//			if (anSNode instanceof ExternalMethodSNode) {¬∂//				processExternalMethodSNode(aRootOfProgramSNode, aRootOfFileSNode, (ExternalMethodSNode) anSNode);¬∂//			}¬∂//		}¬∂//	}¬∂//	public static void processExternalMethodSNode (RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode, ExternalMethodSNode anExternalMethodSNode) {¬∂//		MethodSNode aMethodSNode = aRootOfProgramSNode.getExternalToInternalMethod().get(anExternalMethodSNode.toString());¬∂//		if (aMethodSNode == null) {¬∂//			aMethodSNode = findMethodSNode(aRootOfProgramSNode, aRootOfFileSNode, anExternalMethodSNode);¬∂//			if (aMethodSNode != null) {¬∂//				aRootOfProgramSNode.getExternalToInternalMethod().put(anExternalMethodSNode.toString(),aMethodSNode );¬∂//			}¬∂//		}¬∂//		if (aMethodSNode != null) {¬∂//			anExternalMethodSNode.setActualMethodSNode(aMethodSNode);¬∂//		}¬∂//	}¬∂//	public static MethodSNode findMethodSNode (RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode, ExternalMethodSNode anExternalMethodSNode) {¬∂////		MethodSNode foundMethodSNode = null;¬∂//		for (String aFileName:aRootOfProgramSNode.getFileNameToSNode().keySet()) {¬∂//			if (aFileName.equals(aRootOfFileSNode.getFileName()))¬∂//				continue;¬∂//			¬∂//			RootOfFileSNode aSearchedRootOfFileSNode = aRootOfProgramSNode.getFileNameToSNode().get(aFileName);¬∂//			 for (SNode anSNode:aSearchedRootOfFileSNode.getChildren()) {¬∂//				if (anSNode instanceof MethodSNode && !(anSNode instanceof ExternalMethodSNode)) {¬∂//					if (anSNode.toString().equals(anExternalMethodSNode)) {¬∂//						return (MethodSNode) anSNode;¬∂//						¬∂//					}¬∂////					processExternalMethodSNode(aRootOfProgramSNode, aRootOfFileSNode, (ExternalMethodSNode) anSNode);¬∂//				}¬∂//			}¬∂//		}¬∂//		return null;¬∂//	}¬∂//	public static void processExternalMethodSNodes (RootOfProgramSNode aRootOfProgramSNode) {¬∂//		for (String aFileName:aRootOfProgramSNode.getFileNameToSNode().keySet()) {¬∂//			RootOfFileSNode aRootOfFileSNode = aRootOfProgramSNode.getFileNameToSNode().get(aFileName);¬∂//			processExternalMethodSNodes(aRootOfProgramSNode, aRootOfFileSNode);¬∂//			¬∂//		}¬∂//¬∂//	}¬∂}¬∂")]]]></diff>
  </Command>
  <Command __id="187859" _type="MoveCaretCommand" caretOffset="3472" date="Wed Jan 01 00:45:06 EST 2020" docOffset="3472" starttimestamp="1576666505112" timestamp="1191001506" />
  <Command __id="187860" _type="DiffBasedFileOpenCommand" date="Wed Jan 01 00:45:27 EST 2020" docASTNodeCount="1" docActiveCodeLength="453" docExpressionCount="0" docLength="453" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="1191022515">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\my_sum_sequential.cpp]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"#include <iostream>¬∂#include <omp.h>¬∂¬∂using namespace std;¬∂void printSumWithTimes(int sum, int start, int end);¬∂void printNumThreads();¬∂void recordThreadIndex(int index);¬∂void sum_sequential(double* array, int size) {¬∂¬∂	cout << "sum_sequential\n";¬∂¬∂	double start = omp_get_wtime();¬∂¬∂	double sum = 0;¬∂¬∂	for (int i = 0; i < size; i++) {¬∂		sum += array[i];¬∂		recordThreadIndex(i);¬∂	}¬∂¬∂	double end = omp_get_wtime();¬∂¬∂	printSumWithTimes(sum, start, end);¬∂}¬∂")]]]></diff>
  </Command>
  <Command __id="187861" _type="SelectTextCommand" caretOffset="280" date="Wed Jan 01 00:45:27 EST 2020" end="280" start="265" starttimestamp="1576666505112" timestamp="1191022727" />
  <Command __id="187862" _type="DiffBasedFileOpenCommand" date="Wed Jan 01 00:45:29 EST 2020" docASTNodeCount="1" docActiveCodeLength="535" docExpressionCount="0" docLength="622" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="1191024677">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\my_sum_parallel_for_reduction.cpp]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"#include <iostream>¬∂#include <omp.h>¬∂¬∂using namespace std;¬∂¬∂//const int SIZE = 1000;¬∂void printSumWithTimes(int sum, int start, int end);¬∂void printNumThreads();¬∂void recordThreadIndex(int index);¬∂void sum_parallel_for_reduction(double* array, int size) {¬∂	cout << "sum_parallel_for_reduction\n";¬∂¬∂	double start = omp_get_wtime();¬∂¬∂	double sum = 0;¬∂    #pragma omp  parallel for reduction ( + : sum )¬∂"), Diff(INSERT,"//    #pragma omp  for reduction ( + : sum )¬∂¬∂"), Diff(EQUAL,"//	#pragma omp  for¬∂¬∂	for (int i = 0; i < size; i++) {¬∂"), Diff(DELETE,"//"), Diff(EQUAL,"		sum += array[i];¬∂¬∂		recordThreadIndex(i);¬∂	}¬∂¬∂	double end = omp_get_wtime();¬∂¬∂	printSumWithTimes(sum, start, end);¬∂¬∂}¬∂")]]]></diff>
    <snapshot><![CDATA[#include <iostream>
#include <omp.h>

using namespace std;

//const int SIZE = 1000;
void printSumWithTimes(int sum, int start, int end);
void printNumThreads();
void recordThreadIndex(int index);
void sum_parallel_for_reduction(double* array, int size) {
	cout << "sum_parallel_for_reduction\n";

	double start = omp_get_wtime();

	double sum = 0;
    #pragma omp  parallel for reduction ( + : sum )
//    #pragma omp  for reduction ( + : sum )

//	#pragma omp  for

	for (int i = 0; i < size; i++) {
		sum += array[i];

		recordThreadIndex(i);
	}

	double end = omp_get_wtime();

	printSumWithTimes(sum, start, end);

}
]]></snapshot>
  </Command>
  <Command __id="187863" _type="MoveCaretCommand" caretOffset="502" date="Wed Jan 01 00:45:29 EST 2020" docOffset="502" starttimestamp="1576666505112" timestamp="1191024886" />
  <Command __id="188046" _type="ShellCommand" date="Wed Jan 01 00:50:52 EST 2020" starttimestamp="1576666505112" timestamp="1191347124" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="188048" _type="MoveCaretCommand" caretOffset="502" date="Wed Jan 01 00:50:52 EST 2020" docOffset="502" starttimestamp="1576666505112" timestamp="1191347610" />
  <Command __id="188049" _type="EclipseCommand" commandID="" date="Wed Jan 01 00:50:53 EST 2020" starttimestamp="1576666505112" timestamp="1191348342" />
  <Command __id="188050" _type="EclipseCommand" commandID="" date="Wed Jan 01 00:50:53 EST 2020" starttimestamp="1576666505112" timestamp="1191348552" />
  <DocumentChange __id="188028" _type="Insert" date="Wed Jan 01 00:48:42 EST 2020" docASTNodeCount="4270" docActiveCodeLength="30320" docExpressionCount="2667" docLength="34506" length="1" offset="26563" starttimestamp="1576666505112" timestamp="1191217397">
    <text><![CDATA[o]]></text>
  </DocumentChange>
  <DocumentChange __id="188035" _type="Replace" date="Wed Jan 01 00:48:47 EST 2020" docASTNodeCount="4270" docActiveCodeLength="30312" docExpressionCount="2667" docLength="34498" endLine="743" insertionLength="18" int_docASTNodeCount="4268" int_docActiveCodeLength="30294" int_docExpressionCount="2665" int_docLength="34480" length="26" offset="26639" startLine="743" starttimestamp="1576666505112" timestamp="1191222561">
    <deletedText><![CDATA[    	fillOMPParallelSNodes]]></deletedText>
    <insertedText><![CDATA[    	fillForSNodes]]></insertedText>
  </DocumentChange>
  <Command __id="188047" _type="DiffBasedFileOpenCommand" date="Wed Jan 01 00:50:52 EST 2020" docASTNodeCount="1" docActiveCodeLength="535" docExpressionCount="0" docLength="622" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="1191347404">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\my_sum_parallel_for_reduction.cpp]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"#include <iostream>¬∂#include <omp.h>¬∂¬∂using namespace std;¬∂¬∂//const int SIZE = 1000;¬∂void printSumWithTimes(int sum, int start, int end);¬∂void printNumThreads();¬∂void recordThreadIndex(int index);¬∂void sum_parallel_for_reduction(double* array, int size) {¬∂	cout << "sum_parallel_for_reduction\n";¬∂¬∂	double start = omp_get_wtime();¬∂¬∂	double sum = 0;¬∂    #pragma omp  parallel for reduction ( + : sum )¬∂//    #pragma omp  for reduction ( + : sum )¬∂¬∂//	#pragma omp  for¬∂¬∂	for (int i = 0; i < size; i++) {¬∂		sum += array[i];¬∂¬∂		recordThreadIndex(i);¬∂	}¬∂¬∂	double end = omp_get_wtime();¬∂¬∂	printSumWithTimes(sum, start, end);¬∂¬∂}¬∂")]]]></diff>
  </Command>
  <Command __id="188051" _type="MoveCaretCommand" caretOffset="349" date="Wed Jan 01 00:50:56 EST 2020" docOffset="349" starttimestamp="1576666505112" timestamp="1191351613" />
  <Command __id="188053" _type="EclipseCommand" commandID="org.eclipse.cdt.ui.edit.text.c.toggle.comment" date="Wed Jan 01 00:50:58 EST 2020" starttimestamp="1576666505112" timestamp="1191352932" />
  <Command __id="188054" _type="MoveCaretCommand" caretOffset="449" date="Wed Jan 01 00:51:01 EST 2020" docOffset="449" starttimestamp="1576666505112" timestamp="1191356139" />
  <Command __id="188056" _type="EclipseCommand" commandID="org.eclipse.cdt.ui.edit.text.c.toggle.comment" date="Wed Jan 01 00:51:02 EST 2020" starttimestamp="1576666505112" timestamp="1191357162" />
  <Command __id="188058" _type="RunCommand" date="Wed Jan 01 00:51:17 EST 2020" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="1191372380" type="Run" />
  <Command __id="188059" _type="RunCommand" date="Wed Jan 01 00:51:17 EST 2020" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="1191372380" type="Run" />
  <Command __id="188060" _type="RunCommand" date="Wed Jan 01 00:51:17 EST 2020" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="1191372402" type="Debug" />
  <Command __id="188061" _type="RunCommand" date="Wed Jan 01 00:51:17 EST 2020" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="1191372402" type="Run" />
  <Command __id="188062" _type="RunCommand" date="Wed Jan 01 00:51:17 EST 2020" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="1191372402" type="Debug" />
  <Command __id="188063" _type="RunCommand" date="Wed Jan 01 00:51:17 EST 2020" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="1191372403" type="Run" />
  <Command __id="188064" _type="EHExceptionCommand" date="Wed Jan 01 00:51:17 EST 2020" starttimestamp="1576666505112" timestamp="1191372704" type="Exception">
    <outputString><![CDATA[sum_sequential
Sum: 499500
Took: 0
thread:0 lastIndex:999
_____________________________
sum_parallel_for_reduction
Sum: 499500
Took: 0
thread:0 lastIndex:999
_____________________________
sum_parallel_for_local_var
Sum: 499500
Took: 0
thread:0 lastIndex:124
thread:1 lastIndex:249
thread:2 lastIndex:374
thread:3 lastIndex:499
thread:4 lastIndex:624
thread:5 lastIndex:749
thread:6 lastIndex:874
thread:7 lastIndex:999
_____________________________
sum_parallel
Sum: 499500
Took: 0
_____________________________
]]></outputString>
  </Command>
  <Command __id="188065" _type="ShellCommand" date="Wed Jan 01 00:51:30 EST 2020" starttimestamp="1576666505112" timestamp="1191385175" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="188066" _type="ShellCommand" date="Wed Jan 01 00:51:30 EST 2020" starttimestamp="1576666505112" timestamp="1191385341" type="ECLIPSE_GAINED_FOCUS" />
  <DocumentChange __id="188052" _type="Insert" date="Wed Jan 01 00:50:57 EST 2020" docASTNodeCount="1" docActiveCodeLength="484" docExpressionCount="0" docLength="624" length="2" offset="349" starttimestamp="1576666505112" timestamp="1191352887">
    <text><![CDATA[//]]></text>
  </DocumentChange>
  <DocumentChange __id="188055" _type="Delete" date="Wed Jan 01 00:51:02 EST 2020" docASTNodeCount="1" docActiveCodeLength="501" docExpressionCount="0" docLength="622" endLine="18" length="2" offset="449" startLine="18" starttimestamp="1576666505112" timestamp="1191357115">
    <text><![CDATA[//]]></text>
  </DocumentChange>
  <Command __id="188067" _type="MoveCaretCommand" caretOffset="449" date="Wed Jan 01 00:51:44 EST 2020" docOffset="449" starttimestamp="1576666505112" timestamp="1191399718" />
  <Command __id="188069" _type="EclipseCommand" commandID="org.eclipse.cdt.ui.edit.text.c.toggle.comment" date="Wed Jan 01 00:51:47 EST 2020" starttimestamp="1576666505112" timestamp="1191401963" />
  <DocumentChange __id="188564" _type="Insert" date="Wed Jan 01 01:04:33 EST 2020" docASTNodeCount="483" docActiveCodeLength="3577" docExpressionCount="371" docLength="6328" length="1" offset="3661" starttimestamp="1576666505112" timestamp="1192168408">
    <text><![CDATA[F]]></text>
  </DocumentChange>
  <DocumentChange __id="188578" _type="Insert" date="Wed Jan 01 01:04:42 EST 2020" docASTNodeCount="495" docActiveCodeLength="3645" docExpressionCount="382" docLength="6396" length="68" offset="1061" starttimestamp="1576666505112" timestamp="1192177659">
    <text><![CDATA[import gradingTools.shared.testcases.openmp.scannedTree.OMPForSNode;]]></text>
  </DocumentChange>
  <DocumentChange __id="188579" _type="Insert" date="Wed Jan 01 01:04:42 EST 2020" docASTNodeCount="495" docActiveCodeLength="3647" docExpressionCount="382" docLength="6398" length="2" offset="1061" starttimestamp="1576666505112" timestamp="1192177659">
    <text><![CDATA[
]]></text>
  </DocumentChange>
  <Command __id="188589" _type="RunCommand" date="Wed Jan 01 01:04:59 EST 2020" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="1192194477" type="Run" />
  <Command __id="188590" _type="RunCommand" date="Wed Jan 01 01:04:59 EST 2020" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="1192194478" type="Run" />
  <Command __id="188591" _type="RunCommand" date="Wed Jan 01 01:04:59 EST 2020" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="1192194869" type="Run" />
  <Command __id="188614" _type="RunCommand" date="Wed Jan 01 01:05:26 EST 2020" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="1192221375" type="Run" />
  <Command __id="188615" _type="EHExceptionCommand" date="Wed Jan 01 01:05:26 EST 2020" starttimestamp="1576666505112" timestamp="1192221412" type="Exception">
    <outputString><![CDATA[I***(TestCaseResult) ### SequentialSumTestCase: 1.0
Returning first of multiple entry points:[MyOpenMPTraining.exe, OpenMPTraining.exe]
I***(BasicProcessRunner) Running command:D:\dewan_backup\C\MyOpenMPTraining\Debug\MyOpenMPTraining.exe
I***(BasicProcessRunner) Running in folder: D:\dewan_backup\C\MyOpenMPTraining\Debug
I***(BasicProcessRunner)  Process started: D:\dewan_backup\C\MyOpenMPTraining\Debug\MyOpenMPTraining.exe folder: D:\dewan_backup\C\MyOpenMPTraining\Debug entry point: null class path: D:\dewan_backup\Java\PLTeaching\PL_Java\bin;D:\dewan_backup\Java\lib\oeall22.jar;C:\Users\dewan\.p2\pool\plugins\org.junit_4.12.0.v201504281640\junit.jar;C:\Users\dewan\.p2\pool\plugins\org.hamcrest.core_1.3.0.v20180420-1519.jar;D:\dewan_backup\Java\GraderBasics\lib\commons-configuration-1.9.jar;D:\dewan_backup\Java\GraderBasics\lib\commons-lang-2.6.jar;D:\dewan_backup\Java\GraderBasics\lib\commons-logging-1.1.1.jar;G:\My Drive\Java\lib\Herrmes\lib\weka3_6.jar;D:\dewan_backup\Java\GraderBasics\target\classes;D:\dewan_backup\Java\DemoCourseLocalBasicChecks\bin
]]></outputString>
  </Command>
  <Command __id="188616" _type="RunCommand" date="Wed Jan 01 01:05:26 EST 2020" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="1192221415" type="Run" />
  <Command __id="188617" _type="RunCommand" date="Wed Jan 01 01:05:26 EST 2020" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="1192221418" type="Run" />
  <Command __id="188618" _type="EHExceptionCommand" date="Wed Jan 01 01:05:26 EST 2020" starttimestamp="1576666505112" timestamp="1192221473" type="Exception">
    <outputString><![CDATA[I***(ARunnerInputStreamProcessor) Provided Input:
I***(BasicRunningProject) 1577858726534:Received output from main: sum_sequential
I***(BasicRunningProject) 1577858726535:Processing line from main: sum_sequential
I***(BasicRunningProject) 1577858726535:Received output from main: Sum: 499500
I***(BasicRunningProject) 1577858726535:Processing line from main: Sum: 499500
I***(BasicRunningProject) 1577858726535:Received output from main: Took: 0
I***(BasicRunningProject) 1577858726535:Processing line from main: Took: 0
I***(BasicRunningProject) 1577858726536:Received output from main: thread:0 lastIndex:999
I***(BasicRunningProject) 1577858726536:Processing line from main: thread:0 lastIndex:999
I***(BasicRunningProject) 1577858726536:Received output from main: _____________________________
I***(BasicRunningProject) 1577858726536:Processing line from main: _____________________________
I***(BasicRunningProject) 1577858726536:Received output from main: sum_parallel_for_reduction
I***(BasicRunningProject) 1577858726536:Processing line from main: sum_parallel_for_reduction
I***(BasicRunningProject) 1577858726536:Received output from main: Sum: 499500
I***(BasicRunningProject) 1577858726536:Processing line from main: Sum: 499500
I***(BasicRunningProject) 1577858726537:Received output from main: Took: 0
I***(BasicRunningProject) 1577858726537:Processing line from main: Took: 0
I***(BasicRunningProject) 1577858726537:Received output from main: thread:0 lastIndex:999
I***(BasicRunningProject) 1577858726537:Processing line from main: thread:0 lastIndex:999
I***(BasicRunningProject) 1577858726537:Received output from main: _____________________________
I***(BasicRunningProject) 1577858726537:Processing line from main: _____________________________
I***(BasicRunningProject) 1577858726538:Received output from main: sum_parallel_for_local_var
I***(BasicRunningProject) 1577858726538:Processing line from main: sum_parallel_for_local_var
I***(BasicRunningProject) 1577858726538:Received output from main: Sum: 499500
I***(BasicRunningProject) 1577858726538:Processing line from main: Sum: 499500
I***(BasicRunningProject) 1577858726538:Received output from main: Took: 0
I***(BasicRunningProject) 1577858726538:Processing line from main: Took: 0
I***(BasicRunningProject) 1577858726538:Received output from main: thread:0 lastIndex:124
I***(BasicRunningProject) 1577858726538:Processing line from main: thread:0 lastIndex:124
I***(BasicRunningProject) 1577858726538:Received output from main: thread:1 lastIndex:249
I***(BasicRunningProject) 1577858726538:Processing line from main: thread:1 lastIndex:249
I***(BasicRunningProject) 1577858726539:Received output from main: thread:2 lastIndex:374
I***(BasicRunningProject) 1577858726539:Processing line from main: thread:2 lastIndex:374
I***(BasicRunningProject) 1577858726539:Received output from main: thread:3 lastIndex:499
I***(BasicRunningProject) 1577858726539:Processing line from main: thread:3 lastIndex:499
I***(BasicRunningProject) 1577858726539:Received output from main: thread:4 lastIndex:624
I***(BasicRunningProject) 1577858726539:Processing line from main: thread:4 lastIndex:624
I***(BasicRunningProject) 1577858726539:Received output from main: thread:5 lastIndex:749
I***(BasicRunningProject) 1577858726539:Processing line from main: thread:5 lastIndex:749
I***(BasicProcessRunner)  Process finished; folder: D:\dewan_backup\C\MyOpenMPTraining\Debug entry point: null class path: D:\dewan_backup\Java\PLTeaching\PL_Java\bin;D:\dewan_backup\Java\lib\oeall22.jar;C:\Users\dewan\.p2\pool\plugins\org.junit_4.12.0.v201504281640\junit.jar;C:\Users\dewan\.p2\pool\plugins\org.hamcrest.core_1.3.0.v20180420-1519.jar;D:\dewan_backup\Java\GraderBasics\lib\commons-configuration-1.9.jar;D:\dewan_backup\Java\GraderBasics\lib\commons-lang-2.6.jar;D:\dewan_backup\Java\GraderBasics\lib\commons-logging-1.1.1.jar;G:\My Drive\Java\lib\Herrmes\lib\weka3_6.jar;D:\dewan_backup\Java\GraderBasics\target\classes;D:\dewan_backup\Java\DemoCourseLocalBasicChecks\bin
I***(BasicRunningProject) 1577858726539:Received output from main: thread:6 lastIndex:874
I***(BasicRunningProject) 1577858726540:Processing line from main: thread:6 lastIndex:874
I***(BasicRunningProject) 1577858726540:Received output from main: thread:7 lastIndex:999
I***(BasicRunningProject) 1577858726540:Processing line from main: thread:7 lastIndex:999
I***(BasicRunningProject) 1577858726540:Received output from main: _____________________________
I***(BasicRunningProject) 1577858726540:Processing line from main: _____________________________
I***(BasicRunningProject) 1577858726540:Received output from main: sum_parallel
I***(BasicRunningProject) 1577858726540:Processing line from main: sum_parallel
I***(BasicRunningProject) 1577858726540:Received output from main: Sum: 499500
I***(BasicRunningProject) 1577858726541:Processing line from main: Sum: 499500
I***(BasicRunningProject) 1577858726541:Received output from main: Took: 0
I***(BasicRunningProject) 1577858726541:Processing line from main: Took: 0
I***(BasicRunningProject) 1577858726541:Received output from main: _____________________________
I***(BasicRunningProject) 1577858726541:Processing line from main: _____________________________
I***(BasicRunningProject) Thread[AWT-EventQueue-0,6,main] sleeping for ms:2000 waiting for pending output from threads 
]]></outputString>
  </Command>
  <Command __id="188685" _type="DiffBasedFileOpenCommand" date="Wed Jan 01 01:07:20 EST 2020" docASTNodeCount="495" docActiveCodeLength="3647" docExpressionCount="382" docLength="6398" projectName="DemoCourseLocalBasicChecks" starttimestamp="1576666505112" timestamp="1192335674">
    <filePath><![CDATA[D:\dewan_backup\Java\DemoCourseLocalBasicChecks\src\gradingTools\comp123\assignment1\openmp\testcases\SequentialSumTestCase.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package gradingTools.comp123.assignment1.openmp.testcases;¬∂¬∂import java.util.Arrays;¬∂import java.util.List;¬∂import java.util.Map;¬∂import java.util.Set;¬∂import java.util.regex.Pattern;¬∂¬∂import grader.basics.execution.NotRunnableException;¬∂import grader.basics.execution.RunningProject;¬∂import grader.basics.junit.NotAutomatableException;¬∂import grader.basics.junit.TestCaseResult;¬∂import grader.basics.project.NotGradableException;¬∂import grader.basics.project.Project;¬∂import grader.basics.project.source.ABasicTextManager;¬∂import grader.basics.testcase.PassFailJUnitTestCase;¬∂import gradingTools.shared.testcases.SubstringSequenceChecker;¬∂import gradingTools.shared.testcases.openmp.OpenMPPragma;¬∂import gradingTools.shared.testcases.openmp.OpenMPUtils;¬∂import gradingTools.shared.testcases.openmp.scannedTree.AssignmentSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.ExternalMethodSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.ForSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.MethodSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.OMPForSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.OMPParallelSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.OMPSNodeUtils;¬∂import gradingTools.shared.testcases.openmp.scannedTree.RootOfFileSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.RootOfProgramSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.SNode;¬∂import gradingTools.shared.testcases.utils.LinesMatchKind;¬∂import gradingTools.shared.testcases.utils.LinesMatcher;¬∂import gradingTools.utils.RunningProjectUtils;¬∂¬∂public class SequentialSumTestCase extends PassFailJUnitTestCase {¬∂	public static final int TIME_OUT_SECS = 1; // secs¬∂	protected SubstringSequenceChecker checker = new ASequentialSumChecker();	¬∂¬∂	public SequentialSumTestCase() {¬∂	}¬∂¬∂	¬∂¬∂	@Override¬∂	public TestCaseResult test(Project project, boolean autoGrade) throws NotAutomatableException,¬∂			NotGradableException {¬∂		try {¬∂			RunningProject aRunningProject = RunningProjectUtils.runProject(project, TIME_OUT_SECS);¬∂			String anOutput = aRunningProject.await();¬∂			LinesMatcher aLinesMatcher = aRunningProject.getLinesMatcher();¬∂			boolean aRetval = checker.check(aLinesMatcher, LinesMatchKind.ONE_TIME_LINE, Pattern.DOTALL);¬∂			String aSource = project.getSource();¬∂//			Map<String, StringBuffer> aFileNameToContents = ABasicTextManager.extractFileContents(aSource);¬∂//			for (String aFileName:aFileNameToContents.keySet()) {¬∂//				StringBuffer aFileContents = aFileNameToContents.get(aFileName);¬∂////				List<OpenMPPragma> anOpenMPPragmas = OpenMPUtils.getOpemMPPragmas(aFileContents);¬∂//				SNode anSNode = OMPSNodeUtils.getSNode(aFileName, aFileContents);¬∂//				System.out.println("file name:" + aFileName);¬∂//				System.out.println("pragmas:" + anSNode);¬∂//			}¬∂			RootOfProgramSNode aRootOfProgramSNode = OMPSNodeUtils.getRootOfProgramSNode(aSource);¬∂			Set<AssignmentSNode> anAssignments = OMPSNodeUtils.assignmentsToSharedVariables(aRootOfProgramSNode);¬∂			anAssignments = OMPSNodeUtils.assignmentsToSharedArrays(aRootOfProgramSNode);¬∂			anAssignments = OMPSNodeUtils.assignmentsToParallelCriticalSharedVariables(aRootOfProgramSNode);¬∂			anAssignments = OMPSNodeUtils.assignmentsToNonParallelCriticalSharedVariables(aRootOfProgramSNode);¬∂			anAssignments = OMPSNodeUtils.assignmentsToParallelNonCriticalSharedVariables(aRootOfProgramSNode);¬∂			Set<OMPParallelSNode> anOMPParallelSNodes = OMPSNodeUtils.ompParallelSNodes(aRootOfProgramSNode);¬∂			Set<ForSNode> aForSNodes = OMPSNodeUtils.forSNodes(aRootOfProgramSNode);¬∂			Set<OMPForSNode> anOMPForSNodes = OMPSNodeUtils.ompForSNodes(aRootOfProgramSNode);¬∂¬∂¬∂			¬∂¬∂¬∂			String anExpectedLines = Arrays.toString(checker.getSubstrings());¬∂¬∂			if (!aRetval) {¬∂				return fail("Output  did not match:" + anExpectedLines);¬∂¬∂			}¬∂			return pass();¬∂			¬∂¬∂		} catch (NotRunnableException e) {¬∂			throw new NotGradableException();¬∂		}¬∂	}¬∂//	public static void processExternalMethodSNodes (RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode) {¬∂//		for (SNode anSNode:aRootOfFileSNode.getChildren()) {¬∂//			if (anSNode instanceof ExternalMethodSNode) {¬∂//				processExternalMethodSNode(aRootOfProgramSNode, aRootOfFileSNode, (ExternalMethodSNode) anSNode);¬∂//			}¬∂//		}¬∂//	}¬∂//	public static void processExternalMethodSNode (RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode, ExternalMethodSNode anExternalMethodSNode) {¬∂//		MethodSNode aMethodSNode = aRootOfProgramSNode.getExternalToInternalMethod().get(anExternalMethodSNode.toString());¬∂//		if (aMethodSNode == null) {¬∂//			aMethodSNode = findMethodSNode(aRootOfProgramSNode, aRootOfFileSNode, anExternalMethodSNode);¬∂//			if (aMethodSNode != null) {¬∂//				aRootOfProgramSNode.getExternalToInternalMethod().put(anExternalMethodSNode.toString(),aMethodSNode );¬∂//			}¬∂//		}¬∂//		if (aMethodSNode != null) {¬∂//			anExternalMethodSNode.setActualMethodSNode(aMethodSNode);¬∂//		}¬∂//	}¬∂//	public static MethodSNode findMethodSNode (RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode, ExternalMethodSNode anExternalMethodSNode) {¬∂////		MethodSNode foundMethodSNode = null;¬∂//		for (String aFileName:aRootOfProgramSNode.getFileNameToSNode().keySet()) {¬∂//			if (aFileName.equals(aRootOfFileSNode.getFileName()))¬∂//				continue;¬∂//			¬∂//			RootOfFileSNode aSearchedRootOfFileSNode = aRootOfProgramSNode.getFileNameToSNode().get(aFileName);¬∂//			 for (SNode anSNode:aSearchedRootOfFileSNode.getChildren()) {¬∂//				if (anSNode instanceof MethodSNode && !(anSNode instanceof ExternalMethodSNode)) {¬∂//					if (anSNode.toString().equals(anExternalMethodSNode)) {¬∂//						return (MethodSNode) anSNode;¬∂//						¬∂//					}¬∂////					processExternalMethodSNode(aRootOfProgramSNode, aRootOfFileSNode, (ExternalMethodSNode) anSNode);¬∂//				}¬∂//			}¬∂//		}¬∂//		return null;¬∂//	}¬∂//	public static void processExternalMethodSNodes (RootOfProgramSNode aRootOfProgramSNode) {¬∂//		for (String aFileName:aRootOfProgramSNode.getFileNameToSNode().keySet()) {¬∂//			RootOfFileSNode aRootOfFileSNode = aRootOfProgramSNode.getFileNameToSNode().get(aFileName);¬∂//			processExternalMethodSNodes(aRootOfProgramSNode, aRootOfFileSNode);¬∂//			¬∂//		}¬∂//¬∂//	}¬∂}¬∂")]]]></diff>
  </Command>
  <Command __id="188704" _type="EclipseCommand" commandID="org.eclipse.debug.ui.commands.Resume" date="Wed Jan 01 01:08:17 EST 2020" starttimestamp="1576666505112" timestamp="1192392705" />
  <Command __id="188705" _type="RunCommand" date="Wed Jan 01 01:08:17 EST 2020" kind="StepInto" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="1192392705" type="Run" />
  <Command __id="188706" _type="EHExceptionCommand" date="Wed Jan 01 01:08:17 EST 2020" starttimestamp="1576666505112" timestamp="1192392822" type="Exception">
    <outputString><![CDATA[I***(TestCaseResult) ### anonymous: 1.0
]]></outputString>
  </Command>
  <Command __id="188707" _type="DiffBasedFileOpenCommand" date="Wed Jan 01 01:09:41 EST 2020" docASTNodeCount="1" docActiveCodeLength="659" docExpressionCount="0" docLength="747" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="1192475918">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\my_sum_parallel_for_local_var.cpp]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"#include <iostream>¬∂#include <omp.h>¬∂¬∂using namespace std;¬∂¬∂void printSumWithTimes (int sum, int start, int end);¬∂void printNumThreads();¬∂void recordThreadIndex(int index);¬∂void sum_parallel_for_local_var(double* array, int size)¬∂{¬∂	cout << "sum_parallel_for_local_var\n";¬∂¬∂	double start = omp_get_wtime();¬∂¬∂	double sum = 0;¬∂¬∂	int a, b;¬∂//¬∂//	for (int i = 0; i < size; i++) {¬∂//			sum += array[i];¬∂//			recordThreadIndex(i);¬∂//	}¬∂¬∂    #pragma omp parallel shared (sum, start) private (a, b)¬∂	{¬∂		double local_sum = 0;¬∂¬∂		#pragma omp for¬∂		for(int i = 0; i < size; i++) {¬∂			local_sum += array[i];¬∂			recordThreadIndex(i);¬∂		}¬∂¬∂		#pragma omp critical¬∂		sum += local_sum;¬∂	}¬∂¬∂	double end = omp_get_wtime();¬∂¬∂	printSumWithTimes(sum, start, end);¬∂	¬∂}¬∂")]]]></diff>
  </Command>
  <Command __id="188708" _type="MoveCaretCommand" caretOffset="621" date="Wed Jan 01 01:09:41 EST 2020" docOffset="621" starttimestamp="1576666505112" timestamp="1192476242" />
  <Command __id="188710" _type="SelectTextCommand" caretOffset="449" date="Wed Jan 01 01:09:53 EST 2020" end="451" start="449" starttimestamp="1576666505112" timestamp="1192488248" />
  <Command __id="188709" _type="DiffBasedFileOpenCommand" date="Wed Jan 01 01:09:53 EST 2020" docASTNodeCount="1" docActiveCodeLength="484" docExpressionCount="0" docLength="624" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="1192488024">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\my_sum_parallel_for_reduction.cpp]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"#include <iostream>¬∂#include <omp.h>¬∂¬∂using namespace std;¬∂¬∂//const int SIZE = 1000;¬∂void printSumWithTimes(int sum, int start, int end);¬∂void printNumThreads();¬∂void recordThreadIndex(int index);¬∂void sum_parallel_for_reduction(double* array, int size) {¬∂	cout << "sum_parallel_for_reduction\n";¬∂¬∂	double start = omp_get_wtime();¬∂¬∂	double sum = 0;¬∂"), Diff(INSERT,"//"), Diff(EQUAL,"    #pragma omp  parallel for reduction ( + : sum )¬∂//    #pragma omp  for reduction ( + : sum )¬∂¬∂//	#pragma omp  for¬∂¬∂	for (int i = 0; i < size; i++) {¬∂		sum += array[i];¬∂¬∂		recordThreadIndex(i);¬∂	}¬∂¬∂	double end = omp_get_wtime();¬∂¬∂	printSumWithTimes(sum, start, end);¬∂¬∂}¬∂")]]]></diff>
    <snapshot><![CDATA[#include <iostream>
#include <omp.h>

using namespace std;

//const int SIZE = 1000;
void printSumWithTimes(int sum, int start, int end);
void printNumThreads();
void recordThreadIndex(int index);
void sum_parallel_for_reduction(double* array, int size) {
	cout << "sum_parallel_for_reduction\n";

	double start = omp_get_wtime();

	double sum = 0;
//    #pragma omp  parallel for reduction ( + : sum )
//    #pragma omp  for reduction ( + : sum )

//	#pragma omp  for

	for (int i = 0; i < size; i++) {
		sum += array[i];

		recordThreadIndex(i);
	}

	double end = omp_get_wtime();

	printSumWithTimes(sum, start, end);

}
]]></snapshot>
  </Command>
  <Command __id="188711" _type="MoveCaretCommand" caretOffset="349" date="Wed Jan 01 01:09:58 EST 2020" docOffset="349" starttimestamp="1576666505112" timestamp="1192493523" />
  <Command __id="188713" _type="EclipseCommand" commandID="org.eclipse.cdt.ui.edit.text.c.toggle.comment" date="Wed Jan 01 01:10:01 EST 2020" starttimestamp="1576666505112" timestamp="1192495954" />
  <Command __id="188714" _type="EclipseCommand" commandID="org.eclipse.ui.file.save" date="Wed Jan 01 01:10:02 EST 2020" starttimestamp="1576666505112" timestamp="1192497101" />
  <Command __id="188716" _type="RunCommand" date="Wed Jan 01 01:10:11 EST 2020" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="1192506471" type="Run" />
  <Command __id="188717" _type="RunCommand" date="Wed Jan 01 01:10:11 EST 2020" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="1192506477" type="Run" />
  <Command __id="188718" _type="RunCommand" date="Wed Jan 01 01:10:11 EST 2020" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="1192506478" type="Run" />
  <Command __id="188719" _type="EHExceptionCommand" date="Wed Jan 01 01:10:11 EST 2020" starttimestamp="1576666505112" timestamp="1192506522" type="Exception">
    <outputString><![CDATA[I***(TestCaseResult) ### SequentialSumTestCase: 1.0
Returning first of multiple entry points:[MyOpenMPTraining.exe, OpenMPTraining.exe]
I***(BasicProcessRunner) Running command:D:\dewan_backup\C\MyOpenMPTraining\Debug\MyOpenMPTraining.exe
I***(BasicProcessRunner) Running in folder: D:\dewan_backup\C\MyOpenMPTraining\Debug
I***(BasicProcessRunner)  Process started: D:\dewan_backup\C\MyOpenMPTraining\Debug\MyOpenMPTraining.exe folder: D:\dewan_backup\C\MyOpenMPTraining\Debug entry point: null class path: D:\dewan_backup\Java\PLTeaching\PL_Java\bin;D:\dewan_backup\Java\lib\oeall22.jar;C:\Users\dewan\.p2\pool\plugins\org.junit_4.12.0.v201504281640\junit.jar;C:\Users\dewan\.p2\pool\plugins\org.hamcrest.core_1.3.0.v20180420-1519.jar;D:\dewan_backup\Java\GraderBasics\lib\commons-configuration-1.9.jar;D:\dewan_backup\Java\GraderBasics\lib\commons-lang-2.6.jar;D:\dewan_backup\Java\GraderBasics\lib\commons-logging-1.1.1.jar;G:\My Drive\Java\lib\Herrmes\lib\weka3_6.jar;D:\dewan_backup\Java\GraderBasics\target\classes;D:\dewan_backup\Java\DemoCourseLocalBasicChecks\bin
I***(ARunnerInputStreamProcessor) Provided Input:
]]></outputString>
  </Command>
  <Command __id="188720" _type="EHExceptionCommand" date="Wed Jan 01 01:10:11 EST 2020" starttimestamp="1576666505112" timestamp="1192506592" type="Exception">
    <outputString><![CDATA[I***(BasicRunningProject) 1577859011636:Received output from main: sum_sequential
I***(BasicRunningProject) 1577859011636:Processing line from main: sum_sequential
I***(BasicRunningProject) 1577859011637:Received output from main: Sum: 499500
I***(BasicRunningProject) 1577859011637:Processing line from main: Sum: 499500
I***(BasicRunningProject) 1577859011637:Received output from main: Took: 0
I***(BasicRunningProject) 1577859011637:Processing line from main: Took: 0
I***(BasicRunningProject) 1577859011637:Received output from main: thread:0 lastIndex:999
I***(BasicRunningProject) 1577859011637:Processing line from main: thread:0 lastIndex:999
I***(BasicRunningProject) 1577859011637:Received output from main: _____________________________
I***(BasicRunningProject) 1577859011638:Processing line from main: _____________________________
I***(BasicRunningProject) 1577859011638:Received output from main: sum_parallel_for_reduction
I***(BasicRunningProject) 1577859011638:Processing line from main: sum_parallel_for_reduction
I***(BasicRunningProject) 1577859011639:Received output from main: Sum: 499500
I***(BasicRunningProject) 1577859011639:Processing line from main: Sum: 499500
I***(BasicRunningProject) 1577859011639:Received output from main: Took: 0
I***(BasicRunningProject) 1577859011639:Processing line from main: Took: 0
I***(BasicRunningProject) 1577859011639:Received output from main: thread:0 lastIndex:999
I***(BasicRunningProject) 1577859011639:Processing line from main: thread:0 lastIndex:999
I***(BasicRunningProject) 1577859011639:Received output from main: _____________________________
I***(BasicRunningProject) 1577859011639:Processing line from main: _____________________________
I***(BasicRunningProject) 1577859011639:Received output from main: sum_parallel_for_local_var
I***(BasicRunningProject) 1577859011640:Processing line from main: sum_parallel_for_local_var
I***(BasicRunningProject) 1577859011640:Received output from main: Sum: 499500
I***(BasicRunningProject) 1577859011640:Processing line from main: Sum: 499500
I***(BasicRunningProject) 1577859011640:Received output from main: Took: 0
I***(BasicRunningProject) 1577859011640:Processing line from main: Took: 0
I***(BasicRunningProject) 1577859011640:Received output from main: thread:0 lastIndex:124
I***(BasicRunningProject) 1577859011640:Processing line from main: thread:0 lastIndex:124
I***(BasicRunningProject) 1577859011640:Received output from main: thread:1 lastIndex:249
I***(BasicRunningProject) 1577859011640:Processing line from main: thread:1 lastIndex:249
I***(BasicRunningProject) 1577859011640:Received output from main: thread:2 lastIndex:374
I***(BasicRunningProject) 1577859011640:Processing line from main: thread:2 lastIndex:374
I***(BasicRunningProject) 1577859011640:Received output from main: thread:3 lastIndex:499
I***(BasicRunningProject) 1577859011641:Processing line from main: thread:3 lastIndex:499
I***(BasicRunningProject) 1577859011641:Received output from main: thread:4 lastIndex:624
I***(BasicRunningProject) 1577859011642:Processing line from main: thread:4 lastIndex:624
I***(BasicRunningProject) 1577859011642:Received output from main: thread:5 lastIndex:749
I***(BasicRunningProject) 1577859011642:Processing line from main: thread:5 lastIndex:749
I***(BasicRunningProject) 1577859011642:Received output from main: thread:6 lastIndex:874
I***(BasicRunningProject) 1577859011642:Processing line from main: thread:6 lastIndex:874
I***(BasicRunningProject) 1577859011642:Received output from main: thread:7 lastIndex:999
I***(BasicRunningProject) 1577859011642:Processing line from main: thread:7 lastIndex:999
I***(BasicRunningProject) 1577859011642:Received output from main: _____________________________
I***(BasicRunningProject) 1577859011642:Processing line from main: _____________________________
I***(BasicRunningProject) 1577859011643:Received output from main: sum_parallel
I***(BasicRunningProject) 1577859011643:Processing line from main: sum_parallel
I***(BasicRunningProject) 1577859011643:Received output from main: Sum: 499500
I***(BasicRunningProject) 1577859011643:Processing line from main: Sum: 499500
I***(BasicRunningProject) 1577859011643:Received output from main: Took: 0
I***(BasicRunningProject) 1577859011643:Processing line from main: Took: 0
I***(BasicProcessRunner)  Process finished; folder: D:\dewan_backup\C\MyOpenMPTraining\Debug entry point: null class path: D:\dewan_backup\Java\PLTeaching\PL_Java\bin;D:\dewan_backup\Java\lib\oeall22.jar;C:\Users\dewan\.p2\pool\plugins\org.junit_4.12.0.v201504281640\junit.jar;C:\Users\dewan\.p2\pool\plugins\org.hamcrest.core_1.3.0.v20180420-1519.jar;D:\dewan_backup\Java\GraderBasics\lib\commons-configuration-1.9.jar;D:\dewan_backup\Java\GraderBasics\lib\commons-lang-2.6.jar;D:\dewan_backup\Java\GraderBasics\lib\commons-logging-1.1.1.jar;G:\My Drive\Java\lib\Herrmes\lib\weka3_6.jar;D:\dewan_backup\Java\GraderBasics\target\classes;D:\dewan_backup\Java\DemoCourseLocalBasicChecks\bin
I***(BasicRunningProject) 1577859011643:Received output from main: _____________________________
I***(BasicRunningProject) 1577859011643:Processing line from main: _____________________________
I***(BasicRunningProject) Thread[AWT-EventQueue-0,6,main] sleeping for ms:2000 waiting for pending output from threads 
]]></outputString>
  </Command>
  <Command __id="188723" _type="DiffBasedFileOpenCommand" date="Wed Jan 01 01:10:16 EST 2020" docASTNodeCount="495" docActiveCodeLength="3647" docExpressionCount="382" docLength="6398" projectName="DemoCourseLocalBasicChecks" starttimestamp="1576666505112" timestamp="1192511675">
    <filePath><![CDATA[D:\dewan_backup\Java\DemoCourseLocalBasicChecks\src\gradingTools\comp123\assignment1\openmp\testcases\SequentialSumTestCase.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package gradingTools.comp123.assignment1.openmp.testcases;¬∂¬∂import java.util.Arrays;¬∂import java.util.List;¬∂import java.util.Map;¬∂import java.util.Set;¬∂import java.util.regex.Pattern;¬∂¬∂import grader.basics.execution.NotRunnableException;¬∂import grader.basics.execution.RunningProject;¬∂import grader.basics.junit.NotAutomatableException;¬∂import grader.basics.junit.TestCaseResult;¬∂import grader.basics.project.NotGradableException;¬∂import grader.basics.project.Project;¬∂import grader.basics.project.source.ABasicTextManager;¬∂import grader.basics.testcase.PassFailJUnitTestCase;¬∂import gradingTools.shared.testcases.SubstringSequenceChecker;¬∂import gradingTools.shared.testcases.openmp.OpenMPPragma;¬∂import gradingTools.shared.testcases.openmp.OpenMPUtils;¬∂import gradingTools.shared.testcases.openmp.scannedTree.AssignmentSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.ExternalMethodSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.ForSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.MethodSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.OMPForSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.OMPParallelSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.OMPSNodeUtils;¬∂import gradingTools.shared.testcases.openmp.scannedTree.RootOfFileSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.RootOfProgramSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.SNode;¬∂import gradingTools.shared.testcases.utils.LinesMatchKind;¬∂import gradingTools.shared.testcases.utils.LinesMatcher;¬∂import gradingTools.utils.RunningProjectUtils;¬∂¬∂public class SequentialSumTestCase extends PassFailJUnitTestCase {¬∂	public static final int TIME_OUT_SECS = 1; // secs¬∂	protected SubstringSequenceChecker checker = new ASequentialSumChecker();	¬∂¬∂	public SequentialSumTestCase() {¬∂	}¬∂¬∂	¬∂¬∂	@Override¬∂	public TestCaseResult test(Project project, boolean autoGrade) throws NotAutomatableException,¬∂			NotGradableException {¬∂		try {¬∂			RunningProject aRunningProject = RunningProjectUtils.runProject(project, TIME_OUT_SECS);¬∂			String anOutput = aRunningProject.await();¬∂			LinesMatcher aLinesMatcher = aRunningProject.getLinesMatcher();¬∂			boolean aRetval = checker.check(aLinesMatcher, LinesMatchKind.ONE_TIME_LINE, Pattern.DOTALL);¬∂			String aSource = project.getSource();¬∂//			Map<String, StringBuffer> aFileNameToContents = ABasicTextManager.extractFileContents(aSource);¬∂//			for (String aFileName:aFileNameToContents.keySet()) {¬∂//				StringBuffer aFileContents = aFileNameToContents.get(aFileName);¬∂////				List<OpenMPPragma> anOpenMPPragmas = OpenMPUtils.getOpemMPPragmas(aFileContents);¬∂//				SNode anSNode = OMPSNodeUtils.getSNode(aFileName, aFileContents);¬∂//				System.out.println("file name:" + aFileName);¬∂//				System.out.println("pragmas:" + anSNode);¬∂//			}¬∂			RootOfProgramSNode aRootOfProgramSNode = OMPSNodeUtils.getRootOfProgramSNode(aSource);¬∂			Set<AssignmentSNode> anAssignments = OMPSNodeUtils.assignmentsToSharedVariables(aRootOfProgramSNode);¬∂			anAssignments = OMPSNodeUtils.assignmentsToSharedArrays(aRootOfProgramSNode);¬∂			anAssignments = OMPSNodeUtils.assignmentsToParallelCriticalSharedVariables(aRootOfProgramSNode);¬∂			anAssignments = OMPSNodeUtils.assignmentsToNonParallelCriticalSharedVariables(aRootOfProgramSNode);¬∂			anAssignments = OMPSNodeUtils.assignmentsToParallelNonCriticalSharedVariables(aRootOfProgramSNode);¬∂			Set<OMPParallelSNode> anOMPParallelSNodes = OMPSNodeUtils.ompParallelSNodes(aRootOfProgramSNode);¬∂			Set<ForSNode> aForSNodes = OMPSNodeUtils.forSNodes(aRootOfProgramSNode);¬∂			Set<OMPForSNode> anOMPForSNodes = OMPSNodeUtils.ompForSNodes(aRootOfProgramSNode);¬∂¬∂¬∂			¬∂¬∂¬∂			String anExpectedLines = Arrays.toString(checker.getSubstrings());¬∂¬∂			if (!aRetval) {¬∂				return fail("Output  did not match:" + anExpectedLines);¬∂¬∂			}¬∂			return pass();¬∂			¬∂¬∂		} catch (NotRunnableException e) {¬∂			throw new NotGradableException();¬∂		}¬∂	}¬∂//	public static void processExternalMethodSNodes (RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode) {¬∂//		for (SNode anSNode:aRootOfFileSNode.getChildren()) {¬∂//			if (anSNode instanceof ExternalMethodSNode) {¬∂//				processExternalMethodSNode(aRootOfProgramSNode, aRootOfFileSNode, (ExternalMethodSNode) anSNode);¬∂//			}¬∂//		}¬∂//	}¬∂//	public static void processExternalMethodSNode (RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode, ExternalMethodSNode anExternalMethodSNode) {¬∂//		MethodSNode aMethodSNode = aRootOfProgramSNode.getExternalToInternalMethod().get(anExternalMethodSNode.toString());¬∂//		if (aMethodSNode == null) {¬∂//			aMethodSNode = findMethodSNode(aRootOfProgramSNode, aRootOfFileSNode, anExternalMethodSNode);¬∂//			if (aMethodSNode != null) {¬∂//				aRootOfProgramSNode.getExternalToInternalMethod().put(anExternalMethodSNode.toString(),aMethodSNode );¬∂//			}¬∂//		}¬∂//		if (aMethodSNode != null) {¬∂//			anExternalMethodSNode.setActualMethodSNode(aMethodSNode);¬∂//		}¬∂//	}¬∂//	public static MethodSNode findMethodSNode (RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode, ExternalMethodSNode anExternalMethodSNode) {¬∂////		MethodSNode foundMethodSNode = null;¬∂//		for (String aFileName:aRootOfProgramSNode.getFileNameToSNode().keySet()) {¬∂//			if (aFileName.equals(aRootOfFileSNode.getFileName()))¬∂//				continue;¬∂//			¬∂//			RootOfFileSNode aSearchedRootOfFileSNode = aRootOfProgramSNode.getFileNameToSNode().get(aFileName);¬∂//			 for (SNode anSNode:aSearchedRootOfFileSNode.getChildren()) {¬∂//				if (anSNode instanceof MethodSNode && !(anSNode instanceof ExternalMethodSNode)) {¬∂//					if (anSNode.toString().equals(anExternalMethodSNode)) {¬∂//						return (MethodSNode) anSNode;¬∂//						¬∂//					}¬∂////					processExternalMethodSNode(aRootOfProgramSNode, aRootOfFileSNode, (ExternalMethodSNode) anSNode);¬∂//				}¬∂//			}¬∂//		}¬∂//		return null;¬∂//	}¬∂//	public static void processExternalMethodSNodes (RootOfProgramSNode aRootOfProgramSNode) {¬∂//		for (String aFileName:aRootOfProgramSNode.getFileNameToSNode().keySet()) {¬∂//			RootOfFileSNode aRootOfFileSNode = aRootOfProgramSNode.getFileNameToSNode().get(aFileName);¬∂//			processExternalMethodSNodes(aRootOfProgramSNode, aRootOfFileSNode);¬∂//			¬∂//		}¬∂//¬∂//	}¬∂}¬∂")]]]></diff>
  </Command>
  <Command __id="188750" _type="MoveCaretCommand" caretOffset="3483" date="Wed Jan 01 01:11:06 EST 2020" docOffset="3483" starttimestamp="1576666505112" timestamp="1192561154" />
  <Command __id="188751" _type="DiffBasedFileOpenCommand" date="Wed Jan 01 01:11:09 EST 2020" docASTNodeCount="1" docActiveCodeLength="659" docExpressionCount="0" docLength="747" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="1192563969">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\my_sum_parallel_for_local_var.cpp]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"#include <iostream>¬∂#include <omp.h>¬∂¬∂using namespace std;¬∂¬∂void printSumWithTimes (int sum, int start, int end);¬∂void printNumThreads();¬∂void recordThreadIndex(int index);¬∂void sum_parallel_for_local_var(double* array, int size)¬∂{¬∂	cout << "sum_parallel_for_local_var\n";¬∂¬∂	double start = omp_get_wtime();¬∂¬∂	double sum = 0;¬∂¬∂	int a, b;¬∂//¬∂//	for (int i = 0; i < size; i++) {¬∂//			sum += array[i];¬∂//			recordThreadIndex(i);¬∂//	}¬∂¬∂    #pragma omp parallel shared (sum, start) private (a, b)¬∂	{¬∂		double local_sum = 0;¬∂¬∂		#pragma omp for¬∂		for(int i = 0; i < size; i++) {¬∂			local_sum += array[i];¬∂			recordThreadIndex(i);¬∂		}¬∂¬∂		#pragma omp critical¬∂		sum += local_sum;¬∂	}¬∂¬∂	double end = omp_get_wtime();¬∂¬∂	printSumWithTimes(sum, start, end);¬∂	¬∂}¬∂")]]]></diff>
  </Command>
  <Command __id="188752" _type="MoveCaretCommand" caretOffset="621" date="Wed Jan 01 01:11:09 EST 2020" docOffset="621" starttimestamp="1576666505112" timestamp="1192564228" />
  <Command __id="188754" _type="MoveCaretCommand" caretOffset="349" date="Wed Jan 01 01:11:13 EST 2020" docOffset="349" starttimestamp="1576666505112" timestamp="1192568253" />
  <Command __id="188755" _type="SelectTextCommand" caretOffset="401" date="Wed Jan 01 01:11:23 EST 2020" end="466" start="401" starttimestamp="1576666505112" timestamp="1192578584" />
  <Command __id="188756" _type="MoveCaretCommand" caretOffset="466" date="Wed Jan 01 01:11:31 EST 2020" docOffset="466" starttimestamp="1576666505112" timestamp="1192586787" />
  <DocumentChange __id="190018" _type="Insert" date="Wed Jan 01 01:40:42 EST 2020" docASTNodeCount="4422" docActiveCodeLength="31256" docExpressionCount="2749" docLength="35442" length="1" offset="8306" starttimestamp="1576666505112" timestamp="1194337879">
    <text><![CDATA[)]]></text>
  </DocumentChange>
  <Command __id="190088" _type="DiffBasedFileOpenCommand" date="Wed Jan 01 01:41:50 EST 2020" docASTNodeCount="236" docActiveCodeLength="1780" docExpressionCount="130" docLength="2279" projectName="GraderBasics" starttimestamp="1576666505112" timestamp="1194405478">
    <filePath><![CDATA[D:\dewan_backup\Java\GraderBasics\src\gradingTools\shared\testcases\openmp\scannedTree\AnOMPForSNode.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package gradingTools.shared.testcases.openmp.scannedTree;¬∂¬∂import java.util.ArrayList;¬∂import java.util.List;¬∂¬∂public class AnOMPForSNode extends AnOMPSNode implements OMPForSNode  {¬∂	protected String reductionVariable;¬∂	protected String reductionOperation;¬∂	protected List<AssignmentSNode> reductionVariableAssignments = new ArrayList();¬∂	protected List<String> reductionOperationUses = new ArrayList();¬∂	protected Boolean indexVariableNotShared;¬∂//	protected boolean inParallel;¬∂	¬∂	public AnOMPForSNode(int lineNumber) {¬∂		super(lineNumber);¬∂	}¬∂	@Override¬∂	public void addChild(SNode aChild) {¬∂		super.addChild(aChild);¬∂		if (aChild instanceof ForSNode) {¬∂			ForSNode aForSNode = (ForSNode) aChild;¬∂			AssignmentSNode anAssignmentSNode = aForSNode.getInitalization();¬∂			if (anAssignmentSNode != null) {¬∂				 indexVariableNotShared = ¬∂						 (anAssignmentSNode instanceof DeclaringAssignmentSNode) ?¬∂								true:¬∂								OMPSNodeUtils.isSharedVariable(this, anAssignmentSNode.getLHS());¬∂			}¬∂			¬∂		}¬∂		¬∂		¬∂//		if (reductionVariable != null) {¬∂//			if (aChild instanceof AssignmentSNode) {¬∂//				AssignmentSNode anAssignmentSNode = (AssignmentSNode) aChild;¬∂//				getReductionVariableAssignments().add(anAssignmentSNode);¬∂//				if (reductionOperation != null) { // can it ever be not null¬∂//					if (anAssignmentSNode.getOperationAndRHS().contains(reductionOperation)) {¬∂//						getReductionOperationUses().add(anAssignmentSNode.getOperationAndRHS());¬∂//					}¬∂//				}¬∂//			}			¬∂//		}¬∂	}¬∂	@Override¬∂	public String getReductionOperation() {¬∂		return reductionOperation;¬∂	}¬∂	@Override¬∂	public void setReductionOperation(String reductionOperation) {¬∂		this.reductionOperation = reductionOperation;¬∂	}¬∂	@Override¬∂	public List<AssignmentSNode> getReductionVariableAssignments() {¬∂		return reductionVariableAssignments;¬∂	}¬∂	@Override¬∂	public List<String> getReductionOperationUses() {¬∂		return reductionOperationUses;¬∂	}¬∂	@Override¬∂	public String getReductionVariable() {¬∂		return reductionVariable;¬∂	}¬∂	@Override¬∂	public void setReductionVariable(String reductionVariable) {¬∂		this.reductionVariable = reductionVariable;¬∂	}¬∂	@Override¬∂	public void setParent (SNode aParent) {¬∂		super.setParent(aParent);¬∂	}¬∂}¬∂")]]]></diff>
  </Command>
  <Command __id="190095" _type="DiffBasedFileOpenCommand" date="Wed Jan 01 01:41:56 EST 2020" docASTNodeCount="527" docActiveCodeLength="3955" docExpressionCount="393" docLength="6706" projectName="DemoCourseLocalBasicChecks" starttimestamp="1576666505112" timestamp="1194411215">
    <filePath><![CDATA[D:\dewan_backup\Java\DemoCourseLocalBasicChecks\src\gradingTools\comp123\assignment1\openmp\testcases\SequentialSumTestCase.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package gradingTools.comp123.assignment1.openmp.testcases;¬∂¬∂import java.util.Arrays;¬∂import java.util.List;¬∂import java.util.Map;¬∂import java.util.Set;¬∂import java.util.regex.Pattern;¬∂¬∂import grader.basics.execution.NotRunnableException;¬∂import grader.basics.execution.RunningProject;¬∂import grader.basics.junit.NotAutomatableException;¬∂import grader.basics.junit.TestCaseResult;¬∂import grader.basics.project.NotGradableException;¬∂import grader.basics.project.Project;¬∂import grader.basics.project.source.ABasicTextManager;¬∂import grader.basics.testcase.PassFailJUnitTestCase;¬∂import gradingTools.shared.testcases.SubstringSequenceChecker;¬∂import gradingTools.shared.testcases.openmp.OpenMPPragma;¬∂import gradingTools.shared.testcases.openmp.OpenMPUtils;¬∂import gradingTools.shared.testcases.openmp.scannedTree.AssignmentSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.ExternalMethodSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.ForSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.MethodSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.OMPForSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.OMPParallelSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.OMPSNodeUtils;¬∂import gradingTools.shared.testcases.openmp.scannedTree.RootOfFileSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.RootOfProgramSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.SNode;¬∂import gradingTools.shared.testcases.utils.LinesMatchKind;¬∂import gradingTools.shared.testcases.utils.LinesMatcher;¬∂import gradingTools.utils.RunningProjectUtils;¬∂¬∂public class SequentialSumTestCase extends PassFailJUnitTestCase {¬∂	public static final int TIME_OUT_SECS = 1; // secs¬∂	protected SubstringSequenceChecker checker = new ASequentialSumChecker();	¬∂¬∂	public SequentialSumTestCase() {¬∂	}¬∂¬∂	¬∂¬∂	@Override¬∂	public TestCaseResult test(Project project, boolean autoGrade) throws NotAutomatableException,¬∂			NotGradableException {¬∂		try {¬∂			RunningProject aRunningProject = RunningProjectUtils.runProject(project, TIME_OUT_SECS);¬∂			String anOutput = aRunningProject.await();¬∂			LinesMatcher aLinesMatcher = aRunningProject.getLinesMatcher();¬∂			boolean aRetval = checker.check(aLinesMatcher, LinesMatchKind.ONE_TIME_LINE, Pattern.DOTALL);¬∂			String aSource = project.getSource();¬∂//			Map<String, StringBuffer> aFileNameToContents = ABasicTextManager.extractFileContents(aSource);¬∂//			for (String aFileName:aFileNameToContents.keySet()) {¬∂//				StringBuffer aFileContents = aFileNameToContents.get(aFileName);¬∂////				List<OpenMPPragma> anOpenMPPragmas = OpenMPUtils.getOpemMPPragmas(aFileContents);¬∂//				SNode anSNode = OMPSNodeUtils.getSNode(aFileName, aFileContents);¬∂//				System.out.println("file name:" + aFileName);¬∂//				System.out.println("pragmas:" + anSNode);¬∂//			}¬∂			RootOfProgramSNode aRootOfProgramSNode = OMPSNodeUtils.getRootOfProgramSNode(aSource);¬∂			Set<AssignmentSNode> anAssignments = OMPSNodeUtils.assignmentsToSharedVariables(aRootOfProgramSNode);¬∂			Set<AssignmentSNode> anAssignmentsToSharedArrays = OMPSNodeUtils.assignmentsToSharedArrays(aRootOfProgramSNode);¬∂			Set<AssignmentSNode> anAssignmentsToParallelCriticalSharedVariables = OMPSNodeUtils.assignmentsToParallelCriticalSharedVariables(aRootOfProgramSNode);¬∂			Set<AssignmentSNode> anAssignmentsToNonParallelCriticalSharedVariables  = OMPSNodeUtils.assignmentsToNonParallelCriticalSharedVariables(aRootOfProgramSNode);¬∂			Set<AssignmentSNode> anAssignmentsToParallelNonCriticalSharedVariables = OMPSNodeUtils.assignmentsToParallelNonCriticalSharedVariables(aRootOfProgramSNode);¬∂			Set<OMPParallelSNode> anOMPParallelSNodes = OMPSNodeUtils.ompParallelSNodes(aRootOfProgramSNode);¬∂			Set<ForSNode> aForSNodes = OMPSNodeUtils.forSNodes(aRootOfProgramSNode);¬∂			Set<OMPForSNode> anOMPForSNodes = OMPSNodeUtils.ompForSNodes(aRootOfProgramSNode);¬∂			Set<OMPForSNode> anOMPReducingForSNodes = OMPSNodeUtils.ompReducingForNodes(aRootOfProgramSNode);¬∂¬∂¬∂¬∂			¬∂¬∂¬∂			String anExpectedLines = Arrays.toString(checker.getSubstrings());¬∂¬∂			if (!aRetval) {¬∂				return fail("Output  did not match:" + anExpectedLines);¬∂¬∂			}¬∂			return pass();¬∂			¬∂¬∂		} catch (NotRunnableException e) {¬∂			throw new NotGradableException();¬∂		}¬∂	}¬∂//	public static void processExternalMethodSNodes (RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode) {¬∂//		for (SNode anSNode:aRootOfFileSNode.getChildren()) {¬∂//			if (anSNode instanceof ExternalMethodSNode) {¬∂//				processExternalMethodSNode(aRootOfProgramSNode, aRootOfFileSNode, (ExternalMethodSNode) anSNode);¬∂//			}¬∂//		}¬∂//	}¬∂//	public static void processExternalMethodSNode (RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode, ExternalMethodSNode anExternalMethodSNode) {¬∂//		MethodSNode aMethodSNode = aRootOfProgramSNode.getExternalToInternalMethod().get(anExternalMethodSNode.toString());¬∂//		if (aMethodSNode == null) {¬∂//			aMethodSNode = findMethodSNode(aRootOfProgramSNode, aRootOfFileSNode, anExternalMethodSNode);¬∂//			if (aMethodSNode != null) {¬∂//				aRootOfProgramSNode.getExternalToInternalMethod().put(anExternalMethodSNode.toString(),aMethodSNode );¬∂//			}¬∂//		}¬∂//		if (aMethodSNode != null) {¬∂//			anExternalMethodSNode.setActualMethodSNode(aMethodSNode);¬∂//		}¬∂//	}¬∂//	public static MethodSNode findMethodSNode (RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode, ExternalMethodSNode anExternalMethodSNode) {¬∂////		MethodSNode foundMethodSNode = null;¬∂//		for (String aFileName:aRootOfProgramSNode.getFileNameToSNode().keySet()) {¬∂//			if (aFileName.equals(aRootOfFileSNode.getFileName()))¬∂//				continue;¬∂//			¬∂//			RootOfFileSNode aSearchedRootOfFileSNode = aRootOfProgramSNode.getFileNameToSNode().get(aFileName);¬∂//			 for (SNode anSNode:aSearchedRootOfFileSNode.getChildren()) {¬∂//				if (anSNode instanceof MethodSNode && !(anSNode instanceof ExternalMethodSNode)) {¬∂//					if (anSNode.toString().equals(anExternalMethodSNode)) {¬∂//						return (MethodSNode) anSNode;¬∂//						¬∂//					}¬∂////					processExternalMethodSNode(aRootOfProgramSNode, aRootOfFileSNode, (ExternalMethodSNode) anSNode);¬∂//				}¬∂//			}¬∂//		}¬∂//		return null;¬∂//	}¬∂//	public static void processExternalMethodSNodes (RootOfProgramSNode aRootOfProgramSNode) {¬∂//		for (String aFileName:aRootOfProgramSNode.getFileNameToSNode().keySet()) {¬∂//			RootOfFileSNode aRootOfFileSNode = aRootOfProgramSNode.getFileNameToSNode().get(aFileName);¬∂//			processExternalMethodSNodes(aRootOfProgramSNode, aRootOfFileSNode);¬∂//			¬∂//		}¬∂//¬∂//	}¬∂}¬∂")]]]></diff>
  </Command>
  <Command __id="190172" _type="ShellCommand" date="Wed Jan 01 05:02:25 EST 2020" starttimestamp="1576666505112" timestamp="1206440601" type="ECLIPSE_MAXIMIZED" />
  <Command __id="190173" _type="ShellCommand" date="Wed Jan 01 05:02:25 EST 2020" starttimestamp="1576666505112" timestamp="1206440753" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="190174" _type="DiffBasedFileOpenCommand" date="Wed Jan 01 05:02:38 EST 2020" docASTNodeCount="1" docActiveCodeLength="659" docExpressionCount="0" docLength="747" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="1206453349">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\my_sum_parallel_for_local_var.cpp]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"#include <iostream>¬∂#include <omp.h>¬∂¬∂using namespace std;¬∂¬∂void printSumWithTimes (int sum, int start, int end);¬∂void printNumThreads();¬∂void recordThreadIndex(int index);¬∂void sum_parallel_for_local_var(double* array, int size)¬∂{¬∂	cout << "sum_parallel_for_local_var\n";¬∂¬∂	double start = omp_get_wtime();¬∂¬∂	double sum = 0;¬∂¬∂	int a, b;¬∂//¬∂//	for (int i = 0; i < size; i++) {¬∂//			sum += array[i];¬∂//			recordThreadIndex(i);¬∂//	}¬∂¬∂    #pragma omp parallel shared (sum, start) private (a, b)¬∂	{¬∂		double local_sum = 0;¬∂¬∂		#pragma omp for¬∂		for(int i = 0; i < size; i++) {¬∂			local_sum += array[i];¬∂			recordThreadIndex(i);¬∂		}¬∂¬∂		#pragma omp critical¬∂		sum += local_sum;¬∂	}¬∂¬∂	double end = omp_get_wtime();¬∂¬∂	printSumWithTimes(sum, start, end);¬∂	¬∂}¬∂")]]]></diff>
  </Command>
  <Command __id="190175" _type="MoveCaretCommand" caretOffset="621" date="Wed Jan 01 05:02:38 EST 2020" docOffset="621" starttimestamp="1576666505112" timestamp="1206453621" />
  <DocumentChange __id="197052" _type="Insert" date="Wed Jan 01 10:12:12 EST 2020" docASTNodeCount="4568" docActiveCodeLength="32563" docExpressionCount="2837" docLength="37762" length="1" offset="32185" starttimestamp="1576666505112" timestamp="1225027283">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <Command __id="197118" _type="DiffBasedFileOpenCommand" date="Wed Jan 01 10:12:49 EST 2020" docASTNodeCount="563" docActiveCodeLength="4315" docExpressionCount="417" docLength="7066" projectName="DemoCourseLocalBasicChecks" starttimestamp="1576666505112" timestamp="1225064396">
    <filePath><![CDATA[D:\dewan_backup\Java\DemoCourseLocalBasicChecks\src\gradingTools\comp123\assignment1\openmp\testcases\SequentialSumTestCase.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package gradingTools.comp123.assignment1.openmp.testcases;¬∂¬∂import java.util.Arrays;¬∂import java.util.List;¬∂import java.util.Map;¬∂import java.util.Set;¬∂import java.util.regex.Pattern;¬∂¬∂import grader.basics.execution.NotRunnableException;¬∂import grader.basics.execution.RunningProject;¬∂import grader.basics.junit.NotAutomatableException;¬∂import grader.basics.junit.TestCaseResult;¬∂import grader.basics.project.NotGradableException;¬∂import grader.basics.project.Project;¬∂import grader.basics.project.source.ABasicTextManager;¬∂import grader.basics.testcase.PassFailJUnitTestCase;¬∂import gradingTools.shared.testcases.SubstringSequenceChecker;¬∂import gradingTools.shared.testcases.openmp.OpenMPPragma;¬∂import gradingTools.shared.testcases.openmp.OpenMPUtils;¬∂import gradingTools.shared.testcases.openmp.scannedTree.AssignmentSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.ExternalMethodSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.ForSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.MethodSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.OMPForSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.OMPParallelSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.OMPSNodeUtils;¬∂import gradingTools.shared.testcases.openmp.scannedTree.RootOfFileSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.RootOfProgramSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.SNode;¬∂import gradingTools.shared.testcases.utils.LinesMatchKind;¬∂import gradingTools.shared.testcases.utils.LinesMatcher;¬∂import gradingTools.utils.RunningProjectUtils;¬∂¬∂public class SequentialSumTestCase extends PassFailJUnitTestCase {¬∂	public static final int TIME_OUT_SECS = 1; // secs¬∂	protected SubstringSequenceChecker checker = new ASequentialSumChecker();	¬∂¬∂	public SequentialSumTestCase() {¬∂	}¬∂¬∂	¬∂¬∂	@Override¬∂	public TestCaseResult test(Project project, boolean autoGrade) throws NotAutomatableException,¬∂			NotGradableException {¬∂		try {¬∂			RunningProject aRunningProject = RunningProjectUtils.runProject(project, TIME_OUT_SECS);¬∂			String anOutput = aRunningProject.await();¬∂			LinesMatcher aLinesMatcher = aRunningProject.getLinesMatcher();¬∂			boolean aRetval = checker.check(aLinesMatcher, LinesMatchKind.ONE_TIME_LINE, Pattern.DOTALL);¬∂			String aSource = project.getSource();¬∂//			Map<String, StringBuffer> aFileNameToContents = ABasicTextManager.extractFileContents(aSource);¬∂//			for (String aFileName:aFileNameToContents.keySet()) {¬∂//				StringBuffer aFileContents = aFileNameToContents.get(aFileName);¬∂////				List<OpenMPPragma> anOpenMPPragmas = OpenMPUtils.getOpemMPPragmas(aFileContents);¬∂//				SNode anSNode = OMPSNodeUtils.getSNode(aFileName, aFileContents);¬∂//				System.out.println("file name:" + aFileName);¬∂//				System.out.println("pragmas:" + anSNode);¬∂//			}¬∂			RootOfProgramSNode aRootOfProgramSNode = OMPSNodeUtils.getRootOfProgramSNode(aSource);¬∂			Set<AssignmentSNode> anAssignments = OMPSNodeUtils.assignmentsToSharedVariables(aRootOfProgramSNode);¬∂			Set<AssignmentSNode> anAssignmentsToSharedArrays = OMPSNodeUtils.assignmentsToSharedArrays(aRootOfProgramSNode);¬∂			Set<AssignmentSNode> anAssignmentsToParallelCriticalSharedVariables = OMPSNodeUtils.assignmentsToParallelCriticalSharedVariables(aRootOfProgramSNode);¬∂			Set<AssignmentSNode> anAssignmentsToNonParallelCriticalSharedVariables  = OMPSNodeUtils.assignmentsToNonParallelCriticalSharedVariables(aRootOfProgramSNode);¬∂			Set<AssignmentSNode> anAssignmentsToParallelNonCriticalSharedVariables = OMPSNodeUtils.assignmentsToParallelNonCriticalSharedVariables(aRootOfProgramSNode);¬∂			Set<OMPParallelSNode> anOMPParallelSNodes = OMPSNodeUtils.ompParallelSNodes(aRootOfProgramSNode);¬∂			Set<ForSNode> aForSNodes = OMPSNodeUtils.forSNodes(aRootOfProgramSNode);¬∂			Set<OMPForSNode> anOMPForSNodes = OMPSNodeUtils.ompForSNodes(aRootOfProgramSNode);¬∂			Set<OMPForSNode> anOMPReducingForSNodes = OMPSNodeUtils.ompReducingForNodes(aRootOfProgramSNode);¬∂			for (OMPForSNode anOMPForSNode:anOMPReducingForSNodes) {¬∂				Set<AssignmentSNode> anAssignmentsToReducingForNode = OMPSNodeUtils.assignmentsToOMPReducingForNode(anOMPForSNode);¬∂				if (anAssignmentsToReducingForNode.isEmpty()) {¬∂					System.err.println(anOMPForSNode + " does not have assignment to:" + anOMPForSNode.getReductionVariable());¬∂				}¬∂			}¬∂¬∂¬∂			¬∂¬∂¬∂			String anExpectedLines = Arrays.toString(checker.getSubstrings());¬∂¬∂			if (!aRetval) {¬∂				return fail("Output  did not match:" + anExpectedLines);¬∂¬∂			}¬∂			return pass();¬∂			¬∂¬∂		} catch (NotRunnableException e) {¬∂			throw new NotGradableException();¬∂		}¬∂	}¬∂//	public static void processExternalMethodSNodes (RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode) {¬∂//		for (SNode anSNode:aRootOfFileSNode.getChildren()) {¬∂//			if (anSNode instanceof ExternalMethodSNode) {¬∂//				processExternalMethodSNode(aRootOfProgramSNode, aRootOfFileSNode, (ExternalMethodSNode) anSNode);¬∂//			}¬∂//		}¬∂//	}¬∂//	public static void processExternalMethodSNode (RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode, ExternalMethodSNode anExternalMethodSNode) {¬∂//		MethodSNode aMethodSNode = aRootOfProgramSNode.getExternalToInternalMethod().get(anExternalMethodSNode.toString());¬∂//		if (aMethodSNode == null) {¬∂//			aMethodSNode = findMethodSNode(aRootOfProgramSNode, aRootOfFileSNode, anExternalMethodSNode);¬∂//			if (aMethodSNode != null) {¬∂//				aRootOfProgramSNode.getExternalToInternalMethod().put(anExternalMethodSNode.toString(),aMethodSNode );¬∂//			}¬∂//		}¬∂//		if (aMethodSNode != null) {¬∂//			anExternalMethodSNode.setActualMethodSNode(aMethodSNode);¬∂//		}¬∂//	}¬∂//	public static MethodSNode findMethodSNode (RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode, ExternalMethodSNode anExternalMethodSNode) {¬∂////		MethodSNode foundMethodSNode = null;¬∂//		for (String aFileName:aRootOfProgramSNode.getFileNameToSNode().keySet()) {¬∂//			if (aFileName.equals(aRootOfFileSNode.getFileName()))¬∂//				continue;¬∂//			¬∂//			RootOfFileSNode aSearchedRootOfFileSNode = aRootOfProgramSNode.getFileNameToSNode().get(aFileName);¬∂//			 for (SNode anSNode:aSearchedRootOfFileSNode.getChildren()) {¬∂//				if (anSNode instanceof MethodSNode && !(anSNode instanceof ExternalMethodSNode)) {¬∂//					if (anSNode.toString().equals(anExternalMethodSNode)) {¬∂//						return (MethodSNode) anSNode;¬∂//						¬∂//					}¬∂////					processExternalMethodSNode(aRootOfProgramSNode, aRootOfFileSNode, (ExternalMethodSNode) anSNode);¬∂//				}¬∂//			}¬∂//		}¬∂//		return null;¬∂//	}¬∂//	public static void processExternalMethodSNodes (RootOfProgramSNode aRootOfProgramSNode) {¬∂//		for (String aFileName:aRootOfProgramSNode.getFileNameToSNode().keySet()) {¬∂//			RootOfFileSNode aRootOfFileSNode = aRootOfProgramSNode.getFileNameToSNode().get(aFileName);¬∂//			processExternalMethodSNodes(aRootOfProgramSNode, aRootOfFileSNode);¬∂//			¬∂//		}¬∂//¬∂//	}¬∂}¬∂")]]]></diff>
  </Command>
  <Command __id="197133" _type="ShellCommand" date="Wed Jan 01 10:13:38 EST 2020" starttimestamp="1576666505112" timestamp="1225113066" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="197134" _type="RunCommand" date="Wed Jan 01 10:13:38 EST 2020" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="1225113187" type="Debug" />
  <Command __id="197135" _type="RunCommand" date="Wed Jan 01 10:13:38 EST 2020" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="1225113187" type="Debug" />
  <Command __id="197136" _type="RunCommand" date="Wed Jan 01 10:13:38 EST 2020" kind="HitBreakPoint" projectName="PL_Java" starttimestamp="1576666505112" timestamp="1225113187" type="Run" />
  <Command __id="197138" _type="MoveCaretCommand" caretOffset="348" date="Wed Jan 01 10:13:42 EST 2020" docOffset="348" starttimestamp="1576666505112" timestamp="1225117590" />
  <Command __id="197137" _type="DiffBasedFileOpenCommand" date="Wed Jan 01 10:13:42 EST 2020" docASTNodeCount="1" docActiveCodeLength="535" docExpressionCount="0" docLength="622" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="1225117404">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\my_sum_parallel_for_reduction.cpp]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"#include <iostream>¬∂#include <omp.h>¬∂¬∂using namespace std;¬∂¬∂//const int SIZE = 1000;¬∂void printSumWithTimes(int sum, int start, int end);¬∂void printNumThreads();¬∂void recordThreadIndex(int index);¬∂void sum_parallel_for_reduction(double* array, int size) {¬∂	cout << "sum_parallel_for_reduction\n";¬∂¬∂	double start = omp_get_wtime();¬∂¬∂	double sum = 0;¬∂    #pragma omp  parallel for reduction ( + : sum )¬∂//    #pragma omp  for reduction ( + : sum )¬∂¬∂//	#pragma omp  for¬∂¬∂	for (int i = 0; i < size; i++) {¬∂		sum += array[i];¬∂¬∂		recordThreadIndex(i);¬∂	}¬∂¬∂	double end = omp_get_wtime();¬∂¬∂	printSumWithTimes(sum, start, end);¬∂¬∂}¬∂")]]]></diff>
  </Command>
  <DocumentChange __id="197140" _type="Insert" date="Wed Jan 01 10:13:58 EST 2020" docASTNodeCount="1" docActiveCodeLength="536" docExpressionCount="0" docLength="623" length="1" offset="196" starttimestamp="1576666505112" timestamp="1225133246">
    <text><![CDATA[
]]></text>
  </DocumentChange>
  <DocumentChange __id="197142" _type="Insert" date="Wed Jan 01 10:13:58 EST 2020" docASTNodeCount="1" docActiveCodeLength="537" docExpressionCount="0" docLength="624" length="1" offset="197" starttimestamp="1576666505112" timestamp="1225133760">
    <text><![CDATA[v]]></text>
  </DocumentChange>
  <Command __id="197139" _type="MoveCaretCommand" caretOffset="196" date="Wed Jan 01 10:13:57 EST 2020" docOffset="196" starttimestamp="1576666505112" timestamp="1225132493" />
  <Command __id="197141" _type="InsertStringCommand" date="Wed Jan 01 10:13:58 EST 2020" starttimestamp="1576666505112" timestamp="1225133250" timestamp2="1225133250">
    <data><![CDATA[]]></data>
  </Command>
  <Command __id="197143" _type="InsertStringCommand" date="Wed Jan 01 10:13:58 EST 2020" starttimestamp="1576666505112" timestamp="1225133765" timestamp2="1225133765">
    <data><![CDATA[v]]></data>
  </Command>
  <Command __id="197145" _type="InsertStringCommand" date="Wed Jan 01 10:14:00 EST 2020" starttimestamp="1576666505112" timestamp="1225135194" timestamp2="1225135194">
    <data><![CDATA[o]]></data>
  </Command>
  <Command __id="197147" _type="InsertStringCommand" date="Wed Jan 01 10:14:00 EST 2020" starttimestamp="1576666505112" timestamp="1225135429" timestamp2="1225135429">
    <data><![CDATA[i]]></data>
  </Command>
  <Command __id="197149" _type="InsertStringCommand" date="Wed Jan 01 10:14:01 EST 2020" starttimestamp="1576666505112" timestamp="1225136413" timestamp2="1225136413">
    <data><![CDATA[d]]></data>
  </Command>
  <Command __id="197151" _type="InsertStringCommand" date="Wed Jan 01 10:14:01 EST 2020" starttimestamp="1576666505112" timestamp="1225136740" timestamp2="1225136740">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="197153" _type="InsertStringCommand" date="Wed Jan 01 10:14:02 EST 2020" starttimestamp="1576666505112" timestamp="1225136896" timestamp2="1225136896">
    <data><![CDATA[i]]></data>
  </Command>
  <Command __id="197155" _type="InsertStringCommand" date="Wed Jan 01 10:14:02 EST 2020" starttimestamp="1576666505112" timestamp="1225137195" timestamp2="1225137195">
    <data><![CDATA[n]]></data>
  </Command>
  <Command __id="197157" _type="InsertStringCommand" date="Wed Jan 01 10:14:02 EST 2020" starttimestamp="1576666505112" timestamp="1225137418" timestamp2="1225137418">
    <data><![CDATA[c]]></data>
  </Command>
  <Command __id="197159" _type="InsertStringCommand" date="Wed Jan 01 10:14:03 EST 2020" starttimestamp="1576666505112" timestamp="1225138004" timestamp2="1225138004">
    <data><![CDATA[r]]></data>
  </Command>
  <Command __id="197161" _type="InsertStringCommand" date="Wed Jan 01 10:14:03 EST 2020" starttimestamp="1576666505112" timestamp="1225138122" timestamp2="1225138122">
    <data><![CDATA[e]]></data>
  </Command>
  <Command __id="197163" _type="InsertStringCommand" date="Wed Jan 01 10:14:03 EST 2020" starttimestamp="1576666505112" timestamp="1225138416" timestamp2="1225138416">
    <data><![CDATA[e]]></data>
  </Command>
  <Command __id="197165" _type="InsertStringCommand" date="Wed Jan 01 10:14:03 EST 2020" starttimestamp="1576666505112" timestamp="1225138570" timestamp2="1225138570">
    <data><![CDATA[n]]></data>
  </Command>
  <Command __id="197167" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Wed Jan 01 10:14:04 EST 2020" starttimestamp="1576666505112" timestamp="1225139121" />
  <Command __id="197169" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Wed Jan 01 10:14:04 EST 2020" starttimestamp="1576666505112" timestamp="1225139296" />
  <Command __id="197171" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Wed Jan 01 10:14:04 EST 2020" starttimestamp="1576666505112" timestamp="1225139444" />
  <Command __id="197173" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Wed Jan 01 10:14:04 EST 2020" starttimestamp="1576666505112" timestamp="1225139621" />
  <Command __id="197175" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Wed Jan 01 10:14:04 EST 2020" starttimestamp="1576666505112" timestamp="1225139797" />
  <Command __id="197177" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Wed Jan 01 10:14:05 EST 2020" starttimestamp="1576666505112" timestamp="1225139959" />
  <Command __id="197179" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Wed Jan 01 10:14:05 EST 2020" starttimestamp="1576666505112" timestamp="1225140118" />
  <Command __id="197181" _type="InsertStringCommand" date="Wed Jan 01 10:14:05 EST 2020" starttimestamp="1576666505112" timestamp="1225140340" timestamp2="1225140340">
    <data><![CDATA[a]]></data>
  </Command>
  <Command __id="197183" _type="InsertStringCommand" date="Wed Jan 01 10:14:05 EST 2020" starttimestamp="1576666505112" timestamp="1225140636" timestamp2="1225140636">
    <data><![CDATA[d]]></data>
  </Command>
  <Command __id="197185" _type="InsertStringCommand" date="Wed Jan 01 10:14:05 EST 2020" starttimestamp="1576666505112" timestamp="1225140792" timestamp2="1225140792">
    <data><![CDATA[d]]></data>
  </Command>
  <DocumentChange __id="197144" _type="Insert" date="Wed Jan 01 10:14:00 EST 2020" docASTNodeCount="1" docActiveCodeLength="538" docExpressionCount="0" docLength="625" length="1" offset="198" starttimestamp="1576666505112" timestamp="1225135190">
    <text><![CDATA[o]]></text>
  </DocumentChange>
  <DocumentChange __id="197146" _type="Insert" date="Wed Jan 01 10:14:00 EST 2020" docASTNodeCount="1" docActiveCodeLength="539" docExpressionCount="0" docLength="626" length="1" offset="199" starttimestamp="1576666505112" timestamp="1225135426">
    <text><![CDATA[i]]></text>
  </DocumentChange>
  <DocumentChange __id="197148" _type="Insert" date="Wed Jan 01 10:14:01 EST 2020" docASTNodeCount="1" docActiveCodeLength="540" docExpressionCount="0" docLength="627" length="1" offset="200" starttimestamp="1576666505112" timestamp="1225136409">
    <text><![CDATA[d]]></text>
  </DocumentChange>
  <DocumentChange __id="197150" _type="Insert" date="Wed Jan 01 10:14:01 EST 2020" docASTNodeCount="1" docActiveCodeLength="541" docExpressionCount="0" docLength="628" length="1" offset="201" starttimestamp="1576666505112" timestamp="1225136736">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="197152" _type="Insert" date="Wed Jan 01 10:14:01 EST 2020" docASTNodeCount="1" docActiveCodeLength="542" docExpressionCount="0" docLength="629" length="1" offset="202" starttimestamp="1576666505112" timestamp="1225136885">
    <text><![CDATA[i]]></text>
  </DocumentChange>
  <DocumentChange __id="197154" _type="Insert" date="Wed Jan 01 10:14:02 EST 2020" docASTNodeCount="1" docActiveCodeLength="543" docExpressionCount="0" docLength="630" length="1" offset="203" starttimestamp="1576666505112" timestamp="1225137192">
    <text><![CDATA[n]]></text>
  </DocumentChange>
  <DocumentChange __id="197156" _type="Insert" date="Wed Jan 01 10:14:02 EST 2020" docASTNodeCount="1" docActiveCodeLength="544" docExpressionCount="0" docLength="631" length="1" offset="204" starttimestamp="1576666505112" timestamp="1225137415">
    <text><![CDATA[c]]></text>
  </DocumentChange>
  <DocumentChange __id="197158" _type="Insert" date="Wed Jan 01 10:14:03 EST 2020" docASTNodeCount="1" docActiveCodeLength="545" docExpressionCount="0" docLength="632" length="1" offset="205" starttimestamp="1576666505112" timestamp="1225138000">
    <text><![CDATA[r]]></text>
  </DocumentChange>
  <DocumentChange __id="197160" _type="Insert" date="Wed Jan 01 10:14:03 EST 2020" docASTNodeCount="1" docActiveCodeLength="546" docExpressionCount="0" docLength="633" length="1" offset="206" starttimestamp="1576666505112" timestamp="1225138118">
    <text><![CDATA[e]]></text>
  </DocumentChange>
  <DocumentChange __id="197162" _type="Insert" date="Wed Jan 01 10:14:03 EST 2020" docASTNodeCount="1" docActiveCodeLength="547" docExpressionCount="0" docLength="634" length="1" offset="207" starttimestamp="1576666505112" timestamp="1225138412">
    <text><![CDATA[e]]></text>
  </DocumentChange>
  <DocumentChange __id="197164" _type="Insert" date="Wed Jan 01 10:14:03 EST 2020" docASTNodeCount="1" docActiveCodeLength="548" docExpressionCount="0" docLength="635" length="1" offset="208" starttimestamp="1576666505112" timestamp="1225138565">
    <text><![CDATA[n]]></text>
  </DocumentChange>
  <DocumentChange __id="197166" _type="Delete" date="Wed Jan 01 10:14:04 EST 2020" docASTNodeCount="1" docActiveCodeLength="547" docExpressionCount="0" docLength="634" endLine="9" length="1" offset="208" startLine="9" starttimestamp="1576666505112" timestamp="1225139119">
    <text><![CDATA[n]]></text>
  </DocumentChange>
  <DocumentChange __id="197168" _type="Delete" date="Wed Jan 01 10:14:04 EST 2020" docASTNodeCount="1" docActiveCodeLength="546" docExpressionCount="0" docLength="633" endLine="9" length="1" offset="207" startLine="9" starttimestamp="1576666505112" timestamp="1225139290">
    <text><![CDATA[e]]></text>
  </DocumentChange>
  <DocumentChange __id="197170" _type="Delete" date="Wed Jan 01 10:14:04 EST 2020" docASTNodeCount="1" docActiveCodeLength="545" docExpressionCount="0" docLength="632" endLine="9" length="1" offset="206" startLine="9" starttimestamp="1576666505112" timestamp="1225139441">
    <text><![CDATA[e]]></text>
  </DocumentChange>
  <DocumentChange __id="197172" _type="Delete" date="Wed Jan 01 10:14:04 EST 2020" docASTNodeCount="1" docActiveCodeLength="544" docExpressionCount="0" docLength="631" endLine="9" length="1" offset="205" startLine="9" starttimestamp="1576666505112" timestamp="1225139619">
    <text><![CDATA[r]]></text>
  </DocumentChange>
  <DocumentChange __id="197174" _type="Delete" date="Wed Jan 01 10:14:04 EST 2020" docASTNodeCount="1" docActiveCodeLength="543" docExpressionCount="0" docLength="630" endLine="9" length="1" offset="204" startLine="9" starttimestamp="1576666505112" timestamp="1225139791">
    <text><![CDATA[c]]></text>
  </DocumentChange>
  <DocumentChange __id="197176" _type="Delete" date="Wed Jan 01 10:14:05 EST 2020" docASTNodeCount="1" docActiveCodeLength="542" docExpressionCount="0" docLength="629" endLine="9" length="1" offset="203" startLine="9" starttimestamp="1576666505112" timestamp="1225139954">
    <text><![CDATA[n]]></text>
  </DocumentChange>
  <DocumentChange __id="197178" _type="Delete" date="Wed Jan 01 10:14:05 EST 2020" docASTNodeCount="1" docActiveCodeLength="541" docExpressionCount="0" docLength="628" endLine="9" length="1" offset="202" startLine="9" starttimestamp="1576666505112" timestamp="1225140116">
    <text><![CDATA[i]]></text>
  </DocumentChange>
  <DocumentChange __id="197180" _type="Insert" date="Wed Jan 01 10:14:05 EST 2020" docASTNodeCount="1" docActiveCodeLength="542" docExpressionCount="0" docLength="629" length="1" offset="202" starttimestamp="1576666505112" timestamp="1225140337">
    <text><![CDATA[a]]></text>
  </DocumentChange>
  <DocumentChange __id="197182" _type="Insert" date="Wed Jan 01 10:14:05 EST 2020" docASTNodeCount="1" docActiveCodeLength="543" docExpressionCount="0" docLength="630" length="1" offset="203" starttimestamp="1576666505112" timestamp="1225140633">
    <text><![CDATA[d]]></text>
  </DocumentChange>
  <DocumentChange __id="197184" _type="Insert" date="Wed Jan 01 10:14:05 EST 2020" docASTNodeCount="1" docActiveCodeLength="544" docExpressionCount="0" docLength="631" length="1" offset="204" starttimestamp="1576666505112" timestamp="1225140788">
    <text><![CDATA[d]]></text>
  </DocumentChange>
  <DocumentChange __id="197186" _type="Insert" date="Wed Jan 01 10:14:06 EST 2020" docASTNodeCount="1" docActiveCodeLength="545" docExpressionCount="0" docLength="632" length="1" offset="205" starttimestamp="1576666505112" timestamp="1225141687">
    <text><![CDATA[T]]></text>
  </DocumentChange>
  <DocumentChange __id="197188" _type="Insert" date="Wed Jan 01 10:14:07 EST 2020" docASTNodeCount="1" docActiveCodeLength="546" docExpressionCount="0" docLength="633" length="1" offset="206" starttimestamp="1576666505112" timestamp="1225141966">
    <text><![CDATA[o]]></text>
  </DocumentChange>
  <DocumentChange __id="197190" _type="Insert" date="Wed Jan 01 10:14:07 EST 2020" docASTNodeCount="1" docActiveCodeLength="547" docExpressionCount="0" docLength="634" length="1" offset="207" starttimestamp="1576666505112" timestamp="1225142414">
    <text><![CDATA[S]]></text>
  </DocumentChange>
  <Command __id="197187" _type="InsertStringCommand" date="Wed Jan 01 10:14:06 EST 2020" starttimestamp="1576666505112" timestamp="1225141693" timestamp2="1225141693">
    <data><![CDATA[T]]></data>
  </Command>
  <Command __id="197189" _type="InsertStringCommand" date="Wed Jan 01 10:14:07 EST 2020" starttimestamp="1576666505112" timestamp="1225141974" timestamp2="1225141974">
    <data><![CDATA[o]]></data>
  </Command>
  <Command __id="197191" _type="InsertStringCommand" date="Wed Jan 01 10:14:07 EST 2020" starttimestamp="1576666505112" timestamp="1225142418" timestamp2="1225142418">
    <data><![CDATA[S]]></data>
  </Command>
  <Command __id="197193" _type="InsertStringCommand" date="Wed Jan 01 10:14:07 EST 2020" starttimestamp="1576666505112" timestamp="1225142650" timestamp2="1225142650">
    <data><![CDATA[u]]></data>
  </Command>
  <Command __id="197195" _type="InsertStringCommand" date="Wed Jan 01 10:14:08 EST 2020" starttimestamp="1576666505112" timestamp="1225142904" timestamp2="1225142904">
    <data><![CDATA[m]]></data>
  </Command>
  <Command __id="197197" _type="InsertStringCommand" date="Wed Jan 01 10:14:08 EST 2020" starttimestamp="1576666505112" timestamp="1225143843" timestamp2="1225143843">
    <data><![CDATA[(]]></data>
  </Command>
  <Command __id="197198" _type="ShellCommand" date="Wed Jan 01 10:14:09 EST 2020" starttimestamp="1576666505112" timestamp="1225144646" type="ECLIPSE_LOST_FOCUS" />
  <DocumentChange __id="197192" _type="Insert" date="Wed Jan 01 10:14:07 EST 2020" docASTNodeCount="1" docActiveCodeLength="548" docExpressionCount="0" docLength="635" length="1" offset="208" starttimestamp="1576666505112" timestamp="1225142642">
    <text><![CDATA[u]]></text>
  </DocumentChange>
  <DocumentChange __id="197194" _type="Insert" date="Wed Jan 01 10:14:08 EST 2020" docASTNodeCount="1" docActiveCodeLength="549" docExpressionCount="0" docLength="636" length="1" offset="209" starttimestamp="1576666505112" timestamp="1225142900">
    <text><![CDATA[m]]></text>
  </DocumentChange>
  <DocumentChange __id="197196" _type="Insert" date="Wed Jan 01 10:14:08 EST 2020" docASTNodeCount="1" docActiveCodeLength="551" docExpressionCount="0" docLength="638" length="2" offset="210" starttimestamp="1576666505112" timestamp="1225143837">
    <text><![CDATA[()]]></text>
  </DocumentChange>
  <DocumentChange __id="197200" _type="Insert" date="Wed Jan 01 10:14:13 EST 2020" docASTNodeCount="1" docActiveCodeLength="552" docExpressionCount="0" docLength="639" length="1" offset="211" starttimestamp="1576666505112" timestamp="1225148089">
    <text><![CDATA[i]]></text>
  </DocumentChange>
  <DocumentChange __id="197202" _type="Insert" date="Wed Jan 01 10:14:13 EST 2020" docASTNodeCount="1" docActiveCodeLength="553" docExpressionCount="0" docLength="640" length="1" offset="212" starttimestamp="1576666505112" timestamp="1225148347">
    <text><![CDATA[n]]></text>
  </DocumentChange>
  <DocumentChange __id="197204" _type="Insert" date="Wed Jan 01 10:14:13 EST 2020" docASTNodeCount="1" docActiveCodeLength="554" docExpressionCount="0" docLength="641" length="1" offset="213" starttimestamp="1576666505112" timestamp="1225148425">
    <text><![CDATA[t]]></text>
  </DocumentChange>
  <DocumentChange __id="197206" _type="Insert" date="Wed Jan 01 10:14:14 EST 2020" docASTNodeCount="1" docActiveCodeLength="555" docExpressionCount="0" docLength="642" length="1" offset="214" starttimestamp="1576666505112" timestamp="1225149174">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="197208" _type="Insert" date="Wed Jan 01 10:14:15 EST 2020" docASTNodeCount="1" docActiveCodeLength="556" docExpressionCount="0" docLength="643" length="1" offset="215" starttimestamp="1576666505112" timestamp="1225150801">
    <text><![CDATA[*]]></text>
  </DocumentChange>
  <Command __id="197199" _type="ShellCommand" date="Wed Jan 01 10:14:12 EST 2020" starttimestamp="1576666505112" timestamp="1225147119" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="197201" _type="InsertStringCommand" date="Wed Jan 01 10:14:13 EST 2020" starttimestamp="1576666505112" timestamp="1225148096" timestamp2="1225148096">
    <data><![CDATA[i]]></data>
  </Command>
  <Command __id="197203" _type="InsertStringCommand" date="Wed Jan 01 10:14:13 EST 2020" starttimestamp="1576666505112" timestamp="1225148351" timestamp2="1225148351">
    <data><![CDATA[n]]></data>
  </Command>
  <Command __id="197205" _type="InsertStringCommand" date="Wed Jan 01 10:14:13 EST 2020" starttimestamp="1576666505112" timestamp="1225148428" timestamp2="1225148428">
    <data><![CDATA[t]]></data>
  </Command>
  <Command __id="197207" _type="InsertStringCommand" date="Wed Jan 01 10:14:14 EST 2020" starttimestamp="1576666505112" timestamp="1225149176" timestamp2="1225149176">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="197209" _type="InsertStringCommand" date="Wed Jan 01 10:14:15 EST 2020" starttimestamp="1576666505112" timestamp="1225150805" timestamp2="1225150805">
    <data><![CDATA[*]]></data>
  </Command>
  <Command __id="197211" _type="InsertStringCommand" date="Wed Jan 01 10:14:19 EST 2020" starttimestamp="1576666505112" timestamp="1225153919" timestamp2="1225153919">
    <data><![CDATA[a]]></data>
  </Command>
  <Command __id="197212" _type="MoveCaretCommand" caretOffset="210" date="Wed Jan 01 10:14:21 EST 2020" docOffset="210" starttimestamp="1576666505112" timestamp="1225156251" />
  <Command __id="197214" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Wed Jan 01 10:14:21 EST 2020" starttimestamp="1576666505112" timestamp="1225156751" />
  <Command __id="197216" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Wed Jan 01 10:14:22 EST 2020" starttimestamp="1576666505112" timestamp="1225156938" />
  <Command __id="197218" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Wed Jan 01 10:14:22 EST 2020" starttimestamp="1576666505112" timestamp="1225157131" />
  <Command __id="197220" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Wed Jan 01 10:14:22 EST 2020" starttimestamp="1576666505112" timestamp="1225157299" />
  <Command __id="197222" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Wed Jan 01 10:14:22 EST 2020" starttimestamp="1576666505112" timestamp="1225157520" />
  <DocumentChange __id="197210" _type="Insert" date="Wed Jan 01 10:14:19 EST 2020" docASTNodeCount="1" docActiveCodeLength="557" docExpressionCount="0" docLength="644" length="1" offset="216" starttimestamp="1576666505112" timestamp="1225153916">
    <text><![CDATA[a]]></text>
  </DocumentChange>
  <DocumentChange __id="197213" _type="Delete" date="Wed Jan 01 10:14:21 EST 2020" docASTNodeCount="1" docActiveCodeLength="556" docExpressionCount="0" docLength="643" endLine="9" length="1" offset="209" startLine="9" starttimestamp="1576666505112" timestamp="1225156748">
    <text><![CDATA[m]]></text>
  </DocumentChange>
  <DocumentChange __id="197215" _type="Delete" date="Wed Jan 01 10:14:22 EST 2020" docASTNodeCount="1" docActiveCodeLength="555" docExpressionCount="0" docLength="642" endLine="9" length="1" offset="208" startLine="9" starttimestamp="1576666505112" timestamp="1225156934">
    <text><![CDATA[u]]></text>
  </DocumentChange>
  <DocumentChange __id="197217" _type="Delete" date="Wed Jan 01 10:14:22 EST 2020" docASTNodeCount="1" docActiveCodeLength="554" docExpressionCount="0" docLength="641" endLine="9" length="1" offset="207" startLine="9" starttimestamp="1576666505112" timestamp="1225157126">
    <text><![CDATA[S]]></text>
  </DocumentChange>
  <DocumentChange __id="197219" _type="Delete" date="Wed Jan 01 10:14:22 EST 2020" docASTNodeCount="1" docActiveCodeLength="553" docExpressionCount="0" docLength="640" endLine="9" length="1" offset="206" startLine="9" starttimestamp="1576666505112" timestamp="1225157297">
    <text><![CDATA[o]]></text>
  </DocumentChange>
  <DocumentChange __id="197221" _type="Delete" date="Wed Jan 01 10:14:22 EST 2020" docASTNodeCount="1" docActiveCodeLength="552" docExpressionCount="0" docLength="639" endLine="9" length="1" offset="205" startLine="9" starttimestamp="1576666505112" timestamp="1225157518">
    <text><![CDATA[T]]></text>
  </DocumentChange>
  <DocumentChange __id="197224" _type="Delete" date="Wed Jan 01 10:14:26 EST 2020" docASTNodeCount="1" docActiveCodeLength="551" docExpressionCount="0" docLength="638" endLine="9" length="1" offset="211" startLine="9" starttimestamp="1576666505112" timestamp="1225161134">
    <text><![CDATA[a]]></text>
  </DocumentChange>
  <DocumentChange __id="197226" _type="Insert" date="Wed Jan 01 10:14:26 EST 2020" docASTNodeCount="1" docActiveCodeLength="552" docExpressionCount="0" docLength="639" length="1" offset="211" starttimestamp="1576666505112" timestamp="1225161506">
    <text><![CDATA[f]]></text>
  </DocumentChange>
  <DocumentChange __id="197228" _type="Insert" date="Wed Jan 01 10:14:26 EST 2020" docASTNodeCount="1" docActiveCodeLength="553" docExpressionCount="0" docLength="640" length="1" offset="212" starttimestamp="1576666505112" timestamp="1225161657">
    <text><![CDATA[i]]></text>
  </DocumentChange>
  <DocumentChange __id="197230" _type="Insert" date="Wed Jan 01 10:14:26 EST 2020" docASTNodeCount="1" docActiveCodeLength="554" docExpressionCount="0" docLength="641" length="1" offset="213" starttimestamp="1576666505112" timestamp="1225161775">
    <text><![CDATA[r]]></text>
  </DocumentChange>
  <DocumentChange __id="197232" _type="Insert" date="Wed Jan 01 10:14:27 EST 2020" docASTNodeCount="1" docActiveCodeLength="555" docExpressionCount="0" docLength="642" length="1" offset="214" starttimestamp="1576666505112" timestamp="1225162023">
    <text><![CDATA[s]]></text>
  </DocumentChange>
  <DocumentChange __id="197234" _type="Insert" date="Wed Jan 01 10:14:27 EST 2020" docASTNodeCount="1" docActiveCodeLength="556" docExpressionCount="0" docLength="643" length="1" offset="215" starttimestamp="1576666505112" timestamp="1225162169">
    <text><![CDATA[t]]></text>
  </DocumentChange>
  <DocumentChange __id="197236" _type="Delete" date="Wed Jan 01 10:14:28 EST 2020" docASTNodeCount="1" docActiveCodeLength="555" docExpressionCount="0" docLength="642" endLine="9" length="1" offset="215" startLine="9" starttimestamp="1576666505112" timestamp="1225163163">
    <text><![CDATA[t]]></text>
  </DocumentChange>
  <DocumentChange __id="197238" _type="Delete" date="Wed Jan 01 10:14:28 EST 2020" docASTNodeCount="1" docActiveCodeLength="554" docExpressionCount="0" docLength="641" endLine="9" length="1" offset="214" startLine="9" starttimestamp="1576666505112" timestamp="1225163330">
    <text><![CDATA[s]]></text>
  </DocumentChange>
  <DocumentChange __id="197240" _type="Delete" date="Wed Jan 01 10:14:28 EST 2020" docASTNodeCount="1" docActiveCodeLength="553" docExpressionCount="0" docLength="640" endLine="9" length="1" offset="213" startLine="9" starttimestamp="1576666505112" timestamp="1225163501">
    <text><![CDATA[r]]></text>
  </DocumentChange>
  <DocumentChange __id="197242" _type="Delete" date="Wed Jan 01 10:14:28 EST 2020" docASTNodeCount="1" docActiveCodeLength="552" docExpressionCount="0" docLength="639" endLine="9" length="1" offset="212" startLine="9" starttimestamp="1576666505112" timestamp="1225163664">
    <text><![CDATA[i]]></text>
  </DocumentChange>
  <DocumentChange __id="197244" _type="Delete" date="Wed Jan 01 10:14:28 EST 2020" docASTNodeCount="1" docActiveCodeLength="551" docExpressionCount="0" docLength="638" endLine="9" length="1" offset="211" startLine="9" starttimestamp="1576666505112" timestamp="1225163859">
    <text><![CDATA[f]]></text>
  </DocumentChange>
  <DocumentChange __id="197246" _type="Insert" date="Wed Jan 01 10:14:29 EST 2020" docASTNodeCount="1" docActiveCodeLength="552" docExpressionCount="0" docLength="639" length="1" offset="211" starttimestamp="1576666505112" timestamp="1225164214">
    <text><![CDATA[a]]></text>
  </DocumentChange>
  <Command __id="197223" _type="MoveCaretCommand" caretOffset="212" date="Wed Jan 01 10:14:25 EST 2020" docOffset="212" starttimestamp="1576666505112" timestamp="1225160665" />
  <Command __id="197225" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Wed Jan 01 10:14:26 EST 2020" starttimestamp="1576666505112" timestamp="1225161137" />
  <Command __id="197227" _type="InsertStringCommand" date="Wed Jan 01 10:14:26 EST 2020" starttimestamp="1576666505112" timestamp="1225161509" timestamp2="1225161509">
    <data><![CDATA[f]]></data>
  </Command>
  <Command __id="197229" _type="InsertStringCommand" date="Wed Jan 01 10:14:26 EST 2020" starttimestamp="1576666505112" timestamp="1225161661" timestamp2="1225161661">
    <data><![CDATA[i]]></data>
  </Command>
  <Command __id="197231" _type="InsertStringCommand" date="Wed Jan 01 10:14:26 EST 2020" starttimestamp="1576666505112" timestamp="1225161779" timestamp2="1225161779">
    <data><![CDATA[r]]></data>
  </Command>
  <Command __id="197233" _type="InsertStringCommand" date="Wed Jan 01 10:14:27 EST 2020" starttimestamp="1576666505112" timestamp="1225162027" timestamp2="1225162027">
    <data><![CDATA[s]]></data>
  </Command>
  <Command __id="197235" _type="InsertStringCommand" date="Wed Jan 01 10:14:27 EST 2020" starttimestamp="1576666505112" timestamp="1225162174" timestamp2="1225162174">
    <data><![CDATA[t]]></data>
  </Command>
  <Command __id="197237" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Wed Jan 01 10:14:28 EST 2020" starttimestamp="1576666505112" timestamp="1225163165" />
  <Command __id="197239" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Wed Jan 01 10:14:28 EST 2020" starttimestamp="1576666505112" timestamp="1225163332" />
  <Command __id="197241" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Wed Jan 01 10:14:28 EST 2020" starttimestamp="1576666505112" timestamp="1225163508" />
  <Command __id="197243" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Wed Jan 01 10:14:28 EST 2020" starttimestamp="1576666505112" timestamp="1225163666" />
  <Command __id="197245" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Wed Jan 01 10:14:28 EST 2020" starttimestamp="1576666505112" timestamp="1225163862" />
  <Command __id="197247" _type="InsertStringCommand" date="Wed Jan 01 10:14:29 EST 2020" starttimestamp="1576666505112" timestamp="1225164218" timestamp2="1225164218">
    <data><![CDATA[a]]></data>
  </Command>
  <Command __id="197249" _type="InsertStringCommand" date="Wed Jan 01 10:14:30 EST 2020" starttimestamp="1576666505112" timestamp="1225165311" timestamp2="1225165311">
    <data><![CDATA[1]]></data>
  </Command>
  <Command __id="197251" _type="InsertStringCommand" date="Wed Jan 01 10:14:30 EST 2020" starttimestamp="1576666505112" timestamp="1225165617" timestamp2="1225165617">
    <data><![CDATA[,]]></data>
  </Command>
  <Command __id="197253" _type="InsertStringCommand" date="Wed Jan 01 10:14:30 EST 2020" starttimestamp="1576666505112" timestamp="1225165763" timestamp2="1225165763">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="197255" _type="InsertStringCommand" date="Wed Jan 01 10:14:31 EST 2020" starttimestamp="1576666505112" timestamp="1225165913" timestamp2="1225165913">
    <data><![CDATA[i]]></data>
  </Command>
  <Command __id="197257" _type="InsertStringCommand" date="Wed Jan 01 10:14:31 EST 2020" starttimestamp="1576666505112" timestamp="1225166167" timestamp2="1225166167">
    <data><![CDATA[n]]></data>
  </Command>
  <Command __id="197259" _type="InsertStringCommand" date="Wed Jan 01 10:14:31 EST 2020" starttimestamp="1576666505112" timestamp="1225166280" timestamp2="1225166280">
    <data><![CDATA[t]]></data>
  </Command>
  <Command __id="197261" _type="InsertStringCommand" date="Wed Jan 01 10:14:31 EST 2020" starttimestamp="1576666505112" timestamp="1225166841" timestamp2="1225166841">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="197263" _type="InsertStringCommand" date="Wed Jan 01 10:14:32 EST 2020" starttimestamp="1576666505112" timestamp="1225167194" timestamp2="1225167194">
    <data><![CDATA[i]]></data>
  </Command>
  <Command __id="197265" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Wed Jan 01 10:14:32 EST 2020" starttimestamp="1576666505112" timestamp="1225167731" />
  <Command __id="197267" _type="InsertStringCommand" date="Wed Jan 01 10:14:32 EST 2020" starttimestamp="1576666505112" timestamp="1225167853" timestamp2="1225167853">
    <data><![CDATA[a]]></data>
  </Command>
  <Command __id="197269" _type="InsertStringCommand" date="Wed Jan 01 10:14:33 EST 2020" starttimestamp="1576666505112" timestamp="1225168086" timestamp2="1225168086">
    <data><![CDATA[n]]></data>
  </Command>
  <DocumentChange __id="197248" _type="Insert" date="Wed Jan 01 10:14:30 EST 2020" docASTNodeCount="1" docActiveCodeLength="553" docExpressionCount="0" docLength="640" length="1" offset="212" starttimestamp="1576666505112" timestamp="1225165305">
    <text><![CDATA[1]]></text>
  </DocumentChange>
  <DocumentChange __id="197250" _type="Insert" date="Wed Jan 01 10:14:30 EST 2020" docASTNodeCount="1" docActiveCodeLength="554" docExpressionCount="0" docLength="641" length="1" offset="213" starttimestamp="1576666505112" timestamp="1225165614">
    <text><![CDATA[,]]></text>
  </DocumentChange>
  <DocumentChange __id="197252" _type="Insert" date="Wed Jan 01 10:14:30 EST 2020" docASTNodeCount="1" docActiveCodeLength="555" docExpressionCount="0" docLength="642" length="1" offset="214" starttimestamp="1576666505112" timestamp="1225165759">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="197254" _type="Insert" date="Wed Jan 01 10:14:31 EST 2020" docASTNodeCount="1" docActiveCodeLength="556" docExpressionCount="0" docLength="643" length="1" offset="215" starttimestamp="1576666505112" timestamp="1225165909">
    <text><![CDATA[i]]></text>
  </DocumentChange>
  <DocumentChange __id="197256" _type="Insert" date="Wed Jan 01 10:14:31 EST 2020" docASTNodeCount="1" docActiveCodeLength="557" docExpressionCount="0" docLength="644" length="1" offset="216" starttimestamp="1576666505112" timestamp="1225166161">
    <text><![CDATA[n]]></text>
  </DocumentChange>
  <DocumentChange __id="197258" _type="Insert" date="Wed Jan 01 10:14:31 EST 2020" docASTNodeCount="1" docActiveCodeLength="558" docExpressionCount="0" docLength="645" length="1" offset="217" starttimestamp="1576666505112" timestamp="1225166276">
    <text><![CDATA[t]]></text>
  </DocumentChange>
  <DocumentChange __id="197260" _type="Insert" date="Wed Jan 01 10:14:31 EST 2020" docASTNodeCount="1" docActiveCodeLength="559" docExpressionCount="0" docLength="646" length="1" offset="218" starttimestamp="1576666505112" timestamp="1225166839">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="197262" _type="Insert" date="Wed Jan 01 10:14:32 EST 2020" docASTNodeCount="1" docActiveCodeLength="560" docExpressionCount="0" docLength="647" length="1" offset="219" starttimestamp="1576666505112" timestamp="1225167189">
    <text><![CDATA[i]]></text>
  </DocumentChange>
  <DocumentChange __id="197264" _type="Delete" date="Wed Jan 01 10:14:32 EST 2020" docASTNodeCount="1" docActiveCodeLength="559" docExpressionCount="0" docLength="646" endLine="9" length="1" offset="219" startLine="9" starttimestamp="1576666505112" timestamp="1225167728">
    <text><![CDATA[i]]></text>
  </DocumentChange>
  <DocumentChange __id="197266" _type="Insert" date="Wed Jan 01 10:14:32 EST 2020" docASTNodeCount="1" docActiveCodeLength="560" docExpressionCount="0" docLength="647" length="1" offset="219" starttimestamp="1576666505112" timestamp="1225167850">
    <text><![CDATA[a]]></text>
  </DocumentChange>
  <DocumentChange __id="197268" _type="Insert" date="Wed Jan 01 10:14:33 EST 2020" docASTNodeCount="1" docActiveCodeLength="561" docExpressionCount="0" docLength="648" length="1" offset="220" starttimestamp="1576666505112" timestamp="1225168081">
    <text><![CDATA[n]]></text>
  </DocumentChange>
  <DocumentChange __id="197270" _type="Insert" date="Wed Jan 01 10:14:33 EST 2020" docASTNodeCount="1" docActiveCodeLength="562" docExpressionCount="0" docLength="649" length="1" offset="221" starttimestamp="1576666505112" timestamp="1225168442">
    <text><![CDATA[I]]></text>
  </DocumentChange>
  <DocumentChange __id="197272" _type="Insert" date="Wed Jan 01 10:14:33 EST 2020" docASTNodeCount="1" docActiveCodeLength="563" docExpressionCount="0" docLength="650" length="1" offset="222" starttimestamp="1576666505112" timestamp="1225168716">
    <text><![CDATA[n]]></text>
  </DocumentChange>
  <DocumentChange __id="197274" _type="Insert" date="Wed Jan 01 10:14:33 EST 2020" docASTNodeCount="1" docActiveCodeLength="564" docExpressionCount="0" docLength="651" length="1" offset="223" starttimestamp="1576666505112" timestamp="1225168752">
    <text><![CDATA[b]]></text>
  </DocumentChange>
  <DocumentChange __id="197276" _type="Insert" date="Wed Jan 01 10:14:34 EST 2020" docASTNodeCount="1" docActiveCodeLength="565" docExpressionCount="0" docLength="652" length="1" offset="224" starttimestamp="1576666505112" timestamp="1225168985">
    <text><![CDATA[c]]></text>
  </DocumentChange>
  <DocumentChange __id="197278" _type="Insert" date="Wed Jan 01 10:14:34 EST 2020" docASTNodeCount="1" docActiveCodeLength="566" docExpressionCount="0" docLength="653" length="1" offset="225" starttimestamp="1576666505112" timestamp="1225169224">
    <text><![CDATA[r]]></text>
  </DocumentChange>
  <DocumentChange __id="197280" _type="Insert" date="Wed Jan 01 10:14:34 EST 2020" docASTNodeCount="1" docActiveCodeLength="567" docExpressionCount="0" docLength="654" length="1" offset="226" starttimestamp="1576666505112" timestamp="1225169351">
    <text><![CDATA[e]]></text>
  </DocumentChange>
  <DocumentChange __id="197282" _type="Delete" date="Wed Jan 01 10:14:34 EST 2020" docASTNodeCount="1" docActiveCodeLength="566" docExpressionCount="0" docLength="653" endLine="9" length="1" offset="226" startLine="9" starttimestamp="1576666505112" timestamp="1225169654">
    <text><![CDATA[e]]></text>
  </DocumentChange>
  <DocumentChange __id="197284" _type="Delete" date="Wed Jan 01 10:14:34 EST 2020" docASTNodeCount="1" docActiveCodeLength="565" docExpressionCount="0" docLength="652" endLine="9" length="1" offset="225" startLine="9" starttimestamp="1576666505112" timestamp="1225169800">
    <text><![CDATA[r]]></text>
  </DocumentChange>
  <DocumentChange __id="197286" _type="Delete" date="Wed Jan 01 10:14:35 EST 2020" docASTNodeCount="1" docActiveCodeLength="564" docExpressionCount="0" docLength="651" endLine="9" length="1" offset="224" startLine="9" starttimestamp="1576666505112" timestamp="1225169962">
    <text><![CDATA[c]]></text>
  </DocumentChange>
  <DocumentChange __id="197288" _type="Delete" date="Wed Jan 01 10:14:35 EST 2020" docASTNodeCount="1" docActiveCodeLength="563" docExpressionCount="0" docLength="650" endLine="9" length="1" offset="223" startLine="9" starttimestamp="1576666505112" timestamp="1225170126">
    <text><![CDATA[b]]></text>
  </DocumentChange>
  <DocumentChange __id="197290" _type="Insert" date="Wed Jan 01 10:14:36 EST 2020" docASTNodeCount="1" docActiveCodeLength="564" docExpressionCount="0" docLength="651" length="1" offset="223" starttimestamp="1576666505112" timestamp="1225170916">
    <text><![CDATA[c]]></text>
  </DocumentChange>
  <DocumentChange __id="197292" _type="Insert" date="Wed Jan 01 10:14:36 EST 2020" docASTNodeCount="1" docActiveCodeLength="565" docExpressionCount="0" docLength="652" length="1" offset="224" starttimestamp="1576666505112" timestamp="1225171169">
    <text><![CDATA[r]]></text>
  </DocumentChange>
  <DocumentChange __id="197294" _type="Insert" date="Wed Jan 01 10:14:36 EST 2020" docASTNodeCount="1" docActiveCodeLength="566" docExpressionCount="0" docLength="653" length="1" offset="225" starttimestamp="1576666505112" timestamp="1225171344">
    <text><![CDATA[e]]></text>
  </DocumentChange>
  <Command __id="197271" _type="InsertStringCommand" date="Wed Jan 01 10:14:33 EST 2020" starttimestamp="1576666505112" timestamp="1225168445" timestamp2="1225168445">
    <data><![CDATA[I]]></data>
  </Command>
  <Command __id="197273" _type="InsertStringCommand" date="Wed Jan 01 10:14:33 EST 2020" starttimestamp="1576666505112" timestamp="1225168725" timestamp2="1225168725">
    <data><![CDATA[n]]></data>
  </Command>
  <Command __id="197275" _type="InsertStringCommand" date="Wed Jan 01 10:14:33 EST 2020" starttimestamp="1576666505112" timestamp="1225168757" timestamp2="1225168757">
    <data><![CDATA[b]]></data>
  </Command>
  <Command __id="197277" _type="InsertStringCommand" date="Wed Jan 01 10:14:34 EST 2020" starttimestamp="1576666505112" timestamp="1225168990" timestamp2="1225168990">
    <data><![CDATA[c]]></data>
  </Command>
  <Command __id="197279" _type="InsertStringCommand" date="Wed Jan 01 10:14:34 EST 2020" starttimestamp="1576666505112" timestamp="1225169228" timestamp2="1225169228">
    <data><![CDATA[r]]></data>
  </Command>
  <Command __id="197281" _type="InsertStringCommand" date="Wed Jan 01 10:14:34 EST 2020" starttimestamp="1576666505112" timestamp="1225169354" timestamp2="1225169354">
    <data><![CDATA[e]]></data>
  </Command>
  <Command __id="197283" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Wed Jan 01 10:14:34 EST 2020" starttimestamp="1576666505112" timestamp="1225169656" />
  <Command __id="197285" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Wed Jan 01 10:14:34 EST 2020" starttimestamp="1576666505112" timestamp="1225169802" />
  <Command __id="197287" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Wed Jan 01 10:14:35 EST 2020" starttimestamp="1576666505112" timestamp="1225169965" />
  <Command __id="197289" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Wed Jan 01 10:14:35 EST 2020" starttimestamp="1576666505112" timestamp="1225170128" />
  <Command __id="197291" _type="InsertStringCommand" date="Wed Jan 01 10:14:36 EST 2020" starttimestamp="1576666505112" timestamp="1225170919" timestamp2="1225170919">
    <data><![CDATA[c]]></data>
  </Command>
  <Command __id="197293" _type="InsertStringCommand" date="Wed Jan 01 10:14:36 EST 2020" starttimestamp="1576666505112" timestamp="1225171180" timestamp2="1225171180">
    <data><![CDATA[r]]></data>
  </Command>
  <Command __id="197295" _type="InsertStringCommand" date="Wed Jan 01 10:14:36 EST 2020" starttimestamp="1576666505112" timestamp="1225171350" timestamp2="1225171350">
    <data><![CDATA[e]]></data>
  </Command>
  <Command __id="197297" _type="InsertStringCommand" date="Wed Jan 01 10:14:36 EST 2020" starttimestamp="1576666505112" timestamp="1225171511" timestamp2="1225171511">
    <data><![CDATA[m]]></data>
  </Command>
  <Command __id="197299" _type="InsertStringCommand" date="Wed Jan 01 10:14:36 EST 2020" starttimestamp="1576666505112" timestamp="1225171606" timestamp2="1225171606">
    <data><![CDATA[e]]></data>
  </Command>
  <Command __id="197301" _type="InsertStringCommand" date="Wed Jan 01 10:14:36 EST 2020" starttimestamp="1576666505112" timestamp="1225171717" timestamp2="1225171717">
    <data><![CDATA[n]]></data>
  </Command>
  <Command __id="197303" _type="InsertStringCommand" date="Wed Jan 01 10:14:37 EST 2020" starttimestamp="1576666505112" timestamp="1225171984" timestamp2="1225171984">
    <data><![CDATA[t]]></data>
  </Command>
  <Command __id="197304" _type="MoveCaretCommand" caretOffset="213" date="Wed Jan 01 10:14:38 EST 2020" docOffset="213" starttimestamp="1576666505112" timestamp="1225173296" />
  <Command __id="197306" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Wed Jan 01 10:14:38 EST 2020" starttimestamp="1576666505112" timestamp="1225173770" />
  <Command __id="197308" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Wed Jan 01 10:14:39 EST 2020" starttimestamp="1576666505112" timestamp="1225173923" />
  <Command __id="197310" _type="InsertStringCommand" date="Wed Jan 01 10:14:39 EST 2020" starttimestamp="1576666505112" timestamp="1225174796" timestamp2="1225174796">
    <data><![CDATA[p]]></data>
  </Command>
  <Command __id="197311" _type="MoveCaretCommand" caretOffset="230" date="Wed Jan 01 10:14:41 EST 2020" docOffset="230" starttimestamp="1576666505112" timestamp="1225176637" />
  <Command __id="197312" _type="MoveCaretCommand" caretOffset="203" date="Wed Jan 01 10:14:43 EST 2020" docOffset="203" starttimestamp="1576666505112" timestamp="1225178840" />
  <Command __id="197313" _type="SelectTextCommand" caretOffset="205" date="Wed Jan 01 10:14:44 EST 2020" end="205" start="202" starttimestamp="1576666505112" timestamp="1225179090" />
  <DocumentChange __id="197296" _type="Insert" date="Wed Jan 01 10:14:36 EST 2020" docASTNodeCount="1" docActiveCodeLength="567" docExpressionCount="0" docLength="654" length="1" offset="226" starttimestamp="1576666505112" timestamp="1225171502">
    <text><![CDATA[m]]></text>
  </DocumentChange>
  <DocumentChange __id="197298" _type="Insert" date="Wed Jan 01 10:14:36 EST 2020" docASTNodeCount="1" docActiveCodeLength="568" docExpressionCount="0" docLength="655" length="1" offset="227" starttimestamp="1576666505112" timestamp="1225171602">
    <text><![CDATA[e]]></text>
  </DocumentChange>
  <DocumentChange __id="197300" _type="Insert" date="Wed Jan 01 10:14:36 EST 2020" docASTNodeCount="1" docActiveCodeLength="569" docExpressionCount="0" docLength="656" length="1" offset="228" starttimestamp="1576666505112" timestamp="1225171714">
    <text><![CDATA[n]]></text>
  </DocumentChange>
  <DocumentChange __id="197302" _type="Insert" date="Wed Jan 01 10:14:37 EST 2020" docASTNodeCount="1" docActiveCodeLength="570" docExpressionCount="0" docLength="657" length="1" offset="229" starttimestamp="1576666505112" timestamp="1225171979">
    <text><![CDATA[t]]></text>
  </DocumentChange>
  <DocumentChange __id="197305" _type="Delete" date="Wed Jan 01 10:14:38 EST 2020" docASTNodeCount="1" docActiveCodeLength="569" docExpressionCount="0" docLength="656" endLine="9" length="1" offset="212" startLine="9" starttimestamp="1576666505112" timestamp="1225173766">
    <text><![CDATA[1]]></text>
  </DocumentChange>
  <DocumentChange __id="197307" _type="Delete" date="Wed Jan 01 10:14:39 EST 2020" docASTNodeCount="1" docActiveCodeLength="568" docExpressionCount="0" docLength="655" endLine="9" length="1" offset="211" startLine="9" starttimestamp="1576666505112" timestamp="1225173916">
    <text><![CDATA[a]]></text>
  </DocumentChange>
  <DocumentChange __id="197309" _type="Insert" date="Wed Jan 01 10:14:39 EST 2020" docASTNodeCount="1" docActiveCodeLength="569" docExpressionCount="0" docLength="656" length="1" offset="211" starttimestamp="1576666505112" timestamp="1225174792">
    <text><![CDATA[p]]></text>
  </DocumentChange>
  <DocumentChange __id="197315" _type="Insert" date="Wed Jan 01 10:14:45 EST 2020" docASTNodeCount="1" docActiveCodeLength="570" docExpressionCount="0" docLength="657" length="1" offset="230" starttimestamp="1576666505112" timestamp="1225180834">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="197317" _type="Insert" date="Wed Jan 01 10:14:46 EST 2020" docASTNodeCount="1" docActiveCodeLength="571" docExpressionCount="0" docLength="658" length="1" offset="231" starttimestamp="1576666505112" timestamp="1225181548">
    <text><![CDATA[{]]></text>
  </DocumentChange>
  <DocumentChange __id="197319" _type="Insert" date="Wed Jan 01 10:14:46 EST 2020" docASTNodeCount="1" docActiveCodeLength="575" docExpressionCount="0" docLength="662" length="4" offset="232" starttimestamp="1576666505112" timestamp="1225181824">
    <text><![CDATA[
	
}]]></text>
  </DocumentChange>
  <DocumentChange __id="197321" _type="Insert" date="Wed Jan 01 10:14:51 EST 2020" docASTNodeCount="1" docActiveCodeLength="576" docExpressionCount="0" docLength="663" length="1" offset="234" starttimestamp="1576666505112" timestamp="1225186081">
    <text><![CDATA[*]]></text>
  </DocumentChange>
  <DocumentChange __id="197323" _type="Insert" date="Wed Jan 01 10:14:52 EST 2020" docASTNodeCount="1" docActiveCodeLength="577" docExpressionCount="0" docLength="664" length="1" offset="235" starttimestamp="1576666505112" timestamp="1225187372">
    <text><![CDATA[p]]></text>
  </DocumentChange>
  <DocumentChange __id="197325" _type="Insert" date="Wed Jan 01 10:14:52 EST 2020" docASTNodeCount="1" docActiveCodeLength="578" docExpressionCount="0" docLength="665" length="1" offset="236" starttimestamp="1576666505112" timestamp="1225187787">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="197327" _type="Insert" date="Wed Jan 01 10:14:53 EST 2020" docASTNodeCount="1" docActiveCodeLength="579" docExpressionCount="0" docLength="666" length="1" offset="237" starttimestamp="1576666505112" timestamp="1225188841">
    <text><![CDATA[=]]></text>
  </DocumentChange>
  <DocumentChange __id="197329" _type="Insert" date="Wed Jan 01 10:14:54 EST 2020" docASTNodeCount="1" docActiveCodeLength="580" docExpressionCount="0" docLength="667" length="1" offset="238" starttimestamp="1576666505112" timestamp="1225189343">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="197331" _type="Insert" date="Wed Jan 01 10:14:55 EST 2020" docASTNodeCount="1" docActiveCodeLength="581" docExpressionCount="0" docLength="668" length="1" offset="239" starttimestamp="1576666505112" timestamp="1225190674">
    <text><![CDATA[*]]></text>
  </DocumentChange>
  <DocumentChange __id="197333" _type="Insert" date="Wed Jan 01 10:14:56 EST 2020" docASTNodeCount="1" docActiveCodeLength="582" docExpressionCount="0" docLength="669" length="1" offset="240" starttimestamp="1576666505112" timestamp="1225191261">
    <text><![CDATA[p]]></text>
  </DocumentChange>
  <DocumentChange __id="197335" _type="Insert" date="Wed Jan 01 10:14:56 EST 2020" docASTNodeCount="1" docActiveCodeLength="583" docExpressionCount="0" docLength="670" length="1" offset="241" starttimestamp="1576666505112" timestamp="1225191619">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <Command __id="197314" _type="MoveCaretCommand" caretOffset="230" date="Wed Jan 01 10:14:45 EST 2020" docOffset="230" starttimestamp="1576666505112" timestamp="1225180563" />
  <Command __id="197316" _type="InsertStringCommand" date="Wed Jan 01 10:14:45 EST 2020" starttimestamp="1576666505112" timestamp="1225180838" timestamp2="1225180838">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="197318" _type="InsertStringCommand" date="Wed Jan 01 10:14:46 EST 2020" starttimestamp="1576666505112" timestamp="1225181550" timestamp2="1225181550">
    <data><![CDATA[{]]></data>
  </Command>
  <Command __id="197320" _type="InsertStringCommand" date="Wed Jan 01 10:14:46 EST 2020" starttimestamp="1576666505112" timestamp="1225181828" timestamp2="1225181828">
    <data><![CDATA[]]></data>
  </Command>
  <Command __id="197322" _type="InsertStringCommand" date="Wed Jan 01 10:14:51 EST 2020" starttimestamp="1576666505112" timestamp="1225186084" timestamp2="1225186084">
    <data><![CDATA[*]]></data>
  </Command>
  <Command __id="197324" _type="InsertStringCommand" date="Wed Jan 01 10:14:52 EST 2020" starttimestamp="1576666505112" timestamp="1225187375" timestamp2="1225187375">
    <data><![CDATA[p]]></data>
  </Command>
  <Command __id="197326" _type="InsertStringCommand" date="Wed Jan 01 10:14:52 EST 2020" starttimestamp="1576666505112" timestamp="1225187790" timestamp2="1225187790">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="197328" _type="InsertStringCommand" date="Wed Jan 01 10:14:53 EST 2020" starttimestamp="1576666505112" timestamp="1225188846" timestamp2="1225188846">
    <data><![CDATA[=]]></data>
  </Command>
  <Command __id="197330" _type="InsertStringCommand" date="Wed Jan 01 10:14:54 EST 2020" starttimestamp="1576666505112" timestamp="1225189347" timestamp2="1225189347">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="197332" _type="InsertStringCommand" date="Wed Jan 01 10:14:55 EST 2020" starttimestamp="1576666505112" timestamp="1225190677" timestamp2="1225190677">
    <data><![CDATA[*]]></data>
  </Command>
  <Command __id="197334" _type="InsertStringCommand" date="Wed Jan 01 10:14:56 EST 2020" starttimestamp="1576666505112" timestamp="1225191266" timestamp2="1225191266">
    <data><![CDATA[p]]></data>
  </Command>
  <Command __id="197336" _type="InsertStringCommand" date="Wed Jan 01 10:14:56 EST 2020" starttimestamp="1576666505112" timestamp="1225191623" timestamp2="1225191623">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="197338" _type="InsertStringCommand" date="Wed Jan 01 10:14:58 EST 2020" starttimestamp="1576666505112" timestamp="1225193162" timestamp2="1225193162">
    <data><![CDATA[+]]></data>
  </Command>
  <Command __id="197340" _type="InsertStringCommand" date="Wed Jan 01 10:14:58 EST 2020" starttimestamp="1576666505112" timestamp="1225193410" timestamp2="1225193410">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="197342" _type="InsertStringCommand" date="Wed Jan 01 10:14:58 EST 2020" starttimestamp="1576666505112" timestamp="1225193571" timestamp2="1225193571">
    <data><![CDATA[a]]></data>
  </Command>
  <Command __id="197344" _type="InsertStringCommand" date="Wed Jan 01 10:14:58 EST 2020" starttimestamp="1576666505112" timestamp="1225193724" timestamp2="1225193724">
    <data><![CDATA[n]]></data>
  </Command>
  <Command __id="197346" _type="InsertStringCommand" date="Wed Jan 01 10:14:59 EST 2020" starttimestamp="1576666505112" timestamp="1225194050" timestamp2="1225194050">
    <data><![CDATA[I]]></data>
  </Command>
  <Command __id="197348" _type="InsertStringCommand" date="Wed Jan 01 10:14:59 EST 2020" starttimestamp="1576666505112" timestamp="1225194283" timestamp2="1225194283">
    <data><![CDATA[n]]></data>
  </Command>
  <Command __id="197350" _type="InsertStringCommand" date="Wed Jan 01 10:14:59 EST 2020" starttimestamp="1576666505112" timestamp="1225194573" timestamp2="1225194573">
    <data><![CDATA[c]]></data>
  </Command>
  <Command __id="197352" _type="InsertStringCommand" date="Wed Jan 01 10:14:59 EST 2020" starttimestamp="1576666505112" timestamp="1225194805" timestamp2="1225194805">
    <data><![CDATA[r]]></data>
  </Command>
  <Command __id="197354" _type="InsertStringCommand" date="Wed Jan 01 10:14:59 EST 2020" starttimestamp="1576666505112" timestamp="1225194884" timestamp2="1225194884">
    <data><![CDATA[e]]></data>
  </Command>
  <Command __id="197356" _type="InsertStringCommand" date="Wed Jan 01 10:15:00 EST 2020" starttimestamp="1576666505112" timestamp="1225195143" timestamp2="1225195143">
    <data><![CDATA[m]]></data>
  </Command>
  <Command __id="197358" _type="InsertStringCommand" date="Wed Jan 01 10:15:00 EST 2020" starttimestamp="1576666505112" timestamp="1225195255" timestamp2="1225195255">
    <data><![CDATA[e]]></data>
  </Command>
  <Command __id="197360" _type="InsertStringCommand" date="Wed Jan 01 10:15:00 EST 2020" starttimestamp="1576666505112" timestamp="1225195400" timestamp2="1225195400">
    <data><![CDATA[n]]></data>
  </Command>
  <Command __id="197362" _type="InsertStringCommand" date="Wed Jan 01 10:15:00 EST 2020" starttimestamp="1576666505112" timestamp="1225195700" timestamp2="1225195700">
    <data><![CDATA[t]]></data>
  </Command>
  <Command __id="197364" _type="InsertStringCommand" date="Wed Jan 01 10:15:01 EST 2020" starttimestamp="1576666505112" timestamp="1225196668" timestamp2="1225196668">
    <data><![CDATA[;]]></data>
  </Command>
  <DocumentChange __id="197337" _type="Insert" date="Wed Jan 01 10:14:58 EST 2020" docASTNodeCount="1" docActiveCodeLength="584" docExpressionCount="0" docLength="671" length="1" offset="242" starttimestamp="1576666505112" timestamp="1225193159">
    <text><![CDATA[+]]></text>
  </DocumentChange>
  <DocumentChange __id="197339" _type="Insert" date="Wed Jan 01 10:14:58 EST 2020" docASTNodeCount="1" docActiveCodeLength="585" docExpressionCount="0" docLength="672" length="1" offset="243" starttimestamp="1576666505112" timestamp="1225193407">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="197341" _type="Insert" date="Wed Jan 01 10:14:58 EST 2020" docASTNodeCount="1" docActiveCodeLength="586" docExpressionCount="0" docLength="673" length="1" offset="244" starttimestamp="1576666505112" timestamp="1225193562">
    <text><![CDATA[a]]></text>
  </DocumentChange>
  <DocumentChange __id="197343" _type="Insert" date="Wed Jan 01 10:14:58 EST 2020" docASTNodeCount="1" docActiveCodeLength="587" docExpressionCount="0" docLength="674" length="1" offset="245" starttimestamp="1576666505112" timestamp="1225193715">
    <text><![CDATA[n]]></text>
  </DocumentChange>
  <DocumentChange __id="197345" _type="Insert" date="Wed Jan 01 10:14:59 EST 2020" docASTNodeCount="1" docActiveCodeLength="588" docExpressionCount="0" docLength="675" length="1" offset="246" starttimestamp="1576666505112" timestamp="1225194046">
    <text><![CDATA[I]]></text>
  </DocumentChange>
  <DocumentChange __id="197347" _type="Insert" date="Wed Jan 01 10:14:59 EST 2020" docASTNodeCount="1" docActiveCodeLength="589" docExpressionCount="0" docLength="676" length="1" offset="247" starttimestamp="1576666505112" timestamp="1225194279">
    <text><![CDATA[n]]></text>
  </DocumentChange>
  <DocumentChange __id="197349" _type="Insert" date="Wed Jan 01 10:14:59 EST 2020" docASTNodeCount="1" docActiveCodeLength="590" docExpressionCount="0" docLength="677" length="1" offset="248" starttimestamp="1576666505112" timestamp="1225194570">
    <text><![CDATA[c]]></text>
  </DocumentChange>
  <DocumentChange __id="197351" _type="Insert" date="Wed Jan 01 10:14:59 EST 2020" docASTNodeCount="1" docActiveCodeLength="591" docExpressionCount="0" docLength="678" length="1" offset="249" starttimestamp="1576666505112" timestamp="1225194802">
    <text><![CDATA[r]]></text>
  </DocumentChange>
  <DocumentChange __id="197353" _type="Insert" date="Wed Jan 01 10:14:59 EST 2020" docASTNodeCount="1" docActiveCodeLength="592" docExpressionCount="0" docLength="679" length="1" offset="250" starttimestamp="1576666505112" timestamp="1225194881">
    <text><![CDATA[e]]></text>
  </DocumentChange>
  <DocumentChange __id="197355" _type="Insert" date="Wed Jan 01 10:15:00 EST 2020" docASTNodeCount="1" docActiveCodeLength="593" docExpressionCount="0" docLength="680" length="1" offset="251" starttimestamp="1576666505112" timestamp="1225195138">
    <text><![CDATA[m]]></text>
  </DocumentChange>
  <DocumentChange __id="197357" _type="Insert" date="Wed Jan 01 10:15:00 EST 2020" docASTNodeCount="1" docActiveCodeLength="594" docExpressionCount="0" docLength="681" length="1" offset="252" starttimestamp="1576666505112" timestamp="1225195251">
    <text><![CDATA[e]]></text>
  </DocumentChange>
  <DocumentChange __id="197359" _type="Insert" date="Wed Jan 01 10:15:00 EST 2020" docASTNodeCount="1" docActiveCodeLength="595" docExpressionCount="0" docLength="682" length="1" offset="253" starttimestamp="1576666505112" timestamp="1225195397">
    <text><![CDATA[n]]></text>
  </DocumentChange>
  <DocumentChange __id="197361" _type="Insert" date="Wed Jan 01 10:15:00 EST 2020" docASTNodeCount="1" docActiveCodeLength="596" docExpressionCount="0" docLength="683" length="1" offset="254" starttimestamp="1576666505112" timestamp="1225195696">
    <text><![CDATA[t]]></text>
  </DocumentChange>
  <DocumentChange __id="197363" _type="Insert" date="Wed Jan 01 10:15:01 EST 2020" docASTNodeCount="1" docActiveCodeLength="597" docExpressionCount="0" docLength="684" length="1" offset="255" starttimestamp="1576666505112" timestamp="1225196666">
    <text><![CDATA[;]]></text>
  </DocumentChange>
  <Command __id="197365" _type="MoveCaretCommand" caretOffset="566" date="Wed Jan 01 10:15:08 EST 2020" docOffset="566" starttimestamp="1576666505112" timestamp="1225203065" />
  <Command __id="197367" _type="EclipseCommand" commandID="org.eclipse.cdt.ui.edit.text.c.toggle.comment" date="Wed Jan 01 10:15:09 EST 2020" starttimestamp="1576666505112" timestamp="1225204139" />
  <DocumentChange __id="197366" _type="Insert" date="Wed Jan 01 10:15:09 EST 2020" docASTNodeCount="1" docActiveCodeLength="579" docExpressionCount="0" docLength="686" length="2" offset="564" starttimestamp="1576666505112" timestamp="1225204117">
    <text><![CDATA[//]]></text>
  </DocumentChange>
  <Command __id="197368" _type="MoveCaretCommand" caretOffset="585" date="Wed Jan 01 10:15:16 EST 2020" docOffset="585" starttimestamp="1576666505112" timestamp="1225211033" />
  <DocumentChange __id="197369" _type="Insert" date="Wed Jan 01 10:15:17 EST 2020" docASTNodeCount="1" docActiveCodeLength="581" docExpressionCount="0" docLength="688" length="2" offset="585" starttimestamp="1576666505112" timestamp="1225212136">
    <text><![CDATA[		]]></text>
  </DocumentChange>
  <Command __id="197370" _type="InsertStringCommand" date="Wed Jan 01 10:15:17 EST 2020" starttimestamp="1576666505112" timestamp="1225212140" timestamp2="1225212140">
    <data><![CDATA[	]]></data>
  </Command>
  <DocumentChange __id="197371" _type="Insert" date="Wed Jan 01 10:15:17 EST 2020" docASTNodeCount="1" docActiveCodeLength="582" docExpressionCount="0" docLength="689" length="1" offset="587" starttimestamp="1576666505112" timestamp="1225212628">
    <text><![CDATA[a]]></text>
  </DocumentChange>
  <Command __id="197372" _type="InsertStringCommand" date="Wed Jan 01 10:15:17 EST 2020" starttimestamp="1576666505112" timestamp="1225212638" timestamp2="1225212638">
    <data><![CDATA[a]]></data>
  </Command>
  <DocumentChange __id="197373" _type="Insert" date="Wed Jan 01 10:15:18 EST 2020" docASTNodeCount="1" docActiveCodeLength="583" docExpressionCount="0" docLength="690" length="1" offset="588" starttimestamp="1576666505112" timestamp="1225213008">
    <text><![CDATA[d]]></text>
  </DocumentChange>
  <Command __id="197374" _type="InsertStringCommand" date="Wed Jan 01 10:15:18 EST 2020" starttimestamp="1576666505112" timestamp="1225213011" timestamp2="1225213011">
    <data><![CDATA[d]]></data>
  </Command>
  <DocumentChange __id="197375" _type="Insert" date="Wed Jan 01 10:15:18 EST 2020" docASTNodeCount="1" docActiveCodeLength="584" docExpressionCount="0" docLength="691" length="1" offset="589" starttimestamp="1576666505112" timestamp="1225213144">
    <text><![CDATA[d]]></text>
  </DocumentChange>
  <Command __id="197376" _type="InsertStringCommand" date="Wed Jan 01 10:15:18 EST 2020" starttimestamp="1576666505112" timestamp="1225213154" timestamp2="1225213154">
    <data><![CDATA[d]]></data>
  </Command>
  <DocumentChange __id="197377" _type="Insert" date="Wed Jan 01 10:15:19 EST 2020" docASTNodeCount="1" docActiveCodeLength="586" docExpressionCount="0" docLength="693" length="2" offset="590" starttimestamp="1576666505112" timestamp="1225213911">
    <text><![CDATA[()]]></text>
  </DocumentChange>
  <Command __id="197378" _type="InsertStringCommand" date="Wed Jan 01 10:15:19 EST 2020" starttimestamp="1576666505112" timestamp="1225213916" timestamp2="1225213916">
    <data><![CDATA[(]]></data>
  </Command>
  <DocumentChange __id="197379" _type="Insert" date="Wed Jan 01 10:15:20 EST 2020" docASTNodeCount="1" docActiveCodeLength="587" docExpressionCount="0" docLength="694" length="1" offset="591" starttimestamp="1576666505112" timestamp="1225215407">
    <text><![CDATA[&]]></text>
  </DocumentChange>
  <Command __id="197380" _type="InsertStringCommand" date="Wed Jan 01 10:15:20 EST 2020" starttimestamp="1576666505112" timestamp="1225215412" timestamp2="1225215412">
    <data><![CDATA[&]]></data>
  </Command>
  <DocumentChange __id="197381" _type="Insert" date="Wed Jan 01 10:15:21 EST 2020" docASTNodeCount="1" docActiveCodeLength="588" docExpressionCount="0" docLength="695" length="1" offset="592" starttimestamp="1576666505112" timestamp="1225216806">
    <text><![CDATA[s]]></text>
  </DocumentChange>
  <Command __id="197382" _type="InsertStringCommand" date="Wed Jan 01 10:15:21 EST 2020" starttimestamp="1576666505112" timestamp="1225216808" timestamp2="1225216808">
    <data><![CDATA[s]]></data>
  </Command>
  <DocumentChange __id="197383" _type="Insert" date="Wed Jan 01 10:15:22 EST 2020" docASTNodeCount="1" docActiveCodeLength="589" docExpressionCount="0" docLength="696" length="1" offset="593" starttimestamp="1576666505112" timestamp="1225217165">
    <text><![CDATA[u]]></text>
  </DocumentChange>
  <Command __id="197384" _type="InsertStringCommand" date="Wed Jan 01 10:15:22 EST 2020" starttimestamp="1576666505112" timestamp="1225217166" timestamp2="1225217166">
    <data><![CDATA[u]]></data>
  </Command>
  <DocumentChange __id="197385" _type="Insert" date="Wed Jan 01 10:15:22 EST 2020" docASTNodeCount="1" docActiveCodeLength="590" docExpressionCount="0" docLength="697" length="1" offset="594" starttimestamp="1576666505112" timestamp="1225217430">
    <text><![CDATA[n]]></text>
  </DocumentChange>
  <Command __id="197386" _type="InsertStringCommand" date="Wed Jan 01 10:15:22 EST 2020" starttimestamp="1576666505112" timestamp="1225217435" timestamp2="1225217435">
    <data><![CDATA[n]]></data>
  </Command>
  <DocumentChange __id="197387" _type="Delete" date="Wed Jan 01 10:15:23 EST 2020" docASTNodeCount="1" docActiveCodeLength="589" docExpressionCount="0" docLength="696" endLine="25" length="1" offset="594" startLine="25" starttimestamp="1576666505112" timestamp="1225218239">
    <text><![CDATA[n]]></text>
  </DocumentChange>
  <Command __id="197388" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Wed Jan 01 10:15:23 EST 2020" starttimestamp="1576666505112" timestamp="1225218240" />
  <DocumentChange __id="197389" _type="Insert" date="Wed Jan 01 10:15:23 EST 2020" docASTNodeCount="1" docActiveCodeLength="590" docExpressionCount="0" docLength="697" length="1" offset="594" starttimestamp="1576666505112" timestamp="1225218564">
    <text><![CDATA[m]]></text>
  </DocumentChange>
  <Command __id="197390" _type="InsertStringCommand" date="Wed Jan 01 10:15:23 EST 2020" starttimestamp="1576666505112" timestamp="1225218567" timestamp2="1225218567">
    <data><![CDATA[m]]></data>
  </Command>
  <DocumentChange __id="197391" _type="Insert" date="Wed Jan 01 10:15:23 EST 2020" docASTNodeCount="1" docActiveCodeLength="591" docExpressionCount="0" docLength="698" length="1" offset="595" starttimestamp="1576666505112" timestamp="1225218833">
    <text><![CDATA[,]]></text>
  </DocumentChange>
  <Command __id="197392" _type="InsertStringCommand" date="Wed Jan 01 10:15:23 EST 2020" starttimestamp="1576666505112" timestamp="1225218835" timestamp2="1225218835">
    <data><![CDATA[,]]></data>
  </Command>
  <Command __id="197394" _type="InsertStringCommand" date="Wed Jan 01 10:15:24 EST 2020" starttimestamp="1576666505112" timestamp="1225219111" timestamp2="1225219111">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="197395" _type="SelectTextCommand" caretOffset="583" date="Wed Jan 01 10:15:30 EST 2020" end="583" start="575" starttimestamp="1576666505112" timestamp="1225225613" />
  <Command __id="197396" _type="CopyCommand" date="Wed Jan 01 10:15:31 EST 2020" starttimestamp="1576666505112" timestamp="1225226136" />
  <DocumentChange __id="197393" _type="Insert" date="Wed Jan 01 10:15:24 EST 2020" docASTNodeCount="1" docActiveCodeLength="592" docExpressionCount="0" docLength="699" length="1" offset="596" starttimestamp="1576666505112" timestamp="1225219109">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <Command __id="197397" _type="MoveCaretCommand" caretOffset="596" date="Wed Jan 01 10:15:33 EST 2020" docOffset="596" starttimestamp="1576666505112" timestamp="1225227908" />
  <DocumentChange __id="197398" _type="Insert" date="Wed Jan 01 10:15:37 EST 2020" docASTNodeCount="1" docActiveCodeLength="593" docExpressionCount="0" docLength="700" length="1" offset="596" starttimestamp="1576666505112" timestamp="1225232081">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <Command __id="197399" _type="InsertStringCommand" date="Wed Jan 01 10:15:37 EST 2020" starttimestamp="1576666505112" timestamp="1225232087" timestamp2="1225232087">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="197401" _type="PasteCommand" date="Wed Jan 01 10:15:37 EST 2020" starttimestamp="1576666505112" timestamp="1225232735" />
  <Command __id="197402" _type="MoveCaretCommand" caretOffset="607" date="Wed Jan 01 10:15:39 EST 2020" docOffset="607" starttimestamp="1576666505112" timestamp="1225234448" />
  <Command __id="197404" _type="InsertStringCommand" date="Wed Jan 01 10:15:40 EST 2020" starttimestamp="1576666505112" timestamp="1225235332" timestamp2="1225235332">
    <data><![CDATA[;]]></data>
  </Command>
  <DocumentChange __id="197400" _type="Insert" date="Wed Jan 01 10:15:37 EST 2020" docASTNodeCount="1" docActiveCodeLength="601" docExpressionCount="0" docLength="708" length="8" offset="597" starttimestamp="1576666505112" timestamp="1225232719">
    <text><![CDATA[array[i]]]></text>
  </DocumentChange>
  <DocumentChange __id="197403" _type="Insert" date="Wed Jan 01 10:15:40 EST 2020" docASTNodeCount="1" docActiveCodeLength="602" docExpressionCount="0" docLength="709" length="1" offset="607" starttimestamp="1576666505112" timestamp="1225235328">
    <text><![CDATA[;]]></text>
  </DocumentChange>
  <Command __id="197405" _type="MoveCaretCommand" caretOffset="237" date="Wed Jan 01 10:15:43 EST 2020" docOffset="237" starttimestamp="1576666505112" timestamp="1225238085" />
  <Command __id="197407" _type="InsertStringCommand" date="Wed Jan 01 10:15:45 EST 2020" starttimestamp="1576666505112" timestamp="1225240600" timestamp2="1225240600">
    <data><![CDATA[+]]></data>
  </Command>
  <Command __id="197408" _type="MoveCaretCommand" caretOffset="245" date="Wed Jan 01 10:15:47 EST 2020" docOffset="245" starttimestamp="1576666505112" timestamp="1225242459" />
  <Command __id="197410" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Wed Jan 01 10:15:47 EST 2020" starttimestamp="1576666505112" timestamp="1225242847" />
  <Command __id="197412" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Wed Jan 01 10:15:48 EST 2020" starttimestamp="1576666505112" timestamp="1225243020" />
  <Command __id="197414" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Wed Jan 01 10:15:48 EST 2020" starttimestamp="1576666505112" timestamp="1225243208" />
  <Command __id="197416" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Wed Jan 01 10:15:48 EST 2020" starttimestamp="1576666505112" timestamp="1225243376" />
  <Command __id="197418" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Wed Jan 01 10:15:48 EST 2020" starttimestamp="1576666505112" timestamp="1225243541" />
  <Command __id="197419" _type="MoveCaretCommand" caretOffset="588" date="Wed Jan 01 10:16:19 EST 2020" docOffset="588" starttimestamp="1576666505112" timestamp="1225274729" />
  <Command __id="197421" _type="InsertStringCommand" date="Wed Jan 01 10:16:20 EST 2020" starttimestamp="1576666505112" timestamp="1225275160" timestamp2="1225275160">
    <data><![CDATA[ ]]></data>
  </Command>
  <Command __id="197422" _type="MoveCaretCommand" caretOffset="609" date="Wed Jan 01 10:16:21 EST 2020" docOffset="609" starttimestamp="1576666505112" timestamp="1225276792" />
  <Command __id="197423" _type="EclipseCommand" commandID="org.eclipse.ui.file.save" date="Wed Jan 01 10:16:25 EST 2020" starttimestamp="1576666505112" timestamp="1225280229" />
  <Command __id="197439" _type="RunCommand" date="Wed Jan 01 10:16:56 EST 2020" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="1225311658" type="Run" />
  <Command __id="197440" _type="RunCommand" date="Wed Jan 01 10:16:56 EST 2020" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="1225311658" type="Run" />
  <Command __id="197441" _type="RunCommand" date="Wed Jan 01 10:16:56 EST 2020" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="1225311672" type="Debug" />
  <Command __id="197442" _type="RunCommand" date="Wed Jan 01 10:16:56 EST 2020" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="1225311673" type="Run" />
  <Command __id="197443" _type="RunCommand" date="Wed Jan 01 10:16:56 EST 2020" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="1225311673" type="Debug" />
  <Command __id="197444" _type="RunCommand" date="Wed Jan 01 10:16:56 EST 2020" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="1225311673" type="Run" />
  <Command __id="197445" _type="EHExceptionCommand" date="Wed Jan 01 10:16:56 EST 2020" starttimestamp="1576666505112" timestamp="1225311829" type="Exception">
    <outputString><![CDATA[sum_sequential
Sum: 499500
Took: 0
thread:0 lastIndex:999
_____________________________
sum_parallel_for_reduction
Sum: 499500
Took: 0
thread:0 lastIndex:124
thread:1 lastIndex:249
thread:2 lastIndex:374
thread:3 lastIndex:499
thread:4 lastIndex:624
thread:5 lastIndex:749
thread:6 lastIndex:874
thread:7 lastIndex:999
_____________________________
sum_parallel_for_local_var
Sum: 499500
Took: 0
thread:0 lastIndex:124
thread:1 lastIndex:249
thread:2 lastIndex:374
thread:3 lastIndex:499
thread:4 lastIndex:624
thread:5 lastIndex:749
thread:6 lastIndex:874
thread:7 lastIndex:999
_____________________________
sum_parallel
Sum: 499500
Took: 0
_____________________________
]]></outputString>
  </Command>
  <DocumentChange __id="197406" _type="Insert" date="Wed Jan 01 10:15:45 EST 2020" docASTNodeCount="1" docActiveCodeLength="603" docExpressionCount="0" docLength="710" length="1" offset="237" starttimestamp="1576666505112" timestamp="1225240597">
    <text><![CDATA[+]]></text>
  </DocumentChange>
  <DocumentChange __id="197409" _type="Delete" date="Wed Jan 01 10:15:47 EST 2020" docASTNodeCount="1" docActiveCodeLength="602" docExpressionCount="0" docLength="709" endLine="10" length="1" offset="244" startLine="10" starttimestamp="1576666505112" timestamp="1225242844">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="197411" _type="Delete" date="Wed Jan 01 10:15:48 EST 2020" docASTNodeCount="1" docActiveCodeLength="601" docExpressionCount="0" docLength="708" endLine="10" length="1" offset="243" startLine="10" starttimestamp="1576666505112" timestamp="1225243017">
    <text><![CDATA[+]]></text>
  </DocumentChange>
  <DocumentChange __id="197413" _type="Delete" date="Wed Jan 01 10:15:48 EST 2020" docASTNodeCount="1" docActiveCodeLength="600" docExpressionCount="0" docLength="707" endLine="10" length="1" offset="242" startLine="10" starttimestamp="1576666505112" timestamp="1225243206">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="197415" _type="Delete" date="Wed Jan 01 10:15:48 EST 2020" docASTNodeCount="1" docActiveCodeLength="599" docExpressionCount="0" docLength="706" endLine="10" length="1" offset="241" startLine="10" starttimestamp="1576666505112" timestamp="1225243370">
    <text><![CDATA[p]]></text>
  </DocumentChange>
  <DocumentChange __id="197417" _type="Delete" date="Wed Jan 01 10:15:48 EST 2020" docASTNodeCount="1" docActiveCodeLength="598" docExpressionCount="0" docLength="705" endLine="10" length="1" offset="240" startLine="10" starttimestamp="1576666505112" timestamp="1225243539">
    <text><![CDATA[*]]></text>
  </DocumentChange>
  <DocumentChange __id="197420" _type="Insert" date="Wed Jan 01 10:16:20 EST 2020" docASTNodeCount="1" docActiveCodeLength="599" docExpressionCount="0" docLength="706" length="1" offset="588" starttimestamp="1576666505112" timestamp="1225275157">
    <text><![CDATA[ ]]></text>
  </DocumentChange>
  <DocumentChange __id="197426" _type="Replace" date="Wed Jan 01 10:16:43 EST 2020" docASTNodeCount="1" docActiveCodeLength="597" docExpressionCount="0" docLength="704" endLine="9" insertionLength="1" int_docASTNodeCount="1" int_docActiveCodeLength="596" int_docExpressionCount="0" int_docLength="703" length="3" offset="206" startLine="9" starttimestamp="1576666505112" timestamp="1225298565">
    <deletedText><![CDATA[int]]></deletedText>
    <insertedText><![CDATA[d]]></insertedText>
  </DocumentChange>
  <DocumentChange __id="197428" _type="Insert" date="Wed Jan 01 10:16:43 EST 2020" docASTNodeCount="1" docActiveCodeLength="598" docExpressionCount="0" docLength="705" length="1" offset="207" starttimestamp="1576666505112" timestamp="1225298724">
    <text><![CDATA[o]]></text>
  </DocumentChange>
  <DocumentChange __id="197430" _type="Insert" date="Wed Jan 01 10:16:44 EST 2020" docASTNodeCount="1" docActiveCodeLength="599" docExpressionCount="0" docLength="706" length="1" offset="208" starttimestamp="1576666505112" timestamp="1225298977">
    <text><![CDATA[u]]></text>
  </DocumentChange>
  <DocumentChange __id="197432" _type="Insert" date="Wed Jan 01 10:16:44 EST 2020" docASTNodeCount="1" docActiveCodeLength="600" docExpressionCount="0" docLength="707" length="1" offset="209" starttimestamp="1576666505112" timestamp="1225299208">
    <text><![CDATA[b]]></text>
  </DocumentChange>
  <DocumentChange __id="197434" _type="Insert" date="Wed Jan 01 10:16:44 EST 2020" docASTNodeCount="1" docActiveCodeLength="601" docExpressionCount="0" docLength="708" length="1" offset="210" starttimestamp="1576666505112" timestamp="1225299501">
    <text><![CDATA[l]]></text>
  </DocumentChange>
  <DocumentChange __id="197436" _type="Insert" date="Wed Jan 01 10:16:44 EST 2020" docASTNodeCount="1" docActiveCodeLength="602" docExpressionCount="0" docLength="709" length="1" offset="211" starttimestamp="1576666505112" timestamp="1225299611">
    <text><![CDATA[e]]></text>
  </DocumentChange>
  <Command __id="197446" _type="ShellCommand" date="Wed Jan 01 10:17:07 EST 2020" starttimestamp="1576666505112" timestamp="1225322078" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="197447" _type="ShellCommand" date="Wed Jan 01 10:17:07 EST 2020" starttimestamp="1576666505112" timestamp="1225322566" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="197448" _type="MoveCaretCommand" caretOffset="585" date="Wed Jan 01 10:17:07 EST 2020" docOffset="585" starttimestamp="1576666505112" timestamp="1225322688" />
  <Command __id="197449" _type="ShellCommand" date="Wed Jan 01 10:17:08 EST 2020" starttimestamp="1576666505112" timestamp="1225323562" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="197450" _type="ShellCommand" date="Wed Jan 01 10:17:09 EST 2020" starttimestamp="1576666505112" timestamp="1225324014" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="197454" _type="RunCommand" date="Wed Jan 01 10:17:17 EST 2020" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="1225332781" type="Run" />
  <Command __id="197455" _type="RunCommand" date="Wed Jan 01 10:17:17 EST 2020" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="1225332781" type="Run" />
  <Command __id="197456" _type="RunCommand" date="Wed Jan 01 10:17:17 EST 2020" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="1225332822" type="Debug" />
  <Command __id="197457" _type="RunCommand" date="Wed Jan 01 10:17:17 EST 2020" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="1225332822" type="Run" />
  <Command __id="197458" _type="RunCommand" date="Wed Jan 01 10:17:17 EST 2020" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="1225332822" type="Debug" />
  <Command __id="197459" _type="RunCommand" date="Wed Jan 01 10:17:17 EST 2020" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="1225332822" type="Run" />
  <Command __id="197460" _type="EHExceptionCommand" date="Wed Jan 01 10:17:18 EST 2020" starttimestamp="1576666505112" timestamp="1225332975" type="Exception">
    <outputString><![CDATA[sum_sequential
Sum: 499500
Took: 0
thread:0 lastIndex:999
_____________________________
sum_parallel_for_reduction
Sum: 0
Took: 0
thread:0 lastIndex:124
thread:1 lastIndex:249
thread:2 lastIndex:374
thread:3 lastIndex:499
thread:4 lastIndex:624
thread:5 lastIndex:749
thread:6 lastIndex:874
thread:7 lastIndex:999
_____________________________
sum_parallel_for_local_var
Sum: 499500
Took: 0
thread:0 lastIndex:124
thread:1 lastIndex:249
thread:2 lastIndex:374
thread:3 lastIndex:499
thread:4 lastIndex:624
thread:5 lastIndex:749
thread:6 lastIndex:874
thread:7 lastIndex:999
_____________________________
sum_parallel
Sum: 499500
Took: 0
_____________________________
]]></outputString>
  </Command>
  <Command __id="197461" _type="MoveCaretCommand" caretOffset="584" date="Wed Jan 01 10:17:30 EST 2020" docOffset="584" starttimestamp="1576666505112" timestamp="1225345488" />
  <Command __id="197463" _type="EclipseCommand" commandID="org.eclipse.cdt.ui.edit.text.c.toggle.comment" date="Wed Jan 01 10:17:31 EST 2020" starttimestamp="1576666505112" timestamp="1225346429" />
  <Command __id="197464" _type="EclipseCommand" commandID="org.eclipse.ui.file.save" date="Wed Jan 01 10:17:32 EST 2020" starttimestamp="1576666505112" timestamp="1225346914" />
  <DocumentChange __id="217798" _type="Replace" date="Fri Jan 10 10:09:52 EST 2020" docASTNodeCount="5134" docActiveCodeLength="37681" docExpressionCount="3174" docLength="43800" endLine="1100" insertionLength="18" int_docASTNodeCount="5133" int_docActiveCodeLength="37663" int_docExpressionCount="3173" int_docLength="43782" length="18" offset="42214" startLine="1100" starttimestamp="1576666505112" timestamp="2002487592">
    <deletedText><![CDATA[anAliasassignments]]></deletedText>
    <insertedText><![CDATA[anAliasAssignments]]></insertedText>
  </DocumentChange>
  <DocumentChange __id="217799" _type="Replace" date="Fri Jan 10 10:09:52 EST 2020" docASTNodeCount="5134" docActiveCodeLength="37681" docExpressionCount="3174" docLength="43800" endLine="1099" insertionLength="18" int_docASTNodeCount="5134" int_docActiveCodeLength="37663" int_docExpressionCount="3174" int_docLength="43782" length="18" offset="42062" startLine="1099" starttimestamp="1576666505112" timestamp="2002487609">
    <deletedText><![CDATA[anAliasassignments]]></deletedText>
    <insertedText><![CDATA[anAliasAssignments]]></insertedText>
  </DocumentChange>
  <Command __id="217885" _type="DiffBasedFileOpenCommand" date="Fri Jan 10 10:11:11 EST 2020" docASTNodeCount="428" docActiveCodeLength="2628" docExpressionCount="248" docLength="3166" projectName="GraderBasics" starttimestamp="1576666505112" timestamp="2002566346">
    <filePath><![CDATA[D:\dewan_backup\Java\GraderBasics\src\gradingTools\shared\testcases\openmp\scannedTree\AnSNode.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package gradingTools.shared.testcases.openmp.scannedTree;¬∂¬∂import java.util.ArrayList;¬∂import java.util.HashSet;¬∂import java.util.List;¬∂import java.util.Set;¬∂¬∂import gradingTools.shared.testcases.openmp.AnAssignment;¬∂import gradingTools.shared.testcases.openmp.Assignment;¬∂import gradingTools.shared.testcases.openmp.ForHeader;¬∂import gradingTools.shared.testcases.openmp.OpenMPPragma;¬∂import gradingTools.shared.testcases.openmp.OpenMPUtils;¬∂import gradingTools.shared.testcases.openmp.checks.OpenMPPragmaAttribute;¬∂¬∂public class AnSNode implements SNode {¬∂	protected List<DeclarationSNode> variableDeclarations = new ArrayList();//separate subclass for this variable?¬∂//	protected List<String> localVariables = new ArrayList();//separate subclass for this variable?¬∂	protected List<String> localVariables = new ArrayList();//separate subclass for this variable?¬∂	protected int lineNumber;¬∂	protected List<SNode> children = new ArrayList();¬∂	protected List<Assignment> assignments = new ArrayList();¬∂	protected List<ForSNode> forNodes = new ArrayList();¬∂	protected List<OMPSNode> ompSNodes = new ArrayList();¬∂	protected Set<OpenMPPragmaAttribute> attributes = new HashSet();¬∂	protected SNode parent;¬∂	boolean inParallel = false;¬∂	boolean inCritical = false;¬∂¬∂	int numberOfNestingFors;¬∂¬∂	public AnSNode(int lineNumber) {¬∂		super();¬∂		this.lineNumber = lineNumber;		¬∂	}¬∂	¬∂	@Override¬∂	public int getLineNumber() {¬∂		return lineNumber;¬∂	}¬∂	¬∂	@Override¬∂	public List<ForSNode> getForNodes() {¬∂		return forNodes;¬∂	}¬∂	//	@Override¬∂//	public void setAnnotatedText(List<String> nextNonEmptyString) {¬∂//		this.annotatedText = nextNonEmptyString;¬∂//	}¬∂	¬∂	@Override¬∂	public SNode getParent() {¬∂		return parent;¬∂	}¬∂	@Override¬∂	public void setParent(SNode parent) {¬∂		this.parent = parent;¬∂		parent.getChildren().add(this);¬∂		inParallel = OMPSNodeUtils.hasParallelAncestor(this);		¬∂		inCritical = OMPSNodeUtils.hasCriticalAncestor(this);	¬∂		numberOfNestingFors = OMPSNodeUtils.numberOfNestingFors(parent);¬∂¬∂¬∂	}¬∂	@Override¬∂	public List<SNode> getChildren() {¬∂		return children;¬∂	}¬∂	¬∂	¬∂	@Override¬∂	public List<Assignment> getAssignments() {¬∂		return assignments;¬∂	}¬∂	// are the two method below the same? Or is a local variable something that is declared and not shared?¬∂	@Override¬∂	public List<DeclarationSNode> getVariableDeclarations() {¬∂		return variableDeclarations;¬∂	}¬∂	@Override¬∂	public List<String> getLocalVariableIdentifiers() {¬∂		return localVariables;¬∂	}¬∂	@Override¬∂	public List<OMPSNode> getOmpSNodes() {¬∂		return ompSNodes;¬∂	}¬∂	¬∂	@Override¬∂	public void addChild(SNode aChild) {¬∂		this.getChildren().add(aChild);¬∂//		if (aChild instanceof DeclaringAssignmentSNode) {¬∂//			localVariables.add(((DeclaringAssignmentSNode) aChild).getLhsVariable());¬∂//		}¬∂	}¬∂	@Override¬∂	public Set<OpenMPPragmaAttribute> getAttributes() {¬∂		return attributes;¬∂	}¬∂	@Override¬∂	public boolean isInParallel() {¬∂		return inParallel;¬∂	}¬∂	@Override¬∂	public boolean isInCritical() {¬∂		return inCritical;¬∂	}¬∂	@Override¬∂	public boolean isLeaf() {¬∂		return getChildren().isEmpty();¬∂	}¬∂¬∂}¬∂")]]]></diff>
  </Command>
  <Command __id="217889" _type="DiffBasedFileOpenCommand" date="Fri Jan 10 10:11:14 EST 2020" docASTNodeCount="5134" docActiveCodeLength="37681" docExpressionCount="3174" docLength="43800" projectName="GraderBasics" starttimestamp="1576666505112" timestamp="2002569070">
    <filePath><![CDATA[D:\dewan_backup\Java\GraderBasics\src\gradingTools\shared\testcases\openmp\scannedTree\OMPSNodeUtils.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package gradingTools.shared.testcases.openmp.scannedTree;¬∂¬∂import java.util.ArrayList;¬∂import java.util.Arrays;¬∂import java.util.HashMap;¬∂import java.util.HashSet;¬∂import java.util.List;¬∂import java.util.Map;¬∂import java.util.Set;¬∂import java.util.Stack;¬∂import java.util.regex.Matcher;¬∂import java.util.regex.Pattern;¬∂¬∂import org.apache.commons.lang.StringUtils;¬∂¬∂import grader.basics.project.source.ABasicTextManager;¬∂import gradingTools.shared.testcases.openmp.OpenMPKeywordEnum;¬∂import gradingTools.shared.testcases.openmp.OpenMPParallelPragma;¬∂import gradingTools.shared.testcases.openmp.OpenMPUtils;¬∂import gradingTools.shared.testcases.openmp.scannedTree.ADeclarationSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.ADeclaringAssignmentSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.AForSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.ATextSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.AnAssignmentSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.AnOMPCriticalSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.AnOMPForSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.AnOMPParallelSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.AnOMPSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.AnSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.AssignmentSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.DeclarationSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.DeclaringAssignmentSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.ForSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.OMPForSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.OMPSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.SNode;¬∂¬∂public class OMPSNodeUtils extends OpenMPUtils {¬∂¬∂	public static RootOfFileSNode getSNode(String aFileName, StringBuffer aFileBuffer) {¬∂		String[] aFileLines = aFileBuffer.toString().split("\n");¬∂		return getSNode(aFileName, aFileLines);¬∂	}¬∂¬∂	public static AssignmentSNode getAssignmentSNode(int aLineNumber, String aString) {¬∂		if (aString == null) {¬∂			return null;¬∂		}¬∂		String[] aTokens = aString.split("=");¬∂		if (aTokens.length == 1) {¬∂			return new AnAssignmentSNode(aLineNumber, aTokens[0], null);¬∂		} else {¬∂		return new AnAssignmentSNode(aLineNumber, aTokens[0], aTokens[1]);¬∂		}¬∂	}¬∂¬∂	public static DeclarationSNode getDeclarationSNode(int aLineNumber, String aString) {¬∂		String[] aTokens = aString.split(" ");¬∂		return new ADeclarationSNode(aLineNumber, aTokens[0], aTokens[1]);¬∂	}¬∂¬∂	public static DeclaringAssignmentSNode getDeclaringAssignmentSNode(int aLineNumber, String aString) {¬∂		String[] anLHSAndRHS = aString.split("=");¬∂		String[] aTypeAndVariable = anLHSAndRHS[0].split(" ");¬∂		return new ADeclaringAssignmentSNode(aLineNumber, aTypeAndVariable[0], aTypeAndVariable[1], anLHSAndRHS[1]);¬∂	}¬∂	public static ConstDeclarationSNode getConstDeclarationSNode(int aLineNumber, String aString) {¬∂		String anAssignmentString = aString.substring(CONST.length()).trim();¬∂		String[] anLHSAndRHS = anAssignmentString.split("=");¬∂		String[] aTypeAndVariable = anLHSAndRHS[0].split(" ");¬∂		return new AConstDeclarationSNode(aLineNumber, aTypeAndVariable[0], aTypeAndVariable[1], anLHSAndRHS[1]);¬∂	}¬∂¬∂	public static boolean isDeclaringAssignment(String aFileLine) {¬∂		return startsWithTypeName(aFileLine) && aFileLine.contains("=");¬∂	}¬∂	public static boolean isConstDeclaration(String aFileLine) {¬∂		return aFileLine.startsWith(CONST);¬∂	}¬∂	public static boolean isMethodDeclaration(String aFileLine) {¬∂		return startsWithTypeName(aFileLine) && ¬∂				aFileLine.contains("(") &&¬∂				!aFileLine.contains("=");¬∂	}¬∂	public static boolean isExternalMethodDeclaration(String aFileLine) {¬∂		return isMethodDeclaration(aFileLine) && aFileLine.endsWith(";");¬∂	}¬∂¬∂¬∂	public static boolean isVariableDeclaration(String aFileLine) {¬∂¬∂		return startsWithTypeName(aFileLine) && !aFileLine.contains("(");¬∂	}¬∂¬∂	public static boolean isAssignment(String aFileLine) {¬∂		return aFileLine.contains("=") && !aFileLine.contains("==");¬∂	}¬∂¬∂	public static boolean isForNode(String aFileLine) {¬∂		return aFileLine.startsWith("for");¬∂	}¬∂¬∂	public static ForSNode getForSNode(int aLineNumber, String aFileLine) {¬∂¬∂		int aLeftParenIndex = aFileLine.indexOf("(");¬∂		int aRightParenIndex = aFileLine.indexOf(")");¬∂		if (aLeftParenIndex < 0 || aRightParenIndex < 0) {¬∂			return null;¬∂		}¬∂		String aHeaderString = aFileLine.substring(aLeftParenIndex + 1, aRightParenIndex);¬∂		String[] aForComponents = aHeaderString.split(";");¬∂		AssignmentSNode anAssignmentSNode = null;¬∂		String aForInitializaton = aForComponents[0];¬∂		if (!aForInitializaton.isEmpty() && aForInitializaton.contains("=")) {¬∂			if (isDeclaringAssignment(aForInitializaton)) {¬∂				anAssignmentSNode = getDeclaringAssignmentSNode(aLineNumber, aForInitializaton);¬∂			} else {¬∂				anAssignmentSNode = getAssignmentSNode(aLineNumber, aForInitializaton);¬∂			}¬∂¬∂		}		¬∂		return new AForSNode(aLineNumber, anAssignmentSNode, aForComponents[1], getAssignmentSNode(aLineNumber, aForComponents[2]));¬∂	}¬∂	static String[] emptyArray = {};¬∂	public static MethodSNode getMethodSNode(int aLineNumber, String aFileLine, boolean isInternal) {¬∂¬∂		int aLeftParenIndex = aFileLine.indexOf("(");¬∂		int aRightParenIndex = aFileLine.indexOf(")");¬∂		if (aLeftParenIndex < 0 || aRightParenIndex < 0) {¬∂			return null;¬∂		}¬∂		String aMethodNameAndType = aFileLine.substring(0, aLeftParenIndex);¬∂		String[] aMethodNameAndTypeTokens = aMethodNameAndType.split("\\s+"); ¬∂		¬∂		String aMethodParameters = aFileLine.substring(aLeftParenIndex +1 , aRightParenIndex);¬∂		String[] aMethodParameterTokens = aMethodParameters.isEmpty()?emptyArray:¬∂		 aMethodParameters.split(",");¬∂		¬∂//		String[] aMethodParameterTypes = new String[aMethodParameterTokens.length];¬∂//		String[] aMethodParameterNames = new String[aMethodParameterTokens.length];¬∂		List<DeclarationSNode> aDeclarationSNodeList = new ArrayList();¬∂		for (int i = 0; i < aMethodParameterTokens.length; i++ ) {¬∂			String[] aTypeAndName = aMethodParameterTokens[i].trim().split("\\s+");¬∂			if (aTypeAndName.length < 2) {¬∂				continue;¬∂			}¬∂			aDeclarationSNodeList.add(new ADeclarationSNode(aLineNumber, aTypeAndName[0].trim(), aTypeAndName[1].trim()));¬∂//			aMethodParameterTypes[i] = aTypeAndName[0].trim();¬∂//			aMethodParameterNames[i] = aTypeAndName[1].trim();¬∂		}¬∂		if (isInternal)¬∂//		return new AMethodSNode(aLineNumber, aMethodNameAndTypeTokens[0], aMethodNameAndTypeTokens[1], aMethodParameterTypes,aMethodParameterNames );¬∂			return new AMethodSNode(aLineNumber, aMethodNameAndTypeTokens[0], aMethodNameAndTypeTokens[1], aDeclarationSNodeList );¬∂		else¬∂			return new AnExternalMethodSNode(aLineNumber, aMethodNameAndTypeTokens[0], aMethodNameAndTypeTokens[1], aDeclarationSNodeList );¬∂	}¬∂¬∂	public static void setReductionData(OMPForSNode lastChild, String aStoredToken, int aLeftParenIndex,¬∂			int aRightParenIndex) {¬∂		int aColonIndex = aStoredToken.indexOf(":");¬∂		if (aLeftParenIndex != -1 && aRightParenIndex != -1 && aColonIndex != -1) {¬∂			String anOperationString = aStoredToken.substring(aLeftParenIndex + 1, aColonIndex).trim();¬∂			String aVariableString = aStoredToken.substring(aColonIndex + 1, aRightParenIndex).trim();¬∂			((OMPForSNode) lastChild).setReductionVariable(aVariableString);¬∂			((OMPForSNode) lastChild).setReductionOperation(anOperationString);¬∂		}¬∂	}¬∂¬∂	public static void setSharedOrPrivateData(OMPSNode lastChild, String aStoredToken, int aLeftParenIndex,¬∂			int aRightParenIndex, boolean isShared) {¬∂//		int aColonIndex = aStoredToken.indexOf(":");¬∂		if (aLeftParenIndex != -1 && aRightParenIndex != -1) {¬∂			String aVariableDeclarations = aStoredToken.substring(aLeftParenIndex + 1, aRightParenIndex);¬∂			String[] aVariables = aVariableDeclarations.split(",");¬∂			if (isShared) {¬∂				lastChild.setSharedVariables(aVariables);¬∂			} else {¬∂				lastChild.setPrivateVariables(aVariables);¬∂			}¬∂		}¬∂	}¬∂¬∂	public static RootOfFileSNode getSNode(String aFileName, String[] aFileLines) {¬∂		Stack<SNode> anSNodes = new Stack();¬∂¬∂		RootOfFileSNode retVal = new ARootOfFileSNode(aFileName);¬∂		anSNodes.add(retVal);¬∂		SNode previousHeaderNode = null;¬∂		for (int i = 0; i < aFileLines.length; i++) {¬∂			String aFileLine = aFileLines[i].trim();¬∂			if (!isCodeLine(aFileLine)) {¬∂				continue;¬∂			}¬∂			if (isForNode(aFileLine)) {¬∂				ForSNode aForSNode = getForSNode(i, aFileLine);¬∂				SNode aParent = previousHeaderNode != null?previousHeaderNode:anSNodes.peek();¬∂				aForSNode.setParent(anSNodes.peek());¬∂				aForSNode.setParent(aParent);¬∂¬∂//				anSNodes.push(aForSNode);¬∂				previousHeaderNode = aForSNode;¬∂				if (aFileLine.endsWith(")")) {¬∂					continue;¬∂				}¬∂			}¬∂			if (isExternalMethodDeclaration(aFileLine)) {¬∂				MethodSNode aMethodSNode = getMethodSNode(i, aFileLine, false);¬∂				aMethodSNode.setParent(anSNodes.peek());¬∂//				anSNodes.push(aForSNode);¬∂				previousHeaderNode = aMethodSNode;¬∂				if (aFileLine.endsWith(")")) {¬∂					continue;¬∂				}¬∂			}¬∂			if (isMethodDeclaration(aFileLine)) {¬∂				MethodSNode aMethodSNode = getMethodSNode(i, aFileLine, true);¬∂				aMethodSNode.setParent(anSNodes.peek());¬∂//				anSNodes.push(aForSNode);¬∂				previousHeaderNode = aMethodSNode;¬∂				if (aFileLine.endsWith(")")) {¬∂					continue;¬∂				}¬∂			}¬∂			if (isPragmaStart(aFileLine)) {¬∂				OMPSNode anOMPSNode = getOMPSNode(i, anSNodes.peek(), aFileLine);¬∂//				anSNodes.push(anOMPSNode);¬∂				previousHeaderNode = anOMPSNode;¬∂				continue;¬∂			}¬∂			if (isBlockStart(aFileLine)) {¬∂				SNode aBlockSNode = new ABlockSNode(i);¬∂				if (previousHeaderNode != null) {¬∂					aBlockSNode.setParent(previousHeaderNode);¬∂				} else {¬∂					aBlockSNode.setParent(anSNodes.peek());¬∂				}¬∂				anSNodes.push(aBlockSNode);¬∂				previousHeaderNode = null;¬∂				continue;¬∂			}¬∂//			} else ¬∂			if (isBlockEnd(aFileLine)) {¬∂				anSNodes.pop();¬∂				continue;¬∂			}¬∂			SNode aNewLeafNode = null;¬∂			if (isConstDeclaration(aFileLine)) {¬∂				aNewLeafNode = getConstDeclarationSNode(i, aFileLine);¬∂¬∂			} else if (isDeclaringAssignment(aFileLine)) {¬∂				aNewLeafNode = getDeclaringAssignmentSNode(i, aFileLine);¬∂¬∂			} else if (isAssignment(aFileLine)) {¬∂				aNewLeafNode = getAssignmentSNode(i, aFileLine);¬∂			} else if (isVariableDeclaration(aFileLine)) {¬∂				aNewLeafNode = getDeclarationSNode(i, aFileLine);¬∂			} else {¬∂				List<MethodCall> aCalls = callsIn(i, aFileLine, null); // parent will be assigned below¬∂				if (aCalls != null && aCalls.size() == 1) {¬∂					aNewLeafNode = aCalls.get(0);¬∂				} else {¬∂					aNewLeafNode = new ATextSNode(i, aFileLine);¬∂				}¬∂			}¬∂//			else {¬∂//				aNewLeafNode = new ATextSNode(i, aFileLine);¬∂//			}¬∂			if (previousHeaderNode != null) {¬∂				aNewLeafNode.setParent(previousHeaderNode);¬∂			} else {¬∂				aNewLeafNode.setParent(anSNodes.peek());¬∂			}¬∂¬∂		}¬∂¬∂		return retVal;¬∂	}¬∂¬∂	public static OMPSNode getOMPSNode(int aLineIndex, SNode aParentNode, String aFileLine) {¬∂		String[] aTokens = aFileLine.split("\\s+");¬∂		if (aTokens.length <= 2) {¬∂			return null;¬∂		}¬∂		if (!aTokens[1].equals("omp")) {¬∂			return null;¬∂		}¬∂		if (aTokens.length < 3) {¬∂			return null;¬∂		}¬∂		String aFirstToken = aTokens[2];¬∂		OpenMPKeywordEnum anOpenMPKeyword = stringToOpenMPKeyword.get(aFirstToken);¬∂//		List<OpenMPPragma> retVal = new ArrayList();¬∂		OMPSNode lastChild = null;¬∂		int aStartIndex = 2;¬∂		OMPSNode aNewNode = null;¬∂		OMPForSNode aForChild = null;¬∂		switch (anOpenMPKeyword) {¬∂		case PARALLEL:¬∂			aNewNode = new AnOMPParallelSNode(aLineIndex);¬∂¬∂			if (aTokens.length > 3 && aTokens[3].equals("for")) {¬∂				aForChild = new AnOMPForSNode(aLineIndex);¬∂				aForChild.setParent(aNewNode);¬∂¬∂				aStartIndex++;¬∂			}¬∂			break;¬∂		case FOR:¬∂			aNewNode = new AnOMPForSNode(aLineIndex);¬∂			;¬∂			break;¬∂		case CRITICAL:¬∂			aNewNode = new AnOMPCriticalSNode(aLineIndex);¬∂//			retVal.add (lastChild);¬∂			break;¬∂		default:¬∂			aNewNode = new AnOMPSNode(aLineIndex);¬∂¬∂		}¬∂¬∂		if (lastChild != null) {¬∂			aNewNode.setParent(lastChild);¬∂		} else {¬∂			aNewNode.setParent(aParentNode);¬∂		}¬∂		lastChild = aForChild == null ? aNewNode : aForChild;¬∂¬∂		for (int i = aStartIndex; i < aTokens.length; i++) {¬∂			String aStoredToken = aTokens[i].trim();¬∂			if (aStoredToken.isEmpty()) {¬∂				continue;¬∂			}¬∂			if (aStoredToken.startsWith("reduction") || aStoredToken.startsWith("shared")¬∂					|| aStoredToken.startsWith("private")) {¬∂				// combine all tokens until ")" into one for normalization¬∂				while (!aStoredToken.endsWith(")")) {¬∂					i++;¬∂					if (i >= aTokens.length) {¬∂						break;¬∂					}¬∂					String aNewToken = aTokens[i].trim();¬∂					aStoredToken += aNewToken;¬∂				}¬∂				int aLeftParenIndex = aStoredToken.indexOf("(");¬∂				int aRightParenIndex = aStoredToken.indexOf(")");¬∂				if (aStoredToken.startsWith("reduction")) {¬∂					setReductionData((OMPForSNode) lastChild, aStoredToken, aLeftParenIndex, aRightParenIndex);¬∂				} else if (aStoredToken.startsWith("private")) {¬∂					setSharedOrPrivateData((OMPSNode) lastChild, aStoredToken, aLeftParenIndex, aRightParenIndex,¬∂							false);¬∂¬∂				} else if (aStoredToken.startsWith("shared")) {¬∂					setSharedOrPrivateData(lastChild, aStoredToken, aLeftParenIndex, aRightParenIndex, true);¬∂¬∂				}¬∂¬∂			}¬∂¬∂			lastChild.getOpenMPTokens().add(aStoredToken);¬∂		}¬∂¬∂		return lastChild;¬∂¬∂	}¬∂¬∂	public static boolean hasParallelAncestor(SNode anSNode) {¬∂		if (anSNode == null) {¬∂			return false;¬∂		}¬∂		if (anSNode instanceof OMPParallelSNode) {¬∂			return true;¬∂		}¬∂		return hasParallelAncestor(anSNode.getParent());¬∂	}¬∂	public static boolean hasCriticalAncestor(SNode anSNode) {¬∂		if (anSNode == null) {¬∂			return false;¬∂		}¬∂		if (anSNode instanceof OMPCriticalSNode) {¬∂			return true;¬∂		}¬∂		return hasCriticalAncestor(anSNode.getParent());¬∂	}¬∂¬∂¬∂	public static Boolean isDeclaredShared(OMPSNode anOMPSNode, String anLHS) {¬∂		if (Arrays.asList(anOMPSNode.getSharedVariables()).contains(anLHS)) {¬∂			return true;¬∂		}¬∂		if (Arrays.asList(anOMPSNode.getPrivateVariables()).contains(anLHS)) {¬∂			return false;¬∂		}¬∂		return null;¬∂¬∂	}¬∂¬∂	public static boolean isSharedVariable(SNode anSNode, String anLHS) {¬∂		if (anSNode == null) {¬∂			return false;¬∂		}¬∂		if (anSNode.getLocalVariableIdentifiers().contains(anLHS)) {¬∂			if (!(anSNode instanceof OMPSNode)) { // no shared and private declarations¬∂				return !hasParallelAncestor(anSNode); // shared if not inParallel¬∂			}¬∂			OMPSNode anOMPSNode = (OMPSNode) anSNode;¬∂			return (Arrays.asList(anOMPSNode.getSharedVariables()).contains(anLHS)); // private unless declared shared¬∂		}¬∂		if (anSNode instanceof OMPSNode) {¬∂			OMPSNode anOMPSNode = (OMPSNode) anSNode;¬∂			// the variable is global to this scope, check if it has have been made shared¬∂			// or private by this scope¬∂			Boolean isDeclaredShared = isDeclaredShared(anOMPSNode, anLHS);¬∂			if (isDeclaredShared != null) {¬∂				return isDeclaredShared;¬∂			}¬∂		}¬∂		// check the parent¬∂		return isSharedVariable(anSNode.getParent(), anLHS);¬∂	}¬∂¬∂	public static List<SNode> getAllLeafNodes(SNode aTopNode) {¬∂		List<SNode> retVal = new ArrayList();¬∂		addLeafNodes(aTopNode, retVal);¬∂		return retVal;¬∂	}¬∂¬∂	public static void addLeafNodes(SNode aTopNode, List<SNode> retVal) {¬∂		for (SNode aChild : aTopNode.getChildren()) {¬∂			if (aChild.isLeaf()) {¬∂				retVal.add(aChild);¬∂			} else {¬∂				addLeafNodes(aChild, retVal);¬∂			}¬∂		}¬∂	}¬∂¬∂	public static List<SNode> getNonParallelLeafNodes(SNode aTopNode) {¬∂		List<SNode> retVal = new ArrayList();¬∂		addNonParallelLeafNodes(aTopNode, retVal);¬∂		return retVal;¬∂	}¬∂¬∂	public static void addNonParallelLeafNodes(SNode aTopNode, List<SNode> retVal) {¬∂		if (aTopNode.isInParallel()) {¬∂			return;¬∂		}¬∂		for (SNode aChild : aTopNode.getChildren()) {¬∂			if (aChild.isLeaf()) {¬∂				retVal.add(aChild);¬∂			} else {¬∂				addLeafNodes(aChild, retVal);¬∂			}¬∂		}¬∂	}¬∂	static String callRegex = "([a-zA-Z_$][a-zA-Z_$0-9]*)\\(.*?\\)";¬∂	static Pattern callPattern = Pattern.compile(callRegex);¬∂¬∂	static String identifierRegex = "[a-zA-Z_$][a-zA-Z_$0-9]*";¬∂	static Pattern identifierPattern = Pattern.compile(identifierRegex);¬∂	public static List<String> identifiersIn(String aString) {¬∂		if (aString == null)¬∂			return null;¬∂//		Pattern mypattern = Pattern.compile("[a-zA-Z_$][a-zA-Z_$0-9]*");¬∂//		Matcher mymatcher = mypattern.matcher(aString);¬∂		Matcher mymatcher = identifierPattern.matcher(aString);¬∂		List<String> retVal = new ArrayList();¬∂		while (mymatcher.find()) {¬∂			String find = mymatcher.group(0);¬∂			retVal.add(find);¬∂		}¬∂		return retVal;¬∂	}¬∂	public static List<MethodCall> callsIn(int aLineNumber, String aString, SNode aParent) {¬∂		if (aString == null)¬∂			return emptyList;¬∂		if (isMethodDeclaration(aString)) {¬∂			return emptyList;¬∂		}¬∂//		Pattern mypattern = Pattern.compile("[a-zA-Z_$][a-zA-Z_$0-9]*");¬∂//		Matcher mymatcher = mypattern.matcher(aString);¬∂		Matcher mymatcher = callPattern.matcher(aString);¬∂		List<MethodCall> retVal = new ArrayList();¬∂		while (mymatcher.find()) {¬∂			String find = mymatcher.group(0);¬∂			int aLeftParenIndex = find.indexOf("(");¬∂			int aRightParenIndex = find.indexOf(")");¬∂			String aMethodName = find.substring(0, aLeftParenIndex).trim();¬∂			String aParameters = find.substring(aLeftParenIndex + 1, aRightParenIndex);¬∂			List<String> aParameterList = new ArrayList();¬∂			String[] aParameterTokens = aParameters.split(",");¬∂			for (String aParameter:aParameterTokens) {¬∂				String aParameterTrimmed = aParameter.trim();¬∂				if (!aParameterTrimmed.isEmpty())¬∂				aParameterList.add(aParameterTrimmed);¬∂			}¬∂			retVal.add(new AMethodCall(aLineNumber, aMethodName, aParameterList, aParent));¬∂¬∂//			aCallStrings.add(find);¬∂		}¬∂		return retVal;¬∂	}¬∂	static String numberRegex = "(\\d+\\.\\d+)|(\\d+)";¬∂	static Pattern numberPattern = Pattern.compile(numberRegex);¬∂	public static List<String> numbersIn(String aString) {¬∂		if (aString == null)¬∂			return null;¬∂//		String regex = "(\\d+\\.\\d+)|(\\d+)";¬∂//¬∂//		Matcher m = Pattern.compile(regex).matcher(aString);¬∂		Matcher m =numberPattern.matcher(aString);¬∂¬∂¬∂		List<String> retVal = new ArrayList();¬∂¬∂		while (m.find()) {¬∂			retVal.add(m.group());¬∂		}¬∂		return retVal;¬∂	}¬∂¬∂	public static String subscriptIn(String aString) {¬∂		if (aString == null)¬∂			return null;¬∂		return StringUtils.substringBetween(aString, "[", "]");¬∂	}¬∂	static String[] emptyStringArray = {};¬∂	static List emptyList = new ArrayList();¬∂¬∂	public static String[] subscriptsIn(String aString) {¬∂		if (aString == null)¬∂			return emptyStringArray;¬∂		return StringUtils.substringsBetween(aString, "[", "]");¬∂	}¬∂	static  String operatorRegex = "([+-/*///^])|([/(/)])";¬∂	static Pattern operatorPattern = Pattern.compile(operatorRegex);¬∂¬∂	public static List<String> operatorsIn(String aString) {¬∂		if (aString == null)¬∂			return null;¬∂//		String operatorRegex = "([+-/*///^])|([/(/)])";¬∂//¬∂//		Matcher m = Pattern.compile(operatorRegex).matcher(aString);¬∂		¬∂		Matcher m = operatorPattern.matcher(aString);¬∂¬∂¬∂		List<String> retVal = new ArrayList();¬∂¬∂		while (m.find()) {¬∂			retVal.add(m.group());¬∂		}¬∂		return retVal;¬∂	}¬∂	¬∂	public static int numberOfNestingFors (SNode anSNode) {¬∂		if (anSNode == null) {¬∂			return 0;¬∂		}¬∂		int retVal = numberOfNestingFors (anSNode.getParent()) ;¬∂¬∂		if (anSNode instanceof ForSNode) {¬∂			retVal++;¬∂		} else if (anSNode instanceof MethodSNode) {¬∂			List<MethodCall> aMethodCalls = ((MethodSNode) anSNode).getCalls();¬∂			int aMaxNestingLevel = 0;¬∂			for (MethodCall aMethodCall:aMethodCalls) {¬∂				MethodSNode aCallerMethodSNode = getDeclarationOfCalledMethod(anSNode, aMethodCall);¬∂				int aCallerNumberOfNestingFors = numberOfNestingFors(aCallerMethodSNode);¬∂				aMaxNestingLevel = Math.max(aCallerNumberOfNestingFors, aMaxNestingLevel);				¬∂			}¬∂			return retVal + aMaxNestingLevel;¬∂		}¬∂		return retVal;¬∂	}¬∂	public static boolean hasOperator (SNode anSNode, String anOperator) {¬∂		boolean retVal = false;¬∂		if (anSNode instanceof AssignmentSNode) {¬∂			AssignmentSNode anAssignmentSNode = (AssignmentSNode) anSNode;¬∂			 retVal = (anAssignmentSNode.getLhsOperators().contains(anOperator) || ¬∂					anAssignmentSNode.getRhsOperators().contains(anOperator)) ;¬∂			if (retVal) {¬∂				return retVal;¬∂			} else {¬∂				List<MethodCall> aMethodCalls = anAssignmentSNode.getRhsCalls();¬∂				for (MethodCall aMethodCall:aMethodCalls) {¬∂					MethodSNode aMethodSNode = getDeclarationOfCalledMethod(anSNode, aMethodCall);¬∂					retVal = hasOperator(aMethodSNode, anOperator);¬∂					if (retVal) {¬∂						return retVal;¬∂					}¬∂					¬∂				}¬∂				return false;¬∂			}¬∂			¬∂		}¬∂		for (SNode aChild:anSNode.getChildren()) {¬∂			retVal = hasOperator(aChild, anOperator);¬∂			if (retVal) {¬∂				return retVal;¬∂			}¬∂		}¬∂		return false;¬∂	}¬∂	public static boolean hasMethodCall (SNode anSNode, String anOperator) {¬∂		boolean retVal = false;¬∂		if (anSNode instanceof AssignmentSNode) {¬∂			AssignmentSNode anAssignmentSNode = (AssignmentSNode) anSNode;¬∂			 retVal = (anAssignmentSNode.getLhsOperators().contains(anOperator) || ¬∂					anAssignmentSNode.getRhsOperators().contains(anOperator)) ;¬∂			if (retVal) {¬∂				return retVal;¬∂			} else {¬∂				List<MethodCall> aMethodCalls = anAssignmentSNode.getRhsCalls();¬∂				for (MethodCall aMethodCall:aMethodCalls) {¬∂					MethodSNode aMethodSNode = getDeclarationOfCalledMethod(anSNode, aMethodCall);¬∂					retVal = hasOperator(aMethodSNode, anOperator);¬∂					if (retVal) {¬∂						return retVal;¬∂					}¬∂					¬∂				}¬∂				return false;¬∂			}¬∂			¬∂		}¬∂		for (SNode aChild:anSNode.getChildren()) {¬∂			retVal = hasOperator(aChild, anOperator);¬∂			if (retVal) {¬∂				return retVal;¬∂			}¬∂		}¬∂		return false;¬∂	}¬∂	public static boolean dependsOn (AssignmentSNode anAssignmentSNode, String aVariable, String aCallIdentifier) {¬∂		// This assignment does not change aVariable¬∂		if (!aVariable.equals(anAssignmentSNode.getLhsFirstIdentifier())) {¬∂			return false;¬∂		}¬∂		return dependsOn(anAssignmentSNode.getExpressionSNode(), aCallIdentifier);¬∂//		List<String> aCallIdentifiers = anAssignmentSNode.getRhsCallIdentifiers();¬∂//		boolean retVal = false;¬∂//		if (aCallIdentifiers != null && aCallIdentifiers.contains(aCallIdentifier)) {¬∂//			return true; // this assignment has aCallIdentifier in the rhs¬∂//		}¬∂//		// check if some referenced rhs variable depends on aCallIdentifier¬∂//		List<String> aReferencedVariableIdentifiers = anAssignmentSNode.getRhsVariableIdentifiers();¬∂//		SNode anAssignmentParent = anAssignmentSNode.getParent();¬∂//		if (anAssignmentParent == null) { // should never be trye¬∂//			return false;¬∂//		}¬∂//		int aLineNumber = anAssignmentSNode.getLineNumber();¬∂//		for (String aReferencedVariableIdentifier:aReferencedVariableIdentifiers ) {¬∂//			if (dependsOn (anAssignmentParent, aLineNumber, aReferencedVariableIdentifier, aCallIdentifier)) {¬∂//				return true;¬∂//			}¬∂//		}¬∂//		return false;¬∂	}¬∂	public static boolean dependsOn (ExpressionSNode anExpressionSNode, String aCallIdentifier) {¬∂		// This assignment does not change aVariable¬∂		¬∂		List<String> aCallIdentifiers = anExpressionSNode.getRhsCallIdentifiers();¬∂		boolean retVal = false;¬∂		if (aCallIdentifiers != null && aCallIdentifiers.contains(aCallIdentifier)) {¬∂			return true; // this assignment has aCallIdentifier in the rhs¬∂		}¬∂		// check if some referenced rhs variable depends on aCallIdentifier¬∂		List<String> aReferencedVariableIdentifiers = anExpressionSNode.getRhsVariableIdentifiers();¬∂		SNode anAssignmentParent = anExpressionSNode.getParent().getParent();¬∂		if (anAssignmentParent == null) { // should never be trye¬∂			return false;¬∂		}¬∂		int aLineNumber = anExpressionSNode.getLineNumber();¬∂		for (String aReferencedVariableIdentifier:aReferencedVariableIdentifiers ) {¬∂			if (dependsOn (anAssignmentParent, aLineNumber, aReferencedVariableIdentifier, aCallIdentifier)) {¬∂				return true;¬∂			}¬∂		}¬∂		return false;¬∂	}¬∂	public static Set<AssignmentSNode> assignmentsToSharedVariables(SNode anSNode) {¬∂		Set<AssignmentSNode> retVal =  new HashSet();¬∂		fillAssignmentsToShared(anSNode, retVal);¬∂		return retVal;¬∂		¬∂	}¬∂	public static Set<AssignmentSNode> assignmentsToSharedArrays(SNode anSNode) {¬∂		Set<AssignmentSNode> anAllSharedAssignments =  assignmentsToSharedVariables(anSNode);¬∂		Set<AssignmentSNode> aRetVal = new HashSet();¬∂		for (AssignmentSNode anAssignmentSNode:anAllSharedAssignments) {¬∂			if (anAssignmentSNode.getLhsSubscripts().length > 0) {¬∂				aRetVal.add(anAssignmentSNode);¬∂			}¬∂		}¬∂		return aRetVal;¬∂		¬∂	}¬∂	public static Set<AssignmentSNode> assignmentsToParallelCriticalSharedVariables(SNode anSNode) {¬∂		Set<AssignmentSNode> anAllSharedAssignments =  assignmentsToSharedVariables(anSNode);¬∂		Set<AssignmentSNode> aRetVal = new HashSet();¬∂		for (AssignmentSNode anAssignmentSNode:anAllSharedAssignments) {¬∂			if (anAssignmentSNode.isInParallel() &&¬∂					anAssignmentSNode.isInCritical()) {¬∂				aRetVal.add(anAssignmentSNode);¬∂			}¬∂		}¬∂		return aRetVal;¬∂		¬∂	}¬∂	public static Set<AssignmentSNode> assignmentsToNonParallelCriticalSharedVariables(SNode anSNode) {¬∂		Set<AssignmentSNode> anAllSharedAssignments =  assignmentsToSharedVariables(anSNode);¬∂		Set<AssignmentSNode> aRetVal = new HashSet();¬∂		for (AssignmentSNode anAssignmentSNode:anAllSharedAssignments) {¬∂			if (!anAssignmentSNode.isInParallel() &&¬∂					anAssignmentSNode.isInCritical()) {¬∂				aRetVal.add(anAssignmentSNode);¬∂			}¬∂		}¬∂		return aRetVal;¬∂		¬∂	}¬∂	public static Set<AssignmentSNode> assignmentsToParallelNonCriticalSharedVariables(SNode anSNode) {¬∂		Set<AssignmentSNode> anAllSharedAssignments =  assignmentsToSharedVariables(anSNode);¬∂		Set<AssignmentSNode> aRetVal = new HashSet();¬∂		for (AssignmentSNode anAssignmentSNode:anAllSharedAssignments) {¬∂			if (anAssignmentSNode.isInParallel() &&¬∂					!anAssignmentSNode.isInCritical()) {¬∂				aRetVal.add(anAssignmentSNode);¬∂			}¬∂		}¬∂		return aRetVal;¬∂		¬∂	}¬∂    public static void fillAssignmentsToShared(SNode anSNode, Set<AssignmentSNode> retVal) {¬∂    	if (anSNode instanceof AssignmentSNode) {¬∂			AssignmentSNode anAssignmentSNode = (AssignmentSNode) anSNode;¬∂			String anLHS = anAssignmentSNode.getLhsFirstIdentifier();¬∂			if (isSharedVariable(anSNode, anLHS)) {¬∂				retVal.add(anAssignmentSNode);¬∂				return;¬∂			}¬∂		}¬∂    	for (SNode aChild:anSNode.getChildren()) {¬∂    		fillAssignmentsToShared(aChild, retVal);¬∂    	}¬∂		¬∂	}¬∂    public static void fillInstancesOfNodeType(Class<? extends SNode> aNodeType, SNode anSNode, Set<SNode> retVal) {¬∂    	if (aNodeType.isAssignableFrom(anSNode.getClass())) {¬∂			¬∂				retVal.add(anSNode);¬∂				return;¬∂			}¬∂		¬∂    	for (SNode aChild:anSNode.getChildren()) {¬∂    		fillInstancesOfNodeType(aNodeType, aChild, retVal);¬∂    	}¬∂		¬∂	}¬∂    public static Set<AssignmentSNode>  assignmentSNodes(SNode anSNode) {¬∂    	Set retVal = new HashSet();    	¬∂    	fillInstancesOfNodeType(AssignmentSNode.class, anSNode, retVal );¬∂    	return retVal;¬∂	}¬∂   ¬∂    ¬∂    public static Set<OMPParallelSNode>  ompParallelSNodes(SNode anSNode) {¬∂    	Set retVal = new HashSet();    	¬∂    	fillInstancesOfNodeType(OMPParallelSNode.class, anSNode, retVal );¬∂    	return retVal;¬∂	}¬∂//    public static void fillOMPParallelSNodes(SNode anSNode, Set<OMPParallelSNode> retVal) {¬∂//    	if (anSNode instanceof OMPParallelSNode) {¬∂//    		retVal.add((OMPParallelSNode) anSNode);¬∂//		}¬∂//    	for (SNode aChild:anSNode.getChildren()) {¬∂//    		fillOMPParallelSNodes(aChild, retVal);¬∂//    	}		¬∂//	}¬∂    public static Set<ForSNode>  forSNodes(SNode anSNode) {¬∂    	Set retVal = new HashSet();    	¬∂    	fillInstancesOfNodeType(ForSNode.class, anSNode, retVal );¬∂    	return retVal;¬∂	}¬∂//    public static void fillForSNodes(SNode anSNode, Set<ForSNode> retVal) {¬∂//    	if (anSNode instanceof ForSNode) {¬∂//    		retVal.add((ForSNode) anSNode);¬∂//		}¬∂//    	for (SNode aChild:anSNode.getChildren()) {¬∂//    		fillForSNodes(aChild, retVal);¬∂//    	}		¬∂//	}¬∂    public static Set<OMPForSNode>  ompForSNodes(SNode anSNode) {¬∂    	Set retVal = new HashSet();    	¬∂    	fillInstancesOfNodeType(OMPForSNode.class, anSNode, retVal );¬∂    	return retVal;¬∂	}¬∂//    public static void fillOMPForSNodes(SNode anSNode, Set<OMPForSNode> retVal) {¬∂//    	if (anSNode instanceof OMPForSNode) {¬∂//    		retVal.add((OMPForSNode) anSNode);¬∂//		}¬∂//    	for (SNode aChild:anSNode.getChildren()) {¬∂//    		fillOMPForSNodes(aChild, retVal);¬∂//    	}		¬∂//	}¬∂    public static Set<OMPForSNode> ompReducingForNodes(SNode anSNode) {¬∂		Set<OMPForSNode> anAllOMPForSNodes =  ompForSNodes(anSNode);¬∂		Set<OMPForSNode> aRetVal = new HashSet();¬∂		for (OMPForSNode anOMPForSNode:anAllOMPForSNodes) {¬∂			if (anOMPForSNode.getReductionOperation() != null) {¬∂				aRetVal.add(anOMPForSNode);¬∂			}¬∂		}¬∂		return aRetVal;		¬∂	}¬∂    public static Set<AssignmentSNode> assignmentsToOMPReducingForNode(OMPForSNode anOMPForSNode) {¬∂    	String aReductionVariable = anOMPForSNode.getReductionVariable();¬∂    	return directAssignmentsOfVariableAndItsAliases(anOMPForSNode, aReductionVariable)	;¬∂    	¬∂    }¬∂	public static boolean dependsOn (SNode anSNode, int aVariableLineNumber, String aVariable, String aCallIdentifier) {¬∂		List<SNode> aListSNodes = anSNode.getChildren();¬∂		boolean retVal = false;¬∂		/*¬∂		 * Should probably ignore line number as it assumes straight line code¬∂		 */¬∂		for (int i = aVariableLineNumber; i >= 0; i--) {¬∂			SNode anSNodeChild = aListSNodes.get(i);¬∂			if (anSNodeChild instanceof AssignmentSNode) {¬∂				// does this statement in anSNode directly invoke aCallIdentifier ¬∂				if (dependsOn((AssignmentSNode) anSNodeChild, aVariable, aCallIdentifier))¬∂					return true;¬∂			} else if (!anSNode.isLeaf()) {¬∂					// child is overriding the variable so forget checking its assignment statements¬∂					if (anSNodeChild.getLocalVariableIdentifiers().contains(aVariable)) {¬∂						continue;¬∂					}¬∂					// some subblock of anSNode that has access to aVariable changes variable¬∂¬∂					if (dependsOn(anSNodeChild, anSNodeChild.getChildren().size() - 1, aVariable, aCallIdentifier)) {¬∂						return true;¬∂					}¬∂			}¬∂			¬∂		}¬∂		// none of the statements in anSNode or its descendents  have the required call¬∂		// is the variable a  method parameter ¬∂		if (anSNode instanceof MethodSNode) {¬∂			MethodSNode aMethodSNode = (MethodSNode) anSNode;¬∂			¬∂			int aParameterNumber = aMethodSNode.getLocalVariableIdentifiers().indexOf(aVariable);¬∂			if (aParameterNumber != -1) {¬∂				List <MethodCall> aCalls = aMethodSNode.getCalls();¬∂				for (MethodCall aCall:aCalls) {¬∂//					if (!aCall.getMethodActuals().contains(aVariable))¬∂//						continue;¬∂//					¬∂					MethodSNode aCallerSNode = getDeclarationOfCalledMethod(aMethodSNode, aCall);¬∂					if (dependsOn(aMethodSNode, aCallerSNode.getLineNumber(), aCallerSNode.getLocalVariableIdentifiers().get(aParameterNumber), aCallIdentifier));¬∂//				    if (aCallerDepends) {¬∂				    	return true;¬∂//				    }¬∂				}¬∂				return false;¬∂				// need to find all callers of method and see if any of the aliases for the variable in these¬∂				// calls depend on aCallIndentifier¬∂			}			¬∂			¬∂		} else if (anSNode.getLocalVariableIdentifiers().contains(aVariable)) {¬∂			// before going to the parent node, let us see if aVariable is declared here as a non  parameter ¬∂¬∂			return false; // no point going to parent¬∂		}¬∂		// not a local variable (parameter or declarated variable)¬∂		SNode anSNodeParent = anSNode.getParent() ;¬∂		if (anSNodeParent == null)  {¬∂			return false;¬∂		}¬∂		int anSNodeLineNumber = anSNodeParent.getChildren().indexOf(anSNode);¬∂		return dependsOn(anSNodeParent, anSNodeLineNumber, aVariable, aCallIdentifier);¬∂		¬∂	}¬∂	"), Diff(INSERT,"public static Set<AssignmentSNode> assignmentsOfVariableAliases (SNode anSNode,  String aVariable) {¬∂		Set<AssignmentSNode> retVal = new HashSet();¬∂		fillDirectAssignmentsOfVariableAndItsAliases(anSNode, aVariable, retVal);¬∂		return retVal;¬∂	}¬∂	public static void fillDirectAssignmentsOfVariableAliases (SNode anSNode,  String aVariable, Set<AssignmentSNode> retVal) {¬∂		if (anSNode instanceof MethodCall) {¬∂			MethodCall aMethodCall = (MethodCall) anSNode;¬∂			int aParameterNumber = aMethodCall.getMethodActualIdentifiers().indexOf(aVariable);¬∂			if (aParameterNumber < 0) {¬∂				return;¬∂			}¬∂			MethodSNode aDeclaringMethodSNode = getDeclarationOfCalledMethod(anSNode, aMethodCall);¬∂			String aFormalParameter = aDeclaringMethodSNode.getLocalVariableIdentifiers().get(aParameterNumber);¬∂//			Set<AssignmentSNode> aCallAssignments = ;¬∂			fillDirectAssignmentsOfVariableAliases(aDeclaringMethodSNode, aFormalParameter, retVal);¬∂		} else {¬∂			List<SNode> aChildren = anSNode.getChildren();¬∂			for (SNode aChild:aChildren) {¬∂				fillDirectAssignmentsOfVariableAliases(aChild, aVariable, retVal);¬∂			}¬∂		}		¬∂		¬∂	}¬∂	"), Diff(EQUAL,"¬∂	/*¬∂	 * will not consider assignments to variables in the RHS of these assignments¬∂	 */¬∂	public static Set<AssignmentSNode> directAssignmentsOfVariableAndItsAliases (SNode anSNode,  String aVariable) {¬∂		Set<AssignmentSNode> retVal = new HashSet();¬∂		fillDirectAssignmentsOfVariableAndItsAliases(anSNode, aVariable, retVal);¬∂		return retVal;¬∂	}¬∂"), Diff(INSERT,"	¬∂"), Diff(EQUAL,"//	public static Set<AssignmentSNode> assignmentsEffectingVariableAndItsAliases (SNode anSNode,  String aVariable) {¬∂//		Set<AssignmentSNode> retVal = directAssignmentsOfVariableAndItsAliases(anSNode, aVariable);¬∂//		¬∂//	}¬∂	public static void fillDirectAssignmentsOfVariableAndItsAliases (SNode anSNode,  String aVariable, Set<AssignmentSNode> retVal) {¬∂		if (anSNode instanceof AssignmentSNode) {¬∂			AssignmentSNode anAssignmentSNode = (AssignmentSNode) anSNode;¬∂			if (anAssignmentSNode.getLhsFirstIdentifier().equals(aVariable)) {¬∂				retVal.add(anAssignmentSNode);¬∂			}¬∂		}¬∂		¬∂		else if (anSNode instanceof MethodCall) {¬∂			MethodCall aMethodCall = (MethodCall) anSNode;¬∂			int aParameterNumber = aMethodCall.getMethodActualIdentifiers().indexOf(aVariable);¬∂			if (aParameterNumber < 0) {¬∂				return;¬∂			}¬∂			MethodSNode aDeclaringMethodSNode = getDeclarationOfCalledMethod(anSNode, aMethodCall);¬∂			String aFormalParameter = aDeclaringMethodSNode.getLocalVariableIdentifiers().get(aParameterNumber);¬∂//			Set<AssignmentSNode> aCallAssignments = ;¬∂			fillDirectAssignmentsOfVariableAndItsAliases(aDeclaringMethodSNode, aFormalParameter, retVal);¬∂		} else {¬∂			List<SNode> aChildren = anSNode.getChildren();¬∂			for (SNode aChild:aChildren) {¬∂				fillDirectAssignmentsOfVariableAndItsAliases(aChild, aVariable, retVal);¬∂			}¬∂		}		¬∂		¬∂	}¬∂	¬∂	public static RootOfFileSNode getRootOfFileNode(SNode aCurrentSNode ) {¬∂		if (aCurrentSNode instanceof RootOfFileSNode) {¬∂			return (RootOfFileSNode) aCurrentSNode;¬∂		}¬∂		SNode aParentSNode = aCurrentSNode.getParent() ;¬∂		¬∂		if (aParentSNode == null) {¬∂			return null;¬∂		}¬∂		¬∂		return getRootOfFileNode(aParentSNode);¬∂		¬∂	}¬∂	public static boolean match (MethodSNode aMethodSNode, MethodCall aMethodCall) {¬∂		return aMethodSNode.getMethodName().equals(aMethodCall.getMethodName()) ¬∂				&& aMethodSNode.getLocalVariableIdentifiers().size() == aMethodCall.getMethodActuals().size();¬∂	}¬∂	public static DeclarationSNode getDeclarationOfVariableIdentifier(SNode aCurrentSNode, String anIdentifier) {¬∂		if (aCurrentSNode == null) {¬∂			return null;¬∂		}¬∂		¬∂		¬∂		int anIndex = aCurrentSNode.getLocalVariableIdentifiers().indexOf(anIdentifier);¬∂		if (anIndex < 0) {¬∂			return getDeclarationOfVariableIdentifier(aCurrentSNode.getParent(), anIdentifier);¬∂		}¬∂		DeclarationSNode retVal = aCurrentSNode.getVariableDeclarations().get(anIndex);¬∂//		retVal.getAssignmentsToDeclaredVariable().add(anAssignmentSNode);¬∂//		anAssignmentSNode.setLhsFirstIdentifierDeclaration(retVal);¬∂		return retVal;¬∂	}¬∂	¬∂	public static DeclarationSNode getDeclarationOfAssignedVariable(SNode aCurrentSNode, AssignmentSNode anAssignmentSNode) {¬∂		if (aCurrentSNode == null) {¬∂			return null;¬∂		}¬∂		if (anAssignmentSNode instanceof ADeclaringAssignmentSNode) {¬∂			return (ADeclaringAssignmentSNode) anAssignmentSNode;¬∂		}¬∂		int anIndex = aCurrentSNode.getLocalVariableIdentifiers().indexOf(anAssignmentSNode.getLhsFirstIdentifier());¬∂		if (anIndex < 0) {¬∂			return getDeclarationOfAssignedVariable(aCurrentSNode.getParent(), anAssignmentSNode);¬∂		}¬∂		DeclarationSNode retVal = aCurrentSNode.getVariableDeclarations().get(anIndex);¬∂//		retVal.getAssignmentsToDeclaredVariable().add(anAssignmentSNode);¬∂//		anAssignmentSNode.setLhsFirstIdentifierDeclaration(retVal);¬∂		return retVal;¬∂	}¬∂	¬∂	public static MethodSNode getDeclarationOfCalledMethod(SNode aCurrentSNode, MethodCall aMethodCall ) {¬∂		SNode aRootNode = getRootOfFileNode(aCurrentSNode);¬∂		for (SNode aChild:aRootNode.getChildren()) {¬∂			if (aChild instanceof MethodSNode) {¬∂				MethodSNode aMethodSNode = (MethodSNode) aChild;¬∂				if (match (aMethodSNode, aMethodCall)) {¬∂					return aMethodSNode;¬∂				}¬∂			}¬∂		}¬∂		return null; // this should never happen;¬∂	}¬∂	¬∂	public static RootOfProgramSNode getRootOfProgramSNode(String aSource) {¬∂		RootOfProgramSNode retVal = new ARootOfProgramSNode();¬∂		Map<String, StringBuffer> aFileNameToContents = ABasicTextManager.extractFileContents(aSource);¬∂		for (String aFileName:aFileNameToContents.keySet()) {¬∂			StringBuffer aFileContents = aFileNameToContents.get(aFileName);¬∂//			List<OpenMPPragma> anOpenMPPragmas = OpenMPUtils.getOpemMPPragmas(aFileContents);¬∂			RootOfFileSNode anSNode = OMPSNodeUtils.getSNode(aFileName, aFileContents);¬∂			retVal.getFileNameToSNode().put(aFileName, anSNode);¬∂			anSNode.setParent(retVal);¬∂//			System.out.println("file name:" + aFileName);¬∂//			System.out.println("pragmas:" + anSNode);¬∂		}¬∂		processExternalMethodSNodes(retVal);¬∂		processIndirectAssignments(retVal);¬∂		return retVal;¬∂	}¬∂//	public static void processIndirectAssignments (S aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode) {¬∂//		for (SNode anSNode:aRootOfFileSNode.getChildren()) {¬∂//			-----¬∂//		}¬∂//	}¬∂	public static void processExternalMethodSNodes (RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode) {¬∂		for (SNode anSNode:aRootOfFileSNode.getChildren()) {¬∂			if (anSNode instanceof ExternalMethodSNode) {¬∂				processExternalMethodSNode(aRootOfProgramSNode, aRootOfFileSNode, (ExternalMethodSNode) anSNode);¬∂			}¬∂		}¬∂	}¬∂	public static void processExternalMethodSNode (RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode, ExternalMethodSNode anExternalMethodSNode) {¬∂		MethodSNode aMethodSNode = aRootOfProgramSNode.getExternalToInternalMethod().get(anExternalMethodSNode.toString());¬∂		if (aMethodSNode == null) {¬∂			aMethodSNode = findMethodSNode(aRootOfProgramSNode, aRootOfFileSNode, anExternalMethodSNode);¬∂			if (aMethodSNode != null) {¬∂				aRootOfProgramSNode.getExternalToInternalMethod().put(anExternalMethodSNode.toString(),aMethodSNode );¬∂			}¬∂		}¬∂		if (aMethodSNode != null) {¬∂			anExternalMethodSNode.setActualMethodSNode(aMethodSNode);¬∂			aMethodSNode.getCalls().addAll(anExternalMethodSNode.getLocalCalls());¬∂		}¬∂	}¬∂	¬∂	public static MethodSNode findMethodSNode (RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode, ExternalMethodSNode anExternalMethodSNode) {¬∂//		MethodSNode foundMethodSNode = null;¬∂		for (String aFileName:aRootOfProgramSNode.getFileNameToSNode().keySet()) {¬∂			if (aFileName.equals(aRootOfFileSNode.getFileName()))¬∂				continue;¬∂			¬∂			RootOfFileSNode aSearchedRootOfFileSNode = aRootOfProgramSNode.getFileNameToSNode().get(aFileName);¬∂			 for (SNode anSNode:aSearchedRootOfFileSNode.getChildren()) {¬∂				if (anSNode instanceof MethodSNode && !(anSNode instanceof ExternalMethodSNode)) {¬∂					if (anSNode.toString().equals(anExternalMethodSNode.toString())) {¬∂						return (MethodSNode) anSNode;¬∂						¬∂					}¬∂//					processExternalMethodSNode(aRootOfProgramSNode, aRootOfFileSNode, (ExternalMethodSNode) anSNode);¬∂				}¬∂			}¬∂		}¬∂		return null;¬∂	}¬∂	public static void processExternalMethodSNodes (RootOfProgramSNode aRootOfProgramSNode) {¬∂		for (String aFileName:aRootOfProgramSNode.getFileNameToSNode().keySet()) {¬∂			RootOfFileSNode aRootOfFileSNode = aRootOfProgramSNode.getFileNameToSNode().get(aFileName);¬∂			processExternalMethodSNodes(aRootOfProgramSNode, aRootOfFileSNode);¬∂			aRootOfFileSNode.getOmp_get_num_threads_SNode().¬∂				setActualMethodSNode(aRootOfProgramSNode.getOmp_get_num_threads_SNode());¬∂			aRootOfFileSNode.getOmp_get_thread_num_SNode().¬∂				setActualMethodSNode(aRootOfProgramSNode.getOmp_get_thread_num_SNode());¬∂			aRootOfFileSNode.getOmp_get_wtime_SNode().¬∂			setActualMethodSNode(aRootOfProgramSNode.getOmp_get_wtime_SNode());¬∂		}¬∂¬∂	}¬∂	public static void processIndirectAssignments (SNode anSNode) {¬∂		if (anSNode instanceof ConstDeclarationSNode) {¬∂			return;¬∂		}¬∂		if (anSNode instanceof DeclarationSNode) {¬∂			DeclarationSNode aDeclarationSNode = (DeclarationSNode) anSNode;¬∂			Set<AssignmentSNode> anIndirectAssignments = aDeclarationSNode.getAssignmentsEffectingDeclaredIdentifier();¬∂			if (anIndirectAssignments != null) {¬∂				return; // already assigned¬∂			}¬∂			anIndirectAssignments = new HashSet<>();¬∂			aDeclarationSNode.setAssignmentsEffectingDeclaredIdentifier(anIndirectAssignments);¬∂			Set<AssignmentSNode> aDirectAssignments = aDeclarationSNode.getAssignmentsToDeclaredVariable();¬∂			anIndirectAssignments.addAll(aDirectAssignments);¬∂			"), Diff(INSERT,"Set<AssignmentSNode> anAliasAssignments = assignmentsOfVariableAliases(aDeclarationSNode.getParent(), aDeclarationSNode.getVariableName());¬∂			anIndirectAssignments.addAll(anAliasAssignments);¬∂			"), Diff(EQUAL,"for (AssignmentSNode aDirectAssignment:aDirectAssignments) {¬∂				List<String> aVariableIdentifiers = aDirectAssignment.getRhsVariableIdentifiers();¬∂				¬∂				for (String aVariableIdentifier:aVariableIdentifiers) {¬∂					DeclarationSNode aDependeeDeclarationSNode = getDeclarationOfVariableIdentifier(aDirectAssignment, aVariableIdentifier);¬∂					if (aDependeeDeclarationSNode == null) {¬∂						System.err.println("Could not find declaration of:" + aVariableIdentifier + " referenced in:" + aDirectAssignment );¬∂						continue;¬∂					}¬∂					processIndirectAssignments(aDependeeDeclarationSNode);¬∂					Set<AssignmentSNode> aDependeeIndirectAssignments = aDeclarationSNode.getAssignmentsEffectingDeclaredIdentifier();¬∂					anIndirectAssignments.addAll(aDependeeIndirectAssignments);¬∂					¬∂				}¬∂			}¬∂		} else {¬∂			for (SNode aChild: anSNode.getChildren()) {¬∂				processIndirectAssignments(aChild);¬∂			}¬∂		}¬∂		¬∂	}¬∂	¬∂//	public static void fillIndirectAssignments (SNode anSNode, Set<AssignmentSNode> retVal ) {¬∂//		¬∂//	}¬∂	¬∂¬∂//	public static void main(String[] args) {¬∂//		List<MethodCall> aTokens = callsIn("foo(bar, hgf)/foo2()*foo3(b, a c,)");¬∂//		System.out.println(aTokens);¬∂//		¬∂//		¬∂////		List<String> aTokens = identifiersIn("a[i] + b*2/3");¬∂////		System.out.println(aTokens);¬∂////		aTokens = numbersIn("a[i] + b*2/3");¬∂////		System.out.println(aTokens);¬∂////		aTokens = operatorsIn("a[i] + b*2/3");¬∂////		System.out.println(aTokens);¬∂////¬∂////		System.out.println(StringUtils.substringBetween("a", "[", "]"));¬∂//	}¬∂¬∂}¬∂")]]]></diff>
    <snapshot><![CDATA[package gradingTools.shared.testcases.openmp.scannedTree;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Stack;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.apache.commons.lang.StringUtils;

import grader.basics.project.source.ABasicTextManager;
import gradingTools.shared.testcases.openmp.OpenMPKeywordEnum;
import gradingTools.shared.testcases.openmp.OpenMPParallelPragma;
import gradingTools.shared.testcases.openmp.OpenMPUtils;
import gradingTools.shared.testcases.openmp.scannedTree.ADeclarationSNode;
import gradingTools.shared.testcases.openmp.scannedTree.ADeclaringAssignmentSNode;
import gradingTools.shared.testcases.openmp.scannedTree.AForSNode;
import gradingTools.shared.testcases.openmp.scannedTree.ATextSNode;
import gradingTools.shared.testcases.openmp.scannedTree.AnAssignmentSNode;
import gradingTools.shared.testcases.openmp.scannedTree.AnOMPCriticalSNode;
import gradingTools.shared.testcases.openmp.scannedTree.AnOMPForSNode;
import gradingTools.shared.testcases.openmp.scannedTree.AnOMPParallelSNode;
import gradingTools.shared.testcases.openmp.scannedTree.AnOMPSNode;
import gradingTools.shared.testcases.openmp.scannedTree.AnSNode;
import gradingTools.shared.testcases.openmp.scannedTree.AssignmentSNode;
import gradingTools.shared.testcases.openmp.scannedTree.DeclarationSNode;
import gradingTools.shared.testcases.openmp.scannedTree.DeclaringAssignmentSNode;
import gradingTools.shared.testcases.openmp.scannedTree.ForSNode;
import gradingTools.shared.testcases.openmp.scannedTree.OMPForSNode;
import gradingTools.shared.testcases.openmp.scannedTree.OMPSNode;
import gradingTools.shared.testcases.openmp.scannedTree.SNode;

public class OMPSNodeUtils extends OpenMPUtils {

	public static RootOfFileSNode getSNode(String aFileName, StringBuffer aFileBuffer) {
		String[] aFileLines = aFileBuffer.toString().split("\n");
		return getSNode(aFileName, aFileLines);
	}

	public static AssignmentSNode getAssignmentSNode(int aLineNumber, String aString) {
		if (aString == null) {
			return null;
		}
		String[] aTokens = aString.split("=");
		if (aTokens.length == 1) {
			return new AnAssignmentSNode(aLineNumber, aTokens[0], null);
		} else {
		return new AnAssignmentSNode(aLineNumber, aTokens[0], aTokens[1]);
		}
	}

	public static DeclarationSNode getDeclarationSNode(int aLineNumber, String aString) {
		String[] aTokens = aString.split(" ");
		return new ADeclarationSNode(aLineNumber, aTokens[0], aTokens[1]);
	}

	public static DeclaringAssignmentSNode getDeclaringAssignmentSNode(int aLineNumber, String aString) {
		String[] anLHSAndRHS = aString.split("=");
		String[] aTypeAndVariable = anLHSAndRHS[0].split(" ");
		return new ADeclaringAssignmentSNode(aLineNumber, aTypeAndVariable[0], aTypeAndVariable[1], anLHSAndRHS[1]);
	}
	public static ConstDeclarationSNode getConstDeclarationSNode(int aLineNumber, String aString) {
		String anAssignmentString = aString.substring(CONST.length()).trim();
		String[] anLHSAndRHS = anAssignmentString.split("=");
		String[] aTypeAndVariable = anLHSAndRHS[0].split(" ");
		return new AConstDeclarationSNode(aLineNumber, aTypeAndVariable[0], aTypeAndVariable[1], anLHSAndRHS[1]);
	}

	public static boolean isDeclaringAssignment(String aFileLine) {
		return startsWithTypeName(aFileLine) && aFileLine.contains("=");
	}
	public static boolean isConstDeclaration(String aFileLine) {
		return aFileLine.startsWith(CONST);
	}
	public static boolean isMethodDeclaration(String aFileLine) {
		return startsWithTypeName(aFileLine) && 
				aFileLine.contains("(") &&
				!aFileLine.contains("=");
	}
	public static boolean isExternalMethodDeclaration(String aFileLine) {
		return isMethodDeclaration(aFileLine) && aFileLine.endsWith(";");
	}


	public static boolean isVariableDeclaration(String aFileLine) {

		return startsWithTypeName(aFileLine) && !aFileLine.contains("(");
	}

	public static boolean isAssignment(String aFileLine) {
		return aFileLine.contains("=") && !aFileLine.contains("==");
	}

	public static boolean isForNode(String aFileLine) {
		return aFileLine.startsWith("for");
	}

	public static ForSNode getForSNode(int aLineNumber, String aFileLine) {

		int aLeftParenIndex = aFileLine.indexOf("(");
		int aRightParenIndex = aFileLine.indexOf(")");
		if (aLeftParenIndex < 0 || aRightParenIndex < 0) {
			return null;
		}
		String aHeaderString = aFileLine.substring(aLeftParenIndex + 1, aRightParenIndex);
		String[] aForComponents = aHeaderString.split(";");
		AssignmentSNode anAssignmentSNode = null;
		String aForInitializaton = aForComponents[0];
		if (!aForInitializaton.isEmpty() && aForInitializaton.contains("=")) {
			if (isDeclaringAssignment(aForInitializaton)) {
				anAssignmentSNode = getDeclaringAssignmentSNode(aLineNumber, aForInitializaton);
			} else {
				anAssignmentSNode = getAssignmentSNode(aLineNumber, aForInitializaton);
			}

		}		
		return new AForSNode(aLineNumber, anAssignmentSNode, aForComponents[1], getAssignmentSNode(aLineNumber, aForComponents[2]));
	}
	static String[] emptyArray = {};
	public static MethodSNode getMethodSNode(int aLineNumber, String aFileLine, boolean isInternal) {

		int aLeftParenIndex = aFileLine.indexOf("(");
		int aRightParenIndex = aFileLine.indexOf(")");
		if (aLeftParenIndex < 0 || aRightParenIndex < 0) {
			return null;
		}
		String aMethodNameAndType = aFileLine.substring(0, aLeftParenIndex);
		String[] aMethodNameAndTypeTokens = aMethodNameAndType.split("\\s+"); 
		
		String aMethodParameters = aFileLine.substring(aLeftParenIndex +1 , aRightParenIndex);
		String[] aMethodParameterTokens = aMethodParameters.isEmpty()?emptyArray:
		 aMethodParameters.split(",");
		
//		String[] aMethodParameterTypes = new String[aMethodParameterTokens.length];
//		String[] aMethodParameterNames = new String[aMethodParameterTokens.length];
		List<DeclarationSNode> aDeclarationSNodeList = new ArrayList();
		for (int i = 0; i < aMethodParameterTokens.length; i++ ) {
			String[] aTypeAndName = aMethodParameterTokens[i].trim().split("\\s+");
			if (aTypeAndName.length < 2) {
				continue;
			}
			aDeclarationSNodeList.add(new ADeclarationSNode(aLineNumber, aTypeAndName[0].trim(), aTypeAndName[1].trim()));
//			aMethodParameterTypes[i] = aTypeAndName[0].trim();
//			aMethodParameterNames[i] = aTypeAndName[1].trim();
		}
		if (isInternal)
//		return new AMethodSNode(aLineNumber, aMethodNameAndTypeTokens[0], aMethodNameAndTypeTokens[1], aMethodParameterTypes,aMethodParameterNames );
			return new AMethodSNode(aLineNumber, aMethodNameAndTypeTokens[0], aMethodNameAndTypeTokens[1], aDeclarationSNodeList );
		else
			return new AnExternalMethodSNode(aLineNumber, aMethodNameAndTypeTokens[0], aMethodNameAndTypeTokens[1], aDeclarationSNodeList );
	}

	public static void setReductionData(OMPForSNode lastChild, String aStoredToken, int aLeftParenIndex,
			int aRightParenIndex) {
		int aColonIndex = aStoredToken.indexOf(":");
		if (aLeftParenIndex != -1 && aRightParenIndex != -1 && aColonIndex != -1) {
			String anOperationString = aStoredToken.substring(aLeftParenIndex + 1, aColonIndex).trim();
			String aVariableString = aStoredToken.substring(aColonIndex + 1, aRightParenIndex).trim();
			((OMPForSNode) lastChild).setReductionVariable(aVariableString);
			((OMPForSNode) lastChild).setReductionOperation(anOperationString);
		}
	}

	public static void setSharedOrPrivateData(OMPSNode lastChild, String aStoredToken, int aLeftParenIndex,
			int aRightParenIndex, boolean isShared) {
//		int aColonIndex = aStoredToken.indexOf(":");
		if (aLeftParenIndex != -1 && aRightParenIndex != -1) {
			String aVariableDeclarations = aStoredToken.substring(aLeftParenIndex + 1, aRightParenIndex);
			String[] aVariables = aVariableDeclarations.split(",");
			if (isShared) {
				lastChild.setSharedVariables(aVariables);
			} else {
				lastChild.setPrivateVariables(aVariables);
			}
		}
	}

	public static RootOfFileSNode getSNode(String aFileName, String[] aFileLines) {
		Stack<SNode> anSNodes = new Stack();

		RootOfFileSNode retVal = new ARootOfFileSNode(aFileName);
		anSNodes.add(retVal);
		SNode previousHeaderNode = null;
		for (int i = 0; i < aFileLines.length; i++) {
			String aFileLine = aFileLines[i].trim();
			if (!isCodeLine(aFileLine)) {
				continue;
			}
			if (isForNode(aFileLine)) {
				ForSNode aForSNode = getForSNode(i, aFileLine);
				SNode aParent = previousHeaderNode != null?previousHeaderNode:anSNodes.peek();
				aForSNode.setParent(anSNodes.peek());
				aForSNode.setParent(aParent);

//				anSNodes.push(aForSNode);
				previousHeaderNode = aForSNode;
				if (aFileLine.endsWith(")")) {
					continue;
				}
			}
			if (isExternalMethodDeclaration(aFileLine)) {
				MethodSNode aMethodSNode = getMethodSNode(i, aFileLine, false);
				aMethodSNode.setParent(anSNodes.peek());
//				anSNodes.push(aForSNode);
				previousHeaderNode = aMethodSNode;
				if (aFileLine.endsWith(")")) {
					continue;
				}
			}
			if (isMethodDeclaration(aFileLine)) {
				MethodSNode aMethodSNode = getMethodSNode(i, aFileLine, true);
				aMethodSNode.setParent(anSNodes.peek());
//				anSNodes.push(aForSNode);
				previousHeaderNode = aMethodSNode;
				if (aFileLine.endsWith(")")) {
					continue;
				}
			}
			if (isPragmaStart(aFileLine)) {
				OMPSNode anOMPSNode = getOMPSNode(i, anSNodes.peek(), aFileLine);
//				anSNodes.push(anOMPSNode);
				previousHeaderNode = anOMPSNode;
				continue;
			}
			if (isBlockStart(aFileLine)) {
				SNode aBlockSNode = new ABlockSNode(i);
				if (previousHeaderNode != null) {
					aBlockSNode.setParent(previousHeaderNode);
				} else {
					aBlockSNode.setParent(anSNodes.peek());
				}
				anSNodes.push(aBlockSNode);
				previousHeaderNode = null;
				continue;
			}
//			} else 
			if (isBlockEnd(aFileLine)) {
				anSNodes.pop();
				continue;
			}
			SNode aNewLeafNode = null;
			if (isConstDeclaration(aFileLine)) {
				aNewLeafNode = getConstDeclarationSNode(i, aFileLine);

			} else if (isDeclaringAssignment(aFileLine)) {
				aNewLeafNode = getDeclaringAssignmentSNode(i, aFileLine);

			} else if (isAssignment(aFileLine)) {
				aNewLeafNode = getAssignmentSNode(i, aFileLine);
			} else if (isVariableDeclaration(aFileLine)) {
				aNewLeafNode = getDeclarationSNode(i, aFileLine);
			} else {
				List<MethodCall> aCalls = callsIn(i, aFileLine, null); // parent will be assigned below
				if (aCalls != null && aCalls.size() == 1) {
					aNewLeafNode = aCalls.get(0);
				} else {
					aNewLeafNode = new ATextSNode(i, aFileLine);
				}
			}
//			else {
//				aNewLeafNode = new ATextSNode(i, aFileLine);
//			}
			if (previousHeaderNode != null) {
				aNewLeafNode.setParent(previousHeaderNode);
			} else {
				aNewLeafNode.setParent(anSNodes.peek());
			}

		}

		return retVal;
	}

	public static OMPSNode getOMPSNode(int aLineIndex, SNode aParentNode, String aFileLine) {
		String[] aTokens = aFileLine.split("\\s+");
		if (aTokens.length <= 2) {
			return null;
		}
		if (!aTokens[1].equals("omp")) {
			return null;
		}
		if (aTokens.length < 3) {
			return null;
		}
		String aFirstToken = aTokens[2];
		OpenMPKeywordEnum anOpenMPKeyword = stringToOpenMPKeyword.get(aFirstToken);
//		List<OpenMPPragma> retVal = new ArrayList();
		OMPSNode lastChild = null;
		int aStartIndex = 2;
		OMPSNode aNewNode = null;
		OMPForSNode aForChild = null;
		switch (anOpenMPKeyword) {
		case PARALLEL:
			aNewNode = new AnOMPParallelSNode(aLineIndex);

			if (aTokens.length > 3 && aTokens[3].equals("for")) {
				aForChild = new AnOMPForSNode(aLineIndex);
				aForChild.setParent(aNewNode);

				aStartIndex++;
			}
			break;
		case FOR:
			aNewNode = new AnOMPForSNode(aLineIndex);
			;
			break;
		case CRITICAL:
			aNewNode = new AnOMPCriticalSNode(aLineIndex);
//			retVal.add (lastChild);
			break;
		default:
			aNewNode = new AnOMPSNode(aLineIndex);

		}

		if (lastChild != null) {
			aNewNode.setParent(lastChild);
		} else {
			aNewNode.setParent(aParentNode);
		}
		lastChild = aForChild == null ? aNewNode : aForChild;

		for (int i = aStartIndex; i < aTokens.length; i++) {
			String aStoredToken = aTokens[i].trim();
			if (aStoredToken.isEmpty()) {
				continue;
			}
			if (aStoredToken.startsWith("reduction") || aStoredToken.startsWith("shared")
					|| aStoredToken.startsWith("private")) {
				// combine all tokens until ")" into one for normalization
				while (!aStoredToken.endsWith(")")) {
					i++;
					if (i >= aTokens.length) {
						break;
					}
					String aNewToken = aTokens[i].trim();
					aStoredToken += aNewToken;
				}
				int aLeftParenIndex = aStoredToken.indexOf("(");
				int aRightParenIndex = aStoredToken.indexOf(")");
				if (aStoredToken.startsWith("reduction")) {
					setReductionData((OMPForSNode) lastChild, aStoredToken, aLeftParenIndex, aRightParenIndex);
				} else if (aStoredToken.startsWith("private")) {
					setSharedOrPrivateData((OMPSNode) lastChild, aStoredToken, aLeftParenIndex, aRightParenIndex,
							false);

				} else if (aStoredToken.startsWith("shared")) {
					setSharedOrPrivateData(lastChild, aStoredToken, aLeftParenIndex, aRightParenIndex, true);

				}

			}

			lastChild.getOpenMPTokens().add(aStoredToken);
		}

		return lastChild;

	}

	public static boolean hasParallelAncestor(SNode anSNode) {
		if (anSNode == null) {
			return false;
		}
		if (anSNode instanceof OMPParallelSNode) {
			return true;
		}
		return hasParallelAncestor(anSNode.getParent());
	}
	public static boolean hasCriticalAncestor(SNode anSNode) {
		if (anSNode == null) {
			return false;
		}
		if (anSNode instanceof OMPCriticalSNode) {
			return true;
		}
		return hasCriticalAncestor(anSNode.getParent());
	}


	public static Boolean isDeclaredShared(OMPSNode anOMPSNode, String anLHS) {
		if (Arrays.asList(anOMPSNode.getSharedVariables()).contains(anLHS)) {
			return true;
		}
		if (Arrays.asList(anOMPSNode.getPrivateVariables()).contains(anLHS)) {
			return false;
		}
		return null;

	}

	public static boolean isSharedVariable(SNode anSNode, String anLHS) {
		if (anSNode == null) {
			return false;
		}
		if (anSNode.getLocalVariableIdentifiers().contains(anLHS)) {
			if (!(anSNode instanceof OMPSNode)) { // no shared and private declarations
				return !hasParallelAncestor(anSNode); // shared if not inParallel
			}
			OMPSNode anOMPSNode = (OMPSNode) anSNode;
			return (Arrays.asList(anOMPSNode.getSharedVariables()).contains(anLHS)); // private unless declared shared
		}
		if (anSNode instanceof OMPSNode) {
			OMPSNode anOMPSNode = (OMPSNode) anSNode;
			// the variable is global to this scope, check if it has have been made shared
			// or private by this scope
			Boolean isDeclaredShared = isDeclaredShared(anOMPSNode, anLHS);
			if (isDeclaredShared != null) {
				return isDeclaredShared;
			}
		}
		// check the parent
		return isSharedVariable(anSNode.getParent(), anLHS);
	}

	public static List<SNode> getAllLeafNodes(SNode aTopNode) {
		List<SNode> retVal = new ArrayList();
		addLeafNodes(aTopNode, retVal);
		return retVal;
	}

	public static void addLeafNodes(SNode aTopNode, List<SNode> retVal) {
		for (SNode aChild : aTopNode.getChildren()) {
			if (aChild.isLeaf()) {
				retVal.add(aChild);
			} else {
				addLeafNodes(aChild, retVal);
			}
		}
	}

	public static List<SNode> getNonParallelLeafNodes(SNode aTopNode) {
		List<SNode> retVal = new ArrayList();
		addNonParallelLeafNodes(aTopNode, retVal);
		return retVal;
	}

	public static void addNonParallelLeafNodes(SNode aTopNode, List<SNode> retVal) {
		if (aTopNode.isInParallel()) {
			return;
		}
		for (SNode aChild : aTopNode.getChildren()) {
			if (aChild.isLeaf()) {
				retVal.add(aChild);
			} else {
				addLeafNodes(aChild, retVal);
			}
		}
	}
	static String callRegex = "([a-zA-Z_$][a-zA-Z_$0-9]*)\\(.*?\\)";
	static Pattern callPattern = Pattern.compile(callRegex);

	static String identifierRegex = "[a-zA-Z_$][a-zA-Z_$0-9]*";
	static Pattern identifierPattern = Pattern.compile(identifierRegex);
	public static List<String> identifiersIn(String aString) {
		if (aString == null)
			return null;
//		Pattern mypattern = Pattern.compile("[a-zA-Z_$][a-zA-Z_$0-9]*");
//		Matcher mymatcher = mypattern.matcher(aString);
		Matcher mymatcher = identifierPattern.matcher(aString);
		List<String> retVal = new ArrayList();
		while (mymatcher.find()) {
			String find = mymatcher.group(0);
			retVal.add(find);
		}
		return retVal;
	}
	public static List<MethodCall> callsIn(int aLineNumber, String aString, SNode aParent) {
		if (aString == null)
			return emptyList;
		if (isMethodDeclaration(aString)) {
			return emptyList;
		}
//		Pattern mypattern = Pattern.compile("[a-zA-Z_$][a-zA-Z_$0-9]*");
//		Matcher mymatcher = mypattern.matcher(aString);
		Matcher mymatcher = callPattern.matcher(aString);
		List<MethodCall> retVal = new ArrayList();
		while (mymatcher.find()) {
			String find = mymatcher.group(0);
			int aLeftParenIndex = find.indexOf("(");
			int aRightParenIndex = find.indexOf(")");
			String aMethodName = find.substring(0, aLeftParenIndex).trim();
			String aParameters = find.substring(aLeftParenIndex + 1, aRightParenIndex);
			List<String> aParameterList = new ArrayList();
			String[] aParameterTokens = aParameters.split(",");
			for (String aParameter:aParameterTokens) {
				String aParameterTrimmed = aParameter.trim();
				if (!aParameterTrimmed.isEmpty())
				aParameterList.add(aParameterTrimmed);
			}
			retVal.add(new AMethodCall(aLineNumber, aMethodName, aParameterList, aParent));

//			aCallStrings.add(find);
		}
		return retVal;
	}
	static String numberRegex = "(\\d+\\.\\d+)|(\\d+)";
	static Pattern numberPattern = Pattern.compile(numberRegex);
	public static List<String> numbersIn(String aString) {
		if (aString == null)
			return null;
//		String regex = "(\\d+\\.\\d+)|(\\d+)";
//
//		Matcher m = Pattern.compile(regex).matcher(aString);
		Matcher m =numberPattern.matcher(aString);


		List<String> retVal = new ArrayList();

		while (m.find()) {
			retVal.add(m.group());
		}
		return retVal;
	}

	public static String subscriptIn(String aString) {
		if (aString == null)
			return null;
		return StringUtils.substringBetween(aString, "[", "]");
	}
	static String[] emptyStringArray = {};
	static List emptyList = new ArrayList();

	public static String[] subscriptsIn(String aString) {
		if (aString == null)
			return emptyStringArray;
		return StringUtils.substringsBetween(aString, "[", "]");
	}
	static  String operatorRegex = "([+-/*///^])|([/(/)])";
	static Pattern operatorPattern = Pattern.compile(operatorRegex);

	public static List<String> operatorsIn(String aString) {
		if (aString == null)
			return null;
//		String operatorRegex = "([+-/*///^])|([/(/)])";
//
//		Matcher m = Pattern.compile(operatorRegex).matcher(aString);
		
		Matcher m = operatorPattern.matcher(aString);


		List<String> retVal = new ArrayList();

		while (m.find()) {
			retVal.add(m.group());
		}
		return retVal;
	}
	
	public static int numberOfNestingFors (SNode anSNode) {
		if (anSNode == null) {
			return 0;
		}
		int retVal = numberOfNestingFors (anSNode.getParent()) ;

		if (anSNode instanceof ForSNode) {
			retVal++;
		} else if (anSNode instanceof MethodSNode) {
			List<MethodCall> aMethodCalls = ((MethodSNode) anSNode).getCalls();
			int aMaxNestingLevel = 0;
			for (MethodCall aMethodCall:aMethodCalls) {
				MethodSNode aCallerMethodSNode = getDeclarationOfCalledMethod(anSNode, aMethodCall);
				int aCallerNumberOfNestingFors = numberOfNestingFors(aCallerMethodSNode);
				aMaxNestingLevel = Math.max(aCallerNumberOfNestingFors, aMaxNestingLevel);				
			}
			return retVal + aMaxNestingLevel;
		}
		return retVal;
	}
	public static boolean hasOperator (SNode anSNode, String anOperator) {
		boolean retVal = false;
		if (anSNode instanceof AssignmentSNode) {
			AssignmentSNode anAssignmentSNode = (AssignmentSNode) anSNode;
			 retVal = (anAssignmentSNode.getLhsOperators().contains(anOperator) || 
					anAssignmentSNode.getRhsOperators().contains(anOperator)) ;
			if (retVal) {
				return retVal;
			} else {
				List<MethodCall> aMethodCalls = anAssignmentSNode.getRhsCalls();
				for (MethodCall aMethodCall:aMethodCalls) {
					MethodSNode aMethodSNode = getDeclarationOfCalledMethod(anSNode, aMethodCall);
					retVal = hasOperator(aMethodSNode, anOperator);
					if (retVal) {
						return retVal;
					}
					
				}
				return false;
			}
			
		}
		for (SNode aChild:anSNode.getChildren()) {
			retVal = hasOperator(aChild, anOperator);
			if (retVal) {
				return retVal;
			}
		}
		return false;
	}
	public static boolean hasMethodCall (SNode anSNode, String anOperator) {
		boolean retVal = false;
		if (anSNode instanceof AssignmentSNode) {
			AssignmentSNode anAssignmentSNode = (AssignmentSNode) anSNode;
			 retVal = (anAssignmentSNode.getLhsOperators().contains(anOperator) || 
					anAssignmentSNode.getRhsOperators().contains(anOperator)) ;
			if (retVal) {
				return retVal;
			} else {
				List<MethodCall> aMethodCalls = anAssignmentSNode.getRhsCalls();
				for (MethodCall aMethodCall:aMethodCalls) {
					MethodSNode aMethodSNode = getDeclarationOfCalledMethod(anSNode, aMethodCall);
					retVal = hasOperator(aMethodSNode, anOperator);
					if (retVal) {
						return retVal;
					}
					
				}
				return false;
			}
			
		}
		for (SNode aChild:anSNode.getChildren()) {
			retVal = hasOperator(aChild, anOperator);
			if (retVal) {
				return retVal;
			}
		}
		return false;
	}
	public static boolean dependsOn (AssignmentSNode anAssignmentSNode, String aVariable, String aCallIdentifier) {
		// This assignment does not change aVariable
		if (!aVariable.equals(anAssignmentSNode.getLhsFirstIdentifier())) {
			return false;
		}
		return dependsOn(anAssignmentSNode.getExpressionSNode(), aCallIdentifier);
//		List<String> aCallIdentifiers = anAssignmentSNode.getRhsCallIdentifiers();
//		boolean retVal = false;
//		if (aCallIdentifiers != null && aCallIdentifiers.contains(aCallIdentifier)) {
//			return true; // this assignment has aCallIdentifier in the rhs
//		}
//		// check if some referenced rhs variable depends on aCallIdentifier
//		List<String> aReferencedVariableIdentifiers = anAssignmentSNode.getRhsVariableIdentifiers();
//		SNode anAssignmentParent = anAssignmentSNode.getParent();
//		if (anAssignmentParent == null) { // should never be trye
//			return false;
//		}
//		int aLineNumber = anAssignmentSNode.getLineNumber();
//		for (String aReferencedVariableIdentifier:aReferencedVariableIdentifiers ) {
//			if (dependsOn (anAssignmentParent, aLineNumber, aReferencedVariableIdentifier, aCallIdentifier)) {
//				return true;
//			}
//		}
//		return false;
	}
	public static boolean dependsOn (ExpressionSNode anExpressionSNode, String aCallIdentifier) {
		// This assignment does not change aVariable
		
		List<String> aCallIdentifiers = anExpressionSNode.getRhsCallIdentifiers();
		boolean retVal = false;
		if (aCallIdentifiers != null && aCallIdentifiers.contains(aCallIdentifier)) {
			return true; // this assignment has aCallIdentifier in the rhs
		}
		// check if some referenced rhs variable depends on aCallIdentifier
		List<String> aReferencedVariableIdentifiers = anExpressionSNode.getRhsVariableIdentifiers();
		SNode anAssignmentParent = anExpressionSNode.getParent().getParent();
		if (anAssignmentParent == null) { // should never be trye
			return false;
		}
		int aLineNumber = anExpressionSNode.getLineNumber();
		for (String aReferencedVariableIdentifier:aReferencedVariableIdentifiers ) {
			if (dependsOn (anAssignmentParent, aLineNumber, aReferencedVariableIdentifier, aCallIdentifier)) {
				return true;
			}
		}
		return false;
	}
	public static Set<AssignmentSNode> assignmentsToSharedVariables(SNode anSNode) {
		Set<AssignmentSNode> retVal =  new HashSet();
		fillAssignmentsToShared(anSNode, retVal);
		return retVal;
		
	}
	public static Set<AssignmentSNode> assignmentsToSharedArrays(SNode anSNode) {
		Set<AssignmentSNode> anAllSharedAssignments =  assignmentsToSharedVariables(anSNode);
		Set<AssignmentSNode> aRetVal = new HashSet();
		for (AssignmentSNode anAssignmentSNode:anAllSharedAssignments) {
			if (anAssignmentSNode.getLhsSubscripts().length > 0) {
				aRetVal.add(anAssignmentSNode);
			}
		}
		return aRetVal;
		
	}
	public static Set<AssignmentSNode> assignmentsToParallelCriticalSharedVariables(SNode anSNode) {
		Set<AssignmentSNode> anAllSharedAssignments =  assignmentsToSharedVariables(anSNode);
		Set<AssignmentSNode> aRetVal = new HashSet();
		for (AssignmentSNode anAssignmentSNode:anAllSharedAssignments) {
			if (anAssignmentSNode.isInParallel() &&
					anAssignmentSNode.isInCritical()) {
				aRetVal.add(anAssignmentSNode);
			}
		}
		return aRetVal;
		
	}
	public static Set<AssignmentSNode> assignmentsToNonParallelCriticalSharedVariables(SNode anSNode) {
		Set<AssignmentSNode> anAllSharedAssignments =  assignmentsToSharedVariables(anSNode);
		Set<AssignmentSNode> aRetVal = new HashSet();
		for (AssignmentSNode anAssignmentSNode:anAllSharedAssignments) {
			if (!anAssignmentSNode.isInParallel() &&
					anAssignmentSNode.isInCritical()) {
				aRetVal.add(anAssignmentSNode);
			}
		}
		return aRetVal;
		
	}
	public static Set<AssignmentSNode> assignmentsToParallelNonCriticalSharedVariables(SNode anSNode) {
		Set<AssignmentSNode> anAllSharedAssignments =  assignmentsToSharedVariables(anSNode);
		Set<AssignmentSNode> aRetVal = new HashSet();
		for (AssignmentSNode anAssignmentSNode:anAllSharedAssignments) {
			if (anAssignmentSNode.isInParallel() &&
					!anAssignmentSNode.isInCritical()) {
				aRetVal.add(anAssignmentSNode);
			}
		}
		return aRetVal;
		
	}
    public static void fillAssignmentsToShared(SNode anSNode, Set<AssignmentSNode> retVal) {
    	if (anSNode instanceof AssignmentSNode) {
			AssignmentSNode anAssignmentSNode = (AssignmentSNode) anSNode;
			String anLHS = anAssignmentSNode.getLhsFirstIdentifier();
			if (isSharedVariable(anSNode, anLHS)) {
				retVal.add(anAssignmentSNode);
				return;
			}
		}
    	for (SNode aChild:anSNode.getChildren()) {
    		fillAssignmentsToShared(aChild, retVal);
    	}
		
	}
    public static void fillInstancesOfNodeType(Class<? extends SNode> aNodeType, SNode anSNode, Set<SNode> retVal) {
    	if (aNodeType.isAssignableFrom(anSNode.getClass())) {
			
				retVal.add(anSNode);
				return;
			}
		
    	for (SNode aChild:anSNode.getChildren()) {
    		fillInstancesOfNodeType(aNodeType, aChild, retVal);
    	}
		
	}
    public static Set<AssignmentSNode>  assignmentSNodes(SNode anSNode) {
    	Set retVal = new HashSet();    	
    	fillInstancesOfNodeType(AssignmentSNode.class, anSNode, retVal );
    	return retVal;
	}
   
    
    public static Set<OMPParallelSNode>  ompParallelSNodes(SNode anSNode) {
    	Set retVal = new HashSet();    	
    	fillInstancesOfNodeType(OMPParallelSNode.class, anSNode, retVal );
    	return retVal;
	}
//    public static void fillOMPParallelSNodes(SNode anSNode, Set<OMPParallelSNode> retVal) {
//    	if (anSNode instanceof OMPParallelSNode) {
//    		retVal.add((OMPParallelSNode) anSNode);
//		}
//    	for (SNode aChild:anSNode.getChildren()) {
//    		fillOMPParallelSNodes(aChild, retVal);
//    	}		
//	}
    public static Set<ForSNode>  forSNodes(SNode anSNode) {
    	Set retVal = new HashSet();    	
    	fillInstancesOfNodeType(ForSNode.class, anSNode, retVal );
    	return retVal;
	}
//    public static void fillForSNodes(SNode anSNode, Set<ForSNode> retVal) {
//    	if (anSNode instanceof ForSNode) {
//    		retVal.add((ForSNode) anSNode);
//		}
//    	for (SNode aChild:anSNode.getChildren()) {
//    		fillForSNodes(aChild, retVal);
//    	}		
//	}
    public static Set<OMPForSNode>  ompForSNodes(SNode anSNode) {
    	Set retVal = new HashSet();    	
    	fillInstancesOfNodeType(OMPForSNode.class, anSNode, retVal );
    	return retVal;
	}
//    public static void fillOMPForSNodes(SNode anSNode, Set<OMPForSNode> retVal) {
//    	if (anSNode instanceof OMPForSNode) {
//    		retVal.add((OMPForSNode) anSNode);
//		}
//    	for (SNode aChild:anSNode.getChildren()) {
//    		fillOMPForSNodes(aChild, retVal);
//    	}		
//	}
    public static Set<OMPForSNode> ompReducingForNodes(SNode anSNode) {
		Set<OMPForSNode> anAllOMPForSNodes =  ompForSNodes(anSNode);
		Set<OMPForSNode> aRetVal = new HashSet();
		for (OMPForSNode anOMPForSNode:anAllOMPForSNodes) {
			if (anOMPForSNode.getReductionOperation() != null) {
				aRetVal.add(anOMPForSNode);
			}
		}
		return aRetVal;		
	}
    public static Set<AssignmentSNode> assignmentsToOMPReducingForNode(OMPForSNode anOMPForSNode) {
    	String aReductionVariable = anOMPForSNode.getReductionVariable();
    	return directAssignmentsOfVariableAndItsAliases(anOMPForSNode, aReductionVariable)	;
    	
    }
	public static boolean dependsOn (SNode anSNode, int aVariableLineNumber, String aVariable, String aCallIdentifier) {
		List<SNode> aListSNodes = anSNode.getChildren();
		boolean retVal = false;
		/*
		 * Should probably ignore line number as it assumes straight line code
		 */
		for (int i = aVariableLineNumber; i >= 0; i--) {
			SNode anSNodeChild = aListSNodes.get(i);
			if (anSNodeChild instanceof AssignmentSNode) {
				// does this statement in anSNode directly invoke aCallIdentifier 
				if (dependsOn((AssignmentSNode) anSNodeChild, aVariable, aCallIdentifier))
					return true;
			} else if (!anSNode.isLeaf()) {
					// child is overriding the variable so forget checking its assignment statements
					if (anSNodeChild.getLocalVariableIdentifiers().contains(aVariable)) {
						continue;
					}
					// some subblock of anSNode that has access to aVariable changes variable

					if (dependsOn(anSNodeChild, anSNodeChild.getChildren().size() - 1, aVariable, aCallIdentifier)) {
						return true;
					}
			}
			
		}
		// none of the statements in anSNode or its descendents  have the required call
		// is the variable a  method parameter 
		if (anSNode instanceof MethodSNode) {
			MethodSNode aMethodSNode = (MethodSNode) anSNode;
			
			int aParameterNumber = aMethodSNode.getLocalVariableIdentifiers().indexOf(aVariable);
			if (aParameterNumber != -1) {
				List <MethodCall> aCalls = aMethodSNode.getCalls();
				for (MethodCall aCall:aCalls) {
//					if (!aCall.getMethodActuals().contains(aVariable))
//						continue;
//					
					MethodSNode aCallerSNode = getDeclarationOfCalledMethod(aMethodSNode, aCall);
					if (dependsOn(aMethodSNode, aCallerSNode.getLineNumber(), aCallerSNode.getLocalVariableIdentifiers().get(aParameterNumber), aCallIdentifier));
//				    if (aCallerDepends) {
				    	return true;
//				    }
				}
				return false;
				// need to find all callers of method and see if any of the aliases for the variable in these
				// calls depend on aCallIndentifier
			}			
			
		} else if (anSNode.getLocalVariableIdentifiers().contains(aVariable)) {
			// before going to the parent node, let us see if aVariable is declared here as a non  parameter 

			return false; // no point going to parent
		}
		// not a local variable (parameter or declarated variable)
		SNode anSNodeParent = anSNode.getParent() ;
		if (anSNodeParent == null)  {
			return false;
		}
		int anSNodeLineNumber = anSNodeParent.getChildren().indexOf(anSNode);
		return dependsOn(anSNodeParent, anSNodeLineNumber, aVariable, aCallIdentifier);
		
	}
	public static Set<AssignmentSNode> assignmentsOfVariableAliases (SNode anSNode,  String aVariable) {
		Set<AssignmentSNode> retVal = new HashSet();
		fillDirectAssignmentsOfVariableAndItsAliases(anSNode, aVariable, retVal);
		return retVal;
	}
	public static void fillDirectAssignmentsOfVariableAliases (SNode anSNode,  String aVariable, Set<AssignmentSNode> retVal) {
		if (anSNode instanceof MethodCall) {
			MethodCall aMethodCall = (MethodCall) anSNode;
			int aParameterNumber = aMethodCall.getMethodActualIdentifiers().indexOf(aVariable);
			if (aParameterNumber < 0) {
				return;
			}
			MethodSNode aDeclaringMethodSNode = getDeclarationOfCalledMethod(anSNode, aMethodCall);
			String aFormalParameter = aDeclaringMethodSNode.getLocalVariableIdentifiers().get(aParameterNumber);
//			Set<AssignmentSNode> aCallAssignments = ;
			fillDirectAssignmentsOfVariableAliases(aDeclaringMethodSNode, aFormalParameter, retVal);
		} else {
			List<SNode> aChildren = anSNode.getChildren();
			for (SNode aChild:aChildren) {
				fillDirectAssignmentsOfVariableAliases(aChild, aVariable, retVal);
			}
		}		
		
	}
	
	/*
	 * will not consider assignments to variables in the RHS of these assignments
	 */
	public static Set<AssignmentSNode> directAssignmentsOfVariableAndItsAliases (SNode anSNode,  String aVariable) {
		Set<AssignmentSNode> retVal = new HashSet();
		fillDirectAssignmentsOfVariableAndItsAliases(anSNode, aVariable, retVal);
		return retVal;
	}
	
//	public static Set<AssignmentSNode> assignmentsEffectingVariableAndItsAliases (SNode anSNode,  String aVariable) {
//		Set<AssignmentSNode> retVal = directAssignmentsOfVariableAndItsAliases(anSNode, aVariable);
//		
//	}
	public static void fillDirectAssignmentsOfVariableAndItsAliases (SNode anSNode,  String aVariable, Set<AssignmentSNode> retVal) {
		if (anSNode instanceof AssignmentSNode) {
			AssignmentSNode anAssignmentSNode = (AssignmentSNode) anSNode;
			if (anAssignmentSNode.getLhsFirstIdentifier().equals(aVariable)) {
				retVal.add(anAssignmentSNode);
			}
		}
		
		else if (anSNode instanceof MethodCall) {
			MethodCall aMethodCall = (MethodCall) anSNode;
			int aParameterNumber = aMethodCall.getMethodActualIdentifiers().indexOf(aVariable);
			if (aParameterNumber < 0) {
				return;
			}
			MethodSNode aDeclaringMethodSNode = getDeclarationOfCalledMethod(anSNode, aMethodCall);
			String aFormalParameter = aDeclaringMethodSNode.getLocalVariableIdentifiers().get(aParameterNumber);
//			Set<AssignmentSNode> aCallAssignments = ;
			fillDirectAssignmentsOfVariableAndItsAliases(aDeclaringMethodSNode, aFormalParameter, retVal);
		} else {
			List<SNode> aChildren = anSNode.getChildren();
			for (SNode aChild:aChildren) {
				fillDirectAssignmentsOfVariableAndItsAliases(aChild, aVariable, retVal);
			}
		}		
		
	}
	
	public static RootOfFileSNode getRootOfFileNode(SNode aCurrentSNode ) {
		if (aCurrentSNode instanceof RootOfFileSNode) {
			return (RootOfFileSNode) aCurrentSNode;
		}
		SNode aParentSNode = aCurrentSNode.getParent() ;
		
		if (aParentSNode == null) {
			return null;
		}
		
		return getRootOfFileNode(aParentSNode);
		
	}
	public static boolean match (MethodSNode aMethodSNode, MethodCall aMethodCall) {
		return aMethodSNode.getMethodName().equals(aMethodCall.getMethodName()) 
				&& aMethodSNode.getLocalVariableIdentifiers().size() == aMethodCall.getMethodActuals().size();
	}
	public static DeclarationSNode getDeclarationOfVariableIdentifier(SNode aCurrentSNode, String anIdentifier) {
		if (aCurrentSNode == null) {
			return null;
		}
		
		
		int anIndex = aCurrentSNode.getLocalVariableIdentifiers().indexOf(anIdentifier);
		if (anIndex < 0) {
			return getDeclarationOfVariableIdentifier(aCurrentSNode.getParent(), anIdentifier);
		}
		DeclarationSNode retVal = aCurrentSNode.getVariableDeclarations().get(anIndex);
//		retVal.getAssignmentsToDeclaredVariable().add(anAssignmentSNode);
//		anAssignmentSNode.setLhsFirstIdentifierDeclaration(retVal);
		return retVal;
	}
	
	public static DeclarationSNode getDeclarationOfAssignedVariable(SNode aCurrentSNode, AssignmentSNode anAssignmentSNode) {
		if (aCurrentSNode == null) {
			return null;
		}
		if (anAssignmentSNode instanceof ADeclaringAssignmentSNode) {
			return (ADeclaringAssignmentSNode) anAssignmentSNode;
		}
		int anIndex = aCurrentSNode.getLocalVariableIdentifiers().indexOf(anAssignmentSNode.getLhsFirstIdentifier());
		if (anIndex < 0) {
			return getDeclarationOfAssignedVariable(aCurrentSNode.getParent(), anAssignmentSNode);
		}
		DeclarationSNode retVal = aCurrentSNode.getVariableDeclarations().get(anIndex);
//		retVal.getAssignmentsToDeclaredVariable().add(anAssignmentSNode);
//		anAssignmentSNode.setLhsFirstIdentifierDeclaration(retVal);
		return retVal;
	}
	
	public static MethodSNode getDeclarationOfCalledMethod(SNode aCurrentSNode, MethodCall aMethodCall ) {
		SNode aRootNode = getRootOfFileNode(aCurrentSNode);
		for (SNode aChild:aRootNode.getChildren()) {
			if (aChild instanceof MethodSNode) {
				MethodSNode aMethodSNode = (MethodSNode) aChild;
				if (match (aMethodSNode, aMethodCall)) {
					return aMethodSNode;
				}
			}
		}
		return null; // this should never happen;
	}
	
	public static RootOfProgramSNode getRootOfProgramSNode(String aSource) {
		RootOfProgramSNode retVal = new ARootOfProgramSNode();
		Map<String, StringBuffer> aFileNameToContents = ABasicTextManager.extractFileContents(aSource);
		for (String aFileName:aFileNameToContents.keySet()) {
			StringBuffer aFileContents = aFileNameToContents.get(aFileName);
//			List<OpenMPPragma> anOpenMPPragmas = OpenMPUtils.getOpemMPPragmas(aFileContents);
			RootOfFileSNode anSNode = OMPSNodeUtils.getSNode(aFileName, aFileContents);
			retVal.getFileNameToSNode().put(aFileName, anSNode);
			anSNode.setParent(retVal);
//			System.out.println("file name:" + aFileName);
//			System.out.println("pragmas:" + anSNode);
		}
		processExternalMethodSNodes(retVal);
		processIndirectAssignments(retVal);
		return retVal;
	}
//	public static void processIndirectAssignments (S aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode) {
//		for (SNode anSNode:aRootOfFileSNode.getChildren()) {
//			-----
//		}
//	}
	public static void processExternalMethodSNodes (RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode) {
		for (SNode anSNode:aRootOfFileSNode.getChildren()) {
			if (anSNode instanceof ExternalMethodSNode) {
				processExternalMethodSNode(aRootOfProgramSNode, aRootOfFileSNode, (ExternalMethodSNode) anSNode);
			}
		}
	}
	public static void processExternalMethodSNode (RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode, ExternalMethodSNode anExternalMethodSNode) {
		MethodSNode aMethodSNode = aRootOfProgramSNode.getExternalToInternalMethod().get(anExternalMethodSNode.toString());
		if (aMethodSNode == null) {
			aMethodSNode = findMethodSNode(aRootOfProgramSNode, aRootOfFileSNode, anExternalMethodSNode);
			if (aMethodSNode != null) {
				aRootOfProgramSNode.getExternalToInternalMethod().put(anExternalMethodSNode.toString(),aMethodSNode );
			}
		}
		if (aMethodSNode != null) {
			anExternalMethodSNode.setActualMethodSNode(aMethodSNode);
			aMethodSNode.getCalls().addAll(anExternalMethodSNode.getLocalCalls());
		}
	}
	
	public static MethodSNode findMethodSNode (RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode, ExternalMethodSNode anExternalMethodSNode) {
//		MethodSNode foundMethodSNode = null;
		for (String aFileName:aRootOfProgramSNode.getFileNameToSNode().keySet()) {
			if (aFileName.equals(aRootOfFileSNode.getFileName()))
				continue;
			
			RootOfFileSNode aSearchedRootOfFileSNode = aRootOfProgramSNode.getFileNameToSNode().get(aFileName);
			 for (SNode anSNode:aSearchedRootOfFileSNode.getChildren()) {
				if (anSNode instanceof MethodSNode && !(anSNode instanceof ExternalMethodSNode)) {
					if (anSNode.toString().equals(anExternalMethodSNode.toString())) {
						return (MethodSNode) anSNode;
						
					}
//					processExternalMethodSNode(aRootOfProgramSNode, aRootOfFileSNode, (ExternalMethodSNode) anSNode);
				}
			}
		}
		return null;
	}
	public static void processExternalMethodSNodes (RootOfProgramSNode aRootOfProgramSNode) {
		for (String aFileName:aRootOfProgramSNode.getFileNameToSNode().keySet()) {
			RootOfFileSNode aRootOfFileSNode = aRootOfProgramSNode.getFileNameToSNode().get(aFileName);
			processExternalMethodSNodes(aRootOfProgramSNode, aRootOfFileSNode);
			aRootOfFileSNode.getOmp_get_num_threads_SNode().
				setActualMethodSNode(aRootOfProgramSNode.getOmp_get_num_threads_SNode());
			aRootOfFileSNode.getOmp_get_thread_num_SNode().
				setActualMethodSNode(aRootOfProgramSNode.getOmp_get_thread_num_SNode());
			aRootOfFileSNode.getOmp_get_wtime_SNode().
			setActualMethodSNode(aRootOfProgramSNode.getOmp_get_wtime_SNode());
		}

	}
	public static void processIndirectAssignments (SNode anSNode) {
		if (anSNode instanceof ConstDeclarationSNode) {
			return;
		}
		if (anSNode instanceof DeclarationSNode) {
			DeclarationSNode aDeclarationSNode = (DeclarationSNode) anSNode;
			Set<AssignmentSNode> anIndirectAssignments = aDeclarationSNode.getAssignmentsEffectingDeclaredIdentifier();
			if (anIndirectAssignments != null) {
				return; // already assigned
			}
			anIndirectAssignments = new HashSet<>();
			aDeclarationSNode.setAssignmentsEffectingDeclaredIdentifier(anIndirectAssignments);
			Set<AssignmentSNode> aDirectAssignments = aDeclarationSNode.getAssignmentsToDeclaredVariable();
			anIndirectAssignments.addAll(aDirectAssignments);
			Set<AssignmentSNode> anAliasAssignments = assignmentsOfVariableAliases(aDeclarationSNode.getParent(), aDeclarationSNode.getVariableName());
			anIndirectAssignments.addAll(anAliasAssignments);
			for (AssignmentSNode aDirectAssignment:aDirectAssignments) {
				List<String> aVariableIdentifiers = aDirectAssignment.getRhsVariableIdentifiers();
				
				for (String aVariableIdentifier:aVariableIdentifiers) {
					DeclarationSNode aDependeeDeclarationSNode = getDeclarationOfVariableIdentifier(aDirectAssignment, aVariableIdentifier);
					if (aDependeeDeclarationSNode == null) {
						System.err.println("Could not find declaration of:" + aVariableIdentifier + " referenced in:" + aDirectAssignment );
						continue;
					}
					processIndirectAssignments(aDependeeDeclarationSNode);
					Set<AssignmentSNode> aDependeeIndirectAssignments = aDeclarationSNode.getAssignmentsEffectingDeclaredIdentifier();
					anIndirectAssignments.addAll(aDependeeIndirectAssignments);
					
				}
			}
		} else {
			for (SNode aChild: anSNode.getChildren()) {
				processIndirectAssignments(aChild);
			}
		}
		
	}
	
//	public static void fillIndirectAssignments (SNode anSNode, Set<AssignmentSNode> retVal ) {
//		
//	}
	

//	public static void main(String[] args) {
//		List<MethodCall> aTokens = callsIn("foo(bar, hgf)/foo2()*foo3(b, a c,)");
//		System.out.println(aTokens);
//		
//		
////		List<String> aTokens = identifiersIn("a[i] + b*2/3");
////		System.out.println(aTokens);
////		aTokens = numbersIn("a[i] + b*2/3");
////		System.out.println(aTokens);
////		aTokens = operatorsIn("a[i] + b*2/3");
////		System.out.println(aTokens);
////
////		System.out.println(StringUtils.substringBetween("a", "[", "]"));
//	}

}
]]></snapshot>
  </Command>
  <Command __id="217893" _type="DiffBasedFileOpenCommand" date="Fri Jan 10 10:11:17 EST 2020" docASTNodeCount="399" docActiveCodeLength="3066" docExpressionCount="228" docLength="4804" projectName="GraderBasics" starttimestamp="1576666505112" timestamp="2002572340">
    <filePath><![CDATA[D:\dewan_backup\Java\GraderBasics\src\gradingTools\shared\testcases\openmp\scannedTree\AnAssignmentSNode.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package gradingTools.shared.testcases.openmp.scannedTree;¬∂¬∂import java.util.ArrayList;¬∂import java.util.List;¬∂import java.util.Set;¬∂¬∂public class AnAssignmentSNode extends AnSNode implements AssignmentSNode {¬∂	static String[] emptyStringArray = {};¬∂	String lhs;¬∂	String[] lhsSubscripts = emptyStringArray;¬∂	String lhsFirstIdentifier;¬∂	List<String> lhsOperators;¬∂	String operationAndRHS;¬∂	ExpressionSNode expressionSNode;¬∂	DeclarationSNode lhsFirstIdentifierDeclaration;¬∂//	List<String> rhsVariableIdentifiers;¬∂//	List<String> rhsOperators;¬∂//	List<String> rhsNumbers;¬∂//	List<MethodCall> rhsCalls;¬∂	¬∂//	List<String> rhsCallIdentifiers;¬∂	¬∂	¬∂¬∂	public AnAssignmentSNode(int aLineNumber, String lhs, String operationAndRHS) {¬∂		super(aLineNumber);¬∂		this.lhs = lhs;¬∂		this.operationAndRHS = operationAndRHS;¬∂		lhsFirstIdentifier = OMPSNodeUtils.identifiersIn(lhs).get(0);¬∂		lhsOperators =  OMPSNodeUtils.operatorsIn(lhs);		¬∂		lhsSubscripts = OMPSNodeUtils.subscriptsIn(lhs);¬∂		if (lhsSubscripts == null) {¬∂			lhsSubscripts = emptyStringArray;¬∂		}¬∂		expressionSNode = new AnExpressionSNode(aLineNumber, operationAndRHS);¬∂//		expressionSNode.setParent(this);¬∂//		rhsVariableIdentifiers = OMPSNodeUtils.identifiersIn(operationAndRHS);¬∂//		rhsNumbers = OMPSNodeUtils.numbersIn(operationAndRHS);¬∂//		rhsOperators = OMPSNodeUtils.operatorsIn(operationAndRHS);	¬∂//		rhsCalls = OMPSNodeUtils.callsIn(aLineNumber, operationAndRHS, this);¬∂//		if (rhsCalls == null) {¬∂//			return;¬∂//		}¬∂//		rhsCallIdentifiers = new ArrayList();¬∂//		for (MethodCall aMethodCall:rhsCalls) {¬∂//			MethodSNode aMethodSNode = OMPSNodeUtils.getDeclarationOfCalledMethod(this, aMethodCall);¬∂//			if (aMethodSNode != null) {¬∂//				aMethodSNode.getCallsToMe().add(aMethodCall);¬∂//			}¬∂//			String aMethodName = aMethodCall.getMethodName();¬∂//			rhsCallIdentifiers.add(aMethodName);¬∂//			if (rhsVariableIdentifiers.contains(aMethodName)) {¬∂//				rhsVariableIdentifiers.remove(aMethodName);¬∂//			}¬∂//		}¬∂		¬∂	}¬∂//	protected void setCalledMethodData() {¬∂//		if (rhsCalls == null) {¬∂//			return;¬∂//		}¬∂//		rhsCallIdentifiers = new ArrayList();¬∂//		for (MethodCall aMethodCall:rhsCalls) {¬∂//			MethodSNode aMethodSNode = OMPSNodeUtils.getDeclarationOfCalledMethod(this, aMethodCall);¬∂//			if (aMethodSNode != null) {¬∂//				aMethodSNode.getCalls().add(aMethodCall);¬∂//			}¬∂//			String aMethodName = aMethodCall.getMethodName();¬∂//			rhsCallIdentifiers.add(aMethodName);¬∂//			if (rhsVariableIdentifiers.contains(aMethodName)) {¬∂//				rhsVariableIdentifiers.remove(aMethodName);¬∂//			}¬∂//		}¬∂//	}¬∂	@Override¬∂	public String getLHS() {¬∂		return lhs;¬∂	}¬∂	@Override¬∂	public String getOperationAndRHS() {¬∂		return operationAndRHS;¬∂	}¬∂	public String[] getLhsSubscripts() {¬∂		return lhsSubscripts;¬∂	}¬∂	public String getVariableName() {¬∂		return lhsFirstIdentifier;¬∂	}¬∂	public List<String> getLhsOperators() {¬∂		return lhsOperators;¬∂	}¬∂	public List<String> getRhsIdentifiers() {¬∂//		return rhsVariableIdentifiers;¬∂		return expressionSNode.getRhsIdentifiers();¬∂	}¬∂	public List<String> getRhsOperators() {¬∂//		return rhsOperators;¬∂		return expressionSNode.getRhsOperators();¬∂	}¬∂	public List<String> getRhsNumbers() {¬∂//		return rhsNumbers;¬∂		return expressionSNode.getRhsNumbers();¬∂	}¬∂	@Override¬∂	public List<String> getRhsVariableIdentifiers() {¬∂		return expressionSNode.getRhsVariableIdentifiers();¬∂//		return rhsVariableIdentifiers;¬∂	}¬∂	@Override¬∂	public List<MethodCall> getRhsCalls() {¬∂//		return rhsCalls;¬∂		return expressionSNode.getRhsCalls();¬∂	}¬∂	@Override¬∂	public List<String> getRhsCallIdentifiers() {¬∂//		return rhsCallIdentifiers;¬∂		return expressionSNode.getRhsCallIdentifiers();¬∂	}¬∂	@Override¬∂	public String getLhsFirstIdentifier() {¬∂		return lhsFirstIdentifier;¬∂	}¬∂	@Override¬∂	public void setParent (SNode aParent) {¬∂		super.setParent(aParent);¬∂		expressionSNode.setParent(this);¬∂		DeclarationSNode aDeclarationSNode = OMPSNodeUtils.getDeclarationOfAssignedVariable(this, this);¬∂		if (aDeclarationSNode == null) {¬∂			System.err.println("Null declaration node for assignment:" + this);¬∂		}¬∂		aDeclarationSNode.getAssignmentsToDeclaredVariable().add(this);¬∂		setLhsFirstIdentifierDeclaration(aDeclarationSNode);¬∂//		setCalledMethodData();¬∂	}¬∂	@Override¬∂	public ExpressionSNode getExpressionSNode() {¬∂		return expressionSNode;¬∂	}¬∂	public String toString() {¬∂		return lhs + "=" + operationAndRHS;¬∂	}¬∂	@Override¬∂	public DeclarationSNode getLhsFirstIdentifierDeclaration() {¬∂		return lhsFirstIdentifierDeclaration;¬∂	}¬∂	@Override¬∂	public void setLhsFirstIdentifierDeclaration(DeclarationSNode lhsFirstIdentifierDeclaration) {¬∂		this.lhsFirstIdentifierDeclaration = lhsFirstIdentifierDeclaration;¬∂	}¬∂	¬∂}¬∂")]]]></diff>
  </Command>
  <Command __id="217897" _type="DiffBasedFileOpenCommand" date="Fri Jan 10 10:11:19 EST 2020" docASTNodeCount="5134" docActiveCodeLength="37681" docExpressionCount="3174" docLength="43800" projectName="GraderBasics" starttimestamp="1576666505112" timestamp="2002574003">
    <filePath><![CDATA[D:\dewan_backup\Java\GraderBasics\src\gradingTools\shared\testcases\openmp\scannedTree\OMPSNodeUtils.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package gradingTools.shared.testcases.openmp.scannedTree;¬∂¬∂import java.util.ArrayList;¬∂import java.util.Arrays;¬∂import java.util.HashMap;¬∂import java.util.HashSet;¬∂import java.util.List;¬∂import java.util.Map;¬∂import java.util.Set;¬∂import java.util.Stack;¬∂import java.util.regex.Matcher;¬∂import java.util.regex.Pattern;¬∂¬∂import org.apache.commons.lang.StringUtils;¬∂¬∂import grader.basics.project.source.ABasicTextManager;¬∂import gradingTools.shared.testcases.openmp.OpenMPKeywordEnum;¬∂import gradingTools.shared.testcases.openmp.OpenMPParallelPragma;¬∂import gradingTools.shared.testcases.openmp.OpenMPUtils;¬∂import gradingTools.shared.testcases.openmp.scannedTree.ADeclarationSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.ADeclaringAssignmentSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.AForSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.ATextSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.AnAssignmentSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.AnOMPCriticalSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.AnOMPForSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.AnOMPParallelSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.AnOMPSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.AnSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.AssignmentSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.DeclarationSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.DeclaringAssignmentSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.ForSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.OMPForSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.OMPSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.SNode;¬∂¬∂public class OMPSNodeUtils extends OpenMPUtils {¬∂¬∂	public static RootOfFileSNode getSNode(String aFileName, StringBuffer aFileBuffer) {¬∂		String[] aFileLines = aFileBuffer.toString().split("\n");¬∂		return getSNode(aFileName, aFileLines);¬∂	}¬∂¬∂	public static AssignmentSNode getAssignmentSNode(int aLineNumber, String aString) {¬∂		if (aString == null) {¬∂			return null;¬∂		}¬∂		String[] aTokens = aString.split("=");¬∂		if (aTokens.length == 1) {¬∂			return new AnAssignmentSNode(aLineNumber, aTokens[0], null);¬∂		} else {¬∂		return new AnAssignmentSNode(aLineNumber, aTokens[0], aTokens[1]);¬∂		}¬∂	}¬∂¬∂	public static DeclarationSNode getDeclarationSNode(int aLineNumber, String aString) {¬∂		String[] aTokens = aString.split(" ");¬∂		return new ADeclarationSNode(aLineNumber, aTokens[0], aTokens[1]);¬∂	}¬∂¬∂	public static DeclaringAssignmentSNode getDeclaringAssignmentSNode(int aLineNumber, String aString) {¬∂		String[] anLHSAndRHS = aString.split("=");¬∂		String[] aTypeAndVariable = anLHSAndRHS[0].split(" ");¬∂		return new ADeclaringAssignmentSNode(aLineNumber, aTypeAndVariable[0], aTypeAndVariable[1], anLHSAndRHS[1]);¬∂	}¬∂	public static ConstDeclarationSNode getConstDeclarationSNode(int aLineNumber, String aString) {¬∂		String anAssignmentString = aString.substring(CONST.length()).trim();¬∂		String[] anLHSAndRHS = anAssignmentString.split("=");¬∂		String[] aTypeAndVariable = anLHSAndRHS[0].split(" ");¬∂		return new AConstDeclarationSNode(aLineNumber, aTypeAndVariable[0], aTypeAndVariable[1], anLHSAndRHS[1]);¬∂	}¬∂¬∂	public static boolean isDeclaringAssignment(String aFileLine) {¬∂		return startsWithTypeName(aFileLine) && aFileLine.contains("=");¬∂	}¬∂	public static boolean isConstDeclaration(String aFileLine) {¬∂		return aFileLine.startsWith(CONST);¬∂	}¬∂	public static boolean isMethodDeclaration(String aFileLine) {¬∂		return startsWithTypeName(aFileLine) && ¬∂				aFileLine.contains("(") &&¬∂				!aFileLine.contains("=");¬∂	}¬∂	public static boolean isExternalMethodDeclaration(String aFileLine) {¬∂		return isMethodDeclaration(aFileLine) && aFileLine.endsWith(";");¬∂	}¬∂¬∂¬∂	public static boolean isVariableDeclaration(String aFileLine) {¬∂¬∂		return startsWithTypeName(aFileLine) && !aFileLine.contains("(");¬∂	}¬∂¬∂	public static boolean isAssignment(String aFileLine) {¬∂		return aFileLine.contains("=") && !aFileLine.contains("==");¬∂	}¬∂¬∂	public static boolean isForNode(String aFileLine) {¬∂		return aFileLine.startsWith("for");¬∂	}¬∂¬∂	public static ForSNode getForSNode(int aLineNumber, String aFileLine) {¬∂¬∂		int aLeftParenIndex = aFileLine.indexOf("(");¬∂		int aRightParenIndex = aFileLine.indexOf(")");¬∂		if (aLeftParenIndex < 0 || aRightParenIndex < 0) {¬∂			return null;¬∂		}¬∂		String aHeaderString = aFileLine.substring(aLeftParenIndex + 1, aRightParenIndex);¬∂		String[] aForComponents = aHeaderString.split(";");¬∂		AssignmentSNode anAssignmentSNode = null;¬∂		String aForInitializaton = aForComponents[0];¬∂		if (!aForInitializaton.isEmpty() && aForInitializaton.contains("=")) {¬∂			if (isDeclaringAssignment(aForInitializaton)) {¬∂				anAssignmentSNode = getDeclaringAssignmentSNode(aLineNumber, aForInitializaton);¬∂			} else {¬∂				anAssignmentSNode = getAssignmentSNode(aLineNumber, aForInitializaton);¬∂			}¬∂¬∂		}		¬∂		return new AForSNode(aLineNumber, anAssignmentSNode, aForComponents[1], getAssignmentSNode(aLineNumber, aForComponents[2]));¬∂	}¬∂	static String[] emptyArray = {};¬∂	public static MethodSNode getMethodSNode(int aLineNumber, String aFileLine, boolean isInternal) {¬∂¬∂		int aLeftParenIndex = aFileLine.indexOf("(");¬∂		int aRightParenIndex = aFileLine.indexOf(")");¬∂		if (aLeftParenIndex < 0 || aRightParenIndex < 0) {¬∂			return null;¬∂		}¬∂		String aMethodNameAndType = aFileLine.substring(0, aLeftParenIndex);¬∂		String[] aMethodNameAndTypeTokens = aMethodNameAndType.split("\\s+"); ¬∂		¬∂		String aMethodParameters = aFileLine.substring(aLeftParenIndex +1 , aRightParenIndex);¬∂		String[] aMethodParameterTokens = aMethodParameters.isEmpty()?emptyArray:¬∂		 aMethodParameters.split(",");¬∂		¬∂//		String[] aMethodParameterTypes = new String[aMethodParameterTokens.length];¬∂//		String[] aMethodParameterNames = new String[aMethodParameterTokens.length];¬∂		List<DeclarationSNode> aDeclarationSNodeList = new ArrayList();¬∂		for (int i = 0; i < aMethodParameterTokens.length; i++ ) {¬∂			String[] aTypeAndName = aMethodParameterTokens[i].trim().split("\\s+");¬∂			if (aTypeAndName.length < 2) {¬∂				continue;¬∂			}¬∂			aDeclarationSNodeList.add(new ADeclarationSNode(aLineNumber, aTypeAndName[0].trim(), aTypeAndName[1].trim()));¬∂//			aMethodParameterTypes[i] = aTypeAndName[0].trim();¬∂//			aMethodParameterNames[i] = aTypeAndName[1].trim();¬∂		}¬∂		if (isInternal)¬∂//		return new AMethodSNode(aLineNumber, aMethodNameAndTypeTokens[0], aMethodNameAndTypeTokens[1], aMethodParameterTypes,aMethodParameterNames );¬∂			return new AMethodSNode(aLineNumber, aMethodNameAndTypeTokens[0], aMethodNameAndTypeTokens[1], aDeclarationSNodeList );¬∂		else¬∂			return new AnExternalMethodSNode(aLineNumber, aMethodNameAndTypeTokens[0], aMethodNameAndTypeTokens[1], aDeclarationSNodeList );¬∂	}¬∂¬∂	public static void setReductionData(OMPForSNode lastChild, String aStoredToken, int aLeftParenIndex,¬∂			int aRightParenIndex) {¬∂		int aColonIndex = aStoredToken.indexOf(":");¬∂		if (aLeftParenIndex != -1 && aRightParenIndex != -1 && aColonIndex != -1) {¬∂			String anOperationString = aStoredToken.substring(aLeftParenIndex + 1, aColonIndex).trim();¬∂			String aVariableString = aStoredToken.substring(aColonIndex + 1, aRightParenIndex).trim();¬∂			((OMPForSNode) lastChild).setReductionVariable(aVariableString);¬∂			((OMPForSNode) lastChild).setReductionOperation(anOperationString);¬∂		}¬∂	}¬∂¬∂	public static void setSharedOrPrivateData(OMPSNode lastChild, String aStoredToken, int aLeftParenIndex,¬∂			int aRightParenIndex, boolean isShared) {¬∂//		int aColonIndex = aStoredToken.indexOf(":");¬∂		if (aLeftParenIndex != -1 && aRightParenIndex != -1) {¬∂			String aVariableDeclarations = aStoredToken.substring(aLeftParenIndex + 1, aRightParenIndex);¬∂			String[] aVariables = aVariableDeclarations.split(",");¬∂			if (isShared) {¬∂				lastChild.setSharedVariables(aVariables);¬∂			} else {¬∂				lastChild.setPrivateVariables(aVariables);¬∂			}¬∂		}¬∂	}¬∂¬∂	public static RootOfFileSNode getSNode(String aFileName, String[] aFileLines) {¬∂		Stack<SNode> anSNodes = new Stack();¬∂¬∂		RootOfFileSNode retVal = new ARootOfFileSNode(aFileName);¬∂		anSNodes.add(retVal);¬∂		SNode previousHeaderNode = null;¬∂		for (int i = 0; i < aFileLines.length; i++) {¬∂			String aFileLine = aFileLines[i].trim();¬∂			if (!isCodeLine(aFileLine)) {¬∂				continue;¬∂			}¬∂			if (isForNode(aFileLine)) {¬∂				ForSNode aForSNode = getForSNode(i, aFileLine);¬∂				SNode aParent = previousHeaderNode != null?previousHeaderNode:anSNodes.peek();¬∂				aForSNode.setParent(anSNodes.peek());¬∂				aForSNode.setParent(aParent);¬∂¬∂//				anSNodes.push(aForSNode);¬∂				previousHeaderNode = aForSNode;¬∂				if (aFileLine.endsWith(")")) {¬∂					continue;¬∂				}¬∂			}¬∂			if (isExternalMethodDeclaration(aFileLine)) {¬∂				MethodSNode aMethodSNode = getMethodSNode(i, aFileLine, false);¬∂				aMethodSNode.setParent(anSNodes.peek());¬∂//				anSNodes.push(aForSNode);¬∂				previousHeaderNode = aMethodSNode;¬∂				if (aFileLine.endsWith(")")) {¬∂					continue;¬∂				}¬∂			}¬∂			if (isMethodDeclaration(aFileLine)) {¬∂				MethodSNode aMethodSNode = getMethodSNode(i, aFileLine, true);¬∂				aMethodSNode.setParent(anSNodes.peek());¬∂//				anSNodes.push(aForSNode);¬∂				previousHeaderNode = aMethodSNode;¬∂				if (aFileLine.endsWith(")")) {¬∂					continue;¬∂				}¬∂			}¬∂			if (isPragmaStart(aFileLine)) {¬∂				OMPSNode anOMPSNode = getOMPSNode(i, anSNodes.peek(), aFileLine);¬∂//				anSNodes.push(anOMPSNode);¬∂				previousHeaderNode = anOMPSNode;¬∂				continue;¬∂			}¬∂			if (isBlockStart(aFileLine)) {¬∂				SNode aBlockSNode = new ABlockSNode(i);¬∂				if (previousHeaderNode != null) {¬∂					aBlockSNode.setParent(previousHeaderNode);¬∂				} else {¬∂					aBlockSNode.setParent(anSNodes.peek());¬∂				}¬∂				anSNodes.push(aBlockSNode);¬∂				previousHeaderNode = null;¬∂				continue;¬∂			}¬∂//			} else ¬∂			if (isBlockEnd(aFileLine)) {¬∂				anSNodes.pop();¬∂				continue;¬∂			}¬∂			SNode aNewLeafNode = null;¬∂			if (isConstDeclaration(aFileLine)) {¬∂				aNewLeafNode = getConstDeclarationSNode(i, aFileLine);¬∂¬∂			} else if (isDeclaringAssignment(aFileLine)) {¬∂				aNewLeafNode = getDeclaringAssignmentSNode(i, aFileLine);¬∂¬∂			} else if (isAssignment(aFileLine)) {¬∂				aNewLeafNode = getAssignmentSNode(i, aFileLine);¬∂			} else if (isVariableDeclaration(aFileLine)) {¬∂				aNewLeafNode = getDeclarationSNode(i, aFileLine);¬∂			} else {¬∂				List<MethodCall> aCalls = callsIn(i, aFileLine, null); // parent will be assigned below¬∂				if (aCalls != null && aCalls.size() == 1) {¬∂					aNewLeafNode = aCalls.get(0);¬∂				} else {¬∂					aNewLeafNode = new ATextSNode(i, aFileLine);¬∂				}¬∂			}¬∂//			else {¬∂//				aNewLeafNode = new ATextSNode(i, aFileLine);¬∂//			}¬∂			if (previousHeaderNode != null) {¬∂				aNewLeafNode.setParent(previousHeaderNode);¬∂			} else {¬∂				aNewLeafNode.setParent(anSNodes.peek());¬∂			}¬∂¬∂		}¬∂¬∂		return retVal;¬∂	}¬∂¬∂	public static OMPSNode getOMPSNode(int aLineIndex, SNode aParentNode, String aFileLine) {¬∂		String[] aTokens = aFileLine.split("\\s+");¬∂		if (aTokens.length <= 2) {¬∂			return null;¬∂		}¬∂		if (!aTokens[1].equals("omp")) {¬∂			return null;¬∂		}¬∂		if (aTokens.length < 3) {¬∂			return null;¬∂		}¬∂		String aFirstToken = aTokens[2];¬∂		OpenMPKeywordEnum anOpenMPKeyword = stringToOpenMPKeyword.get(aFirstToken);¬∂//		List<OpenMPPragma> retVal = new ArrayList();¬∂		OMPSNode lastChild = null;¬∂		int aStartIndex = 2;¬∂		OMPSNode aNewNode = null;¬∂		OMPForSNode aForChild = null;¬∂		switch (anOpenMPKeyword) {¬∂		case PARALLEL:¬∂			aNewNode = new AnOMPParallelSNode(aLineIndex);¬∂¬∂			if (aTokens.length > 3 && aTokens[3].equals("for")) {¬∂				aForChild = new AnOMPForSNode(aLineIndex);¬∂				aForChild.setParent(aNewNode);¬∂¬∂				aStartIndex++;¬∂			}¬∂			break;¬∂		case FOR:¬∂			aNewNode = new AnOMPForSNode(aLineIndex);¬∂			;¬∂			break;¬∂		case CRITICAL:¬∂			aNewNode = new AnOMPCriticalSNode(aLineIndex);¬∂//			retVal.add (lastChild);¬∂			break;¬∂		default:¬∂			aNewNode = new AnOMPSNode(aLineIndex);¬∂¬∂		}¬∂¬∂		if (lastChild != null) {¬∂			aNewNode.setParent(lastChild);¬∂		} else {¬∂			aNewNode.setParent(aParentNode);¬∂		}¬∂		lastChild = aForChild == null ? aNewNode : aForChild;¬∂¬∂		for (int i = aStartIndex; i < aTokens.length; i++) {¬∂			String aStoredToken = aTokens[i].trim();¬∂			if (aStoredToken.isEmpty()) {¬∂				continue;¬∂			}¬∂			if (aStoredToken.startsWith("reduction") || aStoredToken.startsWith("shared")¬∂					|| aStoredToken.startsWith("private")) {¬∂				// combine all tokens until ")" into one for normalization¬∂				while (!aStoredToken.endsWith(")")) {¬∂					i++;¬∂					if (i >= aTokens.length) {¬∂						break;¬∂					}¬∂					String aNewToken = aTokens[i].trim();¬∂					aStoredToken += aNewToken;¬∂				}¬∂				int aLeftParenIndex = aStoredToken.indexOf("(");¬∂				int aRightParenIndex = aStoredToken.indexOf(")");¬∂				if (aStoredToken.startsWith("reduction")) {¬∂					setReductionData((OMPForSNode) lastChild, aStoredToken, aLeftParenIndex, aRightParenIndex);¬∂				} else if (aStoredToken.startsWith("private")) {¬∂					setSharedOrPrivateData((OMPSNode) lastChild, aStoredToken, aLeftParenIndex, aRightParenIndex,¬∂							false);¬∂¬∂				} else if (aStoredToken.startsWith("shared")) {¬∂					setSharedOrPrivateData(lastChild, aStoredToken, aLeftParenIndex, aRightParenIndex, true);¬∂¬∂				}¬∂¬∂			}¬∂¬∂			lastChild.getOpenMPTokens().add(aStoredToken);¬∂		}¬∂¬∂		return lastChild;¬∂¬∂	}¬∂¬∂	public static boolean hasParallelAncestor(SNode anSNode) {¬∂		if (anSNode == null) {¬∂			return false;¬∂		}¬∂		if (anSNode instanceof OMPParallelSNode) {¬∂			return true;¬∂		}¬∂		return hasParallelAncestor(anSNode.getParent());¬∂	}¬∂	public static boolean hasCriticalAncestor(SNode anSNode) {¬∂		if (anSNode == null) {¬∂			return false;¬∂		}¬∂		if (anSNode instanceof OMPCriticalSNode) {¬∂			return true;¬∂		}¬∂		return hasCriticalAncestor(anSNode.getParent());¬∂	}¬∂¬∂¬∂	public static Boolean isDeclaredShared(OMPSNode anOMPSNode, String anLHS) {¬∂		if (Arrays.asList(anOMPSNode.getSharedVariables()).contains(anLHS)) {¬∂			return true;¬∂		}¬∂		if (Arrays.asList(anOMPSNode.getPrivateVariables()).contains(anLHS)) {¬∂			return false;¬∂		}¬∂		return null;¬∂¬∂	}¬∂¬∂	public static boolean isSharedVariable(SNode anSNode, String anLHS) {¬∂		if (anSNode == null) {¬∂			return false;¬∂		}¬∂		if (anSNode.getLocalVariableIdentifiers().contains(anLHS)) {¬∂			if (!(anSNode instanceof OMPSNode)) { // no shared and private declarations¬∂				return !hasParallelAncestor(anSNode); // shared if not inParallel¬∂			}¬∂			OMPSNode anOMPSNode = (OMPSNode) anSNode;¬∂			return (Arrays.asList(anOMPSNode.getSharedVariables()).contains(anLHS)); // private unless declared shared¬∂		}¬∂		if (anSNode instanceof OMPSNode) {¬∂			OMPSNode anOMPSNode = (OMPSNode) anSNode;¬∂			// the variable is global to this scope, check if it has have been made shared¬∂			// or private by this scope¬∂			Boolean isDeclaredShared = isDeclaredShared(anOMPSNode, anLHS);¬∂			if (isDeclaredShared != null) {¬∂				return isDeclaredShared;¬∂			}¬∂		}¬∂		// check the parent¬∂		return isSharedVariable(anSNode.getParent(), anLHS);¬∂	}¬∂¬∂	public static List<SNode> getAllLeafNodes(SNode aTopNode) {¬∂		List<SNode> retVal = new ArrayList();¬∂		addLeafNodes(aTopNode, retVal);¬∂		return retVal;¬∂	}¬∂¬∂	public static void addLeafNodes(SNode aTopNode, List<SNode> retVal) {¬∂		for (SNode aChild : aTopNode.getChildren()) {¬∂			if (aChild.isLeaf()) {¬∂				retVal.add(aChild);¬∂			} else {¬∂				addLeafNodes(aChild, retVal);¬∂			}¬∂		}¬∂	}¬∂¬∂	public static List<SNode> getNonParallelLeafNodes(SNode aTopNode) {¬∂		List<SNode> retVal = new ArrayList();¬∂		addNonParallelLeafNodes(aTopNode, retVal);¬∂		return retVal;¬∂	}¬∂¬∂	public static void addNonParallelLeafNodes(SNode aTopNode, List<SNode> retVal) {¬∂		if (aTopNode.isInParallel()) {¬∂			return;¬∂		}¬∂		for (SNode aChild : aTopNode.getChildren()) {¬∂			if (aChild.isLeaf()) {¬∂				retVal.add(aChild);¬∂			} else {¬∂				addLeafNodes(aChild, retVal);¬∂			}¬∂		}¬∂	}¬∂	static String callRegex = "([a-zA-Z_$][a-zA-Z_$0-9]*)\\(.*?\\)";¬∂	static Pattern callPattern = Pattern.compile(callRegex);¬∂¬∂	static String identifierRegex = "[a-zA-Z_$][a-zA-Z_$0-9]*";¬∂	static Pattern identifierPattern = Pattern.compile(identifierRegex);¬∂	public static List<String> identifiersIn(String aString) {¬∂		if (aString == null)¬∂			return null;¬∂//		Pattern mypattern = Pattern.compile("[a-zA-Z_$][a-zA-Z_$0-9]*");¬∂//		Matcher mymatcher = mypattern.matcher(aString);¬∂		Matcher mymatcher = identifierPattern.matcher(aString);¬∂		List<String> retVal = new ArrayList();¬∂		while (mymatcher.find()) {¬∂			String find = mymatcher.group(0);¬∂			retVal.add(find);¬∂		}¬∂		return retVal;¬∂	}¬∂	public static List<MethodCall> callsIn(int aLineNumber, String aString, SNode aParent) {¬∂		if (aString == null)¬∂			return emptyList;¬∂		if (isMethodDeclaration(aString)) {¬∂			return emptyList;¬∂		}¬∂//		Pattern mypattern = Pattern.compile("[a-zA-Z_$][a-zA-Z_$0-9]*");¬∂//		Matcher mymatcher = mypattern.matcher(aString);¬∂		Matcher mymatcher = callPattern.matcher(aString);¬∂		List<MethodCall> retVal = new ArrayList();¬∂		while (mymatcher.find()) {¬∂			String find = mymatcher.group(0);¬∂			int aLeftParenIndex = find.indexOf("(");¬∂			int aRightParenIndex = find.indexOf(")");¬∂			String aMethodName = find.substring(0, aLeftParenIndex).trim();¬∂			String aParameters = find.substring(aLeftParenIndex + 1, aRightParenIndex);¬∂			List<String> aParameterList = new ArrayList();¬∂			String[] aParameterTokens = aParameters.split(",");¬∂			for (String aParameter:aParameterTokens) {¬∂				String aParameterTrimmed = aParameter.trim();¬∂				if (!aParameterTrimmed.isEmpty())¬∂				aParameterList.add(aParameterTrimmed);¬∂			}¬∂			retVal.add(new AMethodCall(aLineNumber, aMethodName, aParameterList, aParent));¬∂¬∂//			aCallStrings.add(find);¬∂		}¬∂		return retVal;¬∂	}¬∂	static String numberRegex = "(\\d+\\.\\d+)|(\\d+)";¬∂	static Pattern numberPattern = Pattern.compile(numberRegex);¬∂	public static List<String> numbersIn(String aString) {¬∂		if (aString == null)¬∂			return null;¬∂//		String regex = "(\\d+\\.\\d+)|(\\d+)";¬∂//¬∂//		Matcher m = Pattern.compile(regex).matcher(aString);¬∂		Matcher m =numberPattern.matcher(aString);¬∂¬∂¬∂		List<String> retVal = new ArrayList();¬∂¬∂		while (m.find()) {¬∂			retVal.add(m.group());¬∂		}¬∂		return retVal;¬∂	}¬∂¬∂	public static String subscriptIn(String aString) {¬∂		if (aString == null)¬∂			return null;¬∂		return StringUtils.substringBetween(aString, "[", "]");¬∂	}¬∂	static String[] emptyStringArray = {};¬∂	static List emptyList = new ArrayList();¬∂¬∂	public static String[] subscriptsIn(String aString) {¬∂		if (aString == null)¬∂			return emptyStringArray;¬∂		return StringUtils.substringsBetween(aString, "[", "]");¬∂	}¬∂	static  String operatorRegex = "([+-/*///^])|([/(/)])";¬∂	static Pattern operatorPattern = Pattern.compile(operatorRegex);¬∂¬∂	public static List<String> operatorsIn(String aString) {¬∂		if (aString == null)¬∂			return null;¬∂//		String operatorRegex = "([+-/*///^])|([/(/)])";¬∂//¬∂//		Matcher m = Pattern.compile(operatorRegex).matcher(aString);¬∂		¬∂		Matcher m = operatorPattern.matcher(aString);¬∂¬∂¬∂		List<String> retVal = new ArrayList();¬∂¬∂		while (m.find()) {¬∂			retVal.add(m.group());¬∂		}¬∂		return retVal;¬∂	}¬∂	¬∂	public static int numberOfNestingFors (SNode anSNode) {¬∂		if (anSNode == null) {¬∂			return 0;¬∂		}¬∂		int retVal = numberOfNestingFors (anSNode.getParent()) ;¬∂¬∂		if (anSNode instanceof ForSNode) {¬∂			retVal++;¬∂		} else if (anSNode instanceof MethodSNode) {¬∂			List<MethodCall> aMethodCalls = ((MethodSNode) anSNode).getCalls();¬∂			int aMaxNestingLevel = 0;¬∂			for (MethodCall aMethodCall:aMethodCalls) {¬∂				MethodSNode aCallerMethodSNode = getDeclarationOfCalledMethod(anSNode, aMethodCall);¬∂				int aCallerNumberOfNestingFors = numberOfNestingFors(aCallerMethodSNode);¬∂				aMaxNestingLevel = Math.max(aCallerNumberOfNestingFors, aMaxNestingLevel);				¬∂			}¬∂			return retVal + aMaxNestingLevel;¬∂		}¬∂		return retVal;¬∂	}¬∂	public static boolean hasOperator (SNode anSNode, String anOperator) {¬∂		boolean retVal = false;¬∂		if (anSNode instanceof AssignmentSNode) {¬∂			AssignmentSNode anAssignmentSNode = (AssignmentSNode) anSNode;¬∂			 retVal = (anAssignmentSNode.getLhsOperators().contains(anOperator) || ¬∂					anAssignmentSNode.getRhsOperators().contains(anOperator)) ;¬∂			if (retVal) {¬∂				return retVal;¬∂			} else {¬∂				List<MethodCall> aMethodCalls = anAssignmentSNode.getRhsCalls();¬∂				for (MethodCall aMethodCall:aMethodCalls) {¬∂					MethodSNode aMethodSNode = getDeclarationOfCalledMethod(anSNode, aMethodCall);¬∂					retVal = hasOperator(aMethodSNode, anOperator);¬∂					if (retVal) {¬∂						return retVal;¬∂					}¬∂					¬∂				}¬∂				return false;¬∂			}¬∂			¬∂		}¬∂		for (SNode aChild:anSNode.getChildren()) {¬∂			retVal = hasOperator(aChild, anOperator);¬∂			if (retVal) {¬∂				return retVal;¬∂			}¬∂		}¬∂		return false;¬∂	}¬∂	public static boolean hasMethodCall (SNode anSNode, String anOperator) {¬∂		boolean retVal = false;¬∂		if (anSNode instanceof AssignmentSNode) {¬∂			AssignmentSNode anAssignmentSNode = (AssignmentSNode) anSNode;¬∂			 retVal = (anAssignmentSNode.getLhsOperators().contains(anOperator) || ¬∂					anAssignmentSNode.getRhsOperators().contains(anOperator)) ;¬∂			if (retVal) {¬∂				return retVal;¬∂			} else {¬∂				List<MethodCall> aMethodCalls = anAssignmentSNode.getRhsCalls();¬∂				for (MethodCall aMethodCall:aMethodCalls) {¬∂					MethodSNode aMethodSNode = getDeclarationOfCalledMethod(anSNode, aMethodCall);¬∂					retVal = hasOperator(aMethodSNode, anOperator);¬∂					if (retVal) {¬∂						return retVal;¬∂					}¬∂					¬∂				}¬∂				return false;¬∂			}¬∂			¬∂		}¬∂		for (SNode aChild:anSNode.getChildren()) {¬∂			retVal = hasOperator(aChild, anOperator);¬∂			if (retVal) {¬∂				return retVal;¬∂			}¬∂		}¬∂		return false;¬∂	}¬∂	public static boolean dependsOn (AssignmentSNode anAssignmentSNode, String aVariable, String aCallIdentifier) {¬∂		// This assignment does not change aVariable¬∂		if (!aVariable.equals(anAssignmentSNode.getLhsFirstIdentifier())) {¬∂			return false;¬∂		}¬∂		return dependsOn(anAssignmentSNode.getExpressionSNode(), aCallIdentifier);¬∂//		List<String> aCallIdentifiers = anAssignmentSNode.getRhsCallIdentifiers();¬∂//		boolean retVal = false;¬∂//		if (aCallIdentifiers != null && aCallIdentifiers.contains(aCallIdentifier)) {¬∂//			return true; // this assignment has aCallIdentifier in the rhs¬∂//		}¬∂//		// check if some referenced rhs variable depends on aCallIdentifier¬∂//		List<String> aReferencedVariableIdentifiers = anAssignmentSNode.getRhsVariableIdentifiers();¬∂//		SNode anAssignmentParent = anAssignmentSNode.getParent();¬∂//		if (anAssignmentParent == null) { // should never be trye¬∂//			return false;¬∂//		}¬∂//		int aLineNumber = anAssignmentSNode.getLineNumber();¬∂//		for (String aReferencedVariableIdentifier:aReferencedVariableIdentifiers ) {¬∂//			if (dependsOn (anAssignmentParent, aLineNumber, aReferencedVariableIdentifier, aCallIdentifier)) {¬∂//				return true;¬∂//			}¬∂//		}¬∂//		return false;¬∂	}¬∂	public static boolean dependsOn (ExpressionSNode anExpressionSNode, String aCallIdentifier) {¬∂		// This assignment does not change aVariable¬∂		¬∂		List<String> aCallIdentifiers = anExpressionSNode.getRhsCallIdentifiers();¬∂		boolean retVal = false;¬∂		if (aCallIdentifiers != null && aCallIdentifiers.contains(aCallIdentifier)) {¬∂			return true; // this assignment has aCallIdentifier in the rhs¬∂		}¬∂		// check if some referenced rhs variable depends on aCallIdentifier¬∂		List<String> aReferencedVariableIdentifiers = anExpressionSNode.getRhsVariableIdentifiers();¬∂		SNode anAssignmentParent = anExpressionSNode.getParent().getParent();¬∂		if (anAssignmentParent == null) { // should never be trye¬∂			return false;¬∂		}¬∂		int aLineNumber = anExpressionSNode.getLineNumber();¬∂		for (String aReferencedVariableIdentifier:aReferencedVariableIdentifiers ) {¬∂			if (dependsOn (anAssignmentParent, aLineNumber, aReferencedVariableIdentifier, aCallIdentifier)) {¬∂				return true;¬∂			}¬∂		}¬∂		return false;¬∂	}¬∂	public static Set<AssignmentSNode> assignmentsToSharedVariables(SNode anSNode) {¬∂		Set<AssignmentSNode> retVal =  new HashSet();¬∂		fillAssignmentsToShared(anSNode, retVal);¬∂		return retVal;¬∂		¬∂	}¬∂	public static Set<AssignmentSNode> assignmentsToSharedArrays(SNode anSNode) {¬∂		Set<AssignmentSNode> anAllSharedAssignments =  assignmentsToSharedVariables(anSNode);¬∂		Set<AssignmentSNode> aRetVal = new HashSet();¬∂		for (AssignmentSNode anAssignmentSNode:anAllSharedAssignments) {¬∂			if (anAssignmentSNode.getLhsSubscripts().length > 0) {¬∂				aRetVal.add(anAssignmentSNode);¬∂			}¬∂		}¬∂		return aRetVal;¬∂		¬∂	}¬∂	public static Set<AssignmentSNode> assignmentsToParallelCriticalSharedVariables(SNode anSNode) {¬∂		Set<AssignmentSNode> anAllSharedAssignments =  assignmentsToSharedVariables(anSNode);¬∂		Set<AssignmentSNode> aRetVal = new HashSet();¬∂		for (AssignmentSNode anAssignmentSNode:anAllSharedAssignments) {¬∂			if (anAssignmentSNode.isInParallel() &&¬∂					anAssignmentSNode.isInCritical()) {¬∂				aRetVal.add(anAssignmentSNode);¬∂			}¬∂		}¬∂		return aRetVal;¬∂		¬∂	}¬∂	public static Set<AssignmentSNode> assignmentsToNonParallelCriticalSharedVariables(SNode anSNode) {¬∂		Set<AssignmentSNode> anAllSharedAssignments =  assignmentsToSharedVariables(anSNode);¬∂		Set<AssignmentSNode> aRetVal = new HashSet();¬∂		for (AssignmentSNode anAssignmentSNode:anAllSharedAssignments) {¬∂			if (!anAssignmentSNode.isInParallel() &&¬∂					anAssignmentSNode.isInCritical()) {¬∂				aRetVal.add(anAssignmentSNode);¬∂			}¬∂		}¬∂		return aRetVal;¬∂		¬∂	}¬∂	public static Set<AssignmentSNode> assignmentsToParallelNonCriticalSharedVariables(SNode anSNode) {¬∂		Set<AssignmentSNode> anAllSharedAssignments =  assignmentsToSharedVariables(anSNode);¬∂		Set<AssignmentSNode> aRetVal = new HashSet();¬∂		for (AssignmentSNode anAssignmentSNode:anAllSharedAssignments) {¬∂			if (anAssignmentSNode.isInParallel() &&¬∂					!anAssignmentSNode.isInCritical()) {¬∂				aRetVal.add(anAssignmentSNode);¬∂			}¬∂		}¬∂		return aRetVal;¬∂		¬∂	}¬∂    public static void fillAssignmentsToShared(SNode anSNode, Set<AssignmentSNode> retVal) {¬∂    	if (anSNode instanceof AssignmentSNode) {¬∂			AssignmentSNode anAssignmentSNode = (AssignmentSNode) anSNode;¬∂			String anLHS = anAssignmentSNode.getLhsFirstIdentifier();¬∂			if (isSharedVariable(anSNode, anLHS)) {¬∂				retVal.add(anAssignmentSNode);¬∂				return;¬∂			}¬∂		}¬∂    	for (SNode aChild:anSNode.getChildren()) {¬∂    		fillAssignmentsToShared(aChild, retVal);¬∂    	}¬∂		¬∂	}¬∂    public static void fillInstancesOfNodeType(Class<? extends SNode> aNodeType, SNode anSNode, Set<SNode> retVal) {¬∂    	if (aNodeType.isAssignableFrom(anSNode.getClass())) {¬∂			¬∂				retVal.add(anSNode);¬∂				return;¬∂			}¬∂		¬∂    	for (SNode aChild:anSNode.getChildren()) {¬∂    		fillInstancesOfNodeType(aNodeType, aChild, retVal);¬∂    	}¬∂		¬∂	}¬∂    public static Set<AssignmentSNode>  assignmentSNodes(SNode anSNode) {¬∂    	Set retVal = new HashSet();    	¬∂    	fillInstancesOfNodeType(AssignmentSNode.class, anSNode, retVal );¬∂    	return retVal;¬∂	}¬∂   ¬∂    ¬∂    public static Set<OMPParallelSNode>  ompParallelSNodes(SNode anSNode) {¬∂    	Set retVal = new HashSet();    	¬∂    	fillInstancesOfNodeType(OMPParallelSNode.class, anSNode, retVal );¬∂    	return retVal;¬∂	}¬∂//    public static void fillOMPParallelSNodes(SNode anSNode, Set<OMPParallelSNode> retVal) {¬∂//    	if (anSNode instanceof OMPParallelSNode) {¬∂//    		retVal.add((OMPParallelSNode) anSNode);¬∂//		}¬∂//    	for (SNode aChild:anSNode.getChildren()) {¬∂//    		fillOMPParallelSNodes(aChild, retVal);¬∂//    	}		¬∂//	}¬∂    public static Set<ForSNode>  forSNodes(SNode anSNode) {¬∂    	Set retVal = new HashSet();    	¬∂    	fillInstancesOfNodeType(ForSNode.class, anSNode, retVal );¬∂    	return retVal;¬∂	}¬∂//    public static void fillForSNodes(SNode anSNode, Set<ForSNode> retVal) {¬∂//    	if (anSNode instanceof ForSNode) {¬∂//    		retVal.add((ForSNode) anSNode);¬∂//		}¬∂//    	for (SNode aChild:anSNode.getChildren()) {¬∂//    		fillForSNodes(aChild, retVal);¬∂//    	}		¬∂//	}¬∂    public static Set<OMPForSNode>  ompForSNodes(SNode anSNode) {¬∂    	Set retVal = new HashSet();    	¬∂    	fillInstancesOfNodeType(OMPForSNode.class, anSNode, retVal );¬∂    	return retVal;¬∂	}¬∂//    public static void fillOMPForSNodes(SNode anSNode, Set<OMPForSNode> retVal) {¬∂//    	if (anSNode instanceof OMPForSNode) {¬∂//    		retVal.add((OMPForSNode) anSNode);¬∂//		}¬∂//    	for (SNode aChild:anSNode.getChildren()) {¬∂//    		fillOMPForSNodes(aChild, retVal);¬∂//    	}		¬∂//	}¬∂    public static Set<OMPForSNode> ompReducingForNodes(SNode anSNode) {¬∂		Set<OMPForSNode> anAllOMPForSNodes =  ompForSNodes(anSNode);¬∂		Set<OMPForSNode> aRetVal = new HashSet();¬∂		for (OMPForSNode anOMPForSNode:anAllOMPForSNodes) {¬∂			if (anOMPForSNode.getReductionOperation() != null) {¬∂				aRetVal.add(anOMPForSNode);¬∂			}¬∂		}¬∂		return aRetVal;		¬∂	}¬∂    public static Set<AssignmentSNode> assignmentsToOMPReducingForNode(OMPForSNode anOMPForSNode) {¬∂    	String aReductionVariable = anOMPForSNode.getReductionVariable();¬∂    	return directAssignmentsOfVariableAndItsAliases(anOMPForSNode, aReductionVariable)	;¬∂    	¬∂    }¬∂	public static boolean dependsOn (SNode anSNode, int aVariableLineNumber, String aVariable, String aCallIdentifier) {¬∂		List<SNode> aListSNodes = anSNode.getChildren();¬∂		boolean retVal = false;¬∂		/*¬∂		 * Should probably ignore line number as it assumes straight line code¬∂		 */¬∂		for (int i = aVariableLineNumber; i >= 0; i--) {¬∂			SNode anSNodeChild = aListSNodes.get(i);¬∂			if (anSNodeChild instanceof AssignmentSNode) {¬∂				// does this statement in anSNode directly invoke aCallIdentifier ¬∂				if (dependsOn((AssignmentSNode) anSNodeChild, aVariable, aCallIdentifier))¬∂					return true;¬∂			} else if (!anSNode.isLeaf()) {¬∂					// child is overriding the variable so forget checking its assignment statements¬∂					if (anSNodeChild.getLocalVariableIdentifiers().contains(aVariable)) {¬∂						continue;¬∂					}¬∂					// some subblock of anSNode that has access to aVariable changes variable¬∂¬∂					if (dependsOn(anSNodeChild, anSNodeChild.getChildren().size() - 1, aVariable, aCallIdentifier)) {¬∂						return true;¬∂					}¬∂			}¬∂			¬∂		}¬∂		// none of the statements in anSNode or its descendents  have the required call¬∂		// is the variable a  method parameter ¬∂		if (anSNode instanceof MethodSNode) {¬∂			MethodSNode aMethodSNode = (MethodSNode) anSNode;¬∂			¬∂			int aParameterNumber = aMethodSNode.getLocalVariableIdentifiers().indexOf(aVariable);¬∂			if (aParameterNumber != -1) {¬∂				List <MethodCall> aCalls = aMethodSNode.getCalls();¬∂				for (MethodCall aCall:aCalls) {¬∂//					if (!aCall.getMethodActuals().contains(aVariable))¬∂//						continue;¬∂//					¬∂					MethodSNode aCallerSNode = getDeclarationOfCalledMethod(aMethodSNode, aCall);¬∂					if (dependsOn(aMethodSNode, aCallerSNode.getLineNumber(), aCallerSNode.getLocalVariableIdentifiers().get(aParameterNumber), aCallIdentifier));¬∂//				    if (aCallerDepends) {¬∂				    	return true;¬∂//				    }¬∂				}¬∂				return false;¬∂				// need to find all callers of method and see if any of the aliases for the variable in these¬∂				// calls depend on aCallIndentifier¬∂			}			¬∂			¬∂		} else if (anSNode.getLocalVariableIdentifiers().contains(aVariable)) {¬∂			// before going to the parent node, let us see if aVariable is declared here as a non  parameter ¬∂¬∂			return false; // no point going to parent¬∂		}¬∂		// not a local variable (parameter or declarated variable)¬∂		SNode anSNodeParent = anSNode.getParent() ;¬∂		if (anSNodeParent == null)  {¬∂			return false;¬∂		}¬∂		int anSNodeLineNumber = anSNodeParent.getChildren().indexOf(anSNode);¬∂		return dependsOn(anSNodeParent, anSNodeLineNumber, aVariable, aCallIdentifier);¬∂		¬∂	}¬∂	public static Set<AssignmentSNode> assignmentsOfVariableAliases (SNode anSNode,  String aVariable) {¬∂		Set<AssignmentSNode> retVal = new HashSet();¬∂		fillDirectAssignmentsOfVariableAndItsAliases(anSNode, aVariable, retVal);¬∂		return retVal;¬∂	}¬∂	public static void fillDirectAssignmentsOfVariableAliases (SNode anSNode,  String aVariable, Set<AssignmentSNode> retVal) {¬∂		if (anSNode instanceof MethodCall) {¬∂			MethodCall aMethodCall = (MethodCall) anSNode;¬∂			int aParameterNumber = aMethodCall.getMethodActualIdentifiers().indexOf(aVariable);¬∂			if (aParameterNumber < 0) {¬∂				return;¬∂			}¬∂			MethodSNode aDeclaringMethodSNode = getDeclarationOfCalledMethod(anSNode, aMethodCall);¬∂			String aFormalParameter = aDeclaringMethodSNode.getLocalVariableIdentifiers().get(aParameterNumber);¬∂//			Set<AssignmentSNode> aCallAssignments = ;¬∂			fillDirectAssignmentsOfVariableAliases(aDeclaringMethodSNode, aFormalParameter, retVal);¬∂		} else {¬∂			List<SNode> aChildren = anSNode.getChildren();¬∂			for (SNode aChild:aChildren) {¬∂				fillDirectAssignmentsOfVariableAliases(aChild, aVariable, retVal);¬∂			}¬∂		}		¬∂		¬∂	}¬∂	¬∂	/*¬∂	 * will not consider assignments to variables in the RHS of these assignments¬∂	 */¬∂	public static Set<AssignmentSNode> directAssignmentsOfVariableAndItsAliases (SNode anSNode,  String aVariable) {¬∂		Set<AssignmentSNode> retVal = new HashSet();¬∂		fillDirectAssignmentsOfVariableAndItsAliases(anSNode, aVariable, retVal);¬∂		return retVal;¬∂	}¬∂	¬∂//	public static Set<AssignmentSNode> assignmentsEffectingVariableAndItsAliases (SNode anSNode,  String aVariable) {¬∂//		Set<AssignmentSNode> retVal = directAssignmentsOfVariableAndItsAliases(anSNode, aVariable);¬∂//		¬∂//	}¬∂	public static void fillDirectAssignmentsOfVariableAndItsAliases (SNode anSNode,  String aVariable, Set<AssignmentSNode> retVal) {¬∂		if (anSNode instanceof AssignmentSNode) {¬∂			AssignmentSNode anAssignmentSNode = (AssignmentSNode) anSNode;¬∂			if (anAssignmentSNode.getLhsFirstIdentifier().equals(aVariable)) {¬∂				retVal.add(anAssignmentSNode);¬∂			}¬∂		}¬∂		¬∂		else if (anSNode instanceof MethodCall) {¬∂			MethodCall aMethodCall = (MethodCall) anSNode;¬∂			int aParameterNumber = aMethodCall.getMethodActualIdentifiers().indexOf(aVariable);¬∂			if (aParameterNumber < 0) {¬∂				return;¬∂			}¬∂			MethodSNode aDeclaringMethodSNode = getDeclarationOfCalledMethod(anSNode, aMethodCall);¬∂			String aFormalParameter = aDeclaringMethodSNode.getLocalVariableIdentifiers().get(aParameterNumber);¬∂//			Set<AssignmentSNode> aCallAssignments = ;¬∂			fillDirectAssignmentsOfVariableAndItsAliases(aDeclaringMethodSNode, aFormalParameter, retVal);¬∂		} else {¬∂			List<SNode> aChildren = anSNode.getChildren();¬∂			for (SNode aChild:aChildren) {¬∂				fillDirectAssignmentsOfVariableAndItsAliases(aChild, aVariable, retVal);¬∂			}¬∂		}		¬∂		¬∂	}¬∂	¬∂	public static RootOfFileSNode getRootOfFileNode(SNode aCurrentSNode ) {¬∂		if (aCurrentSNode instanceof RootOfFileSNode) {¬∂			return (RootOfFileSNode) aCurrentSNode;¬∂		}¬∂		SNode aParentSNode = aCurrentSNode.getParent() ;¬∂		¬∂		if (aParentSNode == null) {¬∂			return null;¬∂		}¬∂		¬∂		return getRootOfFileNode(aParentSNode);¬∂		¬∂	}¬∂	public static boolean match (MethodSNode aMethodSNode, MethodCall aMethodCall) {¬∂		return aMethodSNode.getMethodName().equals(aMethodCall.getMethodName()) ¬∂				&& aMethodSNode.getLocalVariableIdentifiers().size() == aMethodCall.getMethodActuals().size();¬∂	}¬∂	public static DeclarationSNode getDeclarationOfVariableIdentifier(SNode aCurrentSNode, String anIdentifier) {¬∂		if (aCurrentSNode == null) {¬∂			return null;¬∂		}¬∂		¬∂		¬∂		int anIndex = aCurrentSNode.getLocalVariableIdentifiers().indexOf(anIdentifier);¬∂		if (anIndex < 0) {¬∂			return getDeclarationOfVariableIdentifier(aCurrentSNode.getParent(), anIdentifier);¬∂		}¬∂		DeclarationSNode retVal = aCurrentSNode.getVariableDeclarations().get(anIndex);¬∂//		retVal.getAssignmentsToDeclaredVariable().add(anAssignmentSNode);¬∂//		anAssignmentSNode.setLhsFirstIdentifierDeclaration(retVal);¬∂		return retVal;¬∂	}¬∂	¬∂	public static DeclarationSNode getDeclarationOfAssignedVariable(SNode aCurrentSNode, AssignmentSNode anAssignmentSNode) {¬∂		if (aCurrentSNode == null) {¬∂			return null;¬∂		}¬∂		if (anAssignmentSNode instanceof ADeclaringAssignmentSNode) {¬∂			return (ADeclaringAssignmentSNode) anAssignmentSNode;¬∂		}¬∂		int anIndex = aCurrentSNode.getLocalVariableIdentifiers().indexOf(anAssignmentSNode.getLhsFirstIdentifier());¬∂		if (anIndex < 0) {¬∂			return getDeclarationOfAssignedVariable(aCurrentSNode.getParent(), anAssignmentSNode);¬∂		}¬∂		DeclarationSNode retVal = aCurrentSNode.getVariableDeclarations().get(anIndex);¬∂//		retVal.getAssignmentsToDeclaredVariable().add(anAssignmentSNode);¬∂//		anAssignmentSNode.setLhsFirstIdentifierDeclaration(retVal);¬∂		return retVal;¬∂	}¬∂	¬∂	public static MethodSNode getDeclarationOfCalledMethod(SNode aCurrentSNode, MethodCall aMethodCall ) {¬∂		SNode aRootNode = getRootOfFileNode(aCurrentSNode);¬∂		for (SNode aChild:aRootNode.getChildren()) {¬∂			if (aChild instanceof MethodSNode) {¬∂				MethodSNode aMethodSNode = (MethodSNode) aChild;¬∂				if (match (aMethodSNode, aMethodCall)) {¬∂					return aMethodSNode;¬∂				}¬∂			}¬∂		}¬∂		return null; // this should never happen;¬∂	}¬∂	¬∂	public static RootOfProgramSNode getRootOfProgramSNode(String aSource) {¬∂		RootOfProgramSNode retVal = new ARootOfProgramSNode();¬∂		Map<String, StringBuffer> aFileNameToContents = ABasicTextManager.extractFileContents(aSource);¬∂		for (String aFileName:aFileNameToContents.keySet()) {¬∂			StringBuffer aFileContents = aFileNameToContents.get(aFileName);¬∂//			List<OpenMPPragma> anOpenMPPragmas = OpenMPUtils.getOpemMPPragmas(aFileContents);¬∂			RootOfFileSNode anSNode = OMPSNodeUtils.getSNode(aFileName, aFileContents);¬∂			retVal.getFileNameToSNode().put(aFileName, anSNode);¬∂			anSNode.setParent(retVal);¬∂//			System.out.println("file name:" + aFileName);¬∂//			System.out.println("pragmas:" + anSNode);¬∂		}¬∂		processExternalMethodSNodes(retVal);¬∂		processIndirectAssignments(retVal);¬∂		return retVal;¬∂	}¬∂//	public static void processIndirectAssignments (S aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode) {¬∂//		for (SNode anSNode:aRootOfFileSNode.getChildren()) {¬∂//			-----¬∂//		}¬∂//	}¬∂	public static void processExternalMethodSNodes (RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode) {¬∂		for (SNode anSNode:aRootOfFileSNode.getChildren()) {¬∂			if (anSNode instanceof ExternalMethodSNode) {¬∂				processExternalMethodSNode(aRootOfProgramSNode, aRootOfFileSNode, (ExternalMethodSNode) anSNode);¬∂			}¬∂		}¬∂	}¬∂	public static void processExternalMethodSNode (RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode, ExternalMethodSNode anExternalMethodSNode) {¬∂		MethodSNode aMethodSNode = aRootOfProgramSNode.getExternalToInternalMethod().get(anExternalMethodSNode.toString());¬∂		if (aMethodSNode == null) {¬∂			aMethodSNode = findMethodSNode(aRootOfProgramSNode, aRootOfFileSNode, anExternalMethodSNode);¬∂			if (aMethodSNode != null) {¬∂				aRootOfProgramSNode.getExternalToInternalMethod().put(anExternalMethodSNode.toString(),aMethodSNode );¬∂			}¬∂		}¬∂		if (aMethodSNode != null) {¬∂			anExternalMethodSNode.setActualMethodSNode(aMethodSNode);¬∂			aMethodSNode.getCalls().addAll(anExternalMethodSNode.getLocalCalls());¬∂		}¬∂	}¬∂	¬∂	public static MethodSNode findMethodSNode (RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode, ExternalMethodSNode anExternalMethodSNode) {¬∂//		MethodSNode foundMethodSNode = null;¬∂		for (String aFileName:aRootOfProgramSNode.getFileNameToSNode().keySet()) {¬∂			if (aFileName.equals(aRootOfFileSNode.getFileName()))¬∂				continue;¬∂			¬∂			RootOfFileSNode aSearchedRootOfFileSNode = aRootOfProgramSNode.getFileNameToSNode().get(aFileName);¬∂			 for (SNode anSNode:aSearchedRootOfFileSNode.getChildren()) {¬∂				if (anSNode instanceof MethodSNode && !(anSNode instanceof ExternalMethodSNode)) {¬∂					if (anSNode.toString().equals(anExternalMethodSNode.toString())) {¬∂						return (MethodSNode) anSNode;¬∂						¬∂					}¬∂//					processExternalMethodSNode(aRootOfProgramSNode, aRootOfFileSNode, (ExternalMethodSNode) anSNode);¬∂				}¬∂			}¬∂		}¬∂		return null;¬∂	}¬∂	public static void processExternalMethodSNodes (RootOfProgramSNode aRootOfProgramSNode) {¬∂		for (String aFileName:aRootOfProgramSNode.getFileNameToSNode().keySet()) {¬∂			RootOfFileSNode aRootOfFileSNode = aRootOfProgramSNode.getFileNameToSNode().get(aFileName);¬∂			processExternalMethodSNodes(aRootOfProgramSNode, aRootOfFileSNode);¬∂			aRootOfFileSNode.getOmp_get_num_threads_SNode().¬∂				setActualMethodSNode(aRootOfProgramSNode.getOmp_get_num_threads_SNode());¬∂			aRootOfFileSNode.getOmp_get_thread_num_SNode().¬∂				setActualMethodSNode(aRootOfProgramSNode.getOmp_get_thread_num_SNode());¬∂			aRootOfFileSNode.getOmp_get_wtime_SNode().¬∂			setActualMethodSNode(aRootOfProgramSNode.getOmp_get_wtime_SNode());¬∂		}¬∂¬∂	}¬∂	public static void processIndirectAssignments (SNode anSNode) {¬∂		if (anSNode instanceof ConstDeclarationSNode) {¬∂			return;¬∂		}¬∂		if (anSNode instanceof DeclarationSNode) {¬∂			DeclarationSNode aDeclarationSNode = (DeclarationSNode) anSNode;¬∂			Set<AssignmentSNode> anIndirectAssignments = aDeclarationSNode.getAssignmentsEffectingDeclaredIdentifier();¬∂			if (anIndirectAssignments != null) {¬∂				return; // already assigned¬∂			}¬∂			anIndirectAssignments = new HashSet<>();¬∂			aDeclarationSNode.setAssignmentsEffectingDeclaredIdentifier(anIndirectAssignments);¬∂			Set<AssignmentSNode> aDirectAssignments = aDeclarationSNode.getAssignmentsToDeclaredVariable();¬∂			anIndirectAssignments.addAll(aDirectAssignments);¬∂			Set<AssignmentSNode> anAliasAssignments = assignmentsOfVariableAliases(aDeclarationSNode.getParent(), aDeclarationSNode.getVariableName());¬∂			anIndirectAssignments.addAll(anAliasAssignments);¬∂			for (AssignmentSNode aDirectAssignment:aDirectAssignments) {¬∂				List<String> aVariableIdentifiers = aDirectAssignment.getRhsVariableIdentifiers();¬∂				¬∂				for (String aVariableIdentifier:aVariableIdentifiers) {¬∂					DeclarationSNode aDependeeDeclarationSNode = getDeclarationOfVariableIdentifier(aDirectAssignment, aVariableIdentifier);¬∂					if (aDependeeDeclarationSNode == null) {¬∂						System.err.println("Could not find declaration of:" + aVariableIdentifier + " referenced in:" + aDirectAssignment );¬∂						continue;¬∂					}¬∂					processIndirectAssignments(aDependeeDeclarationSNode);¬∂					Set<AssignmentSNode> aDependeeIndirectAssignments = aDeclarationSNode.getAssignmentsEffectingDeclaredIdentifier();¬∂					anIndirectAssignments.addAll(aDependeeIndirectAssignments);¬∂					¬∂				}¬∂			}¬∂		} else {¬∂			for (SNode aChild: anSNode.getChildren()) {¬∂				processIndirectAssignments(aChild);¬∂			}¬∂		}¬∂		¬∂	}¬∂	¬∂//	public static void fillIndirectAssignments (SNode anSNode, Set<AssignmentSNode> retVal ) {¬∂//		¬∂//	}¬∂	¬∂¬∂//	public static void main(String[] args) {¬∂//		List<MethodCall> aTokens = callsIn("foo(bar, hgf)/foo2()*foo3(b, a c,)");¬∂//		System.out.println(aTokens);¬∂//		¬∂//		¬∂////		List<String> aTokens = identifiersIn("a[i] + b*2/3");¬∂////		System.out.println(aTokens);¬∂////		aTokens = numbersIn("a[i] + b*2/3");¬∂////		System.out.println(aTokens);¬∂////		aTokens = operatorsIn("a[i] + b*2/3");¬∂////		System.out.println(aTokens);¬∂////¬∂////		System.out.println(StringUtils.substringBetween("a", "[", "]"));¬∂//	}¬∂¬∂}¬∂")]]]></diff>
  </Command>
  <DocumentChange __id="217904" _type="Delete" date="Fri Jan 10 10:11:32 EST 2020" docASTNodeCount="5134" docActiveCodeLength="37675" docExpressionCount="3174" docLength="43794" endLine="885" length="6" offset="32453" startLine="885" starttimestamp="1576666505112" timestamp="2002586949">
    <text><![CDATA[AndIts]]></text>
  </DocumentChange>
  <Command __id="218084" _type="DiffBasedFileOpenCommand" date="Fri Jan 10 10:18:29 EST 2020" docASTNodeCount="428" docActiveCodeLength="2628" docExpressionCount="248" docLength="3166" projectName="GraderBasics" starttimestamp="1576666505112" timestamp="2003004085">
    <filePath><![CDATA[D:\dewan_backup\Java\GraderBasics\src\gradingTools\shared\testcases\openmp\scannedTree\AnSNode.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package gradingTools.shared.testcases.openmp.scannedTree;¬∂¬∂import java.util.ArrayList;¬∂import java.util.HashSet;¬∂import java.util.List;¬∂import java.util.Set;¬∂¬∂import gradingTools.shared.testcases.openmp.AnAssignment;¬∂import gradingTools.shared.testcases.openmp.Assignment;¬∂import gradingTools.shared.testcases.openmp.ForHeader;¬∂import gradingTools.shared.testcases.openmp.OpenMPPragma;¬∂import gradingTools.shared.testcases.openmp.OpenMPUtils;¬∂import gradingTools.shared.testcases.openmp.checks.OpenMPPragmaAttribute;¬∂¬∂public class AnSNode implements SNode {¬∂	protected List<DeclarationSNode> variableDeclarations = new ArrayList();//separate subclass for this variable?¬∂//	protected List<String> localVariables = new ArrayList();//separate subclass for this variable?¬∂	protected List<String> localVariables = new ArrayList();//separate subclass for this variable?¬∂	protected int lineNumber;¬∂	protected List<SNode> children = new ArrayList();¬∂	protected List<Assignment> assignments = new ArrayList();¬∂	protected List<ForSNode> forNodes = new ArrayList();¬∂	protected List<OMPSNode> ompSNodes = new ArrayList();¬∂	protected Set<OpenMPPragmaAttribute> attributes = new HashSet();¬∂	protected SNode parent;¬∂	boolean inParallel = false;¬∂	boolean inCritical = false;¬∂¬∂	int numberOfNestingFors;¬∂¬∂	public AnSNode(int lineNumber) {¬∂		super();¬∂		this.lineNumber = lineNumber;		¬∂	}¬∂	¬∂	@Override¬∂	public int getLineNumber() {¬∂		return lineNumber;¬∂	}¬∂	¬∂	@Override¬∂	public List<ForSNode> getForNodes() {¬∂		return forNodes;¬∂	}¬∂	//	@Override¬∂//	public void setAnnotatedText(List<String> nextNonEmptyString) {¬∂//		this.annotatedText = nextNonEmptyString;¬∂//	}¬∂	¬∂	@Override¬∂	public SNode getParent() {¬∂		return parent;¬∂	}¬∂	@Override¬∂	public void setParent(SNode parent) {¬∂		this.parent = parent;¬∂		parent.getChildren().add(this);¬∂		inParallel = OMPSNodeUtils.hasParallelAncestor(this);		¬∂		inCritical = OMPSNodeUtils.hasCriticalAncestor(this);	¬∂		numberOfNestingFors = OMPSNodeUtils.numberOfNestingFors(parent);¬∂¬∂¬∂	}¬∂	@Override¬∂	public List<SNode> getChildren() {¬∂		return children;¬∂	}¬∂	¬∂	¬∂	@Override¬∂	public List<Assignment> getAssignments() {¬∂		return assignments;¬∂	}¬∂	// are the two method below the same? Or is a local variable something that is declared and not shared?¬∂	@Override¬∂	public List<DeclarationSNode> getVariableDeclarations() {¬∂		return variableDeclarations;¬∂	}¬∂	@Override¬∂	public List<String> getLocalVariableIdentifiers() {¬∂		return localVariables;¬∂	}¬∂	@Override¬∂	public List<OMPSNode> getOmpSNodes() {¬∂		return ompSNodes;¬∂	}¬∂	¬∂	@Override¬∂	public void addChild(SNode aChild) {¬∂		this.getChildren().add(aChild);¬∂//		if (aChild instanceof DeclaringAssignmentSNode) {¬∂//			localVariables.add(((DeclaringAssignmentSNode) aChild).getLhsVariable());¬∂//		}¬∂	}¬∂	@Override¬∂	public Set<OpenMPPragmaAttribute> getAttributes() {¬∂		return attributes;¬∂	}¬∂	@Override¬∂	public boolean isInParallel() {¬∂		return inParallel;¬∂	}¬∂	@Override¬∂	public boolean isInCritical() {¬∂		return inCritical;¬∂	}¬∂	@Override¬∂	public boolean isLeaf() {¬∂		return getChildren().isEmpty();¬∂	}¬∂¬∂}¬∂")]]]></diff>
  </Command>
  <Command __id="218088" _type="DiffBasedFileOpenCommand" date="Fri Jan 10 10:18:30 EST 2020" docASTNodeCount="5134" docActiveCodeLength="37675" docExpressionCount="3174" docLength="43794" projectName="GraderBasics" starttimestamp="1576666505112" timestamp="2003005617">
    <filePath><![CDATA[D:\dewan_backup\Java\GraderBasics\src\gradingTools\shared\testcases\openmp\scannedTree\OMPSNodeUtils.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package gradingTools.shared.testcases.openmp.scannedTree;¬∂¬∂import java.util.ArrayList;¬∂import java.util.Arrays;¬∂import java.util.HashMap;¬∂import java.util.HashSet;¬∂import java.util.List;¬∂import java.util.Map;¬∂import java.util.Set;¬∂import java.util.Stack;¬∂import java.util.regex.Matcher;¬∂import java.util.regex.Pattern;¬∂¬∂import org.apache.commons.lang.StringUtils;¬∂¬∂import grader.basics.project.source.ABasicTextManager;¬∂import gradingTools.shared.testcases.openmp.OpenMPKeywordEnum;¬∂import gradingTools.shared.testcases.openmp.OpenMPParallelPragma;¬∂import gradingTools.shared.testcases.openmp.OpenMPUtils;¬∂import gradingTools.shared.testcases.openmp.scannedTree.ADeclarationSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.ADeclaringAssignmentSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.AForSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.ATextSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.AnAssignmentSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.AnOMPCriticalSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.AnOMPForSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.AnOMPParallelSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.AnOMPSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.AnSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.AssignmentSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.DeclarationSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.DeclaringAssignmentSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.ForSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.OMPForSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.OMPSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.SNode;¬∂¬∂public class OMPSNodeUtils extends OpenMPUtils {¬∂¬∂	public static RootOfFileSNode getSNode(String aFileName, StringBuffer aFileBuffer) {¬∂		String[] aFileLines = aFileBuffer.toString().split("\n");¬∂		return getSNode(aFileName, aFileLines);¬∂	}¬∂¬∂	public static AssignmentSNode getAssignmentSNode(int aLineNumber, String aString) {¬∂		if (aString == null) {¬∂			return null;¬∂		}¬∂		String[] aTokens = aString.split("=");¬∂		if (aTokens.length == 1) {¬∂			return new AnAssignmentSNode(aLineNumber, aTokens[0], null);¬∂		} else {¬∂		return new AnAssignmentSNode(aLineNumber, aTokens[0], aTokens[1]);¬∂		}¬∂	}¬∂¬∂	public static DeclarationSNode getDeclarationSNode(int aLineNumber, String aString) {¬∂		String[] aTokens = aString.split(" ");¬∂		return new ADeclarationSNode(aLineNumber, aTokens[0], aTokens[1]);¬∂	}¬∂¬∂	public static DeclaringAssignmentSNode getDeclaringAssignmentSNode(int aLineNumber, String aString) {¬∂		String[] anLHSAndRHS = aString.split("=");¬∂		String[] aTypeAndVariable = anLHSAndRHS[0].split(" ");¬∂		return new ADeclaringAssignmentSNode(aLineNumber, aTypeAndVariable[0], aTypeAndVariable[1], anLHSAndRHS[1]);¬∂	}¬∂	public static ConstDeclarationSNode getConstDeclarationSNode(int aLineNumber, String aString) {¬∂		String anAssignmentString = aString.substring(CONST.length()).trim();¬∂		String[] anLHSAndRHS = anAssignmentString.split("=");¬∂		String[] aTypeAndVariable = anLHSAndRHS[0].split(" ");¬∂		return new AConstDeclarationSNode(aLineNumber, aTypeAndVariable[0], aTypeAndVariable[1], anLHSAndRHS[1]);¬∂	}¬∂¬∂	public static boolean isDeclaringAssignment(String aFileLine) {¬∂		return startsWithTypeName(aFileLine) && aFileLine.contains("=");¬∂	}¬∂	public static boolean isConstDeclaration(String aFileLine) {¬∂		return aFileLine.startsWith(CONST);¬∂	}¬∂	public static boolean isMethodDeclaration(String aFileLine) {¬∂		return startsWithTypeName(aFileLine) && ¬∂				aFileLine.contains("(") &&¬∂				!aFileLine.contains("=");¬∂	}¬∂	public static boolean isExternalMethodDeclaration(String aFileLine) {¬∂		return isMethodDeclaration(aFileLine) && aFileLine.endsWith(";");¬∂	}¬∂¬∂¬∂	public static boolean isVariableDeclaration(String aFileLine) {¬∂¬∂		return startsWithTypeName(aFileLine) && !aFileLine.contains("(");¬∂	}¬∂¬∂	public static boolean isAssignment(String aFileLine) {¬∂		return aFileLine.contains("=") && !aFileLine.contains("==");¬∂	}¬∂¬∂	public static boolean isForNode(String aFileLine) {¬∂		return aFileLine.startsWith("for");¬∂	}¬∂¬∂	public static ForSNode getForSNode(int aLineNumber, String aFileLine) {¬∂¬∂		int aLeftParenIndex = aFileLine.indexOf("(");¬∂		int aRightParenIndex = aFileLine.indexOf(")");¬∂		if (aLeftParenIndex < 0 || aRightParenIndex < 0) {¬∂			return null;¬∂		}¬∂		String aHeaderString = aFileLine.substring(aLeftParenIndex + 1, aRightParenIndex);¬∂		String[] aForComponents = aHeaderString.split(";");¬∂		AssignmentSNode anAssignmentSNode = null;¬∂		String aForInitializaton = aForComponents[0];¬∂		if (!aForInitializaton.isEmpty() && aForInitializaton.contains("=")) {¬∂			if (isDeclaringAssignment(aForInitializaton)) {¬∂				anAssignmentSNode = getDeclaringAssignmentSNode(aLineNumber, aForInitializaton);¬∂			} else {¬∂				anAssignmentSNode = getAssignmentSNode(aLineNumber, aForInitializaton);¬∂			}¬∂¬∂		}		¬∂		return new AForSNode(aLineNumber, anAssignmentSNode, aForComponents[1], getAssignmentSNode(aLineNumber, aForComponents[2]));¬∂	}¬∂	static String[] emptyArray = {};¬∂	public static MethodSNode getMethodSNode(int aLineNumber, String aFileLine, boolean isInternal) {¬∂¬∂		int aLeftParenIndex = aFileLine.indexOf("(");¬∂		int aRightParenIndex = aFileLine.indexOf(")");¬∂		if (aLeftParenIndex < 0 || aRightParenIndex < 0) {¬∂			return null;¬∂		}¬∂		String aMethodNameAndType = aFileLine.substring(0, aLeftParenIndex);¬∂		String[] aMethodNameAndTypeTokens = aMethodNameAndType.split("\\s+"); ¬∂		¬∂		String aMethodParameters = aFileLine.substring(aLeftParenIndex +1 , aRightParenIndex);¬∂		String[] aMethodParameterTokens = aMethodParameters.isEmpty()?emptyArray:¬∂		 aMethodParameters.split(",");¬∂		¬∂//		String[] aMethodParameterTypes = new String[aMethodParameterTokens.length];¬∂//		String[] aMethodParameterNames = new String[aMethodParameterTokens.length];¬∂		List<DeclarationSNode> aDeclarationSNodeList = new ArrayList();¬∂		for (int i = 0; i < aMethodParameterTokens.length; i++ ) {¬∂			String[] aTypeAndName = aMethodParameterTokens[i].trim().split("\\s+");¬∂			if (aTypeAndName.length < 2) {¬∂				continue;¬∂			}¬∂			aDeclarationSNodeList.add(new ADeclarationSNode(aLineNumber, aTypeAndName[0].trim(), aTypeAndName[1].trim()));¬∂//			aMethodParameterTypes[i] = aTypeAndName[0].trim();¬∂//			aMethodParameterNames[i] = aTypeAndName[1].trim();¬∂		}¬∂		if (isInternal)¬∂//		return new AMethodSNode(aLineNumber, aMethodNameAndTypeTokens[0], aMethodNameAndTypeTokens[1], aMethodParameterTypes,aMethodParameterNames );¬∂			return new AMethodSNode(aLineNumber, aMethodNameAndTypeTokens[0], aMethodNameAndTypeTokens[1], aDeclarationSNodeList );¬∂		else¬∂			return new AnExternalMethodSNode(aLineNumber, aMethodNameAndTypeTokens[0], aMethodNameAndTypeTokens[1], aDeclarationSNodeList );¬∂	}¬∂¬∂	public static void setReductionData(OMPForSNode lastChild, String aStoredToken, int aLeftParenIndex,¬∂			int aRightParenIndex) {¬∂		int aColonIndex = aStoredToken.indexOf(":");¬∂		if (aLeftParenIndex != -1 && aRightParenIndex != -1 && aColonIndex != -1) {¬∂			String anOperationString = aStoredToken.substring(aLeftParenIndex + 1, aColonIndex).trim();¬∂			String aVariableString = aStoredToken.substring(aColonIndex + 1, aRightParenIndex).trim();¬∂			((OMPForSNode) lastChild).setReductionVariable(aVariableString);¬∂			((OMPForSNode) lastChild).setReductionOperation(anOperationString);¬∂		}¬∂	}¬∂¬∂	public static void setSharedOrPrivateData(OMPSNode lastChild, String aStoredToken, int aLeftParenIndex,¬∂			int aRightParenIndex, boolean isShared) {¬∂//		int aColonIndex = aStoredToken.indexOf(":");¬∂		if (aLeftParenIndex != -1 && aRightParenIndex != -1) {¬∂			String aVariableDeclarations = aStoredToken.substring(aLeftParenIndex + 1, aRightParenIndex);¬∂			String[] aVariables = aVariableDeclarations.split(",");¬∂			if (isShared) {¬∂				lastChild.setSharedVariables(aVariables);¬∂			} else {¬∂				lastChild.setPrivateVariables(aVariables);¬∂			}¬∂		}¬∂	}¬∂¬∂	public static RootOfFileSNode getSNode(String aFileName, String[] aFileLines) {¬∂		Stack<SNode> anSNodes = new Stack();¬∂¬∂		RootOfFileSNode retVal = new ARootOfFileSNode(aFileName);¬∂		anSNodes.add(retVal);¬∂		SNode previousHeaderNode = null;¬∂		for (int i = 0; i < aFileLines.length; i++) {¬∂			String aFileLine = aFileLines[i].trim();¬∂			if (!isCodeLine(aFileLine)) {¬∂				continue;¬∂			}¬∂			if (isForNode(aFileLine)) {¬∂				ForSNode aForSNode = getForSNode(i, aFileLine);¬∂				SNode aParent = previousHeaderNode != null?previousHeaderNode:anSNodes.peek();¬∂				aForSNode.setParent(anSNodes.peek());¬∂				aForSNode.setParent(aParent);¬∂¬∂//				anSNodes.push(aForSNode);¬∂				previousHeaderNode = aForSNode;¬∂				if (aFileLine.endsWith(")")) {¬∂					continue;¬∂				}¬∂			}¬∂			if (isExternalMethodDeclaration(aFileLine)) {¬∂				MethodSNode aMethodSNode = getMethodSNode(i, aFileLine, false);¬∂				aMethodSNode.setParent(anSNodes.peek());¬∂//				anSNodes.push(aForSNode);¬∂				previousHeaderNode = aMethodSNode;¬∂				if (aFileLine.endsWith(")")) {¬∂					continue;¬∂				}¬∂			}¬∂			if (isMethodDeclaration(aFileLine)) {¬∂				MethodSNode aMethodSNode = getMethodSNode(i, aFileLine, true);¬∂				aMethodSNode.setParent(anSNodes.peek());¬∂//				anSNodes.push(aForSNode);¬∂				previousHeaderNode = aMethodSNode;¬∂				if (aFileLine.endsWith(")")) {¬∂					continue;¬∂				}¬∂			}¬∂			if (isPragmaStart(aFileLine)) {¬∂				OMPSNode anOMPSNode = getOMPSNode(i, anSNodes.peek(), aFileLine);¬∂//				anSNodes.push(anOMPSNode);¬∂				previousHeaderNode = anOMPSNode;¬∂				continue;¬∂			}¬∂			if (isBlockStart(aFileLine)) {¬∂				SNode aBlockSNode = new ABlockSNode(i);¬∂				if (previousHeaderNode != null) {¬∂					aBlockSNode.setParent(previousHeaderNode);¬∂				} else {¬∂					aBlockSNode.setParent(anSNodes.peek());¬∂				}¬∂				anSNodes.push(aBlockSNode);¬∂				previousHeaderNode = null;¬∂				continue;¬∂			}¬∂//			} else ¬∂			if (isBlockEnd(aFileLine)) {¬∂				anSNodes.pop();¬∂				continue;¬∂			}¬∂			SNode aNewLeafNode = null;¬∂			if (isConstDeclaration(aFileLine)) {¬∂				aNewLeafNode = getConstDeclarationSNode(i, aFileLine);¬∂¬∂			} else if (isDeclaringAssignment(aFileLine)) {¬∂				aNewLeafNode = getDeclaringAssignmentSNode(i, aFileLine);¬∂¬∂			} else if (isAssignment(aFileLine)) {¬∂				aNewLeafNode = getAssignmentSNode(i, aFileLine);¬∂			} else if (isVariableDeclaration(aFileLine)) {¬∂				aNewLeafNode = getDeclarationSNode(i, aFileLine);¬∂			} else {¬∂				List<MethodCall> aCalls = callsIn(i, aFileLine, null); // parent will be assigned below¬∂				if (aCalls != null && aCalls.size() == 1) {¬∂					aNewLeafNode = aCalls.get(0);¬∂				} else {¬∂					aNewLeafNode = new ATextSNode(i, aFileLine);¬∂				}¬∂			}¬∂//			else {¬∂//				aNewLeafNode = new ATextSNode(i, aFileLine);¬∂//			}¬∂			if (previousHeaderNode != null) {¬∂				aNewLeafNode.setParent(previousHeaderNode);¬∂			} else {¬∂				aNewLeafNode.setParent(anSNodes.peek());¬∂			}¬∂¬∂		}¬∂¬∂		return retVal;¬∂	}¬∂¬∂	public static OMPSNode getOMPSNode(int aLineIndex, SNode aParentNode, String aFileLine) {¬∂		String[] aTokens = aFileLine.split("\\s+");¬∂		if (aTokens.length <= 2) {¬∂			return null;¬∂		}¬∂		if (!aTokens[1].equals("omp")) {¬∂			return null;¬∂		}¬∂		if (aTokens.length < 3) {¬∂			return null;¬∂		}¬∂		String aFirstToken = aTokens[2];¬∂		OpenMPKeywordEnum anOpenMPKeyword = stringToOpenMPKeyword.get(aFirstToken);¬∂//		List<OpenMPPragma> retVal = new ArrayList();¬∂		OMPSNode lastChild = null;¬∂		int aStartIndex = 2;¬∂		OMPSNode aNewNode = null;¬∂		OMPForSNode aForChild = null;¬∂		switch (anOpenMPKeyword) {¬∂		case PARALLEL:¬∂			aNewNode = new AnOMPParallelSNode(aLineIndex);¬∂¬∂			if (aTokens.length > 3 && aTokens[3].equals("for")) {¬∂				aForChild = new AnOMPForSNode(aLineIndex);¬∂				aForChild.setParent(aNewNode);¬∂¬∂				aStartIndex++;¬∂			}¬∂			break;¬∂		case FOR:¬∂			aNewNode = new AnOMPForSNode(aLineIndex);¬∂			;¬∂			break;¬∂		case CRITICAL:¬∂			aNewNode = new AnOMPCriticalSNode(aLineIndex);¬∂//			retVal.add (lastChild);¬∂			break;¬∂		default:¬∂			aNewNode = new AnOMPSNode(aLineIndex);¬∂¬∂		}¬∂¬∂		if (lastChild != null) {¬∂			aNewNode.setParent(lastChild);¬∂		} else {¬∂			aNewNode.setParent(aParentNode);¬∂		}¬∂		lastChild = aForChild == null ? aNewNode : aForChild;¬∂¬∂		for (int i = aStartIndex; i < aTokens.length; i++) {¬∂			String aStoredToken = aTokens[i].trim();¬∂			if (aStoredToken.isEmpty()) {¬∂				continue;¬∂			}¬∂			if (aStoredToken.startsWith("reduction") || aStoredToken.startsWith("shared")¬∂					|| aStoredToken.startsWith("private")) {¬∂				// combine all tokens until ")" into one for normalization¬∂				while (!aStoredToken.endsWith(")")) {¬∂					i++;¬∂					if (i >= aTokens.length) {¬∂						break;¬∂					}¬∂					String aNewToken = aTokens[i].trim();¬∂					aStoredToken += aNewToken;¬∂				}¬∂				int aLeftParenIndex = aStoredToken.indexOf("(");¬∂				int aRightParenIndex = aStoredToken.indexOf(")");¬∂				if (aStoredToken.startsWith("reduction")) {¬∂					setReductionData((OMPForSNode) lastChild, aStoredToken, aLeftParenIndex, aRightParenIndex);¬∂				} else if (aStoredToken.startsWith("private")) {¬∂					setSharedOrPrivateData((OMPSNode) lastChild, aStoredToken, aLeftParenIndex, aRightParenIndex,¬∂							false);¬∂¬∂				} else if (aStoredToken.startsWith("shared")) {¬∂					setSharedOrPrivateData(lastChild, aStoredToken, aLeftParenIndex, aRightParenIndex, true);¬∂¬∂				}¬∂¬∂			}¬∂¬∂			lastChild.getOpenMPTokens().add(aStoredToken);¬∂		}¬∂¬∂		return lastChild;¬∂¬∂	}¬∂¬∂	public static boolean hasParallelAncestor(SNode anSNode) {¬∂		if (anSNode == null) {¬∂			return false;¬∂		}¬∂		if (anSNode instanceof OMPParallelSNode) {¬∂			return true;¬∂		}¬∂		return hasParallelAncestor(anSNode.getParent());¬∂	}¬∂	public static boolean hasCriticalAncestor(SNode anSNode) {¬∂		if (anSNode == null) {¬∂			return false;¬∂		}¬∂		if (anSNode instanceof OMPCriticalSNode) {¬∂			return true;¬∂		}¬∂		return hasCriticalAncestor(anSNode.getParent());¬∂	}¬∂¬∂¬∂	public static Boolean isDeclaredShared(OMPSNode anOMPSNode, String anLHS) {¬∂		if (Arrays.asList(anOMPSNode.getSharedVariables()).contains(anLHS)) {¬∂			return true;¬∂		}¬∂		if (Arrays.asList(anOMPSNode.getPrivateVariables()).contains(anLHS)) {¬∂			return false;¬∂		}¬∂		return null;¬∂¬∂	}¬∂¬∂	public static boolean isSharedVariable(SNode anSNode, String anLHS) {¬∂		if (anSNode == null) {¬∂			return false;¬∂		}¬∂		if (anSNode.getLocalVariableIdentifiers().contains(anLHS)) {¬∂			if (!(anSNode instanceof OMPSNode)) { // no shared and private declarations¬∂				return !hasParallelAncestor(anSNode); // shared if not inParallel¬∂			}¬∂			OMPSNode anOMPSNode = (OMPSNode) anSNode;¬∂			return (Arrays.asList(anOMPSNode.getSharedVariables()).contains(anLHS)); // private unless declared shared¬∂		}¬∂		if (anSNode instanceof OMPSNode) {¬∂			OMPSNode anOMPSNode = (OMPSNode) anSNode;¬∂			// the variable is global to this scope, check if it has have been made shared¬∂			// or private by this scope¬∂			Boolean isDeclaredShared = isDeclaredShared(anOMPSNode, anLHS);¬∂			if (isDeclaredShared != null) {¬∂				return isDeclaredShared;¬∂			}¬∂		}¬∂		// check the parent¬∂		return isSharedVariable(anSNode.getParent(), anLHS);¬∂	}¬∂¬∂	public static List<SNode> getAllLeafNodes(SNode aTopNode) {¬∂		List<SNode> retVal = new ArrayList();¬∂		addLeafNodes(aTopNode, retVal);¬∂		return retVal;¬∂	}¬∂¬∂	public static void addLeafNodes(SNode aTopNode, List<SNode> retVal) {¬∂		for (SNode aChild : aTopNode.getChildren()) {¬∂			if (aChild.isLeaf()) {¬∂				retVal.add(aChild);¬∂			} else {¬∂				addLeafNodes(aChild, retVal);¬∂			}¬∂		}¬∂	}¬∂¬∂	public static List<SNode> getNonParallelLeafNodes(SNode aTopNode) {¬∂		List<SNode> retVal = new ArrayList();¬∂		addNonParallelLeafNodes(aTopNode, retVal);¬∂		return retVal;¬∂	}¬∂¬∂	public static void addNonParallelLeafNodes(SNode aTopNode, List<SNode> retVal) {¬∂		if (aTopNode.isInParallel()) {¬∂			return;¬∂		}¬∂		for (SNode aChild : aTopNode.getChildren()) {¬∂			if (aChild.isLeaf()) {¬∂				retVal.add(aChild);¬∂			} else {¬∂				addLeafNodes(aChild, retVal);¬∂			}¬∂		}¬∂	}¬∂	static String callRegex = "([a-zA-Z_$][a-zA-Z_$0-9]*)\\(.*?\\)";¬∂	static Pattern callPattern = Pattern.compile(callRegex);¬∂¬∂	static String identifierRegex = "[a-zA-Z_$][a-zA-Z_$0-9]*";¬∂	static Pattern identifierPattern = Pattern.compile(identifierRegex);¬∂	public static List<String> identifiersIn(String aString) {¬∂		if (aString == null)¬∂			return null;¬∂//		Pattern mypattern = Pattern.compile("[a-zA-Z_$][a-zA-Z_$0-9]*");¬∂//		Matcher mymatcher = mypattern.matcher(aString);¬∂		Matcher mymatcher = identifierPattern.matcher(aString);¬∂		List<String> retVal = new ArrayList();¬∂		while (mymatcher.find()) {¬∂			String find = mymatcher.group(0);¬∂			retVal.add(find);¬∂		}¬∂		return retVal;¬∂	}¬∂	public static List<MethodCall> callsIn(int aLineNumber, String aString, SNode aParent) {¬∂		if (aString == null)¬∂			return emptyList;¬∂		if (isMethodDeclaration(aString)) {¬∂			return emptyList;¬∂		}¬∂//		Pattern mypattern = Pattern.compile("[a-zA-Z_$][a-zA-Z_$0-9]*");¬∂//		Matcher mymatcher = mypattern.matcher(aString);¬∂		Matcher mymatcher = callPattern.matcher(aString);¬∂		List<MethodCall> retVal = new ArrayList();¬∂		while (mymatcher.find()) {¬∂			String find = mymatcher.group(0);¬∂			int aLeftParenIndex = find.indexOf("(");¬∂			int aRightParenIndex = find.indexOf(")");¬∂			String aMethodName = find.substring(0, aLeftParenIndex).trim();¬∂			String aParameters = find.substring(aLeftParenIndex + 1, aRightParenIndex);¬∂			List<String> aParameterList = new ArrayList();¬∂			String[] aParameterTokens = aParameters.split(",");¬∂			for (String aParameter:aParameterTokens) {¬∂				String aParameterTrimmed = aParameter.trim();¬∂				if (!aParameterTrimmed.isEmpty())¬∂				aParameterList.add(aParameterTrimmed);¬∂			}¬∂			retVal.add(new AMethodCall(aLineNumber, aMethodName, aParameterList, aParent));¬∂¬∂//			aCallStrings.add(find);¬∂		}¬∂		return retVal;¬∂	}¬∂	static String numberRegex = "(\\d+\\.\\d+)|(\\d+)";¬∂	static Pattern numberPattern = Pattern.compile(numberRegex);¬∂	public static List<String> numbersIn(String aString) {¬∂		if (aString == null)¬∂			return null;¬∂//		String regex = "(\\d+\\.\\d+)|(\\d+)";¬∂//¬∂//		Matcher m = Pattern.compile(regex).matcher(aString);¬∂		Matcher m =numberPattern.matcher(aString);¬∂¬∂¬∂		List<String> retVal = new ArrayList();¬∂¬∂		while (m.find()) {¬∂			retVal.add(m.group());¬∂		}¬∂		return retVal;¬∂	}¬∂¬∂	public static String subscriptIn(String aString) {¬∂		if (aString == null)¬∂			return null;¬∂		return StringUtils.substringBetween(aString, "[", "]");¬∂	}¬∂	static String[] emptyStringArray = {};¬∂	static List emptyList = new ArrayList();¬∂¬∂	public static String[] subscriptsIn(String aString) {¬∂		if (aString == null)¬∂			return emptyStringArray;¬∂		return StringUtils.substringsBetween(aString, "[", "]");¬∂	}¬∂	static  String operatorRegex = "([+-/*///^])|([/(/)])";¬∂	static Pattern operatorPattern = Pattern.compile(operatorRegex);¬∂¬∂	public static List<String> operatorsIn(String aString) {¬∂		if (aString == null)¬∂			return null;¬∂//		String operatorRegex = "([+-/*///^])|([/(/)])";¬∂//¬∂//		Matcher m = Pattern.compile(operatorRegex).matcher(aString);¬∂		¬∂		Matcher m = operatorPattern.matcher(aString);¬∂¬∂¬∂		List<String> retVal = new ArrayList();¬∂¬∂		while (m.find()) {¬∂			retVal.add(m.group());¬∂		}¬∂		return retVal;¬∂	}¬∂	¬∂	public static int numberOfNestingFors (SNode anSNode) {¬∂		if (anSNode == null) {¬∂			return 0;¬∂		}¬∂		int retVal = numberOfNestingFors (anSNode.getParent()) ;¬∂¬∂		if (anSNode instanceof ForSNode) {¬∂			retVal++;¬∂		} else if (anSNode instanceof MethodSNode) {¬∂			List<MethodCall> aMethodCalls = ((MethodSNode) anSNode).getCalls();¬∂			int aMaxNestingLevel = 0;¬∂			for (MethodCall aMethodCall:aMethodCalls) {¬∂				MethodSNode aCallerMethodSNode = getDeclarationOfCalledMethod(anSNode, aMethodCall);¬∂				int aCallerNumberOfNestingFors = numberOfNestingFors(aCallerMethodSNode);¬∂				aMaxNestingLevel = Math.max(aCallerNumberOfNestingFors, aMaxNestingLevel);				¬∂			}¬∂			return retVal + aMaxNestingLevel;¬∂		}¬∂		return retVal;¬∂	}¬∂	public static boolean hasOperator (SNode anSNode, String anOperator) {¬∂		boolean retVal = false;¬∂		if (anSNode instanceof AssignmentSNode) {¬∂			AssignmentSNode anAssignmentSNode = (AssignmentSNode) anSNode;¬∂			 retVal = (anAssignmentSNode.getLhsOperators().contains(anOperator) || ¬∂					anAssignmentSNode.getRhsOperators().contains(anOperator)) ;¬∂			if (retVal) {¬∂				return retVal;¬∂			} else {¬∂				List<MethodCall> aMethodCalls = anAssignmentSNode.getRhsCalls();¬∂				for (MethodCall aMethodCall:aMethodCalls) {¬∂					MethodSNode aMethodSNode = getDeclarationOfCalledMethod(anSNode, aMethodCall);¬∂					retVal = hasOperator(aMethodSNode, anOperator);¬∂					if (retVal) {¬∂						return retVal;¬∂					}¬∂					¬∂				}¬∂				return false;¬∂			}¬∂			¬∂		}¬∂		for (SNode aChild:anSNode.getChildren()) {¬∂			retVal = hasOperator(aChild, anOperator);¬∂			if (retVal) {¬∂				return retVal;¬∂			}¬∂		}¬∂		return false;¬∂	}¬∂	public static boolean hasMethodCall (SNode anSNode, String anOperator) {¬∂		boolean retVal = false;¬∂		if (anSNode instanceof AssignmentSNode) {¬∂			AssignmentSNode anAssignmentSNode = (AssignmentSNode) anSNode;¬∂			 retVal = (anAssignmentSNode.getLhsOperators().contains(anOperator) || ¬∂					anAssignmentSNode.getRhsOperators().contains(anOperator)) ;¬∂			if (retVal) {¬∂				return retVal;¬∂			} else {¬∂				List<MethodCall> aMethodCalls = anAssignmentSNode.getRhsCalls();¬∂				for (MethodCall aMethodCall:aMethodCalls) {¬∂					MethodSNode aMethodSNode = getDeclarationOfCalledMethod(anSNode, aMethodCall);¬∂					retVal = hasOperator(aMethodSNode, anOperator);¬∂					if (retVal) {¬∂						return retVal;¬∂					}¬∂					¬∂				}¬∂				return false;¬∂			}¬∂			¬∂		}¬∂		for (SNode aChild:anSNode.getChildren()) {¬∂			retVal = hasOperator(aChild, anOperator);¬∂			if (retVal) {¬∂				return retVal;¬∂			}¬∂		}¬∂		return false;¬∂	}¬∂	public static boolean dependsOn (AssignmentSNode anAssignmentSNode, String aVariable, String aCallIdentifier) {¬∂		// This assignment does not change aVariable¬∂		if (!aVariable.equals(anAssignmentSNode.getLhsFirstIdentifier())) {¬∂			return false;¬∂		}¬∂		return dependsOn(anAssignmentSNode.getExpressionSNode(), aCallIdentifier);¬∂//		List<String> aCallIdentifiers = anAssignmentSNode.getRhsCallIdentifiers();¬∂//		boolean retVal = false;¬∂//		if (aCallIdentifiers != null && aCallIdentifiers.contains(aCallIdentifier)) {¬∂//			return true; // this assignment has aCallIdentifier in the rhs¬∂//		}¬∂//		// check if some referenced rhs variable depends on aCallIdentifier¬∂//		List<String> aReferencedVariableIdentifiers = anAssignmentSNode.getRhsVariableIdentifiers();¬∂//		SNode anAssignmentParent = anAssignmentSNode.getParent();¬∂//		if (anAssignmentParent == null) { // should never be trye¬∂//			return false;¬∂//		}¬∂//		int aLineNumber = anAssignmentSNode.getLineNumber();¬∂//		for (String aReferencedVariableIdentifier:aReferencedVariableIdentifiers ) {¬∂//			if (dependsOn (anAssignmentParent, aLineNumber, aReferencedVariableIdentifier, aCallIdentifier)) {¬∂//				return true;¬∂//			}¬∂//		}¬∂//		return false;¬∂	}¬∂	public static boolean dependsOn (ExpressionSNode anExpressionSNode, String aCallIdentifier) {¬∂		// This assignment does not change aVariable¬∂		¬∂		List<String> aCallIdentifiers = anExpressionSNode.getRhsCallIdentifiers();¬∂		boolean retVal = false;¬∂		if (aCallIdentifiers != null && aCallIdentifiers.contains(aCallIdentifier)) {¬∂			return true; // this assignment has aCallIdentifier in the rhs¬∂		}¬∂		// check if some referenced rhs variable depends on aCallIdentifier¬∂		List<String> aReferencedVariableIdentifiers = anExpressionSNode.getRhsVariableIdentifiers();¬∂		SNode anAssignmentParent = anExpressionSNode.getParent().getParent();¬∂		if (anAssignmentParent == null) { // should never be trye¬∂			return false;¬∂		}¬∂		int aLineNumber = anExpressionSNode.getLineNumber();¬∂		for (String aReferencedVariableIdentifier:aReferencedVariableIdentifiers ) {¬∂			if (dependsOn (anAssignmentParent, aLineNumber, aReferencedVariableIdentifier, aCallIdentifier)) {¬∂				return true;¬∂			}¬∂		}¬∂		return false;¬∂	}¬∂	public static Set<AssignmentSNode> assignmentsToSharedVariables(SNode anSNode) {¬∂		Set<AssignmentSNode> retVal =  new HashSet();¬∂		fillAssignmentsToShared(anSNode, retVal);¬∂		return retVal;¬∂		¬∂	}¬∂	public static Set<AssignmentSNode> assignmentsToSharedArrays(SNode anSNode) {¬∂		Set<AssignmentSNode> anAllSharedAssignments =  assignmentsToSharedVariables(anSNode);¬∂		Set<AssignmentSNode> aRetVal = new HashSet();¬∂		for (AssignmentSNode anAssignmentSNode:anAllSharedAssignments) {¬∂			if (anAssignmentSNode.getLhsSubscripts().length > 0) {¬∂				aRetVal.add(anAssignmentSNode);¬∂			}¬∂		}¬∂		return aRetVal;¬∂		¬∂	}¬∂	public static Set<AssignmentSNode> assignmentsToParallelCriticalSharedVariables(SNode anSNode) {¬∂		Set<AssignmentSNode> anAllSharedAssignments =  assignmentsToSharedVariables(anSNode);¬∂		Set<AssignmentSNode> aRetVal = new HashSet();¬∂		for (AssignmentSNode anAssignmentSNode:anAllSharedAssignments) {¬∂			if (anAssignmentSNode.isInParallel() &&¬∂					anAssignmentSNode.isInCritical()) {¬∂				aRetVal.add(anAssignmentSNode);¬∂			}¬∂		}¬∂		return aRetVal;¬∂		¬∂	}¬∂	public static Set<AssignmentSNode> assignmentsToNonParallelCriticalSharedVariables(SNode anSNode) {¬∂		Set<AssignmentSNode> anAllSharedAssignments =  assignmentsToSharedVariables(anSNode);¬∂		Set<AssignmentSNode> aRetVal = new HashSet();¬∂		for (AssignmentSNode anAssignmentSNode:anAllSharedAssignments) {¬∂			if (!anAssignmentSNode.isInParallel() &&¬∂					anAssignmentSNode.isInCritical()) {¬∂				aRetVal.add(anAssignmentSNode);¬∂			}¬∂		}¬∂		return aRetVal;¬∂		¬∂	}¬∂	public static Set<AssignmentSNode> assignmentsToParallelNonCriticalSharedVariables(SNode anSNode) {¬∂		Set<AssignmentSNode> anAllSharedAssignments =  assignmentsToSharedVariables(anSNode);¬∂		Set<AssignmentSNode> aRetVal = new HashSet();¬∂		for (AssignmentSNode anAssignmentSNode:anAllSharedAssignments) {¬∂			if (anAssignmentSNode.isInParallel() &&¬∂					!anAssignmentSNode.isInCritical()) {¬∂				aRetVal.add(anAssignmentSNode);¬∂			}¬∂		}¬∂		return aRetVal;¬∂		¬∂	}¬∂    public static void fillAssignmentsToShared(SNode anSNode, Set<AssignmentSNode> retVal) {¬∂    	if (anSNode instanceof AssignmentSNode) {¬∂			AssignmentSNode anAssignmentSNode = (AssignmentSNode) anSNode;¬∂			String anLHS = anAssignmentSNode.getLhsFirstIdentifier();¬∂			if (isSharedVariable(anSNode, anLHS)) {¬∂				retVal.add(anAssignmentSNode);¬∂				return;¬∂			}¬∂		}¬∂    	for (SNode aChild:anSNode.getChildren()) {¬∂    		fillAssignmentsToShared(aChild, retVal);¬∂    	}¬∂		¬∂	}¬∂    public static void fillInstancesOfNodeType(Class<? extends SNode> aNodeType, SNode anSNode, Set<SNode> retVal) {¬∂    	if (aNodeType.isAssignableFrom(anSNode.getClass())) {¬∂			¬∂				retVal.add(anSNode);¬∂				return;¬∂			}¬∂		¬∂    	for (SNode aChild:anSNode.getChildren()) {¬∂    		fillInstancesOfNodeType(aNodeType, aChild, retVal);¬∂    	}¬∂		¬∂	}¬∂    public static Set<AssignmentSNode>  assignmentSNodes(SNode anSNode) {¬∂    	Set retVal = new HashSet();    	¬∂    	fillInstancesOfNodeType(AssignmentSNode.class, anSNode, retVal );¬∂    	return retVal;¬∂	}¬∂   ¬∂    ¬∂    public static Set<OMPParallelSNode>  ompParallelSNodes(SNode anSNode) {¬∂    	Set retVal = new HashSet();    	¬∂    	fillInstancesOfNodeType(OMPParallelSNode.class, anSNode, retVal );¬∂    	return retVal;¬∂	}¬∂//    public static void fillOMPParallelSNodes(SNode anSNode, Set<OMPParallelSNode> retVal) {¬∂//    	if (anSNode instanceof OMPParallelSNode) {¬∂//    		retVal.add((OMPParallelSNode) anSNode);¬∂//		}¬∂//    	for (SNode aChild:anSNode.getChildren()) {¬∂//    		fillOMPParallelSNodes(aChild, retVal);¬∂//    	}		¬∂//	}¬∂    public static Set<ForSNode>  forSNodes(SNode anSNode) {¬∂    	Set retVal = new HashSet();    	¬∂    	fillInstancesOfNodeType(ForSNode.class, anSNode, retVal );¬∂    	return retVal;¬∂	}¬∂//    public static void fillForSNodes(SNode anSNode, Set<ForSNode> retVal) {¬∂//    	if (anSNode instanceof ForSNode) {¬∂//    		retVal.add((ForSNode) anSNode);¬∂//		}¬∂//    	for (SNode aChild:anSNode.getChildren()) {¬∂//    		fillForSNodes(aChild, retVal);¬∂//    	}		¬∂//	}¬∂    public static Set<OMPForSNode>  ompForSNodes(SNode anSNode) {¬∂    	Set retVal = new HashSet();    	¬∂    	fillInstancesOfNodeType(OMPForSNode.class, anSNode, retVal );¬∂    	return retVal;¬∂	}¬∂//    public static void fillOMPForSNodes(SNode anSNode, Set<OMPForSNode> retVal) {¬∂//    	if (anSNode instanceof OMPForSNode) {¬∂//    		retVal.add((OMPForSNode) anSNode);¬∂//		}¬∂//    	for (SNode aChild:anSNode.getChildren()) {¬∂//    		fillOMPForSNodes(aChild, retVal);¬∂//    	}		¬∂//	}¬∂    public static Set<OMPForSNode> ompReducingForNodes(SNode anSNode) {¬∂		Set<OMPForSNode> anAllOMPForSNodes =  ompForSNodes(anSNode);¬∂		Set<OMPForSNode> aRetVal = new HashSet();¬∂		for (OMPForSNode anOMPForSNode:anAllOMPForSNodes) {¬∂			if (anOMPForSNode.getReductionOperation() != null) {¬∂				aRetVal.add(anOMPForSNode);¬∂			}¬∂		}¬∂		return aRetVal;		¬∂	}¬∂    public static Set<AssignmentSNode> assignmentsToOMPReducingForNode(OMPForSNode anOMPForSNode) {¬∂    	String aReductionVariable = anOMPForSNode.getReductionVariable();¬∂    	return directAssignmentsOfVariableAndItsAliases(anOMPForSNode, aReductionVariable)	;¬∂    	¬∂    }¬∂	public static boolean dependsOn (SNode anSNode, int aVariableLineNumber, String aVariable, String aCallIdentifier) {¬∂		List<SNode> aListSNodes = anSNode.getChildren();¬∂		boolean retVal = false;¬∂		/*¬∂		 * Should probably ignore line number as it assumes straight line code¬∂		 */¬∂		for (int i = aVariableLineNumber; i >= 0; i--) {¬∂			SNode anSNodeChild = aListSNodes.get(i);¬∂			if (anSNodeChild instanceof AssignmentSNode) {¬∂				// does this statement in anSNode directly invoke aCallIdentifier ¬∂				if (dependsOn((AssignmentSNode) anSNodeChild, aVariable, aCallIdentifier))¬∂					return true;¬∂			} else if (!anSNode.isLeaf()) {¬∂					// child is overriding the variable so forget checking its assignment statements¬∂					if (anSNodeChild.getLocalVariableIdentifiers().contains(aVariable)) {¬∂						continue;¬∂					}¬∂					// some subblock of anSNode that has access to aVariable changes variable¬∂¬∂					if (dependsOn(anSNodeChild, anSNodeChild.getChildren().size() - 1, aVariable, aCallIdentifier)) {¬∂						return true;¬∂					}¬∂			}¬∂			¬∂		}¬∂		// none of the statements in anSNode or its descendents  have the required call¬∂		// is the variable a  method parameter ¬∂		if (anSNode instanceof MethodSNode) {¬∂			MethodSNode aMethodSNode = (MethodSNode) anSNode;¬∂			¬∂			int aParameterNumber = aMethodSNode.getLocalVariableIdentifiers().indexOf(aVariable);¬∂			if (aParameterNumber != -1) {¬∂				List <MethodCall> aCalls = aMethodSNode.getCalls();¬∂				for (MethodCall aCall:aCalls) {¬∂//					if (!aCall.getMethodActuals().contains(aVariable))¬∂//						continue;¬∂//					¬∂					MethodSNode aCallerSNode = getDeclarationOfCalledMethod(aMethodSNode, aCall);¬∂					if (dependsOn(aMethodSNode, aCallerSNode.getLineNumber(), aCallerSNode.getLocalVariableIdentifiers().get(aParameterNumber), aCallIdentifier));¬∂//				    if (aCallerDepends) {¬∂				    	return true;¬∂//				    }¬∂				}¬∂				return false;¬∂				// need to find all callers of method and see if any of the aliases for the variable in these¬∂				// calls depend on aCallIndentifier¬∂			}			¬∂			¬∂		} else if (anSNode.getLocalVariableIdentifiers().contains(aVariable)) {¬∂			// before going to the parent node, let us see if aVariable is declared here as a non  parameter ¬∂¬∂			return false; // no point going to parent¬∂		}¬∂		// not a local variable (parameter or declarated variable)¬∂		SNode anSNodeParent = anSNode.getParent() ;¬∂		if (anSNodeParent == null)  {¬∂			return false;¬∂		}¬∂		int anSNodeLineNumber = anSNodeParent.getChildren().indexOf(anSNode);¬∂		return dependsOn(anSNodeParent, anSNodeLineNumber, aVariable, aCallIdentifier);¬∂		¬∂	}¬∂	public static Set<AssignmentSNode> assignmentsOfVariableAliases (SNode anSNode,  String aVariable) {¬∂		Set<AssignmentSNode> retVal = new HashSet();¬∂		fillDirectAssignmentsOfVariableA"), Diff(DELETE,"ndItsA"), Diff(EQUAL,"liases(anSNode, aVariable, retVal);¬∂		return retVal;¬∂	}¬∂	public static void fillDirectAssignmentsOfVariableAliases (SNode anSNode,  String aVariable, Set<AssignmentSNode> retVal) {¬∂		if (anSNode instanceof MethodCall) {¬∂			MethodCall aMethodCall = (MethodCall) anSNode;¬∂			int aParameterNumber = aMethodCall.getMethodActualIdentifiers().indexOf(aVariable);¬∂			if (aParameterNumber < 0) {¬∂				return;¬∂			}¬∂			MethodSNode aDeclaringMethodSNode = getDeclarationOfCalledMethod(anSNode, aMethodCall);¬∂			String aFormalParameter = aDeclaringMethodSNode.getLocalVariableIdentifiers().get(aParameterNumber);¬∂//			Set<AssignmentSNode> aCallAssignments = ;¬∂			fillDirectAssignmentsOfVariableAliases(aDeclaringMethodSNode, aFormalParameter, retVal);¬∂		} else {¬∂			List<SNode> aChildren = anSNode.getChildren();¬∂			for (SNode aChild:aChildren) {¬∂				fillDirectAssignmentsOfVariableAliases(aChild, aVariable, retVal);¬∂			}¬∂		}		¬∂		¬∂	}¬∂	¬∂	/*¬∂	 * will not consider assignments to variables in the RHS of these assignments¬∂	 */¬∂	public static Set<AssignmentSNode> directAssignmentsOfVariableAndItsAliases (SNode anSNode,  String aVariable) {¬∂		Set<AssignmentSNode> retVal = new HashSet();¬∂		fillDirectAssignmentsOfVariableAndItsAliases(anSNode, aVariable, retVal);¬∂		return retVal;¬∂	}¬∂	¬∂//	public static Set<AssignmentSNode> assignmentsEffectingVariableAndItsAliases (SNode anSNode,  String aVariable) {¬∂//		Set<AssignmentSNode> retVal = directAssignmentsOfVariableAndItsAliases(anSNode, aVariable);¬∂//		¬∂//	}¬∂	public static void fillDirectAssignmentsOfVariableAndItsAliases (SNode anSNode,  String aVariable, Set<AssignmentSNode> retVal) {¬∂		if (anSNode instanceof AssignmentSNode) {¬∂			AssignmentSNode anAssignmentSNode = (AssignmentSNode) anSNode;¬∂			if (anAssignmentSNode.getLhsFirstIdentifier().equals(aVariable)) {¬∂				retVal.add(anAssignmentSNode);¬∂			}¬∂		}¬∂		¬∂		else if (anSNode instanceof MethodCall) {¬∂			MethodCall aMethodCall = (MethodCall) anSNode;¬∂			int aParameterNumber = aMethodCall.getMethodActualIdentifiers().indexOf(aVariable);¬∂			if (aParameterNumber < 0) {¬∂				return;¬∂			}¬∂			MethodSNode aDeclaringMethodSNode = getDeclarationOfCalledMethod(anSNode, aMethodCall);¬∂			String aFormalParameter = aDeclaringMethodSNode.getLocalVariableIdentifiers().get(aParameterNumber);¬∂//			Set<AssignmentSNode> aCallAssignments = ;¬∂			fillDirectAssignmentsOfVariableAndItsAliases(aDeclaringMethodSNode, aFormalParameter, retVal);¬∂		} else {¬∂			List<SNode> aChildren = anSNode.getChildren();¬∂			for (SNode aChild:aChildren) {¬∂				fillDirectAssignmentsOfVariableAndItsAliases(aChild, aVariable, retVal);¬∂			}¬∂		}		¬∂		¬∂	}¬∂	¬∂	public static RootOfFileSNode getRootOfFileNode(SNode aCurrentSNode ) {¬∂		if (aCurrentSNode instanceof RootOfFileSNode) {¬∂			return (RootOfFileSNode) aCurrentSNode;¬∂		}¬∂		SNode aParentSNode = aCurrentSNode.getParent() ;¬∂		¬∂		if (aParentSNode == null) {¬∂			return null;¬∂		}¬∂		¬∂		return getRootOfFileNode(aParentSNode);¬∂		¬∂	}¬∂	public static boolean match (MethodSNode aMethodSNode, MethodCall aMethodCall) {¬∂		return aMethodSNode.getMethodName().equals(aMethodCall.getMethodName()) ¬∂				&& aMethodSNode.getLocalVariableIdentifiers().size() == aMethodCall.getMethodActuals().size();¬∂	}¬∂	public static DeclarationSNode getDeclarationOfVariableIdentifier(SNode aCurrentSNode, String anIdentifier) {¬∂		if (aCurrentSNode == null) {¬∂			return null;¬∂		}¬∂		¬∂		¬∂		int anIndex = aCurrentSNode.getLocalVariableIdentifiers().indexOf(anIdentifier);¬∂		if (anIndex < 0) {¬∂			return getDeclarationOfVariableIdentifier(aCurrentSNode.getParent(), anIdentifier);¬∂		}¬∂		DeclarationSNode retVal = aCurrentSNode.getVariableDeclarations().get(anIndex);¬∂//		retVal.getAssignmentsToDeclaredVariable().add(anAssignmentSNode);¬∂//		anAssignmentSNode.setLhsFirstIdentifierDeclaration(retVal);¬∂		return retVal;¬∂	}¬∂	¬∂	public static DeclarationSNode getDeclarationOfAssignedVariable(SNode aCurrentSNode, AssignmentSNode anAssignmentSNode) {¬∂		if (aCurrentSNode == null) {¬∂			return null;¬∂		}¬∂		if (anAssignmentSNode instanceof ADeclaringAssignmentSNode) {¬∂			return (ADeclaringAssignmentSNode) anAssignmentSNode;¬∂		}¬∂		int anIndex = aCurrentSNode.getLocalVariableIdentifiers().indexOf(anAssignmentSNode.getLhsFirstIdentifier());¬∂		if (anIndex < 0) {¬∂			return getDeclarationOfAssignedVariable(aCurrentSNode.getParent(), anAssignmentSNode);¬∂		}¬∂		DeclarationSNode retVal = aCurrentSNode.getVariableDeclarations().get(anIndex);¬∂//		retVal.getAssignmentsToDeclaredVariable().add(anAssignmentSNode);¬∂//		anAssignmentSNode.setLhsFirstIdentifierDeclaration(retVal);¬∂		return retVal;¬∂	}¬∂	¬∂	public static MethodSNode getDeclarationOfCalledMethod(SNode aCurrentSNode, MethodCall aMethodCall ) {¬∂		SNode aRootNode = getRootOfFileNode(aCurrentSNode);¬∂		for (SNode aChild:aRootNode.getChildren()) {¬∂			if (aChild instanceof MethodSNode) {¬∂				MethodSNode aMethodSNode = (MethodSNode) aChild;¬∂				if (match (aMethodSNode, aMethodCall)) {¬∂					return aMethodSNode;¬∂				}¬∂			}¬∂		}¬∂		return null; // this should never happen;¬∂	}¬∂	¬∂	public static RootOfProgramSNode getRootOfProgramSNode(String aSource) {¬∂		RootOfProgramSNode retVal = new ARootOfProgramSNode();¬∂		Map<String, StringBuffer> aFileNameToContents = ABasicTextManager.extractFileContents(aSource);¬∂		for (String aFileName:aFileNameToContents.keySet()) {¬∂			StringBuffer aFileContents = aFileNameToContents.get(aFileName);¬∂//			List<OpenMPPragma> anOpenMPPragmas = OpenMPUtils.getOpemMPPragmas(aFileContents);¬∂			RootOfFileSNode anSNode = OMPSNodeUtils.getSNode(aFileName, aFileContents);¬∂			retVal.getFileNameToSNode().put(aFileName, anSNode);¬∂			anSNode.setParent(retVal);¬∂//			System.out.println("file name:" + aFileName);¬∂//			System.out.println("pragmas:" + anSNode);¬∂		}¬∂		processExternalMethodSNodes(retVal);¬∂		processIndirectAssignments(retVal);¬∂		return retVal;¬∂	}¬∂//	public static void processIndirectAssignments (S aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode) {¬∂//		for (SNode anSNode:aRootOfFileSNode.getChildren()) {¬∂//			-----¬∂//		}¬∂//	}¬∂	public static void processExternalMethodSNodes (RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode) {¬∂		for (SNode anSNode:aRootOfFileSNode.getChildren()) {¬∂			if (anSNode instanceof ExternalMethodSNode) {¬∂				processExternalMethodSNode(aRootOfProgramSNode, aRootOfFileSNode, (ExternalMethodSNode) anSNode);¬∂			}¬∂		}¬∂	}¬∂	public static void processExternalMethodSNode (RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode, ExternalMethodSNode anExternalMethodSNode) {¬∂		MethodSNode aMethodSNode = aRootOfProgramSNode.getExternalToInternalMethod().get(anExternalMethodSNode.toString());¬∂		if (aMethodSNode == null) {¬∂			aMethodSNode = findMethodSNode(aRootOfProgramSNode, aRootOfFileSNode, anExternalMethodSNode);¬∂			if (aMethodSNode != null) {¬∂				aRootOfProgramSNode.getExternalToInternalMethod().put(anExternalMethodSNode.toString(),aMethodSNode );¬∂			}¬∂		}¬∂		if (aMethodSNode != null) {¬∂			anExternalMethodSNode.setActualMethodSNode(aMethodSNode);¬∂			aMethodSNode.getCalls().addAll(anExternalMethodSNode.getLocalCalls());¬∂		}¬∂	}¬∂	¬∂	public static MethodSNode findMethodSNode (RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode, ExternalMethodSNode anExternalMethodSNode) {¬∂//		MethodSNode foundMethodSNode = null;¬∂		for (String aFileName:aRootOfProgramSNode.getFileNameToSNode().keySet()) {¬∂			if (aFileName.equals(aRootOfFileSNode.getFileName()))¬∂				continue;¬∂			¬∂			RootOfFileSNode aSearchedRootOfFileSNode = aRootOfProgramSNode.getFileNameToSNode().get(aFileName);¬∂			 for (SNode anSNode:aSearchedRootOfFileSNode.getChildren()) {¬∂				if (anSNode instanceof MethodSNode && !(anSNode instanceof ExternalMethodSNode)) {¬∂					if (anSNode.toString().equals(anExternalMethodSNode.toString())) {¬∂						return (MethodSNode) anSNode;¬∂						¬∂					}¬∂//					processExternalMethodSNode(aRootOfProgramSNode, aRootOfFileSNode, (ExternalMethodSNode) anSNode);¬∂				}¬∂			}¬∂		}¬∂		return null;¬∂	}¬∂	public static void processExternalMethodSNodes (RootOfProgramSNode aRootOfProgramSNode) {¬∂		for (String aFileName:aRootOfProgramSNode.getFileNameToSNode().keySet()) {¬∂			RootOfFileSNode aRootOfFileSNode = aRootOfProgramSNode.getFileNameToSNode().get(aFileName);¬∂			processExternalMethodSNodes(aRootOfProgramSNode, aRootOfFileSNode);¬∂			aRootOfFileSNode.getOmp_get_num_threads_SNode().¬∂				setActualMethodSNode(aRootOfProgramSNode.getOmp_get_num_threads_SNode());¬∂			aRootOfFileSNode.getOmp_get_thread_num_SNode().¬∂				setActualMethodSNode(aRootOfProgramSNode.getOmp_get_thread_num_SNode());¬∂			aRootOfFileSNode.getOmp_get_wtime_SNode().¬∂			setActualMethodSNode(aRootOfProgramSNode.getOmp_get_wtime_SNode());¬∂		}¬∂¬∂	}¬∂	public static void processIndirectAssignments (SNode anSNode) {¬∂		if (anSNode instanceof ConstDeclarationSNode) {¬∂			return;¬∂		}¬∂		if (anSNode instanceof DeclarationSNode) {¬∂			DeclarationSNode aDeclarationSNode = (DeclarationSNode) anSNode;¬∂			Set<AssignmentSNode> anIndirectAssignments = aDeclarationSNode.getAssignmentsEffectingDeclaredIdentifier();¬∂			if (anIndirectAssignments != null) {¬∂				return; // already assigned¬∂			}¬∂			anIndirectAssignments = new HashSet<>();¬∂			aDeclarationSNode.setAssignmentsEffectingDeclaredIdentifier(anIndirectAssignments);¬∂			Set<AssignmentSNode> aDirectAssignments = aDeclarationSNode.getAssignmentsToDeclaredVariable();¬∂			anIndirectAssignments.addAll(aDirectAssignments);¬∂			Set<AssignmentSNode> anAliasAssignments = assignmentsOfVariableAliases(aDeclarationSNode.getParent(), aDeclarationSNode.getVariableName());¬∂			anIndirectAssignments.addAll(anAliasAssignments);¬∂			for (AssignmentSNode aDirectAssignment:aDirectAssignments) {¬∂				List<String> aVariableIdentifiers = aDirectAssignment.getRhsVariableIdentifiers();¬∂				¬∂				for (String aVariableIdentifier:aVariableIdentifiers) {¬∂					DeclarationSNode aDependeeDeclarationSNode = getDeclarationOfVariableIdentifier(aDirectAssignment, aVariableIdentifier);¬∂					if (aDependeeDeclarationSNode == null) {¬∂						System.err.println("Could not find declaration of:" + aVariableIdentifier + " referenced in:" + aDirectAssignment );¬∂						continue;¬∂					}¬∂					processIndirectAssignments(aDependeeDeclarationSNode);¬∂					Set<AssignmentSNode> aDependeeIndirectAssignments = aDeclarationSNode.getAssignmentsEffectingDeclaredIdentifier();¬∂					anIndirectAssignments.addAll(aDependeeIndirectAssignments);¬∂					¬∂				}¬∂			}¬∂		} else {¬∂			for (SNode aChild: anSNode.getChildren()) {¬∂				processIndirectAssignments(aChild);¬∂			}¬∂		}¬∂		¬∂	}¬∂	¬∂//	public static void fillIndirectAssignments (SNode anSNode, Set<AssignmentSNode> retVal ) {¬∂//		¬∂//	}¬∂	¬∂¬∂//	public static void main(String[] args) {¬∂//		List<MethodCall> aTokens = callsIn("foo(bar, hgf)/foo2()*foo3(b, a c,)");¬∂//		System.out.println(aTokens);¬∂//		¬∂//		¬∂////		List<String> aTokens = identifiersIn("a[i] + b*2/3");¬∂////		System.out.println(aTokens);¬∂////		aTokens = numbersIn("a[i] + b*2/3");¬∂////		System.out.println(aTokens);¬∂////		aTokens = operatorsIn("a[i] + b*2/3");¬∂////		System.out.println(aTokens);¬∂////¬∂////		System.out.println(StringUtils.substringBetween("a", "[", "]"));¬∂//	}¬∂¬∂}¬∂")]]]></diff>
    <snapshot><![CDATA[package gradingTools.shared.testcases.openmp.scannedTree;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Stack;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.apache.commons.lang.StringUtils;

import grader.basics.project.source.ABasicTextManager;
import gradingTools.shared.testcases.openmp.OpenMPKeywordEnum;
import gradingTools.shared.testcases.openmp.OpenMPParallelPragma;
import gradingTools.shared.testcases.openmp.OpenMPUtils;
import gradingTools.shared.testcases.openmp.scannedTree.ADeclarationSNode;
import gradingTools.shared.testcases.openmp.scannedTree.ADeclaringAssignmentSNode;
import gradingTools.shared.testcases.openmp.scannedTree.AForSNode;
import gradingTools.shared.testcases.openmp.scannedTree.ATextSNode;
import gradingTools.shared.testcases.openmp.scannedTree.AnAssignmentSNode;
import gradingTools.shared.testcases.openmp.scannedTree.AnOMPCriticalSNode;
import gradingTools.shared.testcases.openmp.scannedTree.AnOMPForSNode;
import gradingTools.shared.testcases.openmp.scannedTree.AnOMPParallelSNode;
import gradingTools.shared.testcases.openmp.scannedTree.AnOMPSNode;
import gradingTools.shared.testcases.openmp.scannedTree.AnSNode;
import gradingTools.shared.testcases.openmp.scannedTree.AssignmentSNode;
import gradingTools.shared.testcases.openmp.scannedTree.DeclarationSNode;
import gradingTools.shared.testcases.openmp.scannedTree.DeclaringAssignmentSNode;
import gradingTools.shared.testcases.openmp.scannedTree.ForSNode;
import gradingTools.shared.testcases.openmp.scannedTree.OMPForSNode;
import gradingTools.shared.testcases.openmp.scannedTree.OMPSNode;
import gradingTools.shared.testcases.openmp.scannedTree.SNode;

public class OMPSNodeUtils extends OpenMPUtils {

	public static RootOfFileSNode getSNode(String aFileName, StringBuffer aFileBuffer) {
		String[] aFileLines = aFileBuffer.toString().split("\n");
		return getSNode(aFileName, aFileLines);
	}

	public static AssignmentSNode getAssignmentSNode(int aLineNumber, String aString) {
		if (aString == null) {
			return null;
		}
		String[] aTokens = aString.split("=");
		if (aTokens.length == 1) {
			return new AnAssignmentSNode(aLineNumber, aTokens[0], null);
		} else {
		return new AnAssignmentSNode(aLineNumber, aTokens[0], aTokens[1]);
		}
	}

	public static DeclarationSNode getDeclarationSNode(int aLineNumber, String aString) {
		String[] aTokens = aString.split(" ");
		return new ADeclarationSNode(aLineNumber, aTokens[0], aTokens[1]);
	}

	public static DeclaringAssignmentSNode getDeclaringAssignmentSNode(int aLineNumber, String aString) {
		String[] anLHSAndRHS = aString.split("=");
		String[] aTypeAndVariable = anLHSAndRHS[0].split(" ");
		return new ADeclaringAssignmentSNode(aLineNumber, aTypeAndVariable[0], aTypeAndVariable[1], anLHSAndRHS[1]);
	}
	public static ConstDeclarationSNode getConstDeclarationSNode(int aLineNumber, String aString) {
		String anAssignmentString = aString.substring(CONST.length()).trim();
		String[] anLHSAndRHS = anAssignmentString.split("=");
		String[] aTypeAndVariable = anLHSAndRHS[0].split(" ");
		return new AConstDeclarationSNode(aLineNumber, aTypeAndVariable[0], aTypeAndVariable[1], anLHSAndRHS[1]);
	}

	public static boolean isDeclaringAssignment(String aFileLine) {
		return startsWithTypeName(aFileLine) && aFileLine.contains("=");
	}
	public static boolean isConstDeclaration(String aFileLine) {
		return aFileLine.startsWith(CONST);
	}
	public static boolean isMethodDeclaration(String aFileLine) {
		return startsWithTypeName(aFileLine) && 
				aFileLine.contains("(") &&
				!aFileLine.contains("=");
	}
	public static boolean isExternalMethodDeclaration(String aFileLine) {
		return isMethodDeclaration(aFileLine) && aFileLine.endsWith(";");
	}


	public static boolean isVariableDeclaration(String aFileLine) {

		return startsWithTypeName(aFileLine) && !aFileLine.contains("(");
	}

	public static boolean isAssignment(String aFileLine) {
		return aFileLine.contains("=") && !aFileLine.contains("==");
	}

	public static boolean isForNode(String aFileLine) {
		return aFileLine.startsWith("for");
	}

	public static ForSNode getForSNode(int aLineNumber, String aFileLine) {

		int aLeftParenIndex = aFileLine.indexOf("(");
		int aRightParenIndex = aFileLine.indexOf(")");
		if (aLeftParenIndex < 0 || aRightParenIndex < 0) {
			return null;
		}
		String aHeaderString = aFileLine.substring(aLeftParenIndex + 1, aRightParenIndex);
		String[] aForComponents = aHeaderString.split(";");
		AssignmentSNode anAssignmentSNode = null;
		String aForInitializaton = aForComponents[0];
		if (!aForInitializaton.isEmpty() && aForInitializaton.contains("=")) {
			if (isDeclaringAssignment(aForInitializaton)) {
				anAssignmentSNode = getDeclaringAssignmentSNode(aLineNumber, aForInitializaton);
			} else {
				anAssignmentSNode = getAssignmentSNode(aLineNumber, aForInitializaton);
			}

		}		
		return new AForSNode(aLineNumber, anAssignmentSNode, aForComponents[1], getAssignmentSNode(aLineNumber, aForComponents[2]));
	}
	static String[] emptyArray = {};
	public static MethodSNode getMethodSNode(int aLineNumber, String aFileLine, boolean isInternal) {

		int aLeftParenIndex = aFileLine.indexOf("(");
		int aRightParenIndex = aFileLine.indexOf(")");
		if (aLeftParenIndex < 0 || aRightParenIndex < 0) {
			return null;
		}
		String aMethodNameAndType = aFileLine.substring(0, aLeftParenIndex);
		String[] aMethodNameAndTypeTokens = aMethodNameAndType.split("\\s+"); 
		
		String aMethodParameters = aFileLine.substring(aLeftParenIndex +1 , aRightParenIndex);
		String[] aMethodParameterTokens = aMethodParameters.isEmpty()?emptyArray:
		 aMethodParameters.split(",");
		
//		String[] aMethodParameterTypes = new String[aMethodParameterTokens.length];
//		String[] aMethodParameterNames = new String[aMethodParameterTokens.length];
		List<DeclarationSNode> aDeclarationSNodeList = new ArrayList();
		for (int i = 0; i < aMethodParameterTokens.length; i++ ) {
			String[] aTypeAndName = aMethodParameterTokens[i].trim().split("\\s+");
			if (aTypeAndName.length < 2) {
				continue;
			}
			aDeclarationSNodeList.add(new ADeclarationSNode(aLineNumber, aTypeAndName[0].trim(), aTypeAndName[1].trim()));
//			aMethodParameterTypes[i] = aTypeAndName[0].trim();
//			aMethodParameterNames[i] = aTypeAndName[1].trim();
		}
		if (isInternal)
//		return new AMethodSNode(aLineNumber, aMethodNameAndTypeTokens[0], aMethodNameAndTypeTokens[1], aMethodParameterTypes,aMethodParameterNames );
			return new AMethodSNode(aLineNumber, aMethodNameAndTypeTokens[0], aMethodNameAndTypeTokens[1], aDeclarationSNodeList );
		else
			return new AnExternalMethodSNode(aLineNumber, aMethodNameAndTypeTokens[0], aMethodNameAndTypeTokens[1], aDeclarationSNodeList );
	}

	public static void setReductionData(OMPForSNode lastChild, String aStoredToken, int aLeftParenIndex,
			int aRightParenIndex) {
		int aColonIndex = aStoredToken.indexOf(":");
		if (aLeftParenIndex != -1 && aRightParenIndex != -1 && aColonIndex != -1) {
			String anOperationString = aStoredToken.substring(aLeftParenIndex + 1, aColonIndex).trim();
			String aVariableString = aStoredToken.substring(aColonIndex + 1, aRightParenIndex).trim();
			((OMPForSNode) lastChild).setReductionVariable(aVariableString);
			((OMPForSNode) lastChild).setReductionOperation(anOperationString);
		}
	}

	public static void setSharedOrPrivateData(OMPSNode lastChild, String aStoredToken, int aLeftParenIndex,
			int aRightParenIndex, boolean isShared) {
//		int aColonIndex = aStoredToken.indexOf(":");
		if (aLeftParenIndex != -1 && aRightParenIndex != -1) {
			String aVariableDeclarations = aStoredToken.substring(aLeftParenIndex + 1, aRightParenIndex);
			String[] aVariables = aVariableDeclarations.split(",");
			if (isShared) {
				lastChild.setSharedVariables(aVariables);
			} else {
				lastChild.setPrivateVariables(aVariables);
			}
		}
	}

	public static RootOfFileSNode getSNode(String aFileName, String[] aFileLines) {
		Stack<SNode> anSNodes = new Stack();

		RootOfFileSNode retVal = new ARootOfFileSNode(aFileName);
		anSNodes.add(retVal);
		SNode previousHeaderNode = null;
		for (int i = 0; i < aFileLines.length; i++) {
			String aFileLine = aFileLines[i].trim();
			if (!isCodeLine(aFileLine)) {
				continue;
			}
			if (isForNode(aFileLine)) {
				ForSNode aForSNode = getForSNode(i, aFileLine);
				SNode aParent = previousHeaderNode != null?previousHeaderNode:anSNodes.peek();
				aForSNode.setParent(anSNodes.peek());
				aForSNode.setParent(aParent);

//				anSNodes.push(aForSNode);
				previousHeaderNode = aForSNode;
				if (aFileLine.endsWith(")")) {
					continue;
				}
			}
			if (isExternalMethodDeclaration(aFileLine)) {
				MethodSNode aMethodSNode = getMethodSNode(i, aFileLine, false);
				aMethodSNode.setParent(anSNodes.peek());
//				anSNodes.push(aForSNode);
				previousHeaderNode = aMethodSNode;
				if (aFileLine.endsWith(")")) {
					continue;
				}
			}
			if (isMethodDeclaration(aFileLine)) {
				MethodSNode aMethodSNode = getMethodSNode(i, aFileLine, true);
				aMethodSNode.setParent(anSNodes.peek());
//				anSNodes.push(aForSNode);
				previousHeaderNode = aMethodSNode;
				if (aFileLine.endsWith(")")) {
					continue;
				}
			}
			if (isPragmaStart(aFileLine)) {
				OMPSNode anOMPSNode = getOMPSNode(i, anSNodes.peek(), aFileLine);
//				anSNodes.push(anOMPSNode);
				previousHeaderNode = anOMPSNode;
				continue;
			}
			if (isBlockStart(aFileLine)) {
				SNode aBlockSNode = new ABlockSNode(i);
				if (previousHeaderNode != null) {
					aBlockSNode.setParent(previousHeaderNode);
				} else {
					aBlockSNode.setParent(anSNodes.peek());
				}
				anSNodes.push(aBlockSNode);
				previousHeaderNode = null;
				continue;
			}
//			} else 
			if (isBlockEnd(aFileLine)) {
				anSNodes.pop();
				continue;
			}
			SNode aNewLeafNode = null;
			if (isConstDeclaration(aFileLine)) {
				aNewLeafNode = getConstDeclarationSNode(i, aFileLine);

			} else if (isDeclaringAssignment(aFileLine)) {
				aNewLeafNode = getDeclaringAssignmentSNode(i, aFileLine);

			} else if (isAssignment(aFileLine)) {
				aNewLeafNode = getAssignmentSNode(i, aFileLine);
			} else if (isVariableDeclaration(aFileLine)) {
				aNewLeafNode = getDeclarationSNode(i, aFileLine);
			} else {
				List<MethodCall> aCalls = callsIn(i, aFileLine, null); // parent will be assigned below
				if (aCalls != null && aCalls.size() == 1) {
					aNewLeafNode = aCalls.get(0);
				} else {
					aNewLeafNode = new ATextSNode(i, aFileLine);
				}
			}
//			else {
//				aNewLeafNode = new ATextSNode(i, aFileLine);
//			}
			if (previousHeaderNode != null) {
				aNewLeafNode.setParent(previousHeaderNode);
			} else {
				aNewLeafNode.setParent(anSNodes.peek());
			}

		}

		return retVal;
	}

	public static OMPSNode getOMPSNode(int aLineIndex, SNode aParentNode, String aFileLine) {
		String[] aTokens = aFileLine.split("\\s+");
		if (aTokens.length <= 2) {
			return null;
		}
		if (!aTokens[1].equals("omp")) {
			return null;
		}
		if (aTokens.length < 3) {
			return null;
		}
		String aFirstToken = aTokens[2];
		OpenMPKeywordEnum anOpenMPKeyword = stringToOpenMPKeyword.get(aFirstToken);
//		List<OpenMPPragma> retVal = new ArrayList();
		OMPSNode lastChild = null;
		int aStartIndex = 2;
		OMPSNode aNewNode = null;
		OMPForSNode aForChild = null;
		switch (anOpenMPKeyword) {
		case PARALLEL:
			aNewNode = new AnOMPParallelSNode(aLineIndex);

			if (aTokens.length > 3 && aTokens[3].equals("for")) {
				aForChild = new AnOMPForSNode(aLineIndex);
				aForChild.setParent(aNewNode);

				aStartIndex++;
			}
			break;
		case FOR:
			aNewNode = new AnOMPForSNode(aLineIndex);
			;
			break;
		case CRITICAL:
			aNewNode = new AnOMPCriticalSNode(aLineIndex);
//			retVal.add (lastChild);
			break;
		default:
			aNewNode = new AnOMPSNode(aLineIndex);

		}

		if (lastChild != null) {
			aNewNode.setParent(lastChild);
		} else {
			aNewNode.setParent(aParentNode);
		}
		lastChild = aForChild == null ? aNewNode : aForChild;

		for (int i = aStartIndex; i < aTokens.length; i++) {
			String aStoredToken = aTokens[i].trim();
			if (aStoredToken.isEmpty()) {
				continue;
			}
			if (aStoredToken.startsWith("reduction") || aStoredToken.startsWith("shared")
					|| aStoredToken.startsWith("private")) {
				// combine all tokens until ")" into one for normalization
				while (!aStoredToken.endsWith(")")) {
					i++;
					if (i >= aTokens.length) {
						break;
					}
					String aNewToken = aTokens[i].trim();
					aStoredToken += aNewToken;
				}
				int aLeftParenIndex = aStoredToken.indexOf("(");
				int aRightParenIndex = aStoredToken.indexOf(")");
				if (aStoredToken.startsWith("reduction")) {
					setReductionData((OMPForSNode) lastChild, aStoredToken, aLeftParenIndex, aRightParenIndex);
				} else if (aStoredToken.startsWith("private")) {
					setSharedOrPrivateData((OMPSNode) lastChild, aStoredToken, aLeftParenIndex, aRightParenIndex,
							false);

				} else if (aStoredToken.startsWith("shared")) {
					setSharedOrPrivateData(lastChild, aStoredToken, aLeftParenIndex, aRightParenIndex, true);

				}

			}

			lastChild.getOpenMPTokens().add(aStoredToken);
		}

		return lastChild;

	}

	public static boolean hasParallelAncestor(SNode anSNode) {
		if (anSNode == null) {
			return false;
		}
		if (anSNode instanceof OMPParallelSNode) {
			return true;
		}
		return hasParallelAncestor(anSNode.getParent());
	}
	public static boolean hasCriticalAncestor(SNode anSNode) {
		if (anSNode == null) {
			return false;
		}
		if (anSNode instanceof OMPCriticalSNode) {
			return true;
		}
		return hasCriticalAncestor(anSNode.getParent());
	}


	public static Boolean isDeclaredShared(OMPSNode anOMPSNode, String anLHS) {
		if (Arrays.asList(anOMPSNode.getSharedVariables()).contains(anLHS)) {
			return true;
		}
		if (Arrays.asList(anOMPSNode.getPrivateVariables()).contains(anLHS)) {
			return false;
		}
		return null;

	}

	public static boolean isSharedVariable(SNode anSNode, String anLHS) {
		if (anSNode == null) {
			return false;
		}
		if (anSNode.getLocalVariableIdentifiers().contains(anLHS)) {
			if (!(anSNode instanceof OMPSNode)) { // no shared and private declarations
				return !hasParallelAncestor(anSNode); // shared if not inParallel
			}
			OMPSNode anOMPSNode = (OMPSNode) anSNode;
			return (Arrays.asList(anOMPSNode.getSharedVariables()).contains(anLHS)); // private unless declared shared
		}
		if (anSNode instanceof OMPSNode) {
			OMPSNode anOMPSNode = (OMPSNode) anSNode;
			// the variable is global to this scope, check if it has have been made shared
			// or private by this scope
			Boolean isDeclaredShared = isDeclaredShared(anOMPSNode, anLHS);
			if (isDeclaredShared != null) {
				return isDeclaredShared;
			}
		}
		// check the parent
		return isSharedVariable(anSNode.getParent(), anLHS);
	}

	public static List<SNode> getAllLeafNodes(SNode aTopNode) {
		List<SNode> retVal = new ArrayList();
		addLeafNodes(aTopNode, retVal);
		return retVal;
	}

	public static void addLeafNodes(SNode aTopNode, List<SNode> retVal) {
		for (SNode aChild : aTopNode.getChildren()) {
			if (aChild.isLeaf()) {
				retVal.add(aChild);
			} else {
				addLeafNodes(aChild, retVal);
			}
		}
	}

	public static List<SNode> getNonParallelLeafNodes(SNode aTopNode) {
		List<SNode> retVal = new ArrayList();
		addNonParallelLeafNodes(aTopNode, retVal);
		return retVal;
	}

	public static void addNonParallelLeafNodes(SNode aTopNode, List<SNode> retVal) {
		if (aTopNode.isInParallel()) {
			return;
		}
		for (SNode aChild : aTopNode.getChildren()) {
			if (aChild.isLeaf()) {
				retVal.add(aChild);
			} else {
				addLeafNodes(aChild, retVal);
			}
		}
	}
	static String callRegex = "([a-zA-Z_$][a-zA-Z_$0-9]*)\\(.*?\\)";
	static Pattern callPattern = Pattern.compile(callRegex);

	static String identifierRegex = "[a-zA-Z_$][a-zA-Z_$0-9]*";
	static Pattern identifierPattern = Pattern.compile(identifierRegex);
	public static List<String> identifiersIn(String aString) {
		if (aString == null)
			return null;
//		Pattern mypattern = Pattern.compile("[a-zA-Z_$][a-zA-Z_$0-9]*");
//		Matcher mymatcher = mypattern.matcher(aString);
		Matcher mymatcher = identifierPattern.matcher(aString);
		List<String> retVal = new ArrayList();
		while (mymatcher.find()) {
			String find = mymatcher.group(0);
			retVal.add(find);
		}
		return retVal;
	}
	public static List<MethodCall> callsIn(int aLineNumber, String aString, SNode aParent) {
		if (aString == null)
			return emptyList;
		if (isMethodDeclaration(aString)) {
			return emptyList;
		}
//		Pattern mypattern = Pattern.compile("[a-zA-Z_$][a-zA-Z_$0-9]*");
//		Matcher mymatcher = mypattern.matcher(aString);
		Matcher mymatcher = callPattern.matcher(aString);
		List<MethodCall> retVal = new ArrayList();
		while (mymatcher.find()) {
			String find = mymatcher.group(0);
			int aLeftParenIndex = find.indexOf("(");
			int aRightParenIndex = find.indexOf(")");
			String aMethodName = find.substring(0, aLeftParenIndex).trim();
			String aParameters = find.substring(aLeftParenIndex + 1, aRightParenIndex);
			List<String> aParameterList = new ArrayList();
			String[] aParameterTokens = aParameters.split(",");
			for (String aParameter:aParameterTokens) {
				String aParameterTrimmed = aParameter.trim();
				if (!aParameterTrimmed.isEmpty())
				aParameterList.add(aParameterTrimmed);
			}
			retVal.add(new AMethodCall(aLineNumber, aMethodName, aParameterList, aParent));

//			aCallStrings.add(find);
		}
		return retVal;
	}
	static String numberRegex = "(\\d+\\.\\d+)|(\\d+)";
	static Pattern numberPattern = Pattern.compile(numberRegex);
	public static List<String> numbersIn(String aString) {
		if (aString == null)
			return null;
//		String regex = "(\\d+\\.\\d+)|(\\d+)";
//
//		Matcher m = Pattern.compile(regex).matcher(aString);
		Matcher m =numberPattern.matcher(aString);


		List<String> retVal = new ArrayList();

		while (m.find()) {
			retVal.add(m.group());
		}
		return retVal;
	}

	public static String subscriptIn(String aString) {
		if (aString == null)
			return null;
		return StringUtils.substringBetween(aString, "[", "]");
	}
	static String[] emptyStringArray = {};
	static List emptyList = new ArrayList();

	public static String[] subscriptsIn(String aString) {
		if (aString == null)
			return emptyStringArray;
		return StringUtils.substringsBetween(aString, "[", "]");
	}
	static  String operatorRegex = "([+-/*///^])|([/(/)])";
	static Pattern operatorPattern = Pattern.compile(operatorRegex);

	public static List<String> operatorsIn(String aString) {
		if (aString == null)
			return null;
//		String operatorRegex = "([+-/*///^])|([/(/)])";
//
//		Matcher m = Pattern.compile(operatorRegex).matcher(aString);
		
		Matcher m = operatorPattern.matcher(aString);


		List<String> retVal = new ArrayList();

		while (m.find()) {
			retVal.add(m.group());
		}
		return retVal;
	}
	
	public static int numberOfNestingFors (SNode anSNode) {
		if (anSNode == null) {
			return 0;
		}
		int retVal = numberOfNestingFors (anSNode.getParent()) ;

		if (anSNode instanceof ForSNode) {
			retVal++;
		} else if (anSNode instanceof MethodSNode) {
			List<MethodCall> aMethodCalls = ((MethodSNode) anSNode).getCalls();
			int aMaxNestingLevel = 0;
			for (MethodCall aMethodCall:aMethodCalls) {
				MethodSNode aCallerMethodSNode = getDeclarationOfCalledMethod(anSNode, aMethodCall);
				int aCallerNumberOfNestingFors = numberOfNestingFors(aCallerMethodSNode);
				aMaxNestingLevel = Math.max(aCallerNumberOfNestingFors, aMaxNestingLevel);				
			}
			return retVal + aMaxNestingLevel;
		}
		return retVal;
	}
	public static boolean hasOperator (SNode anSNode, String anOperator) {
		boolean retVal = false;
		if (anSNode instanceof AssignmentSNode) {
			AssignmentSNode anAssignmentSNode = (AssignmentSNode) anSNode;
			 retVal = (anAssignmentSNode.getLhsOperators().contains(anOperator) || 
					anAssignmentSNode.getRhsOperators().contains(anOperator)) ;
			if (retVal) {
				return retVal;
			} else {
				List<MethodCall> aMethodCalls = anAssignmentSNode.getRhsCalls();
				for (MethodCall aMethodCall:aMethodCalls) {
					MethodSNode aMethodSNode = getDeclarationOfCalledMethod(anSNode, aMethodCall);
					retVal = hasOperator(aMethodSNode, anOperator);
					if (retVal) {
						return retVal;
					}
					
				}
				return false;
			}
			
		}
		for (SNode aChild:anSNode.getChildren()) {
			retVal = hasOperator(aChild, anOperator);
			if (retVal) {
				return retVal;
			}
		}
		return false;
	}
	public static boolean hasMethodCall (SNode anSNode, String anOperator) {
		boolean retVal = false;
		if (anSNode instanceof AssignmentSNode) {
			AssignmentSNode anAssignmentSNode = (AssignmentSNode) anSNode;
			 retVal = (anAssignmentSNode.getLhsOperators().contains(anOperator) || 
					anAssignmentSNode.getRhsOperators().contains(anOperator)) ;
			if (retVal) {
				return retVal;
			} else {
				List<MethodCall> aMethodCalls = anAssignmentSNode.getRhsCalls();
				for (MethodCall aMethodCall:aMethodCalls) {
					MethodSNode aMethodSNode = getDeclarationOfCalledMethod(anSNode, aMethodCall);
					retVal = hasOperator(aMethodSNode, anOperator);
					if (retVal) {
						return retVal;
					}
					
				}
				return false;
			}
			
		}
		for (SNode aChild:anSNode.getChildren()) {
			retVal = hasOperator(aChild, anOperator);
			if (retVal) {
				return retVal;
			}
		}
		return false;
	}
	public static boolean dependsOn (AssignmentSNode anAssignmentSNode, String aVariable, String aCallIdentifier) {
		// This assignment does not change aVariable
		if (!aVariable.equals(anAssignmentSNode.getLhsFirstIdentifier())) {
			return false;
		}
		return dependsOn(anAssignmentSNode.getExpressionSNode(), aCallIdentifier);
//		List<String> aCallIdentifiers = anAssignmentSNode.getRhsCallIdentifiers();
//		boolean retVal = false;
//		if (aCallIdentifiers != null && aCallIdentifiers.contains(aCallIdentifier)) {
//			return true; // this assignment has aCallIdentifier in the rhs
//		}
//		// check if some referenced rhs variable depends on aCallIdentifier
//		List<String> aReferencedVariableIdentifiers = anAssignmentSNode.getRhsVariableIdentifiers();
//		SNode anAssignmentParent = anAssignmentSNode.getParent();
//		if (anAssignmentParent == null) { // should never be trye
//			return false;
//		}
//		int aLineNumber = anAssignmentSNode.getLineNumber();
//		for (String aReferencedVariableIdentifier:aReferencedVariableIdentifiers ) {
//			if (dependsOn (anAssignmentParent, aLineNumber, aReferencedVariableIdentifier, aCallIdentifier)) {
//				return true;
//			}
//		}
//		return false;
	}
	public static boolean dependsOn (ExpressionSNode anExpressionSNode, String aCallIdentifier) {
		// This assignment does not change aVariable
		
		List<String> aCallIdentifiers = anExpressionSNode.getRhsCallIdentifiers();
		boolean retVal = false;
		if (aCallIdentifiers != null && aCallIdentifiers.contains(aCallIdentifier)) {
			return true; // this assignment has aCallIdentifier in the rhs
		}
		// check if some referenced rhs variable depends on aCallIdentifier
		List<String> aReferencedVariableIdentifiers = anExpressionSNode.getRhsVariableIdentifiers();
		SNode anAssignmentParent = anExpressionSNode.getParent().getParent();
		if (anAssignmentParent == null) { // should never be trye
			return false;
		}
		int aLineNumber = anExpressionSNode.getLineNumber();
		for (String aReferencedVariableIdentifier:aReferencedVariableIdentifiers ) {
			if (dependsOn (anAssignmentParent, aLineNumber, aReferencedVariableIdentifier, aCallIdentifier)) {
				return true;
			}
		}
		return false;
	}
	public static Set<AssignmentSNode> assignmentsToSharedVariables(SNode anSNode) {
		Set<AssignmentSNode> retVal =  new HashSet();
		fillAssignmentsToShared(anSNode, retVal);
		return retVal;
		
	}
	public static Set<AssignmentSNode> assignmentsToSharedArrays(SNode anSNode) {
		Set<AssignmentSNode> anAllSharedAssignments =  assignmentsToSharedVariables(anSNode);
		Set<AssignmentSNode> aRetVal = new HashSet();
		for (AssignmentSNode anAssignmentSNode:anAllSharedAssignments) {
			if (anAssignmentSNode.getLhsSubscripts().length > 0) {
				aRetVal.add(anAssignmentSNode);
			}
		}
		return aRetVal;
		
	}
	public static Set<AssignmentSNode> assignmentsToParallelCriticalSharedVariables(SNode anSNode) {
		Set<AssignmentSNode> anAllSharedAssignments =  assignmentsToSharedVariables(anSNode);
		Set<AssignmentSNode> aRetVal = new HashSet();
		for (AssignmentSNode anAssignmentSNode:anAllSharedAssignments) {
			if (anAssignmentSNode.isInParallel() &&
					anAssignmentSNode.isInCritical()) {
				aRetVal.add(anAssignmentSNode);
			}
		}
		return aRetVal;
		
	}
	public static Set<AssignmentSNode> assignmentsToNonParallelCriticalSharedVariables(SNode anSNode) {
		Set<AssignmentSNode> anAllSharedAssignments =  assignmentsToSharedVariables(anSNode);
		Set<AssignmentSNode> aRetVal = new HashSet();
		for (AssignmentSNode anAssignmentSNode:anAllSharedAssignments) {
			if (!anAssignmentSNode.isInParallel() &&
					anAssignmentSNode.isInCritical()) {
				aRetVal.add(anAssignmentSNode);
			}
		}
		return aRetVal;
		
	}
	public static Set<AssignmentSNode> assignmentsToParallelNonCriticalSharedVariables(SNode anSNode) {
		Set<AssignmentSNode> anAllSharedAssignments =  assignmentsToSharedVariables(anSNode);
		Set<AssignmentSNode> aRetVal = new HashSet();
		for (AssignmentSNode anAssignmentSNode:anAllSharedAssignments) {
			if (anAssignmentSNode.isInParallel() &&
					!anAssignmentSNode.isInCritical()) {
				aRetVal.add(anAssignmentSNode);
			}
		}
		return aRetVal;
		
	}
    public static void fillAssignmentsToShared(SNode anSNode, Set<AssignmentSNode> retVal) {
    	if (anSNode instanceof AssignmentSNode) {
			AssignmentSNode anAssignmentSNode = (AssignmentSNode) anSNode;
			String anLHS = anAssignmentSNode.getLhsFirstIdentifier();
			if (isSharedVariable(anSNode, anLHS)) {
				retVal.add(anAssignmentSNode);
				return;
			}
		}
    	for (SNode aChild:anSNode.getChildren()) {
    		fillAssignmentsToShared(aChild, retVal);
    	}
		
	}
    public static void fillInstancesOfNodeType(Class<? extends SNode> aNodeType, SNode anSNode, Set<SNode> retVal) {
    	if (aNodeType.isAssignableFrom(anSNode.getClass())) {
			
				retVal.add(anSNode);
				return;
			}
		
    	for (SNode aChild:anSNode.getChildren()) {
    		fillInstancesOfNodeType(aNodeType, aChild, retVal);
    	}
		
	}
    public static Set<AssignmentSNode>  assignmentSNodes(SNode anSNode) {
    	Set retVal = new HashSet();    	
    	fillInstancesOfNodeType(AssignmentSNode.class, anSNode, retVal );
    	return retVal;
	}
   
    
    public static Set<OMPParallelSNode>  ompParallelSNodes(SNode anSNode) {
    	Set retVal = new HashSet();    	
    	fillInstancesOfNodeType(OMPParallelSNode.class, anSNode, retVal );
    	return retVal;
	}
//    public static void fillOMPParallelSNodes(SNode anSNode, Set<OMPParallelSNode> retVal) {
//    	if (anSNode instanceof OMPParallelSNode) {
//    		retVal.add((OMPParallelSNode) anSNode);
//		}
//    	for (SNode aChild:anSNode.getChildren()) {
//    		fillOMPParallelSNodes(aChild, retVal);
//    	}		
//	}
    public static Set<ForSNode>  forSNodes(SNode anSNode) {
    	Set retVal = new HashSet();    	
    	fillInstancesOfNodeType(ForSNode.class, anSNode, retVal );
    	return retVal;
	}
//    public static void fillForSNodes(SNode anSNode, Set<ForSNode> retVal) {
//    	if (anSNode instanceof ForSNode) {
//    		retVal.add((ForSNode) anSNode);
//		}
//    	for (SNode aChild:anSNode.getChildren()) {
//    		fillForSNodes(aChild, retVal);
//    	}		
//	}
    public static Set<OMPForSNode>  ompForSNodes(SNode anSNode) {
    	Set retVal = new HashSet();    	
    	fillInstancesOfNodeType(OMPForSNode.class, anSNode, retVal );
    	return retVal;
	}
//    public static void fillOMPForSNodes(SNode anSNode, Set<OMPForSNode> retVal) {
//    	if (anSNode instanceof OMPForSNode) {
//    		retVal.add((OMPForSNode) anSNode);
//		}
//    	for (SNode aChild:anSNode.getChildren()) {
//    		fillOMPForSNodes(aChild, retVal);
//    	}		
//	}
    public static Set<OMPForSNode> ompReducingForNodes(SNode anSNode) {
		Set<OMPForSNode> anAllOMPForSNodes =  ompForSNodes(anSNode);
		Set<OMPForSNode> aRetVal = new HashSet();
		for (OMPForSNode anOMPForSNode:anAllOMPForSNodes) {
			if (anOMPForSNode.getReductionOperation() != null) {
				aRetVal.add(anOMPForSNode);
			}
		}
		return aRetVal;		
	}
    public static Set<AssignmentSNode> assignmentsToOMPReducingForNode(OMPForSNode anOMPForSNode) {
    	String aReductionVariable = anOMPForSNode.getReductionVariable();
    	return directAssignmentsOfVariableAndItsAliases(anOMPForSNode, aReductionVariable)	;
    	
    }
	public static boolean dependsOn (SNode anSNode, int aVariableLineNumber, String aVariable, String aCallIdentifier) {
		List<SNode> aListSNodes = anSNode.getChildren();
		boolean retVal = false;
		/*
		 * Should probably ignore line number as it assumes straight line code
		 */
		for (int i = aVariableLineNumber; i >= 0; i--) {
			SNode anSNodeChild = aListSNodes.get(i);
			if (anSNodeChild instanceof AssignmentSNode) {
				// does this statement in anSNode directly invoke aCallIdentifier 
				if (dependsOn((AssignmentSNode) anSNodeChild, aVariable, aCallIdentifier))
					return true;
			} else if (!anSNode.isLeaf()) {
					// child is overriding the variable so forget checking its assignment statements
					if (anSNodeChild.getLocalVariableIdentifiers().contains(aVariable)) {
						continue;
					}
					// some subblock of anSNode that has access to aVariable changes variable

					if (dependsOn(anSNodeChild, anSNodeChild.getChildren().size() - 1, aVariable, aCallIdentifier)) {
						return true;
					}
			}
			
		}
		// none of the statements in anSNode or its descendents  have the required call
		// is the variable a  method parameter 
		if (anSNode instanceof MethodSNode) {
			MethodSNode aMethodSNode = (MethodSNode) anSNode;
			
			int aParameterNumber = aMethodSNode.getLocalVariableIdentifiers().indexOf(aVariable);
			if (aParameterNumber != -1) {
				List <MethodCall> aCalls = aMethodSNode.getCalls();
				for (MethodCall aCall:aCalls) {
//					if (!aCall.getMethodActuals().contains(aVariable))
//						continue;
//					
					MethodSNode aCallerSNode = getDeclarationOfCalledMethod(aMethodSNode, aCall);
					if (dependsOn(aMethodSNode, aCallerSNode.getLineNumber(), aCallerSNode.getLocalVariableIdentifiers().get(aParameterNumber), aCallIdentifier));
//				    if (aCallerDepends) {
				    	return true;
//				    }
				}
				return false;
				// need to find all callers of method and see if any of the aliases for the variable in these
				// calls depend on aCallIndentifier
			}			
			
		} else if (anSNode.getLocalVariableIdentifiers().contains(aVariable)) {
			// before going to the parent node, let us see if aVariable is declared here as a non  parameter 

			return false; // no point going to parent
		}
		// not a local variable (parameter or declarated variable)
		SNode anSNodeParent = anSNode.getParent() ;
		if (anSNodeParent == null)  {
			return false;
		}
		int anSNodeLineNumber = anSNodeParent.getChildren().indexOf(anSNode);
		return dependsOn(anSNodeParent, anSNodeLineNumber, aVariable, aCallIdentifier);
		
	}
	public static Set<AssignmentSNode> assignmentsOfVariableAliases (SNode anSNode,  String aVariable) {
		Set<AssignmentSNode> retVal = new HashSet();
		fillDirectAssignmentsOfVariableAliases(anSNode, aVariable, retVal);
		return retVal;
	}
	public static void fillDirectAssignmentsOfVariableAliases (SNode anSNode,  String aVariable, Set<AssignmentSNode> retVal) {
		if (anSNode instanceof MethodCall) {
			MethodCall aMethodCall = (MethodCall) anSNode;
			int aParameterNumber = aMethodCall.getMethodActualIdentifiers().indexOf(aVariable);
			if (aParameterNumber < 0) {
				return;
			}
			MethodSNode aDeclaringMethodSNode = getDeclarationOfCalledMethod(anSNode, aMethodCall);
			String aFormalParameter = aDeclaringMethodSNode.getLocalVariableIdentifiers().get(aParameterNumber);
//			Set<AssignmentSNode> aCallAssignments = ;
			fillDirectAssignmentsOfVariableAliases(aDeclaringMethodSNode, aFormalParameter, retVal);
		} else {
			List<SNode> aChildren = anSNode.getChildren();
			for (SNode aChild:aChildren) {
				fillDirectAssignmentsOfVariableAliases(aChild, aVariable, retVal);
			}
		}		
		
	}
	
	/*
	 * will not consider assignments to variables in the RHS of these assignments
	 */
	public static Set<AssignmentSNode> directAssignmentsOfVariableAndItsAliases (SNode anSNode,  String aVariable) {
		Set<AssignmentSNode> retVal = new HashSet();
		fillDirectAssignmentsOfVariableAndItsAliases(anSNode, aVariable, retVal);
		return retVal;
	}
	
//	public static Set<AssignmentSNode> assignmentsEffectingVariableAndItsAliases (SNode anSNode,  String aVariable) {
//		Set<AssignmentSNode> retVal = directAssignmentsOfVariableAndItsAliases(anSNode, aVariable);
//		
//	}
	public static void fillDirectAssignmentsOfVariableAndItsAliases (SNode anSNode,  String aVariable, Set<AssignmentSNode> retVal) {
		if (anSNode instanceof AssignmentSNode) {
			AssignmentSNode anAssignmentSNode = (AssignmentSNode) anSNode;
			if (anAssignmentSNode.getLhsFirstIdentifier().equals(aVariable)) {
				retVal.add(anAssignmentSNode);
			}
		}
		
		else if (anSNode instanceof MethodCall) {
			MethodCall aMethodCall = (MethodCall) anSNode;
			int aParameterNumber = aMethodCall.getMethodActualIdentifiers().indexOf(aVariable);
			if (aParameterNumber < 0) {
				return;
			}
			MethodSNode aDeclaringMethodSNode = getDeclarationOfCalledMethod(anSNode, aMethodCall);
			String aFormalParameter = aDeclaringMethodSNode.getLocalVariableIdentifiers().get(aParameterNumber);
//			Set<AssignmentSNode> aCallAssignments = ;
			fillDirectAssignmentsOfVariableAndItsAliases(aDeclaringMethodSNode, aFormalParameter, retVal);
		} else {
			List<SNode> aChildren = anSNode.getChildren();
			for (SNode aChild:aChildren) {
				fillDirectAssignmentsOfVariableAndItsAliases(aChild, aVariable, retVal);
			}
		}		
		
	}
	
	public static RootOfFileSNode getRootOfFileNode(SNode aCurrentSNode ) {
		if (aCurrentSNode instanceof RootOfFileSNode) {
			return (RootOfFileSNode) aCurrentSNode;
		}
		SNode aParentSNode = aCurrentSNode.getParent() ;
		
		if (aParentSNode == null) {
			return null;
		}
		
		return getRootOfFileNode(aParentSNode);
		
	}
	public static boolean match (MethodSNode aMethodSNode, MethodCall aMethodCall) {
		return aMethodSNode.getMethodName().equals(aMethodCall.getMethodName()) 
				&& aMethodSNode.getLocalVariableIdentifiers().size() == aMethodCall.getMethodActuals().size();
	}
	public static DeclarationSNode getDeclarationOfVariableIdentifier(SNode aCurrentSNode, String anIdentifier) {
		if (aCurrentSNode == null) {
			return null;
		}
		
		
		int anIndex = aCurrentSNode.getLocalVariableIdentifiers().indexOf(anIdentifier);
		if (anIndex < 0) {
			return getDeclarationOfVariableIdentifier(aCurrentSNode.getParent(), anIdentifier);
		}
		DeclarationSNode retVal = aCurrentSNode.getVariableDeclarations().get(anIndex);
//		retVal.getAssignmentsToDeclaredVariable().add(anAssignmentSNode);
//		anAssignmentSNode.setLhsFirstIdentifierDeclaration(retVal);
		return retVal;
	}
	
	public static DeclarationSNode getDeclarationOfAssignedVariable(SNode aCurrentSNode, AssignmentSNode anAssignmentSNode) {
		if (aCurrentSNode == null) {
			return null;
		}
		if (anAssignmentSNode instanceof ADeclaringAssignmentSNode) {
			return (ADeclaringAssignmentSNode) anAssignmentSNode;
		}
		int anIndex = aCurrentSNode.getLocalVariableIdentifiers().indexOf(anAssignmentSNode.getLhsFirstIdentifier());
		if (anIndex < 0) {
			return getDeclarationOfAssignedVariable(aCurrentSNode.getParent(), anAssignmentSNode);
		}
		DeclarationSNode retVal = aCurrentSNode.getVariableDeclarations().get(anIndex);
//		retVal.getAssignmentsToDeclaredVariable().add(anAssignmentSNode);
//		anAssignmentSNode.setLhsFirstIdentifierDeclaration(retVal);
		return retVal;
	}
	
	public static MethodSNode getDeclarationOfCalledMethod(SNode aCurrentSNode, MethodCall aMethodCall ) {
		SNode aRootNode = getRootOfFileNode(aCurrentSNode);
		for (SNode aChild:aRootNode.getChildren()) {
			if (aChild instanceof MethodSNode) {
				MethodSNode aMethodSNode = (MethodSNode) aChild;
				if (match (aMethodSNode, aMethodCall)) {
					return aMethodSNode;
				}
			}
		}
		return null; // this should never happen;
	}
	
	public static RootOfProgramSNode getRootOfProgramSNode(String aSource) {
		RootOfProgramSNode retVal = new ARootOfProgramSNode();
		Map<String, StringBuffer> aFileNameToContents = ABasicTextManager.extractFileContents(aSource);
		for (String aFileName:aFileNameToContents.keySet()) {
			StringBuffer aFileContents = aFileNameToContents.get(aFileName);
//			List<OpenMPPragma> anOpenMPPragmas = OpenMPUtils.getOpemMPPragmas(aFileContents);
			RootOfFileSNode anSNode = OMPSNodeUtils.getSNode(aFileName, aFileContents);
			retVal.getFileNameToSNode().put(aFileName, anSNode);
			anSNode.setParent(retVal);
//			System.out.println("file name:" + aFileName);
//			System.out.println("pragmas:" + anSNode);
		}
		processExternalMethodSNodes(retVal);
		processIndirectAssignments(retVal);
		return retVal;
	}
//	public static void processIndirectAssignments (S aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode) {
//		for (SNode anSNode:aRootOfFileSNode.getChildren()) {
//			-----
//		}
//	}
	public static void processExternalMethodSNodes (RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode) {
		for (SNode anSNode:aRootOfFileSNode.getChildren()) {
			if (anSNode instanceof ExternalMethodSNode) {
				processExternalMethodSNode(aRootOfProgramSNode, aRootOfFileSNode, (ExternalMethodSNode) anSNode);
			}
		}
	}
	public static void processExternalMethodSNode (RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode, ExternalMethodSNode anExternalMethodSNode) {
		MethodSNode aMethodSNode = aRootOfProgramSNode.getExternalToInternalMethod().get(anExternalMethodSNode.toString());
		if (aMethodSNode == null) {
			aMethodSNode = findMethodSNode(aRootOfProgramSNode, aRootOfFileSNode, anExternalMethodSNode);
			if (aMethodSNode != null) {
				aRootOfProgramSNode.getExternalToInternalMethod().put(anExternalMethodSNode.toString(),aMethodSNode );
			}
		}
		if (aMethodSNode != null) {
			anExternalMethodSNode.setActualMethodSNode(aMethodSNode);
			aMethodSNode.getCalls().addAll(anExternalMethodSNode.getLocalCalls());
		}
	}
	
	public static MethodSNode findMethodSNode (RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode, ExternalMethodSNode anExternalMethodSNode) {
//		MethodSNode foundMethodSNode = null;
		for (String aFileName:aRootOfProgramSNode.getFileNameToSNode().keySet()) {
			if (aFileName.equals(aRootOfFileSNode.getFileName()))
				continue;
			
			RootOfFileSNode aSearchedRootOfFileSNode = aRootOfProgramSNode.getFileNameToSNode().get(aFileName);
			 for (SNode anSNode:aSearchedRootOfFileSNode.getChildren()) {
				if (anSNode instanceof MethodSNode && !(anSNode instanceof ExternalMethodSNode)) {
					if (anSNode.toString().equals(anExternalMethodSNode.toString())) {
						return (MethodSNode) anSNode;
						
					}
//					processExternalMethodSNode(aRootOfProgramSNode, aRootOfFileSNode, (ExternalMethodSNode) anSNode);
				}
			}
		}
		return null;
	}
	public static void processExternalMethodSNodes (RootOfProgramSNode aRootOfProgramSNode) {
		for (String aFileName:aRootOfProgramSNode.getFileNameToSNode().keySet()) {
			RootOfFileSNode aRootOfFileSNode = aRootOfProgramSNode.getFileNameToSNode().get(aFileName);
			processExternalMethodSNodes(aRootOfProgramSNode, aRootOfFileSNode);
			aRootOfFileSNode.getOmp_get_num_threads_SNode().
				setActualMethodSNode(aRootOfProgramSNode.getOmp_get_num_threads_SNode());
			aRootOfFileSNode.getOmp_get_thread_num_SNode().
				setActualMethodSNode(aRootOfProgramSNode.getOmp_get_thread_num_SNode());
			aRootOfFileSNode.getOmp_get_wtime_SNode().
			setActualMethodSNode(aRootOfProgramSNode.getOmp_get_wtime_SNode());
		}

	}
	public static void processIndirectAssignments (SNode anSNode) {
		if (anSNode instanceof ConstDeclarationSNode) {
			return;
		}
		if (anSNode instanceof DeclarationSNode) {
			DeclarationSNode aDeclarationSNode = (DeclarationSNode) anSNode;
			Set<AssignmentSNode> anIndirectAssignments = aDeclarationSNode.getAssignmentsEffectingDeclaredIdentifier();
			if (anIndirectAssignments != null) {
				return; // already assigned
			}
			anIndirectAssignments = new HashSet<>();
			aDeclarationSNode.setAssignmentsEffectingDeclaredIdentifier(anIndirectAssignments);
			Set<AssignmentSNode> aDirectAssignments = aDeclarationSNode.getAssignmentsToDeclaredVariable();
			anIndirectAssignments.addAll(aDirectAssignments);
			Set<AssignmentSNode> anAliasAssignments = assignmentsOfVariableAliases(aDeclarationSNode.getParent(), aDeclarationSNode.getVariableName());
			anIndirectAssignments.addAll(anAliasAssignments);
			for (AssignmentSNode aDirectAssignment:aDirectAssignments) {
				List<String> aVariableIdentifiers = aDirectAssignment.getRhsVariableIdentifiers();
				
				for (String aVariableIdentifier:aVariableIdentifiers) {
					DeclarationSNode aDependeeDeclarationSNode = getDeclarationOfVariableIdentifier(aDirectAssignment, aVariableIdentifier);
					if (aDependeeDeclarationSNode == null) {
						System.err.println("Could not find declaration of:" + aVariableIdentifier + " referenced in:" + aDirectAssignment );
						continue;
					}
					processIndirectAssignments(aDependeeDeclarationSNode);
					Set<AssignmentSNode> aDependeeIndirectAssignments = aDeclarationSNode.getAssignmentsEffectingDeclaredIdentifier();
					anIndirectAssignments.addAll(aDependeeIndirectAssignments);
					
				}
			}
		} else {
			for (SNode aChild: anSNode.getChildren()) {
				processIndirectAssignments(aChild);
			}
		}
		
	}
	
//	public static void fillIndirectAssignments (SNode anSNode, Set<AssignmentSNode> retVal ) {
//		
//	}
	

//	public static void main(String[] args) {
//		List<MethodCall> aTokens = callsIn("foo(bar, hgf)/foo2()*foo3(b, a c,)");
//		System.out.println(aTokens);
//		
//		
////		List<String> aTokens = identifiersIn("a[i] + b*2/3");
////		System.out.println(aTokens);
////		aTokens = numbersIn("a[i] + b*2/3");
////		System.out.println(aTokens);
////		aTokens = operatorsIn("a[i] + b*2/3");
////		System.out.println(aTokens);
////
////		System.out.println(StringUtils.substringBetween("a", "[", "]"));
//	}

}
]]></snapshot>
  </Command>
  <Command __id="218092" _type="DiffBasedFileOpenCommand" date="Fri Jan 10 10:18:32 EST 2020" docASTNodeCount="305" docActiveCodeLength="2199" docExpressionCount="180" docLength="2357" projectName="GraderBasics" starttimestamp="1576666505112" timestamp="2003007161">
    <filePath><![CDATA[D:\dewan_backup\Java\GraderBasics\src\gradingTools\shared\testcases\openmp\scannedTree\ADeclarationSNode.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package gradingTools.shared.testcases.openmp.scannedTree;¬∂¬∂import java.util.ArrayList;¬∂import java.util.HashSet;¬∂import java.util.List;¬∂import java.util.Set;¬∂¬∂public class ADeclarationSNode extends AnSNode implements DeclarationSNode {¬∂	String variableName;¬∂	¬∂	String typeName;¬∂	List<String> operators;¬∂	¬∂¬∂	String variableIdentifier;¬∂	String typeIdentifier;¬∂	Set<AssignmentSNode> assignmentsToDeclaredVariable = new HashSet();¬∂	Set<AssignmentSNode> assignmentsEffectingDeclaredIdentifier;¬∂¬∂	¬∂	¬∂	public ADeclarationSNode(int aLineNumber, String aTypeName, String aVariableName) {¬∂		super(aLineNumber);¬∂		typeName = aTypeName;¬∂		variableName = aVariableName;¬∂		operators = OMPSNodeUtils.operatorsIn(typeName);¬∂		operators.addAll(OMPSNodeUtils.operatorsIn(typeName));¬∂		variableIdentifier = OMPSNodeUtils.identifiersIn(variableName).get(0);¬∂		typeIdentifier =  OMPSNodeUtils.identifiersIn(typeName).get(0);¬∂	}¬∂	@Override¬∂	public String getTypeName() {¬∂		return typeName;¬∂	}¬∂	@Override¬∂	public void setTypeName(String typeName) {¬∂		this.typeName = typeName;¬∂	}¬∂	@Override¬∂	public String getVariableName() {¬∂		return variableName;¬∂	}¬∂	@Override¬∂	public void setParent(SNode anSNode) {¬∂		super.setParent(anSNode);¬∂		anSNode.getVariableDeclarations().add(this);¬∂//		anSNode.getLocalVariables().add(variableName);¬∂		anSNode.getLocalVariableIdentifiers().add(variableIdentifier);¬∂¬∂	}¬∂	public String toString() {¬∂		return typeName + " " + variableName;¬∂	}¬∂	@Override¬∂	public String getVariableIdentifier() {¬∂		return variableIdentifier;¬∂	}¬∂	¬∂	@Override¬∂	public String getTypeIdentifier() {¬∂		return typeIdentifier;¬∂	}¬∂	@Override¬∂	public List<String> getOperators() {¬∂		return operators;¬∂	}¬∂	@Override¬∂	public Set<AssignmentSNode> getAssignmentsToDeclaredVariable() {¬∂		return assignmentsToDeclaredVariable;¬∂	}¬∂//	@Override¬∂//¬∂//	public void setVariableName(String variableName) {¬∂//		this.variableName = variableName;¬∂//	}¬∂	@Override¬∂	public Set<AssignmentSNode> getAssignmentsEffectingDeclaredIdentifier() {¬∂		return assignmentsEffectingDeclaredIdentifier;¬∂	}¬∂	@Override¬∂	public void setAssignmentsEffectingDeclaredIdentifier(Set<AssignmentSNode> assignmentsEffectingDeclaredIdentifier) {¬∂		this.assignmentsEffectingDeclaredIdentifier = assignmentsEffectingDeclaredIdentifier;¬∂	}¬∂}¬∂")]]]></diff>
  </Command>
  <Command __id="218096" _type="DiffBasedFileOpenCommand" date="Fri Jan 10 10:18:33 EST 2020" docASTNodeCount="5134" docActiveCodeLength="37675" docExpressionCount="3174" docLength="43794" projectName="GraderBasics" starttimestamp="1576666505112" timestamp="2003008766">
    <filePath><![CDATA[D:\dewan_backup\Java\GraderBasics\src\gradingTools\shared\testcases\openmp\scannedTree\OMPSNodeUtils.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package gradingTools.shared.testcases.openmp.scannedTree;¬∂¬∂import java.util.ArrayList;¬∂import java.util.Arrays;¬∂import java.util.HashMap;¬∂import java.util.HashSet;¬∂import java.util.List;¬∂import java.util.Map;¬∂import java.util.Set;¬∂import java.util.Stack;¬∂import java.util.regex.Matcher;¬∂import java.util.regex.Pattern;¬∂¬∂import org.apache.commons.lang.StringUtils;¬∂¬∂import grader.basics.project.source.ABasicTextManager;¬∂import gradingTools.shared.testcases.openmp.OpenMPKeywordEnum;¬∂import gradingTools.shared.testcases.openmp.OpenMPParallelPragma;¬∂import gradingTools.shared.testcases.openmp.OpenMPUtils;¬∂import gradingTools.shared.testcases.openmp.scannedTree.ADeclarationSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.ADeclaringAssignmentSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.AForSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.ATextSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.AnAssignmentSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.AnOMPCriticalSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.AnOMPForSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.AnOMPParallelSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.AnOMPSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.AnSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.AssignmentSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.DeclarationSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.DeclaringAssignmentSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.ForSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.OMPForSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.OMPSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.SNode;¬∂¬∂public class OMPSNodeUtils extends OpenMPUtils {¬∂¬∂	public static RootOfFileSNode getSNode(String aFileName, StringBuffer aFileBuffer) {¬∂		String[] aFileLines = aFileBuffer.toString().split("\n");¬∂		return getSNode(aFileName, aFileLines);¬∂	}¬∂¬∂	public static AssignmentSNode getAssignmentSNode(int aLineNumber, String aString) {¬∂		if (aString == null) {¬∂			return null;¬∂		}¬∂		String[] aTokens = aString.split("=");¬∂		if (aTokens.length == 1) {¬∂			return new AnAssignmentSNode(aLineNumber, aTokens[0], null);¬∂		} else {¬∂		return new AnAssignmentSNode(aLineNumber, aTokens[0], aTokens[1]);¬∂		}¬∂	}¬∂¬∂	public static DeclarationSNode getDeclarationSNode(int aLineNumber, String aString) {¬∂		String[] aTokens = aString.split(" ");¬∂		return new ADeclarationSNode(aLineNumber, aTokens[0], aTokens[1]);¬∂	}¬∂¬∂	public static DeclaringAssignmentSNode getDeclaringAssignmentSNode(int aLineNumber, String aString) {¬∂		String[] anLHSAndRHS = aString.split("=");¬∂		String[] aTypeAndVariable = anLHSAndRHS[0].split(" ");¬∂		return new ADeclaringAssignmentSNode(aLineNumber, aTypeAndVariable[0], aTypeAndVariable[1], anLHSAndRHS[1]);¬∂	}¬∂	public static ConstDeclarationSNode getConstDeclarationSNode(int aLineNumber, String aString) {¬∂		String anAssignmentString = aString.substring(CONST.length()).trim();¬∂		String[] anLHSAndRHS = anAssignmentString.split("=");¬∂		String[] aTypeAndVariable = anLHSAndRHS[0].split(" ");¬∂		return new AConstDeclarationSNode(aLineNumber, aTypeAndVariable[0], aTypeAndVariable[1], anLHSAndRHS[1]);¬∂	}¬∂¬∂	public static boolean isDeclaringAssignment(String aFileLine) {¬∂		return startsWithTypeName(aFileLine) && aFileLine.contains("=");¬∂	}¬∂	public static boolean isConstDeclaration(String aFileLine) {¬∂		return aFileLine.startsWith(CONST);¬∂	}¬∂	public static boolean isMethodDeclaration(String aFileLine) {¬∂		return startsWithTypeName(aFileLine) && ¬∂				aFileLine.contains("(") &&¬∂				!aFileLine.contains("=");¬∂	}¬∂	public static boolean isExternalMethodDeclaration(String aFileLine) {¬∂		return isMethodDeclaration(aFileLine) && aFileLine.endsWith(";");¬∂	}¬∂¬∂¬∂	public static boolean isVariableDeclaration(String aFileLine) {¬∂¬∂		return startsWithTypeName(aFileLine) && !aFileLine.contains("(");¬∂	}¬∂¬∂	public static boolean isAssignment(String aFileLine) {¬∂		return aFileLine.contains("=") && !aFileLine.contains("==");¬∂	}¬∂¬∂	public static boolean isForNode(String aFileLine) {¬∂		return aFileLine.startsWith("for");¬∂	}¬∂¬∂	public static ForSNode getForSNode(int aLineNumber, String aFileLine) {¬∂¬∂		int aLeftParenIndex = aFileLine.indexOf("(");¬∂		int aRightParenIndex = aFileLine.indexOf(")");¬∂		if (aLeftParenIndex < 0 || aRightParenIndex < 0) {¬∂			return null;¬∂		}¬∂		String aHeaderString = aFileLine.substring(aLeftParenIndex + 1, aRightParenIndex);¬∂		String[] aForComponents = aHeaderString.split(";");¬∂		AssignmentSNode anAssignmentSNode = null;¬∂		String aForInitializaton = aForComponents[0];¬∂		if (!aForInitializaton.isEmpty() && aForInitializaton.contains("=")) {¬∂			if (isDeclaringAssignment(aForInitializaton)) {¬∂				anAssignmentSNode = getDeclaringAssignmentSNode(aLineNumber, aForInitializaton);¬∂			} else {¬∂				anAssignmentSNode = getAssignmentSNode(aLineNumber, aForInitializaton);¬∂			}¬∂¬∂		}		¬∂		return new AForSNode(aLineNumber, anAssignmentSNode, aForComponents[1], getAssignmentSNode(aLineNumber, aForComponents[2]));¬∂	}¬∂	static String[] emptyArray = {};¬∂	public static MethodSNode getMethodSNode(int aLineNumber, String aFileLine, boolean isInternal) {¬∂¬∂		int aLeftParenIndex = aFileLine.indexOf("(");¬∂		int aRightParenIndex = aFileLine.indexOf(")");¬∂		if (aLeftParenIndex < 0 || aRightParenIndex < 0) {¬∂			return null;¬∂		}¬∂		String aMethodNameAndType = aFileLine.substring(0, aLeftParenIndex);¬∂		String[] aMethodNameAndTypeTokens = aMethodNameAndType.split("\\s+"); ¬∂		¬∂		String aMethodParameters = aFileLine.substring(aLeftParenIndex +1 , aRightParenIndex);¬∂		String[] aMethodParameterTokens = aMethodParameters.isEmpty()?emptyArray:¬∂		 aMethodParameters.split(",");¬∂		¬∂//		String[] aMethodParameterTypes = new String[aMethodParameterTokens.length];¬∂//		String[] aMethodParameterNames = new String[aMethodParameterTokens.length];¬∂		List<DeclarationSNode> aDeclarationSNodeList = new ArrayList();¬∂		for (int i = 0; i < aMethodParameterTokens.length; i++ ) {¬∂			String[] aTypeAndName = aMethodParameterTokens[i].trim().split("\\s+");¬∂			if (aTypeAndName.length < 2) {¬∂				continue;¬∂			}¬∂			aDeclarationSNodeList.add(new ADeclarationSNode(aLineNumber, aTypeAndName[0].trim(), aTypeAndName[1].trim()));¬∂//			aMethodParameterTypes[i] = aTypeAndName[0].trim();¬∂//			aMethodParameterNames[i] = aTypeAndName[1].trim();¬∂		}¬∂		if (isInternal)¬∂//		return new AMethodSNode(aLineNumber, aMethodNameAndTypeTokens[0], aMethodNameAndTypeTokens[1], aMethodParameterTypes,aMethodParameterNames );¬∂			return new AMethodSNode(aLineNumber, aMethodNameAndTypeTokens[0], aMethodNameAndTypeTokens[1], aDeclarationSNodeList );¬∂		else¬∂			return new AnExternalMethodSNode(aLineNumber, aMethodNameAndTypeTokens[0], aMethodNameAndTypeTokens[1], aDeclarationSNodeList );¬∂	}¬∂¬∂	public static void setReductionData(OMPForSNode lastChild, String aStoredToken, int aLeftParenIndex,¬∂			int aRightParenIndex) {¬∂		int aColonIndex = aStoredToken.indexOf(":");¬∂		if (aLeftParenIndex != -1 && aRightParenIndex != -1 && aColonIndex != -1) {¬∂			String anOperationString = aStoredToken.substring(aLeftParenIndex + 1, aColonIndex).trim();¬∂			String aVariableString = aStoredToken.substring(aColonIndex + 1, aRightParenIndex).trim();¬∂			((OMPForSNode) lastChild).setReductionVariable(aVariableString);¬∂			((OMPForSNode) lastChild).setReductionOperation(anOperationString);¬∂		}¬∂	}¬∂¬∂	public static void setSharedOrPrivateData(OMPSNode lastChild, String aStoredToken, int aLeftParenIndex,¬∂			int aRightParenIndex, boolean isShared) {¬∂//		int aColonIndex = aStoredToken.indexOf(":");¬∂		if (aLeftParenIndex != -1 && aRightParenIndex != -1) {¬∂			String aVariableDeclarations = aStoredToken.substring(aLeftParenIndex + 1, aRightParenIndex);¬∂			String[] aVariables = aVariableDeclarations.split(",");¬∂			if (isShared) {¬∂				lastChild.setSharedVariables(aVariables);¬∂			} else {¬∂				lastChild.setPrivateVariables(aVariables);¬∂			}¬∂		}¬∂	}¬∂¬∂	public static RootOfFileSNode getSNode(String aFileName, String[] aFileLines) {¬∂		Stack<SNode> anSNodes = new Stack();¬∂¬∂		RootOfFileSNode retVal = new ARootOfFileSNode(aFileName);¬∂		anSNodes.add(retVal);¬∂		SNode previousHeaderNode = null;¬∂		for (int i = 0; i < aFileLines.length; i++) {¬∂			String aFileLine = aFileLines[i].trim();¬∂			if (!isCodeLine(aFileLine)) {¬∂				continue;¬∂			}¬∂			if (isForNode(aFileLine)) {¬∂				ForSNode aForSNode = getForSNode(i, aFileLine);¬∂				SNode aParent = previousHeaderNode != null?previousHeaderNode:anSNodes.peek();¬∂				aForSNode.setParent(anSNodes.peek());¬∂				aForSNode.setParent(aParent);¬∂¬∂//				anSNodes.push(aForSNode);¬∂				previousHeaderNode = aForSNode;¬∂				if (aFileLine.endsWith(")")) {¬∂					continue;¬∂				}¬∂			}¬∂			if (isExternalMethodDeclaration(aFileLine)) {¬∂				MethodSNode aMethodSNode = getMethodSNode(i, aFileLine, false);¬∂				aMethodSNode.setParent(anSNodes.peek());¬∂//				anSNodes.push(aForSNode);¬∂				previousHeaderNode = aMethodSNode;¬∂				if (aFileLine.endsWith(")")) {¬∂					continue;¬∂				}¬∂			}¬∂			if (isMethodDeclaration(aFileLine)) {¬∂				MethodSNode aMethodSNode = getMethodSNode(i, aFileLine, true);¬∂				aMethodSNode.setParent(anSNodes.peek());¬∂//				anSNodes.push(aForSNode);¬∂				previousHeaderNode = aMethodSNode;¬∂				if (aFileLine.endsWith(")")) {¬∂					continue;¬∂				}¬∂			}¬∂			if (isPragmaStart(aFileLine)) {¬∂				OMPSNode anOMPSNode = getOMPSNode(i, anSNodes.peek(), aFileLine);¬∂//				anSNodes.push(anOMPSNode);¬∂				previousHeaderNode = anOMPSNode;¬∂				continue;¬∂			}¬∂			if (isBlockStart(aFileLine)) {¬∂				SNode aBlockSNode = new ABlockSNode(i);¬∂				if (previousHeaderNode != null) {¬∂					aBlockSNode.setParent(previousHeaderNode);¬∂				} else {¬∂					aBlockSNode.setParent(anSNodes.peek());¬∂				}¬∂				anSNodes.push(aBlockSNode);¬∂				previousHeaderNode = null;¬∂				continue;¬∂			}¬∂//			} else ¬∂			if (isBlockEnd(aFileLine)) {¬∂				anSNodes.pop();¬∂				continue;¬∂			}¬∂			SNode aNewLeafNode = null;¬∂			if (isConstDeclaration(aFileLine)) {¬∂				aNewLeafNode = getConstDeclarationSNode(i, aFileLine);¬∂¬∂			} else if (isDeclaringAssignment(aFileLine)) {¬∂				aNewLeafNode = getDeclaringAssignmentSNode(i, aFileLine);¬∂¬∂			} else if (isAssignment(aFileLine)) {¬∂				aNewLeafNode = getAssignmentSNode(i, aFileLine);¬∂			} else if (isVariableDeclaration(aFileLine)) {¬∂				aNewLeafNode = getDeclarationSNode(i, aFileLine);¬∂			} else {¬∂				List<MethodCall> aCalls = callsIn(i, aFileLine, null); // parent will be assigned below¬∂				if (aCalls != null && aCalls.size() == 1) {¬∂					aNewLeafNode = aCalls.get(0);¬∂				} else {¬∂					aNewLeafNode = new ATextSNode(i, aFileLine);¬∂				}¬∂			}¬∂//			else {¬∂//				aNewLeafNode = new ATextSNode(i, aFileLine);¬∂//			}¬∂			if (previousHeaderNode != null) {¬∂				aNewLeafNode.setParent(previousHeaderNode);¬∂			} else {¬∂				aNewLeafNode.setParent(anSNodes.peek());¬∂			}¬∂¬∂		}¬∂¬∂		return retVal;¬∂	}¬∂¬∂	public static OMPSNode getOMPSNode(int aLineIndex, SNode aParentNode, String aFileLine) {¬∂		String[] aTokens = aFileLine.split("\\s+");¬∂		if (aTokens.length <= 2) {¬∂			return null;¬∂		}¬∂		if (!aTokens[1].equals("omp")) {¬∂			return null;¬∂		}¬∂		if (aTokens.length < 3) {¬∂			return null;¬∂		}¬∂		String aFirstToken = aTokens[2];¬∂		OpenMPKeywordEnum anOpenMPKeyword = stringToOpenMPKeyword.get(aFirstToken);¬∂//		List<OpenMPPragma> retVal = new ArrayList();¬∂		OMPSNode lastChild = null;¬∂		int aStartIndex = 2;¬∂		OMPSNode aNewNode = null;¬∂		OMPForSNode aForChild = null;¬∂		switch (anOpenMPKeyword) {¬∂		case PARALLEL:¬∂			aNewNode = new AnOMPParallelSNode(aLineIndex);¬∂¬∂			if (aTokens.length > 3 && aTokens[3].equals("for")) {¬∂				aForChild = new AnOMPForSNode(aLineIndex);¬∂				aForChild.setParent(aNewNode);¬∂¬∂				aStartIndex++;¬∂			}¬∂			break;¬∂		case FOR:¬∂			aNewNode = new AnOMPForSNode(aLineIndex);¬∂			;¬∂			break;¬∂		case CRITICAL:¬∂			aNewNode = new AnOMPCriticalSNode(aLineIndex);¬∂//			retVal.add (lastChild);¬∂			break;¬∂		default:¬∂			aNewNode = new AnOMPSNode(aLineIndex);¬∂¬∂		}¬∂¬∂		if (lastChild != null) {¬∂			aNewNode.setParent(lastChild);¬∂		} else {¬∂			aNewNode.setParent(aParentNode);¬∂		}¬∂		lastChild = aForChild == null ? aNewNode : aForChild;¬∂¬∂		for (int i = aStartIndex; i < aTokens.length; i++) {¬∂			String aStoredToken = aTokens[i].trim();¬∂			if (aStoredToken.isEmpty()) {¬∂				continue;¬∂			}¬∂			if (aStoredToken.startsWith("reduction") || aStoredToken.startsWith("shared")¬∂					|| aStoredToken.startsWith("private")) {¬∂				// combine all tokens until ")" into one for normalization¬∂				while (!aStoredToken.endsWith(")")) {¬∂					i++;¬∂					if (i >= aTokens.length) {¬∂						break;¬∂					}¬∂					String aNewToken = aTokens[i].trim();¬∂					aStoredToken += aNewToken;¬∂				}¬∂				int aLeftParenIndex = aStoredToken.indexOf("(");¬∂				int aRightParenIndex = aStoredToken.indexOf(")");¬∂				if (aStoredToken.startsWith("reduction")) {¬∂					setReductionData((OMPForSNode) lastChild, aStoredToken, aLeftParenIndex, aRightParenIndex);¬∂				} else if (aStoredToken.startsWith("private")) {¬∂					setSharedOrPrivateData((OMPSNode) lastChild, aStoredToken, aLeftParenIndex, aRightParenIndex,¬∂							false);¬∂¬∂				} else if (aStoredToken.startsWith("shared")) {¬∂					setSharedOrPrivateData(lastChild, aStoredToken, aLeftParenIndex, aRightParenIndex, true);¬∂¬∂				}¬∂¬∂			}¬∂¬∂			lastChild.getOpenMPTokens().add(aStoredToken);¬∂		}¬∂¬∂		return lastChild;¬∂¬∂	}¬∂¬∂	public static boolean hasParallelAncestor(SNode anSNode) {¬∂		if (anSNode == null) {¬∂			return false;¬∂		}¬∂		if (anSNode instanceof OMPParallelSNode) {¬∂			return true;¬∂		}¬∂		return hasParallelAncestor(anSNode.getParent());¬∂	}¬∂	public static boolean hasCriticalAncestor(SNode anSNode) {¬∂		if (anSNode == null) {¬∂			return false;¬∂		}¬∂		if (anSNode instanceof OMPCriticalSNode) {¬∂			return true;¬∂		}¬∂		return hasCriticalAncestor(anSNode.getParent());¬∂	}¬∂¬∂¬∂	public static Boolean isDeclaredShared(OMPSNode anOMPSNode, String anLHS) {¬∂		if (Arrays.asList(anOMPSNode.getSharedVariables()).contains(anLHS)) {¬∂			return true;¬∂		}¬∂		if (Arrays.asList(anOMPSNode.getPrivateVariables()).contains(anLHS)) {¬∂			return false;¬∂		}¬∂		return null;¬∂¬∂	}¬∂¬∂	public static boolean isSharedVariable(SNode anSNode, String anLHS) {¬∂		if (anSNode == null) {¬∂			return false;¬∂		}¬∂		if (anSNode.getLocalVariableIdentifiers().contains(anLHS)) {¬∂			if (!(anSNode instanceof OMPSNode)) { // no shared and private declarations¬∂				return !hasParallelAncestor(anSNode); // shared if not inParallel¬∂			}¬∂			OMPSNode anOMPSNode = (OMPSNode) anSNode;¬∂			return (Arrays.asList(anOMPSNode.getSharedVariables()).contains(anLHS)); // private unless declared shared¬∂		}¬∂		if (anSNode instanceof OMPSNode) {¬∂			OMPSNode anOMPSNode = (OMPSNode) anSNode;¬∂			// the variable is global to this scope, check if it has have been made shared¬∂			// or private by this scope¬∂			Boolean isDeclaredShared = isDeclaredShared(anOMPSNode, anLHS);¬∂			if (isDeclaredShared != null) {¬∂				return isDeclaredShared;¬∂			}¬∂		}¬∂		// check the parent¬∂		return isSharedVariable(anSNode.getParent(), anLHS);¬∂	}¬∂¬∂	public static List<SNode> getAllLeafNodes(SNode aTopNode) {¬∂		List<SNode> retVal = new ArrayList();¬∂		addLeafNodes(aTopNode, retVal);¬∂		return retVal;¬∂	}¬∂¬∂	public static void addLeafNodes(SNode aTopNode, List<SNode> retVal) {¬∂		for (SNode aChild : aTopNode.getChildren()) {¬∂			if (aChild.isLeaf()) {¬∂				retVal.add(aChild);¬∂			} else {¬∂				addLeafNodes(aChild, retVal);¬∂			}¬∂		}¬∂	}¬∂¬∂	public static List<SNode> getNonParallelLeafNodes(SNode aTopNode) {¬∂		List<SNode> retVal = new ArrayList();¬∂		addNonParallelLeafNodes(aTopNode, retVal);¬∂		return retVal;¬∂	}¬∂¬∂	public static void addNonParallelLeafNodes(SNode aTopNode, List<SNode> retVal) {¬∂		if (aTopNode.isInParallel()) {¬∂			return;¬∂		}¬∂		for (SNode aChild : aTopNode.getChildren()) {¬∂			if (aChild.isLeaf()) {¬∂				retVal.add(aChild);¬∂			} else {¬∂				addLeafNodes(aChild, retVal);¬∂			}¬∂		}¬∂	}¬∂	static String callRegex = "([a-zA-Z_$][a-zA-Z_$0-9]*)\\(.*?\\)";¬∂	static Pattern callPattern = Pattern.compile(callRegex);¬∂¬∂	static String identifierRegex = "[a-zA-Z_$][a-zA-Z_$0-9]*";¬∂	static Pattern identifierPattern = Pattern.compile(identifierRegex);¬∂	public static List<String> identifiersIn(String aString) {¬∂		if (aString == null)¬∂			return null;¬∂//		Pattern mypattern = Pattern.compile("[a-zA-Z_$][a-zA-Z_$0-9]*");¬∂//		Matcher mymatcher = mypattern.matcher(aString);¬∂		Matcher mymatcher = identifierPattern.matcher(aString);¬∂		List<String> retVal = new ArrayList();¬∂		while (mymatcher.find()) {¬∂			String find = mymatcher.group(0);¬∂			retVal.add(find);¬∂		}¬∂		return retVal;¬∂	}¬∂	public static List<MethodCall> callsIn(int aLineNumber, String aString, SNode aParent) {¬∂		if (aString == null)¬∂			return emptyList;¬∂		if (isMethodDeclaration(aString)) {¬∂			return emptyList;¬∂		}¬∂//		Pattern mypattern = Pattern.compile("[a-zA-Z_$][a-zA-Z_$0-9]*");¬∂//		Matcher mymatcher = mypattern.matcher(aString);¬∂		Matcher mymatcher = callPattern.matcher(aString);¬∂		List<MethodCall> retVal = new ArrayList();¬∂		while (mymatcher.find()) {¬∂			String find = mymatcher.group(0);¬∂			int aLeftParenIndex = find.indexOf("(");¬∂			int aRightParenIndex = find.indexOf(")");¬∂			String aMethodName = find.substring(0, aLeftParenIndex).trim();¬∂			String aParameters = find.substring(aLeftParenIndex + 1, aRightParenIndex);¬∂			List<String> aParameterList = new ArrayList();¬∂			String[] aParameterTokens = aParameters.split(",");¬∂			for (String aParameter:aParameterTokens) {¬∂				String aParameterTrimmed = aParameter.trim();¬∂				if (!aParameterTrimmed.isEmpty())¬∂				aParameterList.add(aParameterTrimmed);¬∂			}¬∂			retVal.add(new AMethodCall(aLineNumber, aMethodName, aParameterList, aParent));¬∂¬∂//			aCallStrings.add(find);¬∂		}¬∂		return retVal;¬∂	}¬∂	static String numberRegex = "(\\d+\\.\\d+)|(\\d+)";¬∂	static Pattern numberPattern = Pattern.compile(numberRegex);¬∂	public static List<String> numbersIn(String aString) {¬∂		if (aString == null)¬∂			return null;¬∂//		String regex = "(\\d+\\.\\d+)|(\\d+)";¬∂//¬∂//		Matcher m = Pattern.compile(regex).matcher(aString);¬∂		Matcher m =numberPattern.matcher(aString);¬∂¬∂¬∂		List<String> retVal = new ArrayList();¬∂¬∂		while (m.find()) {¬∂			retVal.add(m.group());¬∂		}¬∂		return retVal;¬∂	}¬∂¬∂	public static String subscriptIn(String aString) {¬∂		if (aString == null)¬∂			return null;¬∂		return StringUtils.substringBetween(aString, "[", "]");¬∂	}¬∂	static String[] emptyStringArray = {};¬∂	static List emptyList = new ArrayList();¬∂¬∂	public static String[] subscriptsIn(String aString) {¬∂		if (aString == null)¬∂			return emptyStringArray;¬∂		return StringUtils.substringsBetween(aString, "[", "]");¬∂	}¬∂	static  String operatorRegex = "([+-/*///^])|([/(/)])";¬∂	static Pattern operatorPattern = Pattern.compile(operatorRegex);¬∂¬∂	public static List<String> operatorsIn(String aString) {¬∂		if (aString == null)¬∂			return null;¬∂//		String operatorRegex = "([+-/*///^])|([/(/)])";¬∂//¬∂//		Matcher m = Pattern.compile(operatorRegex).matcher(aString);¬∂		¬∂		Matcher m = operatorPattern.matcher(aString);¬∂¬∂¬∂		List<String> retVal = new ArrayList();¬∂¬∂		while (m.find()) {¬∂			retVal.add(m.group());¬∂		}¬∂		return retVal;¬∂	}¬∂	¬∂	public static int numberOfNestingFors (SNode anSNode) {¬∂		if (anSNode == null) {¬∂			return 0;¬∂		}¬∂		int retVal = numberOfNestingFors (anSNode.getParent()) ;¬∂¬∂		if (anSNode instanceof ForSNode) {¬∂			retVal++;¬∂		} else if (anSNode instanceof MethodSNode) {¬∂			List<MethodCall> aMethodCalls = ((MethodSNode) anSNode).getCalls();¬∂			int aMaxNestingLevel = 0;¬∂			for (MethodCall aMethodCall:aMethodCalls) {¬∂				MethodSNode aCallerMethodSNode = getDeclarationOfCalledMethod(anSNode, aMethodCall);¬∂				int aCallerNumberOfNestingFors = numberOfNestingFors(aCallerMethodSNode);¬∂				aMaxNestingLevel = Math.max(aCallerNumberOfNestingFors, aMaxNestingLevel);				¬∂			}¬∂			return retVal + aMaxNestingLevel;¬∂		}¬∂		return retVal;¬∂	}¬∂	public static boolean hasOperator (SNode anSNode, String anOperator) {¬∂		boolean retVal = false;¬∂		if (anSNode instanceof AssignmentSNode) {¬∂			AssignmentSNode anAssignmentSNode = (AssignmentSNode) anSNode;¬∂			 retVal = (anAssignmentSNode.getLhsOperators().contains(anOperator) || ¬∂					anAssignmentSNode.getRhsOperators().contains(anOperator)) ;¬∂			if (retVal) {¬∂				return retVal;¬∂			} else {¬∂				List<MethodCall> aMethodCalls = anAssignmentSNode.getRhsCalls();¬∂				for (MethodCall aMethodCall:aMethodCalls) {¬∂					MethodSNode aMethodSNode = getDeclarationOfCalledMethod(anSNode, aMethodCall);¬∂					retVal = hasOperator(aMethodSNode, anOperator);¬∂					if (retVal) {¬∂						return retVal;¬∂					}¬∂					¬∂				}¬∂				return false;¬∂			}¬∂			¬∂		}¬∂		for (SNode aChild:anSNode.getChildren()) {¬∂			retVal = hasOperator(aChild, anOperator);¬∂			if (retVal) {¬∂				return retVal;¬∂			}¬∂		}¬∂		return false;¬∂	}¬∂	public static boolean hasMethodCall (SNode anSNode, String anOperator) {¬∂		boolean retVal = false;¬∂		if (anSNode instanceof AssignmentSNode) {¬∂			AssignmentSNode anAssignmentSNode = (AssignmentSNode) anSNode;¬∂			 retVal = (anAssignmentSNode.getLhsOperators().contains(anOperator) || ¬∂					anAssignmentSNode.getRhsOperators().contains(anOperator)) ;¬∂			if (retVal) {¬∂				return retVal;¬∂			} else {¬∂				List<MethodCall> aMethodCalls = anAssignmentSNode.getRhsCalls();¬∂				for (MethodCall aMethodCall:aMethodCalls) {¬∂					MethodSNode aMethodSNode = getDeclarationOfCalledMethod(anSNode, aMethodCall);¬∂					retVal = hasOperator(aMethodSNode, anOperator);¬∂					if (retVal) {¬∂						return retVal;¬∂					}¬∂					¬∂				}¬∂				return false;¬∂			}¬∂			¬∂		}¬∂		for (SNode aChild:anSNode.getChildren()) {¬∂			retVal = hasOperator(aChild, anOperator);¬∂			if (retVal) {¬∂				return retVal;¬∂			}¬∂		}¬∂		return false;¬∂	}¬∂	public static boolean dependsOn (AssignmentSNode anAssignmentSNode, String aVariable, String aCallIdentifier) {¬∂		// This assignment does not change aVariable¬∂		if (!aVariable.equals(anAssignmentSNode.getLhsFirstIdentifier())) {¬∂			return false;¬∂		}¬∂		return dependsOn(anAssignmentSNode.getExpressionSNode(), aCallIdentifier);¬∂//		List<String> aCallIdentifiers = anAssignmentSNode.getRhsCallIdentifiers();¬∂//		boolean retVal = false;¬∂//		if (aCallIdentifiers != null && aCallIdentifiers.contains(aCallIdentifier)) {¬∂//			return true; // this assignment has aCallIdentifier in the rhs¬∂//		}¬∂//		// check if some referenced rhs variable depends on aCallIdentifier¬∂//		List<String> aReferencedVariableIdentifiers = anAssignmentSNode.getRhsVariableIdentifiers();¬∂//		SNode anAssignmentParent = anAssignmentSNode.getParent();¬∂//		if (anAssignmentParent == null) { // should never be trye¬∂//			return false;¬∂//		}¬∂//		int aLineNumber = anAssignmentSNode.getLineNumber();¬∂//		for (String aReferencedVariableIdentifier:aReferencedVariableIdentifiers ) {¬∂//			if (dependsOn (anAssignmentParent, aLineNumber, aReferencedVariableIdentifier, aCallIdentifier)) {¬∂//				return true;¬∂//			}¬∂//		}¬∂//		return false;¬∂	}¬∂	public static boolean dependsOn (ExpressionSNode anExpressionSNode, String aCallIdentifier) {¬∂		// This assignment does not change aVariable¬∂		¬∂		List<String> aCallIdentifiers = anExpressionSNode.getRhsCallIdentifiers();¬∂		boolean retVal = false;¬∂		if (aCallIdentifiers != null && aCallIdentifiers.contains(aCallIdentifier)) {¬∂			return true; // this assignment has aCallIdentifier in the rhs¬∂		}¬∂		// check if some referenced rhs variable depends on aCallIdentifier¬∂		List<String> aReferencedVariableIdentifiers = anExpressionSNode.getRhsVariableIdentifiers();¬∂		SNode anAssignmentParent = anExpressionSNode.getParent().getParent();¬∂		if (anAssignmentParent == null) { // should never be trye¬∂			return false;¬∂		}¬∂		int aLineNumber = anExpressionSNode.getLineNumber();¬∂		for (String aReferencedVariableIdentifier:aReferencedVariableIdentifiers ) {¬∂			if (dependsOn (anAssignmentParent, aLineNumber, aReferencedVariableIdentifier, aCallIdentifier)) {¬∂				return true;¬∂			}¬∂		}¬∂		return false;¬∂	}¬∂	public static Set<AssignmentSNode> assignmentsToSharedVariables(SNode anSNode) {¬∂		Set<AssignmentSNode> retVal =  new HashSet();¬∂		fillAssignmentsToShared(anSNode, retVal);¬∂		return retVal;¬∂		¬∂	}¬∂	public static Set<AssignmentSNode> assignmentsToSharedArrays(SNode anSNode) {¬∂		Set<AssignmentSNode> anAllSharedAssignments =  assignmentsToSharedVariables(anSNode);¬∂		Set<AssignmentSNode> aRetVal = new HashSet();¬∂		for (AssignmentSNode anAssignmentSNode:anAllSharedAssignments) {¬∂			if (anAssignmentSNode.getLhsSubscripts().length > 0) {¬∂				aRetVal.add(anAssignmentSNode);¬∂			}¬∂		}¬∂		return aRetVal;¬∂		¬∂	}¬∂	public static Set<AssignmentSNode> assignmentsToParallelCriticalSharedVariables(SNode anSNode) {¬∂		Set<AssignmentSNode> anAllSharedAssignments =  assignmentsToSharedVariables(anSNode);¬∂		Set<AssignmentSNode> aRetVal = new HashSet();¬∂		for (AssignmentSNode anAssignmentSNode:anAllSharedAssignments) {¬∂			if (anAssignmentSNode.isInParallel() &&¬∂					anAssignmentSNode.isInCritical()) {¬∂				aRetVal.add(anAssignmentSNode);¬∂			}¬∂		}¬∂		return aRetVal;¬∂		¬∂	}¬∂	public static Set<AssignmentSNode> assignmentsToNonParallelCriticalSharedVariables(SNode anSNode) {¬∂		Set<AssignmentSNode> anAllSharedAssignments =  assignmentsToSharedVariables(anSNode);¬∂		Set<AssignmentSNode> aRetVal = new HashSet();¬∂		for (AssignmentSNode anAssignmentSNode:anAllSharedAssignments) {¬∂			if (!anAssignmentSNode.isInParallel() &&¬∂					anAssignmentSNode.isInCritical()) {¬∂				aRetVal.add(anAssignmentSNode);¬∂			}¬∂		}¬∂		return aRetVal;¬∂		¬∂	}¬∂	public static Set<AssignmentSNode> assignmentsToParallelNonCriticalSharedVariables(SNode anSNode) {¬∂		Set<AssignmentSNode> anAllSharedAssignments =  assignmentsToSharedVariables(anSNode);¬∂		Set<AssignmentSNode> aRetVal = new HashSet();¬∂		for (AssignmentSNode anAssignmentSNode:anAllSharedAssignments) {¬∂			if (anAssignmentSNode.isInParallel() &&¬∂					!anAssignmentSNode.isInCritical()) {¬∂				aRetVal.add(anAssignmentSNode);¬∂			}¬∂		}¬∂		return aRetVal;¬∂		¬∂	}¬∂    public static void fillAssignmentsToShared(SNode anSNode, Set<AssignmentSNode> retVal) {¬∂    	if (anSNode instanceof AssignmentSNode) {¬∂			AssignmentSNode anAssignmentSNode = (AssignmentSNode) anSNode;¬∂			String anLHS = anAssignmentSNode.getLhsFirstIdentifier();¬∂			if (isSharedVariable(anSNode, anLHS)) {¬∂				retVal.add(anAssignmentSNode);¬∂				return;¬∂			}¬∂		}¬∂    	for (SNode aChild:anSNode.getChildren()) {¬∂    		fillAssignmentsToShared(aChild, retVal);¬∂    	}¬∂		¬∂	}¬∂    public static void fillInstancesOfNodeType(Class<? extends SNode> aNodeType, SNode anSNode, Set<SNode> retVal) {¬∂    	if (aNodeType.isAssignableFrom(anSNode.getClass())) {¬∂			¬∂				retVal.add(anSNode);¬∂				return;¬∂			}¬∂		¬∂    	for (SNode aChild:anSNode.getChildren()) {¬∂    		fillInstancesOfNodeType(aNodeType, aChild, retVal);¬∂    	}¬∂		¬∂	}¬∂    public static Set<AssignmentSNode>  assignmentSNodes(SNode anSNode) {¬∂    	Set retVal = new HashSet();    	¬∂    	fillInstancesOfNodeType(AssignmentSNode.class, anSNode, retVal );¬∂    	return retVal;¬∂	}¬∂   ¬∂    ¬∂    public static Set<OMPParallelSNode>  ompParallelSNodes(SNode anSNode) {¬∂    	Set retVal = new HashSet();    	¬∂    	fillInstancesOfNodeType(OMPParallelSNode.class, anSNode, retVal );¬∂    	return retVal;¬∂	}¬∂//    public static void fillOMPParallelSNodes(SNode anSNode, Set<OMPParallelSNode> retVal) {¬∂//    	if (anSNode instanceof OMPParallelSNode) {¬∂//    		retVal.add((OMPParallelSNode) anSNode);¬∂//		}¬∂//    	for (SNode aChild:anSNode.getChildren()) {¬∂//    		fillOMPParallelSNodes(aChild, retVal);¬∂//    	}		¬∂//	}¬∂    public static Set<ForSNode>  forSNodes(SNode anSNode) {¬∂    	Set retVal = new HashSet();    	¬∂    	fillInstancesOfNodeType(ForSNode.class, anSNode, retVal );¬∂    	return retVal;¬∂	}¬∂//    public static void fillForSNodes(SNode anSNode, Set<ForSNode> retVal) {¬∂//    	if (anSNode instanceof ForSNode) {¬∂//    		retVal.add((ForSNode) anSNode);¬∂//		}¬∂//    	for (SNode aChild:anSNode.getChildren()) {¬∂//    		fillForSNodes(aChild, retVal);¬∂//    	}		¬∂//	}¬∂    public static Set<OMPForSNode>  ompForSNodes(SNode anSNode) {¬∂    	Set retVal = new HashSet();    	¬∂    	fillInstancesOfNodeType(OMPForSNode.class, anSNode, retVal );¬∂    	return retVal;¬∂	}¬∂//    public static void fillOMPForSNodes(SNode anSNode, Set<OMPForSNode> retVal) {¬∂//    	if (anSNode instanceof OMPForSNode) {¬∂//    		retVal.add((OMPForSNode) anSNode);¬∂//		}¬∂//    	for (SNode aChild:anSNode.getChildren()) {¬∂//    		fillOMPForSNodes(aChild, retVal);¬∂//    	}		¬∂//	}¬∂    public static Set<OMPForSNode> ompReducingForNodes(SNode anSNode) {¬∂		Set<OMPForSNode> anAllOMPForSNodes =  ompForSNodes(anSNode);¬∂		Set<OMPForSNode> aRetVal = new HashSet();¬∂		for (OMPForSNode anOMPForSNode:anAllOMPForSNodes) {¬∂			if (anOMPForSNode.getReductionOperation() != null) {¬∂				aRetVal.add(anOMPForSNode);¬∂			}¬∂		}¬∂		return aRetVal;		¬∂	}¬∂    public static Set<AssignmentSNode> assignmentsToOMPReducingForNode(OMPForSNode anOMPForSNode) {¬∂    	String aReductionVariable = anOMPForSNode.getReductionVariable();¬∂    	return directAssignmentsOfVariableAndItsAliases(anOMPForSNode, aReductionVariable)	;¬∂    	¬∂    }¬∂	public static boolean dependsOn (SNode anSNode, int aVariableLineNumber, String aVariable, String aCallIdentifier) {¬∂		List<SNode> aListSNodes = anSNode.getChildren();¬∂		boolean retVal = false;¬∂		/*¬∂		 * Should probably ignore line number as it assumes straight line code¬∂		 */¬∂		for (int i = aVariableLineNumber; i >= 0; i--) {¬∂			SNode anSNodeChild = aListSNodes.get(i);¬∂			if (anSNodeChild instanceof AssignmentSNode) {¬∂				// does this statement in anSNode directly invoke aCallIdentifier ¬∂				if (dependsOn((AssignmentSNode) anSNodeChild, aVariable, aCallIdentifier))¬∂					return true;¬∂			} else if (!anSNode.isLeaf()) {¬∂					// child is overriding the variable so forget checking its assignment statements¬∂					if (anSNodeChild.getLocalVariableIdentifiers().contains(aVariable)) {¬∂						continue;¬∂					}¬∂					// some subblock of anSNode that has access to aVariable changes variable¬∂¬∂					if (dependsOn(anSNodeChild, anSNodeChild.getChildren().size() - 1, aVariable, aCallIdentifier)) {¬∂						return true;¬∂					}¬∂			}¬∂			¬∂		}¬∂		// none of the statements in anSNode or its descendents  have the required call¬∂		// is the variable a  method parameter ¬∂		if (anSNode instanceof MethodSNode) {¬∂			MethodSNode aMethodSNode = (MethodSNode) anSNode;¬∂			¬∂			int aParameterNumber = aMethodSNode.getLocalVariableIdentifiers().indexOf(aVariable);¬∂			if (aParameterNumber != -1) {¬∂				List <MethodCall> aCalls = aMethodSNode.getCalls();¬∂				for (MethodCall aCall:aCalls) {¬∂//					if (!aCall.getMethodActuals().contains(aVariable))¬∂//						continue;¬∂//					¬∂					MethodSNode aCallerSNode = getDeclarationOfCalledMethod(aMethodSNode, aCall);¬∂					if (dependsOn(aMethodSNode, aCallerSNode.getLineNumber(), aCallerSNode.getLocalVariableIdentifiers().get(aParameterNumber), aCallIdentifier));¬∂//				    if (aCallerDepends) {¬∂				    	return true;¬∂//				    }¬∂				}¬∂				return false;¬∂				// need to find all callers of method and see if any of the aliases for the variable in these¬∂				// calls depend on aCallIndentifier¬∂			}			¬∂			¬∂		} else if (anSNode.getLocalVariableIdentifiers().contains(aVariable)) {¬∂			// before going to the parent node, let us see if aVariable is declared here as a non  parameter ¬∂¬∂			return false; // no point going to parent¬∂		}¬∂		// not a local variable (parameter or declarated variable)¬∂		SNode anSNodeParent = anSNode.getParent() ;¬∂		if (anSNodeParent == null)  {¬∂			return false;¬∂		}¬∂		int anSNodeLineNumber = anSNodeParent.getChildren().indexOf(anSNode);¬∂		return dependsOn(anSNodeParent, anSNodeLineNumber, aVariable, aCallIdentifier);¬∂		¬∂	}¬∂	public static Set<AssignmentSNode> assignmentsOfVariableAliases (SNode anSNode,  String aVariable) {¬∂		Set<AssignmentSNode> retVal = new HashSet();¬∂		fillDirectAssignmentsOfVariableAliases(anSNode, aVariable, retVal);¬∂		return retVal;¬∂	}¬∂	public static void fillDirectAssignmentsOfVariableAliases (SNode anSNode,  String aVariable, Set<AssignmentSNode> retVal) {¬∂		if (anSNode instanceof MethodCall) {¬∂			MethodCall aMethodCall = (MethodCall) anSNode;¬∂			int aParameterNumber = aMethodCall.getMethodActualIdentifiers().indexOf(aVariable);¬∂			if (aParameterNumber < 0) {¬∂				return;¬∂			}¬∂			MethodSNode aDeclaringMethodSNode = getDeclarationOfCalledMethod(anSNode, aMethodCall);¬∂			String aFormalParameter = aDeclaringMethodSNode.getLocalVariableIdentifiers().get(aParameterNumber);¬∂//			Set<AssignmentSNode> aCallAssignments = ;¬∂			fillDirectAssignmentsOfVariableAliases(aDeclaringMethodSNode, aFormalParameter, retVal);¬∂		} else {¬∂			List<SNode> aChildren = anSNode.getChildren();¬∂			for (SNode aChild:aChildren) {¬∂				fillDirectAssignmentsOfVariableAliases(aChild, aVariable, retVal);¬∂			}¬∂		}		¬∂		¬∂	}¬∂	¬∂	/*¬∂	 * will not consider assignments to variables in the RHS of these assignments¬∂	 */¬∂	public static Set<AssignmentSNode> directAssignmentsOfVariableAndItsAliases (SNode anSNode,  String aVariable) {¬∂		Set<AssignmentSNode> retVal = new HashSet();¬∂		fillDirectAssignmentsOfVariableAndItsAliases(anSNode, aVariable, retVal);¬∂		return retVal;¬∂	}¬∂	¬∂//	public static Set<AssignmentSNode> assignmentsEffectingVariableAndItsAliases (SNode anSNode,  String aVariable) {¬∂//		Set<AssignmentSNode> retVal = directAssignmentsOfVariableAndItsAliases(anSNode, aVariable);¬∂//		¬∂//	}¬∂	public static void fillDirectAssignmentsOfVariableAndItsAliases (SNode anSNode,  String aVariable, Set<AssignmentSNode> retVal) {¬∂		if (anSNode instanceof AssignmentSNode) {¬∂			AssignmentSNode anAssignmentSNode = (AssignmentSNode) anSNode;¬∂			if (anAssignmentSNode.getLhsFirstIdentifier().equals(aVariable)) {¬∂				retVal.add(anAssignmentSNode);¬∂			}¬∂		}¬∂		¬∂		else if (anSNode instanceof MethodCall) {¬∂			MethodCall aMethodCall = (MethodCall) anSNode;¬∂			int aParameterNumber = aMethodCall.getMethodActualIdentifiers().indexOf(aVariable);¬∂			if (aParameterNumber < 0) {¬∂				return;¬∂			}¬∂			MethodSNode aDeclaringMethodSNode = getDeclarationOfCalledMethod(anSNode, aMethodCall);¬∂			String aFormalParameter = aDeclaringMethodSNode.getLocalVariableIdentifiers().get(aParameterNumber);¬∂//			Set<AssignmentSNode> aCallAssignments = ;¬∂			fillDirectAssignmentsOfVariableAndItsAliases(aDeclaringMethodSNode, aFormalParameter, retVal);¬∂		} else {¬∂			List<SNode> aChildren = anSNode.getChildren();¬∂			for (SNode aChild:aChildren) {¬∂				fillDirectAssignmentsOfVariableAndItsAliases(aChild, aVariable, retVal);¬∂			}¬∂		}		¬∂		¬∂	}¬∂	¬∂	public static RootOfFileSNode getRootOfFileNode(SNode aCurrentSNode ) {¬∂		if (aCurrentSNode instanceof RootOfFileSNode) {¬∂			return (RootOfFileSNode) aCurrentSNode;¬∂		}¬∂		SNode aParentSNode = aCurrentSNode.getParent() ;¬∂		¬∂		if (aParentSNode == null) {¬∂			return null;¬∂		}¬∂		¬∂		return getRootOfFileNode(aParentSNode);¬∂		¬∂	}¬∂	public static boolean match (MethodSNode aMethodSNode, MethodCall aMethodCall) {¬∂		return aMethodSNode.getMethodName().equals(aMethodCall.getMethodName()) ¬∂				&& aMethodSNode.getLocalVariableIdentifiers().size() == aMethodCall.getMethodActuals().size();¬∂	}¬∂	public static DeclarationSNode getDeclarationOfVariableIdentifier(SNode aCurrentSNode, String anIdentifier) {¬∂		if (aCurrentSNode == null) {¬∂			return null;¬∂		}¬∂		¬∂		¬∂		int anIndex = aCurrentSNode.getLocalVariableIdentifiers().indexOf(anIdentifier);¬∂		if (anIndex < 0) {¬∂			return getDeclarationOfVariableIdentifier(aCurrentSNode.getParent(), anIdentifier);¬∂		}¬∂		DeclarationSNode retVal = aCurrentSNode.getVariableDeclarations().get(anIndex);¬∂//		retVal.getAssignmentsToDeclaredVariable().add(anAssignmentSNode);¬∂//		anAssignmentSNode.setLhsFirstIdentifierDeclaration(retVal);¬∂		return retVal;¬∂	}¬∂	¬∂	public static DeclarationSNode getDeclarationOfAssignedVariable(SNode aCurrentSNode, AssignmentSNode anAssignmentSNode) {¬∂		if (aCurrentSNode == null) {¬∂			return null;¬∂		}¬∂		if (anAssignmentSNode instanceof ADeclaringAssignmentSNode) {¬∂			return (ADeclaringAssignmentSNode) anAssignmentSNode;¬∂		}¬∂		int anIndex = aCurrentSNode.getLocalVariableIdentifiers().indexOf(anAssignmentSNode.getLhsFirstIdentifier());¬∂		if (anIndex < 0) {¬∂			return getDeclarationOfAssignedVariable(aCurrentSNode.getParent(), anAssignmentSNode);¬∂		}¬∂		DeclarationSNode retVal = aCurrentSNode.getVariableDeclarations().get(anIndex);¬∂//		retVal.getAssignmentsToDeclaredVariable().add(anAssignmentSNode);¬∂//		anAssignmentSNode.setLhsFirstIdentifierDeclaration(retVal);¬∂		return retVal;¬∂	}¬∂	¬∂	public static MethodSNode getDeclarationOfCalledMethod(SNode aCurrentSNode, MethodCall aMethodCall ) {¬∂		SNode aRootNode = getRootOfFileNode(aCurrentSNode);¬∂		for (SNode aChild:aRootNode.getChildren()) {¬∂			if (aChild instanceof MethodSNode) {¬∂				MethodSNode aMethodSNode = (MethodSNode) aChild;¬∂				if (match (aMethodSNode, aMethodCall)) {¬∂					return aMethodSNode;¬∂				}¬∂			}¬∂		}¬∂		return null; // this should never happen;¬∂	}¬∂	¬∂	public static RootOfProgramSNode getRootOfProgramSNode(String aSource) {¬∂		RootOfProgramSNode retVal = new ARootOfProgramSNode();¬∂		Map<String, StringBuffer> aFileNameToContents = ABasicTextManager.extractFileContents(aSource);¬∂		for (String aFileName:aFileNameToContents.keySet()) {¬∂			StringBuffer aFileContents = aFileNameToContents.get(aFileName);¬∂//			List<OpenMPPragma> anOpenMPPragmas = OpenMPUtils.getOpemMPPragmas(aFileContents);¬∂			RootOfFileSNode anSNode = OMPSNodeUtils.getSNode(aFileName, aFileContents);¬∂			retVal.getFileNameToSNode().put(aFileName, anSNode);¬∂			anSNode.setParent(retVal);¬∂//			System.out.println("file name:" + aFileName);¬∂//			System.out.println("pragmas:" + anSNode);¬∂		}¬∂		processExternalMethodSNodes(retVal);¬∂		processIndirectAssignments(retVal);¬∂		return retVal;¬∂	}¬∂//	public static void processIndirectAssignments (S aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode) {¬∂//		for (SNode anSNode:aRootOfFileSNode.getChildren()) {¬∂//			-----¬∂//		}¬∂//	}¬∂	public static void processExternalMethodSNodes (RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode) {¬∂		for (SNode anSNode:aRootOfFileSNode.getChildren()) {¬∂			if (anSNode instanceof ExternalMethodSNode) {¬∂				processExternalMethodSNode(aRootOfProgramSNode, aRootOfFileSNode, (ExternalMethodSNode) anSNode);¬∂			}¬∂		}¬∂	}¬∂	public static void processExternalMethodSNode (RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode, ExternalMethodSNode anExternalMethodSNode) {¬∂		MethodSNode aMethodSNode = aRootOfProgramSNode.getExternalToInternalMethod().get(anExternalMethodSNode.toString());¬∂		if (aMethodSNode == null) {¬∂			aMethodSNode = findMethodSNode(aRootOfProgramSNode, aRootOfFileSNode, anExternalMethodSNode);¬∂			if (aMethodSNode != null) {¬∂				aRootOfProgramSNode.getExternalToInternalMethod().put(anExternalMethodSNode.toString(),aMethodSNode );¬∂			}¬∂		}¬∂		if (aMethodSNode != null) {¬∂			anExternalMethodSNode.setActualMethodSNode(aMethodSNode);¬∂			aMethodSNode.getCalls().addAll(anExternalMethodSNode.getLocalCalls());¬∂		}¬∂	}¬∂	¬∂	public static MethodSNode findMethodSNode (RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode, ExternalMethodSNode anExternalMethodSNode) {¬∂//		MethodSNode foundMethodSNode = null;¬∂		for (String aFileName:aRootOfProgramSNode.getFileNameToSNode().keySet()) {¬∂			if (aFileName.equals(aRootOfFileSNode.getFileName()))¬∂				continue;¬∂			¬∂			RootOfFileSNode aSearchedRootOfFileSNode = aRootOfProgramSNode.getFileNameToSNode().get(aFileName);¬∂			 for (SNode anSNode:aSearchedRootOfFileSNode.getChildren()) {¬∂				if (anSNode instanceof MethodSNode && !(anSNode instanceof ExternalMethodSNode)) {¬∂					if (anSNode.toString().equals(anExternalMethodSNode.toString())) {¬∂						return (MethodSNode) anSNode;¬∂						¬∂					}¬∂//					processExternalMethodSNode(aRootOfProgramSNode, aRootOfFileSNode, (ExternalMethodSNode) anSNode);¬∂				}¬∂			}¬∂		}¬∂		return null;¬∂	}¬∂	public static void processExternalMethodSNodes (RootOfProgramSNode aRootOfProgramSNode) {¬∂		for (String aFileName:aRootOfProgramSNode.getFileNameToSNode().keySet()) {¬∂			RootOfFileSNode aRootOfFileSNode = aRootOfProgramSNode.getFileNameToSNode().get(aFileName);¬∂			processExternalMethodSNodes(aRootOfProgramSNode, aRootOfFileSNode);¬∂			aRootOfFileSNode.getOmp_get_num_threads_SNode().¬∂				setActualMethodSNode(aRootOfProgramSNode.getOmp_get_num_threads_SNode());¬∂			aRootOfFileSNode.getOmp_get_thread_num_SNode().¬∂				setActualMethodSNode(aRootOfProgramSNode.getOmp_get_thread_num_SNode());¬∂			aRootOfFileSNode.getOmp_get_wtime_SNode().¬∂			setActualMethodSNode(aRootOfProgramSNode.getOmp_get_wtime_SNode());¬∂		}¬∂¬∂	}¬∂	public static void processIndirectAssignments (SNode anSNode) {¬∂		if (anSNode instanceof ConstDeclarationSNode) {¬∂			return;¬∂		}¬∂		if (anSNode instanceof DeclarationSNode) {¬∂			DeclarationSNode aDeclarationSNode = (DeclarationSNode) anSNode;¬∂			Set<AssignmentSNode> anIndirectAssignments = aDeclarationSNode.getAssignmentsEffectingDeclaredIdentifier();¬∂			if (anIndirectAssignments != null) {¬∂				return; // already assigned¬∂			}¬∂			anIndirectAssignments = new HashSet<>();¬∂			aDeclarationSNode.setAssignmentsEffectingDeclaredIdentifier(anIndirectAssignments);¬∂			Set<AssignmentSNode> aDirectAssignments = aDeclarationSNode.getAssignmentsToDeclaredVariable();¬∂			anIndirectAssignments.addAll(aDirectAssignments);¬∂			Set<AssignmentSNode> anAliasAssignments = assignmentsOfVariableAliases(aDeclarationSNode.getParent(), aDeclarationSNode.getVariableName());¬∂			anIndirectAssignments.addAll(anAliasAssignments);¬∂			for (AssignmentSNode aDirectAssignment:aDirectAssignments) {¬∂				List<String> aVariableIdentifiers = aDirectAssignment.getRhsVariableIdentifiers();¬∂				¬∂				for (String aVariableIdentifier:aVariableIdentifiers) {¬∂					DeclarationSNode aDependeeDeclarationSNode = getDeclarationOfVariableIdentifier(aDirectAssignment, aVariableIdentifier);¬∂					if (aDependeeDeclarationSNode == null) {¬∂						System.err.println("Could not find declaration of:" + aVariableIdentifier + " referenced in:" + aDirectAssignment );¬∂						continue;¬∂					}¬∂					processIndirectAssignments(aDependeeDeclarationSNode);¬∂					Set<AssignmentSNode> aDependeeIndirectAssignments = aDeclarationSNode.getAssignmentsEffectingDeclaredIdentifier();¬∂					anIndirectAssignments.addAll(aDependeeIndirectAssignments);¬∂					¬∂				}¬∂			}¬∂		} else {¬∂			for (SNode aChild: anSNode.getChildren()) {¬∂				processIndirectAssignments(aChild);¬∂			}¬∂		}¬∂		¬∂	}¬∂	¬∂//	public static void fillIndirectAssignments (SNode anSNode, Set<AssignmentSNode> retVal ) {¬∂//		¬∂//	}¬∂	¬∂¬∂//	public static void main(String[] args) {¬∂//		List<MethodCall> aTokens = callsIn("foo(bar, hgf)/foo2()*foo3(b, a c,)");¬∂//		System.out.println(aTokens);¬∂//		¬∂//		¬∂////		List<String> aTokens = identifiersIn("a[i] + b*2/3");¬∂////		System.out.println(aTokens);¬∂////		aTokens = numbersIn("a[i] + b*2/3");¬∂////		System.out.println(aTokens);¬∂////		aTokens = operatorsIn("a[i] + b*2/3");¬∂////		System.out.println(aTokens);¬∂////¬∂////		System.out.println(StringUtils.substringBetween("a", "[", "]"));¬∂//	}¬∂¬∂}¬∂")]]]></diff>
  </Command>
  <Command __id="218117" _type="ShellCommand" date="Fri Jan 10 10:20:57 EST 2020" starttimestamp="1576666505112" timestamp="2003152822" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="218216" _type="DiffBasedFileOpenCommand" date="Fri Jan 10 10:29:45 EST 2020" docASTNodeCount="5134" docActiveCodeLength="37675" docExpressionCount="3174" docLength="43794" projectName="GraderBasics" starttimestamp="1576666505112" timestamp="2003680237">
    <filePath><![CDATA[D:\dewan_backup\Java\GraderBasics\src\gradingTools\shared\testcases\openmp\scannedTree\OMPSNodeUtils.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package gradingTools.shared.testcases.openmp.scannedTree;¬∂¬∂import java.util.ArrayList;¬∂import java.util.Arrays;¬∂import java.util.HashMap;¬∂import java.util.HashSet;¬∂import java.util.List;¬∂import java.util.Map;¬∂import java.util.Set;¬∂import java.util.Stack;¬∂import java.util.regex.Matcher;¬∂import java.util.regex.Pattern;¬∂¬∂import org.apache.commons.lang.StringUtils;¬∂¬∂import grader.basics.project.source.ABasicTextManager;¬∂import gradingTools.shared.testcases.openmp.OpenMPKeywordEnum;¬∂import gradingTools.shared.testcases.openmp.OpenMPParallelPragma;¬∂import gradingTools.shared.testcases.openmp.OpenMPUtils;¬∂import gradingTools.shared.testcases.openmp.scannedTree.ADeclarationSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.ADeclaringAssignmentSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.AForSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.ATextSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.AnAssignmentSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.AnOMPCriticalSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.AnOMPForSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.AnOMPParallelSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.AnOMPSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.AnSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.AssignmentSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.DeclarationSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.DeclaringAssignmentSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.ForSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.OMPForSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.OMPSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.SNode;¬∂¬∂public class OMPSNodeUtils extends OpenMPUtils {¬∂¬∂	public static RootOfFileSNode getSNode(String aFileName, StringBuffer aFileBuffer) {¬∂		String[] aFileLines = aFileBuffer.toString().split("\n");¬∂		return getSNode(aFileName, aFileLines);¬∂	}¬∂¬∂	public static AssignmentSNode getAssignmentSNode(int aLineNumber, String aString) {¬∂		if (aString == null) {¬∂			return null;¬∂		}¬∂		String[] aTokens = aString.split("=");¬∂		if (aTokens.length == 1) {¬∂			return new AnAssignmentSNode(aLineNumber, aTokens[0], null);¬∂		} else {¬∂		return new AnAssignmentSNode(aLineNumber, aTokens[0], aTokens[1]);¬∂		}¬∂	}¬∂¬∂	public static DeclarationSNode getDeclarationSNode(int aLineNumber, String aString) {¬∂		String[] aTokens = aString.split(" ");¬∂		return new ADeclarationSNode(aLineNumber, aTokens[0], aTokens[1]);¬∂	}¬∂¬∂	public static DeclaringAssignmentSNode getDeclaringAssignmentSNode(int aLineNumber, String aString) {¬∂		String[] anLHSAndRHS = aString.split("=");¬∂		String[] aTypeAndVariable = anLHSAndRHS[0].split(" ");¬∂		return new ADeclaringAssignmentSNode(aLineNumber, aTypeAndVariable[0], aTypeAndVariable[1], anLHSAndRHS[1]);¬∂	}¬∂	public static ConstDeclarationSNode getConstDeclarationSNode(int aLineNumber, String aString) {¬∂		String anAssignmentString = aString.substring(CONST.length()).trim();¬∂		String[] anLHSAndRHS = anAssignmentString.split("=");¬∂		String[] aTypeAndVariable = anLHSAndRHS[0].split(" ");¬∂		return new AConstDeclarationSNode(aLineNumber, aTypeAndVariable[0], aTypeAndVariable[1], anLHSAndRHS[1]);¬∂	}¬∂¬∂	public static boolean isDeclaringAssignment(String aFileLine) {¬∂		return startsWithTypeName(aFileLine) && aFileLine.contains("=");¬∂	}¬∂	public static boolean isConstDeclaration(String aFileLine) {¬∂		return aFileLine.startsWith(CONST);¬∂	}¬∂	public static boolean isMethodDeclaration(String aFileLine) {¬∂		return startsWithTypeName(aFileLine) && ¬∂				aFileLine.contains("(") &&¬∂				!aFileLine.contains("=");¬∂	}¬∂	public static boolean isExternalMethodDeclaration(String aFileLine) {¬∂		return isMethodDeclaration(aFileLine) && aFileLine.endsWith(";");¬∂	}¬∂¬∂¬∂	public static boolean isVariableDeclaration(String aFileLine) {¬∂¬∂		return startsWithTypeName(aFileLine) && !aFileLine.contains("(");¬∂	}¬∂¬∂	public static boolean isAssignment(String aFileLine) {¬∂		return aFileLine.contains("=") && !aFileLine.contains("==");¬∂	}¬∂¬∂	public static boolean isForNode(String aFileLine) {¬∂		return aFileLine.startsWith("for");¬∂	}¬∂¬∂	public static ForSNode getForSNode(int aLineNumber, String aFileLine) {¬∂¬∂		int aLeftParenIndex = aFileLine.indexOf("(");¬∂		int aRightParenIndex = aFileLine.indexOf(")");¬∂		if (aLeftParenIndex < 0 || aRightParenIndex < 0) {¬∂			return null;¬∂		}¬∂		String aHeaderString = aFileLine.substring(aLeftParenIndex + 1, aRightParenIndex);¬∂		String[] aForComponents = aHeaderString.split(";");¬∂		AssignmentSNode anAssignmentSNode = null;¬∂		String aForInitializaton = aForComponents[0];¬∂		if (!aForInitializaton.isEmpty() && aForInitializaton.contains("=")) {¬∂			if (isDeclaringAssignment(aForInitializaton)) {¬∂				anAssignmentSNode = getDeclaringAssignmentSNode(aLineNumber, aForInitializaton);¬∂			} else {¬∂				anAssignmentSNode = getAssignmentSNode(aLineNumber, aForInitializaton);¬∂			}¬∂¬∂		}		¬∂		return new AForSNode(aLineNumber, anAssignmentSNode, aForComponents[1], getAssignmentSNode(aLineNumber, aForComponents[2]));¬∂	}¬∂	static String[] emptyArray = {};¬∂	public static MethodSNode getMethodSNode(int aLineNumber, String aFileLine, boolean isInternal) {¬∂¬∂		int aLeftParenIndex = aFileLine.indexOf("(");¬∂		int aRightParenIndex = aFileLine.indexOf(")");¬∂		if (aLeftParenIndex < 0 || aRightParenIndex < 0) {¬∂			return null;¬∂		}¬∂		String aMethodNameAndType = aFileLine.substring(0, aLeftParenIndex);¬∂		String[] aMethodNameAndTypeTokens = aMethodNameAndType.split("\\s+"); ¬∂		¬∂		String aMethodParameters = aFileLine.substring(aLeftParenIndex +1 , aRightParenIndex);¬∂		String[] aMethodParameterTokens = aMethodParameters.isEmpty()?emptyArray:¬∂		 aMethodParameters.split(",");¬∂		¬∂//		String[] aMethodParameterTypes = new String[aMethodParameterTokens.length];¬∂//		String[] aMethodParameterNames = new String[aMethodParameterTokens.length];¬∂		List<DeclarationSNode> aDeclarationSNodeList = new ArrayList();¬∂		for (int i = 0; i < aMethodParameterTokens.length; i++ ) {¬∂			String[] aTypeAndName = aMethodParameterTokens[i].trim().split("\\s+");¬∂			if (aTypeAndName.length < 2) {¬∂				continue;¬∂			}¬∂			aDeclarationSNodeList.add(new ADeclarationSNode(aLineNumber, aTypeAndName[0].trim(), aTypeAndName[1].trim()));¬∂//			aMethodParameterTypes[i] = aTypeAndName[0].trim();¬∂//			aMethodParameterNames[i] = aTypeAndName[1].trim();¬∂		}¬∂		if (isInternal)¬∂//		return new AMethodSNode(aLineNumber, aMethodNameAndTypeTokens[0], aMethodNameAndTypeTokens[1], aMethodParameterTypes,aMethodParameterNames );¬∂			return new AMethodSNode(aLineNumber, aMethodNameAndTypeTokens[0], aMethodNameAndTypeTokens[1], aDeclarationSNodeList );¬∂		else¬∂			return new AnExternalMethodSNode(aLineNumber, aMethodNameAndTypeTokens[0], aMethodNameAndTypeTokens[1], aDeclarationSNodeList );¬∂	}¬∂¬∂	public static void setReductionData(OMPForSNode lastChild, String aStoredToken, int aLeftParenIndex,¬∂			int aRightParenIndex) {¬∂		int aColonIndex = aStoredToken.indexOf(":");¬∂		if (aLeftParenIndex != -1 && aRightParenIndex != -1 && aColonIndex != -1) {¬∂			String anOperationString = aStoredToken.substring(aLeftParenIndex + 1, aColonIndex).trim();¬∂			String aVariableString = aStoredToken.substring(aColonIndex + 1, aRightParenIndex).trim();¬∂			((OMPForSNode) lastChild).setReductionVariable(aVariableString);¬∂			((OMPForSNode) lastChild).setReductionOperation(anOperationString);¬∂		}¬∂	}¬∂¬∂	public static void setSharedOrPrivateData(OMPSNode lastChild, String aStoredToken, int aLeftParenIndex,¬∂			int aRightParenIndex, boolean isShared) {¬∂//		int aColonIndex = aStoredToken.indexOf(":");¬∂		if (aLeftParenIndex != -1 && aRightParenIndex != -1) {¬∂			String aVariableDeclarations = aStoredToken.substring(aLeftParenIndex + 1, aRightParenIndex);¬∂			String[] aVariables = aVariableDeclarations.split(",");¬∂			if (isShared) {¬∂				lastChild.setSharedVariables(aVariables);¬∂			} else {¬∂				lastChild.setPrivateVariables(aVariables);¬∂			}¬∂		}¬∂	}¬∂¬∂	public static RootOfFileSNode getSNode(String aFileName, String[] aFileLines) {¬∂		Stack<SNode> anSNodes = new Stack();¬∂¬∂		RootOfFileSNode retVal = new ARootOfFileSNode(aFileName);¬∂		anSNodes.add(retVal);¬∂		SNode previousHeaderNode = null;¬∂		for (int i = 0; i < aFileLines.length; i++) {¬∂			String aFileLine = aFileLines[i].trim();¬∂			if (!isCodeLine(aFileLine)) {¬∂				continue;¬∂			}¬∂			if (isForNode(aFileLine)) {¬∂				ForSNode aForSNode = getForSNode(i, aFileLine);¬∂				SNode aParent = previousHeaderNode != null?previousHeaderNode:anSNodes.peek();¬∂				aForSNode.setParent(anSNodes.peek());¬∂				aForSNode.setParent(aParent);¬∂¬∂//				anSNodes.push(aForSNode);¬∂				previousHeaderNode = aForSNode;¬∂				if (aFileLine.endsWith(")")) {¬∂					continue;¬∂				}¬∂			}¬∂			if (isExternalMethodDeclaration(aFileLine)) {¬∂				MethodSNode aMethodSNode = getMethodSNode(i, aFileLine, false);¬∂				aMethodSNode.setParent(anSNodes.peek());¬∂//				anSNodes.push(aForSNode);¬∂				previousHeaderNode = aMethodSNode;¬∂				if (aFileLine.endsWith(")")) {¬∂					continue;¬∂				}¬∂			}¬∂			if (isMethodDeclaration(aFileLine)) {¬∂				MethodSNode aMethodSNode = getMethodSNode(i, aFileLine, true);¬∂				aMethodSNode.setParent(anSNodes.peek());¬∂//				anSNodes.push(aForSNode);¬∂				previousHeaderNode = aMethodSNode;¬∂				if (aFileLine.endsWith(")")) {¬∂					continue;¬∂				}¬∂			}¬∂			if (isPragmaStart(aFileLine)) {¬∂				OMPSNode anOMPSNode = getOMPSNode(i, anSNodes.peek(), aFileLine);¬∂//				anSNodes.push(anOMPSNode);¬∂				previousHeaderNode = anOMPSNode;¬∂				continue;¬∂			}¬∂			if (isBlockStart(aFileLine)) {¬∂				SNode aBlockSNode = new ABlockSNode(i);¬∂				if (previousHeaderNode != null) {¬∂					aBlockSNode.setParent(previousHeaderNode);¬∂				} else {¬∂					aBlockSNode.setParent(anSNodes.peek());¬∂				}¬∂				anSNodes.push(aBlockSNode);¬∂				previousHeaderNode = null;¬∂				continue;¬∂			}¬∂//			} else ¬∂			if (isBlockEnd(aFileLine)) {¬∂				anSNodes.pop();¬∂				continue;¬∂			}¬∂			SNode aNewLeafNode = null;¬∂			if (isConstDeclaration(aFileLine)) {¬∂				aNewLeafNode = getConstDeclarationSNode(i, aFileLine);¬∂¬∂			} else if (isDeclaringAssignment(aFileLine)) {¬∂				aNewLeafNode = getDeclaringAssignmentSNode(i, aFileLine);¬∂¬∂			} else if (isAssignment(aFileLine)) {¬∂				aNewLeafNode = getAssignmentSNode(i, aFileLine);¬∂			} else if (isVariableDeclaration(aFileLine)) {¬∂				aNewLeafNode = getDeclarationSNode(i, aFileLine);¬∂			} else {¬∂				List<MethodCall> aCalls = callsIn(i, aFileLine, null); // parent will be assigned below¬∂				if (aCalls != null && aCalls.size() == 1) {¬∂					aNewLeafNode = aCalls.get(0);¬∂				} else {¬∂					aNewLeafNode = new ATextSNode(i, aFileLine);¬∂				}¬∂			}¬∂//			else {¬∂//				aNewLeafNode = new ATextSNode(i, aFileLine);¬∂//			}¬∂			if (previousHeaderNode != null) {¬∂				aNewLeafNode.setParent(previousHeaderNode);¬∂			} else {¬∂				aNewLeafNode.setParent(anSNodes.peek());¬∂			}¬∂¬∂		}¬∂¬∂		return retVal;¬∂	}¬∂¬∂	public static OMPSNode getOMPSNode(int aLineIndex, SNode aParentNode, String aFileLine) {¬∂		String[] aTokens = aFileLine.split("\\s+");¬∂		if (aTokens.length <= 2) {¬∂			return null;¬∂		}¬∂		if (!aTokens[1].equals("omp")) {¬∂			return null;¬∂		}¬∂		if (aTokens.length < 3) {¬∂			return null;¬∂		}¬∂		String aFirstToken = aTokens[2];¬∂		OpenMPKeywordEnum anOpenMPKeyword = stringToOpenMPKeyword.get(aFirstToken);¬∂//		List<OpenMPPragma> retVal = new ArrayList();¬∂		OMPSNode lastChild = null;¬∂		int aStartIndex = 2;¬∂		OMPSNode aNewNode = null;¬∂		OMPForSNode aForChild = null;¬∂		switch (anOpenMPKeyword) {¬∂		case PARALLEL:¬∂			aNewNode = new AnOMPParallelSNode(aLineIndex);¬∂¬∂			if (aTokens.length > 3 && aTokens[3].equals("for")) {¬∂				aForChild = new AnOMPForSNode(aLineIndex);¬∂				aForChild.setParent(aNewNode);¬∂¬∂				aStartIndex++;¬∂			}¬∂			break;¬∂		case FOR:¬∂			aNewNode = new AnOMPForSNode(aLineIndex);¬∂			;¬∂			break;¬∂		case CRITICAL:¬∂			aNewNode = new AnOMPCriticalSNode(aLineIndex);¬∂//			retVal.add (lastChild);¬∂			break;¬∂		default:¬∂			aNewNode = new AnOMPSNode(aLineIndex);¬∂¬∂		}¬∂¬∂		if (lastChild != null) {¬∂			aNewNode.setParent(lastChild);¬∂		} else {¬∂			aNewNode.setParent(aParentNode);¬∂		}¬∂		lastChild = aForChild == null ? aNewNode : aForChild;¬∂¬∂		for (int i = aStartIndex; i < aTokens.length; i++) {¬∂			String aStoredToken = aTokens[i].trim();¬∂			if (aStoredToken.isEmpty()) {¬∂				continue;¬∂			}¬∂			if (aStoredToken.startsWith("reduction") || aStoredToken.startsWith("shared")¬∂					|| aStoredToken.startsWith("private")) {¬∂				// combine all tokens until ")" into one for normalization¬∂				while (!aStoredToken.endsWith(")")) {¬∂					i++;¬∂					if (i >= aTokens.length) {¬∂						break;¬∂					}¬∂					String aNewToken = aTokens[i].trim();¬∂					aStoredToken += aNewToken;¬∂				}¬∂				int aLeftParenIndex = aStoredToken.indexOf("(");¬∂				int aRightParenIndex = aStoredToken.indexOf(")");¬∂				if (aStoredToken.startsWith("reduction")) {¬∂					setReductionData((OMPForSNode) lastChild, aStoredToken, aLeftParenIndex, aRightParenIndex);¬∂				} else if (aStoredToken.startsWith("private")) {¬∂					setSharedOrPrivateData((OMPSNode) lastChild, aStoredToken, aLeftParenIndex, aRightParenIndex,¬∂							false);¬∂¬∂				} else if (aStoredToken.startsWith("shared")) {¬∂					setSharedOrPrivateData(lastChild, aStoredToken, aLeftParenIndex, aRightParenIndex, true);¬∂¬∂				}¬∂¬∂			}¬∂¬∂			lastChild.getOpenMPTokens().add(aStoredToken);¬∂		}¬∂¬∂		return lastChild;¬∂¬∂	}¬∂¬∂	public static boolean hasParallelAncestor(SNode anSNode) {¬∂		if (anSNode == null) {¬∂			return false;¬∂		}¬∂		if (anSNode instanceof OMPParallelSNode) {¬∂			return true;¬∂		}¬∂		return hasParallelAncestor(anSNode.getParent());¬∂	}¬∂	public static boolean hasCriticalAncestor(SNode anSNode) {¬∂		if (anSNode == null) {¬∂			return false;¬∂		}¬∂		if (anSNode instanceof OMPCriticalSNode) {¬∂			return true;¬∂		}¬∂		return hasCriticalAncestor(anSNode.getParent());¬∂	}¬∂¬∂¬∂	public static Boolean isDeclaredShared(OMPSNode anOMPSNode, String anLHS) {¬∂		if (Arrays.asList(anOMPSNode.getSharedVariables()).contains(anLHS)) {¬∂			return true;¬∂		}¬∂		if (Arrays.asList(anOMPSNode.getPrivateVariables()).contains(anLHS)) {¬∂			return false;¬∂		}¬∂		return null;¬∂¬∂	}¬∂¬∂	public static boolean isSharedVariable(SNode anSNode, String anLHS) {¬∂		if (anSNode == null) {¬∂			return false;¬∂		}¬∂		if (anSNode.getLocalVariableIdentifiers().contains(anLHS)) {¬∂			if (!(anSNode instanceof OMPSNode)) { // no shared and private declarations¬∂				return !hasParallelAncestor(anSNode); // shared if not inParallel¬∂			}¬∂			OMPSNode anOMPSNode = (OMPSNode) anSNode;¬∂			return (Arrays.asList(anOMPSNode.getSharedVariables()).contains(anLHS)); // private unless declared shared¬∂		}¬∂		if (anSNode instanceof OMPSNode) {¬∂			OMPSNode anOMPSNode = (OMPSNode) anSNode;¬∂			// the variable is global to this scope, check if it has have been made shared¬∂			// or private by this scope¬∂			Boolean isDeclaredShared = isDeclaredShared(anOMPSNode, anLHS);¬∂			if (isDeclaredShared != null) {¬∂				return isDeclaredShared;¬∂			}¬∂		}¬∂		// check the parent¬∂		return isSharedVariable(anSNode.getParent(), anLHS);¬∂	}¬∂¬∂	public static List<SNode> getAllLeafNodes(SNode aTopNode) {¬∂		List<SNode> retVal = new ArrayList();¬∂		addLeafNodes(aTopNode, retVal);¬∂		return retVal;¬∂	}¬∂¬∂	public static void addLeafNodes(SNode aTopNode, List<SNode> retVal) {¬∂		for (SNode aChild : aTopNode.getChildren()) {¬∂			if (aChild.isLeaf()) {¬∂				retVal.add(aChild);¬∂			} else {¬∂				addLeafNodes(aChild, retVal);¬∂			}¬∂		}¬∂	}¬∂¬∂	public static List<SNode> getNonParallelLeafNodes(SNode aTopNode) {¬∂		List<SNode> retVal = new ArrayList();¬∂		addNonParallelLeafNodes(aTopNode, retVal);¬∂		return retVal;¬∂	}¬∂¬∂	public static void addNonParallelLeafNodes(SNode aTopNode, List<SNode> retVal) {¬∂		if (aTopNode.isInParallel()) {¬∂			return;¬∂		}¬∂		for (SNode aChild : aTopNode.getChildren()) {¬∂			if (aChild.isLeaf()) {¬∂				retVal.add(aChild);¬∂			} else {¬∂				addLeafNodes(aChild, retVal);¬∂			}¬∂		}¬∂	}¬∂	static String callRegex = "([a-zA-Z_$][a-zA-Z_$0-9]*)\\(.*?\\)";¬∂	static Pattern callPattern = Pattern.compile(callRegex);¬∂¬∂	static String identifierRegex = "[a-zA-Z_$][a-zA-Z_$0-9]*";¬∂	static Pattern identifierPattern = Pattern.compile(identifierRegex);¬∂	public static List<String> identifiersIn(String aString) {¬∂		if (aString == null)¬∂			return null;¬∂//		Pattern mypattern = Pattern.compile("[a-zA-Z_$][a-zA-Z_$0-9]*");¬∂//		Matcher mymatcher = mypattern.matcher(aString);¬∂		Matcher mymatcher = identifierPattern.matcher(aString);¬∂		List<String> retVal = new ArrayList();¬∂		while (mymatcher.find()) {¬∂			String find = mymatcher.group(0);¬∂			retVal.add(find);¬∂		}¬∂		return retVal;¬∂	}¬∂	public static List<MethodCall> callsIn(int aLineNumber, String aString, SNode aParent) {¬∂		if (aString == null)¬∂			return emptyList;¬∂		if (isMethodDeclaration(aString)) {¬∂			return emptyList;¬∂		}¬∂//		Pattern mypattern = Pattern.compile("[a-zA-Z_$][a-zA-Z_$0-9]*");¬∂//		Matcher mymatcher = mypattern.matcher(aString);¬∂		Matcher mymatcher = callPattern.matcher(aString);¬∂		List<MethodCall> retVal = new ArrayList();¬∂		while (mymatcher.find()) {¬∂			String find = mymatcher.group(0);¬∂			int aLeftParenIndex = find.indexOf("(");¬∂			int aRightParenIndex = find.indexOf(")");¬∂			String aMethodName = find.substring(0, aLeftParenIndex).trim();¬∂			String aParameters = find.substring(aLeftParenIndex + 1, aRightParenIndex);¬∂			List<String> aParameterList = new ArrayList();¬∂			String[] aParameterTokens = aParameters.split(",");¬∂			for (String aParameter:aParameterTokens) {¬∂				String aParameterTrimmed = aParameter.trim();¬∂				if (!aParameterTrimmed.isEmpty())¬∂				aParameterList.add(aParameterTrimmed);¬∂			}¬∂			retVal.add(new AMethodCall(aLineNumber, aMethodName, aParameterList, aParent));¬∂¬∂//			aCallStrings.add(find);¬∂		}¬∂		return retVal;¬∂	}¬∂	static String numberRegex = "(\\d+\\.\\d+)|(\\d+)";¬∂	static Pattern numberPattern = Pattern.compile(numberRegex);¬∂	public static List<String> numbersIn(String aString) {¬∂		if (aString == null)¬∂			return null;¬∂//		String regex = "(\\d+\\.\\d+)|(\\d+)";¬∂//¬∂//		Matcher m = Pattern.compile(regex).matcher(aString);¬∂		Matcher m =numberPattern.matcher(aString);¬∂¬∂¬∂		List<String> retVal = new ArrayList();¬∂¬∂		while (m.find()) {¬∂			retVal.add(m.group());¬∂		}¬∂		return retVal;¬∂	}¬∂¬∂	public static String subscriptIn(String aString) {¬∂		if (aString == null)¬∂			return null;¬∂		return StringUtils.substringBetween(aString, "[", "]");¬∂	}¬∂	static String[] emptyStringArray = {};¬∂	static List emptyList = new ArrayList();¬∂¬∂	public static String[] subscriptsIn(String aString) {¬∂		if (aString == null)¬∂			return emptyStringArray;¬∂		return StringUtils.substringsBetween(aString, "[", "]");¬∂	}¬∂	static  String operatorRegex = "([+-/*///^])|([/(/)])";¬∂	static Pattern operatorPattern = Pattern.compile(operatorRegex);¬∂¬∂	public static List<String> operatorsIn(String aString) {¬∂		if (aString == null)¬∂			return null;¬∂//		String operatorRegex = "([+-/*///^])|([/(/)])";¬∂//¬∂//		Matcher m = Pattern.compile(operatorRegex).matcher(aString);¬∂		¬∂		Matcher m = operatorPattern.matcher(aString);¬∂¬∂¬∂		List<String> retVal = new ArrayList();¬∂¬∂		while (m.find()) {¬∂			retVal.add(m.group());¬∂		}¬∂		return retVal;¬∂	}¬∂	¬∂	public static int numberOfNestingFors (SNode anSNode) {¬∂		if (anSNode == null) {¬∂			return 0;¬∂		}¬∂		int retVal = numberOfNestingFors (anSNode.getParent()) ;¬∂¬∂		if (anSNode instanceof ForSNode) {¬∂			retVal++;¬∂		} else if (anSNode instanceof MethodSNode) {¬∂			List<MethodCall> aMethodCalls = ((MethodSNode) anSNode).getCalls();¬∂			int aMaxNestingLevel = 0;¬∂			for (MethodCall aMethodCall:aMethodCalls) {¬∂				MethodSNode aCallerMethodSNode = getDeclarationOfCalledMethod(anSNode, aMethodCall);¬∂				int aCallerNumberOfNestingFors = numberOfNestingFors(aCallerMethodSNode);¬∂				aMaxNestingLevel = Math.max(aCallerNumberOfNestingFors, aMaxNestingLevel);				¬∂			}¬∂			return retVal + aMaxNestingLevel;¬∂		}¬∂		return retVal;¬∂	}¬∂	public static boolean hasOperator (SNode anSNode, String anOperator) {¬∂		boolean retVal = false;¬∂		if (anSNode instanceof AssignmentSNode) {¬∂			AssignmentSNode anAssignmentSNode = (AssignmentSNode) anSNode;¬∂			 retVal = (anAssignmentSNode.getLhsOperators().contains(anOperator) || ¬∂					anAssignmentSNode.getRhsOperators().contains(anOperator)) ;¬∂			if (retVal) {¬∂				return retVal;¬∂			} else {¬∂				List<MethodCall> aMethodCalls = anAssignmentSNode.getRhsCalls();¬∂				for (MethodCall aMethodCall:aMethodCalls) {¬∂					MethodSNode aMethodSNode = getDeclarationOfCalledMethod(anSNode, aMethodCall);¬∂					retVal = hasOperator(aMethodSNode, anOperator);¬∂					if (retVal) {¬∂						return retVal;¬∂					}¬∂					¬∂				}¬∂				return false;¬∂			}¬∂			¬∂		}¬∂		for (SNode aChild:anSNode.getChildren()) {¬∂			retVal = hasOperator(aChild, anOperator);¬∂			if (retVal) {¬∂				return retVal;¬∂			}¬∂		}¬∂		return false;¬∂	}¬∂	public static boolean hasMethodCall (SNode anSNode, String anOperator) {¬∂		boolean retVal = false;¬∂		if (anSNode instanceof AssignmentSNode) {¬∂			AssignmentSNode anAssignmentSNode = (AssignmentSNode) anSNode;¬∂			 retVal = (anAssignmentSNode.getLhsOperators().contains(anOperator) || ¬∂					anAssignmentSNode.getRhsOperators().contains(anOperator)) ;¬∂			if (retVal) {¬∂				return retVal;¬∂			} else {¬∂				List<MethodCall> aMethodCalls = anAssignmentSNode.getRhsCalls();¬∂				for (MethodCall aMethodCall:aMethodCalls) {¬∂					MethodSNode aMethodSNode = getDeclarationOfCalledMethod(anSNode, aMethodCall);¬∂					retVal = hasOperator(aMethodSNode, anOperator);¬∂					if (retVal) {¬∂						return retVal;¬∂					}¬∂					¬∂				}¬∂				return false;¬∂			}¬∂			¬∂		}¬∂		for (SNode aChild:anSNode.getChildren()) {¬∂			retVal = hasOperator(aChild, anOperator);¬∂			if (retVal) {¬∂				return retVal;¬∂			}¬∂		}¬∂		return false;¬∂	}¬∂	public static boolean dependsOn (AssignmentSNode anAssignmentSNode, String aVariable, String aCallIdentifier) {¬∂		// This assignment does not change aVariable¬∂		if (!aVariable.equals(anAssignmentSNode.getLhsFirstIdentifier())) {¬∂			return false;¬∂		}¬∂		return dependsOn(anAssignmentSNode.getExpressionSNode(), aCallIdentifier);¬∂//		List<String> aCallIdentifiers = anAssignmentSNode.getRhsCallIdentifiers();¬∂//		boolean retVal = false;¬∂//		if (aCallIdentifiers != null && aCallIdentifiers.contains(aCallIdentifier)) {¬∂//			return true; // this assignment has aCallIdentifier in the rhs¬∂//		}¬∂//		// check if some referenced rhs variable depends on aCallIdentifier¬∂//		List<String> aReferencedVariableIdentifiers = anAssignmentSNode.getRhsVariableIdentifiers();¬∂//		SNode anAssignmentParent = anAssignmentSNode.getParent();¬∂//		if (anAssignmentParent == null) { // should never be trye¬∂//			return false;¬∂//		}¬∂//		int aLineNumber = anAssignmentSNode.getLineNumber();¬∂//		for (String aReferencedVariableIdentifier:aReferencedVariableIdentifiers ) {¬∂//			if (dependsOn (anAssignmentParent, aLineNumber, aReferencedVariableIdentifier, aCallIdentifier)) {¬∂//				return true;¬∂//			}¬∂//		}¬∂//		return false;¬∂	}¬∂	public static boolean dependsOn (ExpressionSNode anExpressionSNode, String aCallIdentifier) {¬∂		// This assignment does not change aVariable¬∂		¬∂		List<String> aCallIdentifiers = anExpressionSNode.getRhsCallIdentifiers();¬∂		boolean retVal = false;¬∂		if (aCallIdentifiers != null && aCallIdentifiers.contains(aCallIdentifier)) {¬∂			return true; // this assignment has aCallIdentifier in the rhs¬∂		}¬∂		// check if some referenced rhs variable depends on aCallIdentifier¬∂		List<String> aReferencedVariableIdentifiers = anExpressionSNode.getRhsVariableIdentifiers();¬∂		SNode anAssignmentParent = anExpressionSNode.getParent().getParent();¬∂		if (anAssignmentParent == null) { // should never be trye¬∂			return false;¬∂		}¬∂		int aLineNumber = anExpressionSNode.getLineNumber();¬∂		for (String aReferencedVariableIdentifier:aReferencedVariableIdentifiers ) {¬∂			if (dependsOn (anAssignmentParent, aLineNumber, aReferencedVariableIdentifier, aCallIdentifier)) {¬∂				return true;¬∂			}¬∂		}¬∂		return false;¬∂	}¬∂	public static Set<AssignmentSNode> assignmentsToSharedVariables(SNode anSNode) {¬∂		Set<AssignmentSNode> retVal =  new HashSet();¬∂		fillAssignmentsToShared(anSNode, retVal);¬∂		return retVal;¬∂		¬∂	}¬∂	public static Set<AssignmentSNode> assignmentsToSharedArrays(SNode anSNode) {¬∂		Set<AssignmentSNode> anAllSharedAssignments =  assignmentsToSharedVariables(anSNode);¬∂		Set<AssignmentSNode> aRetVal = new HashSet();¬∂		for (AssignmentSNode anAssignmentSNode:anAllSharedAssignments) {¬∂			if (anAssignmentSNode.getLhsSubscripts().length > 0) {¬∂				aRetVal.add(anAssignmentSNode);¬∂			}¬∂		}¬∂		return aRetVal;¬∂		¬∂	}¬∂	public static Set<AssignmentSNode> assignmentsToParallelCriticalSharedVariables(SNode anSNode) {¬∂		Set<AssignmentSNode> anAllSharedAssignments =  assignmentsToSharedVariables(anSNode);¬∂		Set<AssignmentSNode> aRetVal = new HashSet();¬∂		for (AssignmentSNode anAssignmentSNode:anAllSharedAssignments) {¬∂			if (anAssignmentSNode.isInParallel() &&¬∂					anAssignmentSNode.isInCritical()) {¬∂				aRetVal.add(anAssignmentSNode);¬∂			}¬∂		}¬∂		return aRetVal;¬∂		¬∂	}¬∂	public static Set<AssignmentSNode> assignmentsToNonParallelCriticalSharedVariables(SNode anSNode) {¬∂		Set<AssignmentSNode> anAllSharedAssignments =  assignmentsToSharedVariables(anSNode);¬∂		Set<AssignmentSNode> aRetVal = new HashSet();¬∂		for (AssignmentSNode anAssignmentSNode:anAllSharedAssignments) {¬∂			if (!anAssignmentSNode.isInParallel() &&¬∂					anAssignmentSNode.isInCritical()) {¬∂				aRetVal.add(anAssignmentSNode);¬∂			}¬∂		}¬∂		return aRetVal;¬∂		¬∂	}¬∂	public static Set<AssignmentSNode> assignmentsToParallelNonCriticalSharedVariables(SNode anSNode) {¬∂		Set<AssignmentSNode> anAllSharedAssignments =  assignmentsToSharedVariables(anSNode);¬∂		Set<AssignmentSNode> aRetVal = new HashSet();¬∂		for (AssignmentSNode anAssignmentSNode:anAllSharedAssignments) {¬∂			if (anAssignmentSNode.isInParallel() &&¬∂					!anAssignmentSNode.isInCritical()) {¬∂				aRetVal.add(anAssignmentSNode);¬∂			}¬∂		}¬∂		return aRetVal;¬∂		¬∂	}¬∂    public static void fillAssignmentsToShared(SNode anSNode, Set<AssignmentSNode> retVal) {¬∂    	if (anSNode instanceof AssignmentSNode) {¬∂			AssignmentSNode anAssignmentSNode = (AssignmentSNode) anSNode;¬∂			String anLHS = anAssignmentSNode.getLhsFirstIdentifier();¬∂			if (isSharedVariable(anSNode, anLHS)) {¬∂				retVal.add(anAssignmentSNode);¬∂				return;¬∂			}¬∂		}¬∂    	for (SNode aChild:anSNode.getChildren()) {¬∂    		fillAssignmentsToShared(aChild, retVal);¬∂    	}¬∂		¬∂	}¬∂    public static void fillInstancesOfNodeType(Class<? extends SNode> aNodeType, SNode anSNode, Set<SNode> retVal) {¬∂    	if (aNodeType.isAssignableFrom(anSNode.getClass())) {¬∂			¬∂				retVal.add(anSNode);¬∂				return;¬∂			}¬∂		¬∂    	for (SNode aChild:anSNode.getChildren()) {¬∂    		fillInstancesOfNodeType(aNodeType, aChild, retVal);¬∂    	}¬∂		¬∂	}¬∂    public static Set<AssignmentSNode>  assignmentSNodes(SNode anSNode) {¬∂    	Set retVal = new HashSet();    	¬∂    	fillInstancesOfNodeType(AssignmentSNode.class, anSNode, retVal );¬∂    	return retVal;¬∂	}¬∂   ¬∂    ¬∂    public static Set<OMPParallelSNode>  ompParallelSNodes(SNode anSNode) {¬∂    	Set retVal = new HashSet();    	¬∂    	fillInstancesOfNodeType(OMPParallelSNode.class, anSNode, retVal );¬∂    	return retVal;¬∂	}¬∂//    public static void fillOMPParallelSNodes(SNode anSNode, Set<OMPParallelSNode> retVal) {¬∂//    	if (anSNode instanceof OMPParallelSNode) {¬∂//    		retVal.add((OMPParallelSNode) anSNode);¬∂//		}¬∂//    	for (SNode aChild:anSNode.getChildren()) {¬∂//    		fillOMPParallelSNodes(aChild, retVal);¬∂//    	}		¬∂//	}¬∂    public static Set<ForSNode>  forSNodes(SNode anSNode) {¬∂    	Set retVal = new HashSet();    	¬∂    	fillInstancesOfNodeType(ForSNode.class, anSNode, retVal );¬∂    	return retVal;¬∂	}¬∂//    public static void fillForSNodes(SNode anSNode, Set<ForSNode> retVal) {¬∂//    	if (anSNode instanceof ForSNode) {¬∂//    		retVal.add((ForSNode) anSNode);¬∂//		}¬∂//    	for (SNode aChild:anSNode.getChildren()) {¬∂//    		fillForSNodes(aChild, retVal);¬∂//    	}		¬∂//	}¬∂    public static Set<OMPForSNode>  ompForSNodes(SNode anSNode) {¬∂    	Set retVal = new HashSet();    	¬∂    	fillInstancesOfNodeType(OMPForSNode.class, anSNode, retVal );¬∂    	return retVal;¬∂	}¬∂//    public static void fillOMPForSNodes(SNode anSNode, Set<OMPForSNode> retVal) {¬∂//    	if (anSNode instanceof OMPForSNode) {¬∂//    		retVal.add((OMPForSNode) anSNode);¬∂//		}¬∂//    	for (SNode aChild:anSNode.getChildren()) {¬∂//    		fillOMPForSNodes(aChild, retVal);¬∂//    	}		¬∂//	}¬∂    public static Set<OMPForSNode> ompReducingForNodes(SNode anSNode) {¬∂		Set<OMPForSNode> anAllOMPForSNodes =  ompForSNodes(anSNode);¬∂		Set<OMPForSNode> aRetVal = new HashSet();¬∂		for (OMPForSNode anOMPForSNode:anAllOMPForSNodes) {¬∂			if (anOMPForSNode.getReductionOperation() != null) {¬∂				aRetVal.add(anOMPForSNode);¬∂			}¬∂		}¬∂		return aRetVal;		¬∂	}¬∂    public static Set<AssignmentSNode> assignmentsToOMPReducingForNode(OMPForSNode anOMPForSNode) {¬∂    	String aReductionVariable = anOMPForSNode.getReductionVariable();¬∂    	return directAssignmentsOfVariableAndItsAliases(anOMPForSNode, aReductionVariable)	;¬∂    	¬∂    }¬∂	public static boolean dependsOn (SNode anSNode, int aVariableLineNumber, String aVariable, String aCallIdentifier) {¬∂		List<SNode> aListSNodes = anSNode.getChildren();¬∂		boolean retVal = false;¬∂		/*¬∂		 * Should probably ignore line number as it assumes straight line code¬∂		 */¬∂		for (int i = aVariableLineNumber; i >= 0; i--) {¬∂			SNode anSNodeChild = aListSNodes.get(i);¬∂			if (anSNodeChild instanceof AssignmentSNode) {¬∂				// does this statement in anSNode directly invoke aCallIdentifier ¬∂				if (dependsOn((AssignmentSNode) anSNodeChild, aVariable, aCallIdentifier))¬∂					return true;¬∂			} else if (!anSNode.isLeaf()) {¬∂					// child is overriding the variable so forget checking its assignment statements¬∂					if (anSNodeChild.getLocalVariableIdentifiers().contains(aVariable)) {¬∂						continue;¬∂					}¬∂					// some subblock of anSNode that has access to aVariable changes variable¬∂¬∂					if (dependsOn(anSNodeChild, anSNodeChild.getChildren().size() - 1, aVariable, aCallIdentifier)) {¬∂						return true;¬∂					}¬∂			}¬∂			¬∂		}¬∂		// none of the statements in anSNode or its descendents  have the required call¬∂		// is the variable a  method parameter ¬∂		if (anSNode instanceof MethodSNode) {¬∂			MethodSNode aMethodSNode = (MethodSNode) anSNode;¬∂			¬∂			int aParameterNumber = aMethodSNode.getLocalVariableIdentifiers().indexOf(aVariable);¬∂			if (aParameterNumber != -1) {¬∂				List <MethodCall> aCalls = aMethodSNode.getCalls();¬∂				for (MethodCall aCall:aCalls) {¬∂//					if (!aCall.getMethodActuals().contains(aVariable))¬∂//						continue;¬∂//					¬∂					MethodSNode aCallerSNode = getDeclarationOfCalledMethod(aMethodSNode, aCall);¬∂					if (dependsOn(aMethodSNode, aCallerSNode.getLineNumber(), aCallerSNode.getLocalVariableIdentifiers().get(aParameterNumber), aCallIdentifier));¬∂//				    if (aCallerDepends) {¬∂				    	return true;¬∂//				    }¬∂				}¬∂				return false;¬∂				// need to find all callers of method and see if any of the aliases for the variable in these¬∂				// calls depend on aCallIndentifier¬∂			}			¬∂			¬∂		} else if (anSNode.getLocalVariableIdentifiers().contains(aVariable)) {¬∂			// before going to the parent node, let us see if aVariable is declared here as a non  parameter ¬∂¬∂			return false; // no point going to parent¬∂		}¬∂		// not a local variable (parameter or declarated variable)¬∂		SNode anSNodeParent = anSNode.getParent() ;¬∂		if (anSNodeParent == null)  {¬∂			return false;¬∂		}¬∂		int anSNodeLineNumber = anSNodeParent.getChildren().indexOf(anSNode);¬∂		return dependsOn(anSNodeParent, anSNodeLineNumber, aVariable, aCallIdentifier);¬∂		¬∂	}¬∂	public static Set<AssignmentSNode> assignmentsOfVariableAliases (SNode anSNode,  String aVariable) {¬∂		Set<AssignmentSNode> retVal = new HashSet();¬∂		fillDirectAssignmentsOfVariableAliases(anSNode, aVariable, retVal);¬∂		return retVal;¬∂	}¬∂	public static void fillDirectAssignmentsOfVariableAliases (SNode anSNode,  String aVariable, Set<AssignmentSNode> retVal) {¬∂		if (anSNode instanceof MethodCall) {¬∂			MethodCall aMethodCall = (MethodCall) anSNode;¬∂			int aParameterNumber = aMethodCall.getMethodActualIdentifiers().indexOf(aVariable);¬∂			if (aParameterNumber < 0) {¬∂				return;¬∂			}¬∂			MethodSNode aDeclaringMethodSNode = getDeclarationOfCalledMethod(anSNode, aMethodCall);¬∂			String aFormalParameter = aDeclaringMethodSNode.getLocalVariableIdentifiers().get(aParameterNumber);¬∂//			Set<AssignmentSNode> aCallAssignments = ;¬∂			fillDirectAssignmentsOfVariableAliases(aDeclaringMethodSNode, aFormalParameter, retVal);¬∂		} else {¬∂			List<SNode> aChildren = anSNode.getChildren();¬∂			for (SNode aChild:aChildren) {¬∂				fillDirectAssignmentsOfVariableAliases(aChild, aVariable, retVal);¬∂			}¬∂		}		¬∂		¬∂	}¬∂	¬∂	/*¬∂	 * will not consider assignments to variables in the RHS of these assignments¬∂	 */¬∂	public static Set<AssignmentSNode> directAssignmentsOfVariableAndItsAliases (SNode anSNode,  String aVariable) {¬∂		Set<AssignmentSNode> retVal = new HashSet();¬∂		fillDirectAssignmentsOfVariableAndItsAliases(anSNode, aVariable, retVal);¬∂		return retVal;¬∂	}¬∂	¬∂//	public static Set<AssignmentSNode> assignmentsEffectingVariableAndItsAliases (SNode anSNode,  String aVariable) {¬∂//		Set<AssignmentSNode> retVal = directAssignmentsOfVariableAndItsAliases(anSNode, aVariable);¬∂//		¬∂//	}¬∂	public static void fillDirectAssignmentsOfVariableAndItsAliases (SNode anSNode,  String aVariable, Set<AssignmentSNode> retVal) {¬∂		if (anSNode instanceof AssignmentSNode) {¬∂			AssignmentSNode anAssignmentSNode = (AssignmentSNode) anSNode;¬∂			if (anAssignmentSNode.getLhsFirstIdentifier().equals(aVariable)) {¬∂				retVal.add(anAssignmentSNode);¬∂			}¬∂		}¬∂		¬∂		else if (anSNode instanceof MethodCall) {¬∂			MethodCall aMethodCall = (MethodCall) anSNode;¬∂			int aParameterNumber = aMethodCall.getMethodActualIdentifiers().indexOf(aVariable);¬∂			if (aParameterNumber < 0) {¬∂				return;¬∂			}¬∂			MethodSNode aDeclaringMethodSNode = getDeclarationOfCalledMethod(anSNode, aMethodCall);¬∂			String aFormalParameter = aDeclaringMethodSNode.getLocalVariableIdentifiers().get(aParameterNumber);¬∂//			Set<AssignmentSNode> aCallAssignments = ;¬∂			fillDirectAssignmentsOfVariableAndItsAliases(aDeclaringMethodSNode, aFormalParameter, retVal);¬∂		} else {¬∂			List<SNode> aChildren = anSNode.getChildren();¬∂			for (SNode aChild:aChildren) {¬∂				fillDirectAssignmentsOfVariableAndItsAliases(aChild, aVariable, retVal);¬∂			}¬∂		}		¬∂		¬∂	}¬∂	¬∂	public static RootOfFileSNode getRootOfFileNode(SNode aCurrentSNode ) {¬∂		if (aCurrentSNode instanceof RootOfFileSNode) {¬∂			return (RootOfFileSNode) aCurrentSNode;¬∂		}¬∂		SNode aParentSNode = aCurrentSNode.getParent() ;¬∂		¬∂		if (aParentSNode == null) {¬∂			return null;¬∂		}¬∂		¬∂		return getRootOfFileNode(aParentSNode);¬∂		¬∂	}¬∂	public static boolean match (MethodSNode aMethodSNode, MethodCall aMethodCall) {¬∂		return aMethodSNode.getMethodName().equals(aMethodCall.getMethodName()) ¬∂				&& aMethodSNode.getLocalVariableIdentifiers().size() == aMethodCall.getMethodActuals().size();¬∂	}¬∂	public static DeclarationSNode getDeclarationOfVariableIdentifier(SNode aCurrentSNode, String anIdentifier) {¬∂		if (aCurrentSNode == null) {¬∂			return null;¬∂		}¬∂		¬∂		¬∂		int anIndex = aCurrentSNode.getLocalVariableIdentifiers().indexOf(anIdentifier);¬∂		if (anIndex < 0) {¬∂			return getDeclarationOfVariableIdentifier(aCurrentSNode.getParent(), anIdentifier);¬∂		}¬∂		DeclarationSNode retVal = aCurrentSNode.getVariableDeclarations().get(anIndex);¬∂//		retVal.getAssignmentsToDeclaredVariable().add(anAssignmentSNode);¬∂//		anAssignmentSNode.setLhsFirstIdentifierDeclaration(retVal);¬∂		return retVal;¬∂	}¬∂	¬∂	public static DeclarationSNode getDeclarationOfAssignedVariable(SNode aCurrentSNode, AssignmentSNode anAssignmentSNode) {¬∂		if (aCurrentSNode == null) {¬∂			return null;¬∂		}¬∂		if (anAssignmentSNode instanceof ADeclaringAssignmentSNode) {¬∂			return (ADeclaringAssignmentSNode) anAssignmentSNode;¬∂		}¬∂		int anIndex = aCurrentSNode.getLocalVariableIdentifiers().indexOf(anAssignmentSNode.getLhsFirstIdentifier());¬∂		if (anIndex < 0) {¬∂			return getDeclarationOfAssignedVariable(aCurrentSNode.getParent(), anAssignmentSNode);¬∂		}¬∂		DeclarationSNode retVal = aCurrentSNode.getVariableDeclarations().get(anIndex);¬∂//		retVal.getAssignmentsToDeclaredVariable().add(anAssignmentSNode);¬∂//		anAssignmentSNode.setLhsFirstIdentifierDeclaration(retVal);¬∂		return retVal;¬∂	}¬∂	¬∂	public static MethodSNode getDeclarationOfCalledMethod(SNode aCurrentSNode, MethodCall aMethodCall ) {¬∂		SNode aRootNode = getRootOfFileNode(aCurrentSNode);¬∂		for (SNode aChild:aRootNode.getChildren()) {¬∂			if (aChild instanceof MethodSNode) {¬∂				MethodSNode aMethodSNode = (MethodSNode) aChild;¬∂				if (match (aMethodSNode, aMethodCall)) {¬∂					return aMethodSNode;¬∂				}¬∂			}¬∂		}¬∂		return null; // this should never happen;¬∂	}¬∂	¬∂	public static RootOfProgramSNode getRootOfProgramSNode(String aSource) {¬∂		RootOfProgramSNode retVal = new ARootOfProgramSNode();¬∂		Map<String, StringBuffer> aFileNameToContents = ABasicTextManager.extractFileContents(aSource);¬∂		for (String aFileName:aFileNameToContents.keySet()) {¬∂			StringBuffer aFileContents = aFileNameToContents.get(aFileName);¬∂//			List<OpenMPPragma> anOpenMPPragmas = OpenMPUtils.getOpemMPPragmas(aFileContents);¬∂			RootOfFileSNode anSNode = OMPSNodeUtils.getSNode(aFileName, aFileContents);¬∂			retVal.getFileNameToSNode().put(aFileName, anSNode);¬∂			anSNode.setParent(retVal);¬∂//			System.out.println("file name:" + aFileName);¬∂//			System.out.println("pragmas:" + anSNode);¬∂		}¬∂		processExternalMethodSNodes(retVal);¬∂		processIndirectAssignments(retVal);¬∂		return retVal;¬∂	}¬∂//	public static void processIndirectAssignments (S aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode) {¬∂//		for (SNode anSNode:aRootOfFileSNode.getChildren()) {¬∂//			-----¬∂//		}¬∂//	}¬∂	public static void processExternalMethodSNodes (RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode) {¬∂		for (SNode anSNode:aRootOfFileSNode.getChildren()) {¬∂			if (anSNode instanceof ExternalMethodSNode) {¬∂				processExternalMethodSNode(aRootOfProgramSNode, aRootOfFileSNode, (ExternalMethodSNode) anSNode);¬∂			}¬∂		}¬∂	}¬∂	public static void processExternalMethodSNode (RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode, ExternalMethodSNode anExternalMethodSNode) {¬∂		MethodSNode aMethodSNode = aRootOfProgramSNode.getExternalToInternalMethod().get(anExternalMethodSNode.toString());¬∂		if (aMethodSNode == null) {¬∂			aMethodSNode = findMethodSNode(aRootOfProgramSNode, aRootOfFileSNode, anExternalMethodSNode);¬∂			if (aMethodSNode != null) {¬∂				aRootOfProgramSNode.getExternalToInternalMethod().put(anExternalMethodSNode.toString(),aMethodSNode );¬∂			}¬∂		}¬∂		if (aMethodSNode != null) {¬∂			anExternalMethodSNode.setActualMethodSNode(aMethodSNode);¬∂			aMethodSNode.getCalls().addAll(anExternalMethodSNode.getLocalCalls());¬∂		}¬∂	}¬∂	¬∂	public static MethodSNode findMethodSNode (RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode, ExternalMethodSNode anExternalMethodSNode) {¬∂//		MethodSNode foundMethodSNode = null;¬∂		for (String aFileName:aRootOfProgramSNode.getFileNameToSNode().keySet()) {¬∂			if (aFileName.equals(aRootOfFileSNode.getFileName()))¬∂				continue;¬∂			¬∂			RootOfFileSNode aSearchedRootOfFileSNode = aRootOfProgramSNode.getFileNameToSNode().get(aFileName);¬∂			 for (SNode anSNode:aSearchedRootOfFileSNode.getChildren()) {¬∂				if (anSNode instanceof MethodSNode && !(anSNode instanceof ExternalMethodSNode)) {¬∂					if (anSNode.toString().equals(anExternalMethodSNode.toString())) {¬∂						return (MethodSNode) anSNode;¬∂						¬∂					}¬∂//					processExternalMethodSNode(aRootOfProgramSNode, aRootOfFileSNode, (ExternalMethodSNode) anSNode);¬∂				}¬∂			}¬∂		}¬∂		return null;¬∂	}¬∂	public static void processExternalMethodSNodes (RootOfProgramSNode aRootOfProgramSNode) {¬∂		for (String aFileName:aRootOfProgramSNode.getFileNameToSNode().keySet()) {¬∂			RootOfFileSNode aRootOfFileSNode = aRootOfProgramSNode.getFileNameToSNode().get(aFileName);¬∂			processExternalMethodSNodes(aRootOfProgramSNode, aRootOfFileSNode);¬∂			aRootOfFileSNode.getOmp_get_num_threads_SNode().¬∂				setActualMethodSNode(aRootOfProgramSNode.getOmp_get_num_threads_SNode());¬∂			aRootOfFileSNode.getOmp_get_thread_num_SNode().¬∂				setActualMethodSNode(aRootOfProgramSNode.getOmp_get_thread_num_SNode());¬∂			aRootOfFileSNode.getOmp_get_wtime_SNode().¬∂			setActualMethodSNode(aRootOfProgramSNode.getOmp_get_wtime_SNode());¬∂		}¬∂¬∂	}¬∂	public static void processIndirectAssignments (SNode anSNode) {¬∂		if (anSNode instanceof ConstDeclarationSNode) {¬∂			return;¬∂		}¬∂		if (anSNode instanceof DeclarationSNode) {¬∂			DeclarationSNode aDeclarationSNode = (DeclarationSNode) anSNode;¬∂			Set<AssignmentSNode> anIndirectAssignments = aDeclarationSNode.getAssignmentsEffectingDeclaredIdentifier();¬∂			if (anIndirectAssignments != null) {¬∂				return; // already assigned¬∂			}¬∂			anIndirectAssignments = new HashSet<>();¬∂			aDeclarationSNode.setAssignmentsEffectingDeclaredIdentifier(anIndirectAssignments);¬∂			Set<AssignmentSNode> aDirectAssignments = aDeclarationSNode.getAssignmentsToDeclaredVariable();¬∂			anIndirectAssignments.addAll(aDirectAssignments);¬∂			Set<AssignmentSNode> anAliasAssignments = assignmentsOfVariableAliases(aDeclarationSNode.getParent(), aDeclarationSNode.getVariableName());¬∂			anIndirectAssignments.addAll(anAliasAssignments);¬∂			for (AssignmentSNode aDirectAssignment:aDirectAssignments) {¬∂				List<String> aVariableIdentifiers = aDirectAssignment.getRhsVariableIdentifiers();¬∂				¬∂				for (String aVariableIdentifier:aVariableIdentifiers) {¬∂					DeclarationSNode aDependeeDeclarationSNode = getDeclarationOfVariableIdentifier(aDirectAssignment, aVariableIdentifier);¬∂					if (aDependeeDeclarationSNode == null) {¬∂						System.err.println("Could not find declaration of:" + aVariableIdentifier + " referenced in:" + aDirectAssignment );¬∂						continue;¬∂					}¬∂					processIndirectAssignments(aDependeeDeclarationSNode);¬∂					Set<AssignmentSNode> aDependeeIndirectAssignments = aDeclarationSNode.getAssignmentsEffectingDeclaredIdentifier();¬∂					anIndirectAssignments.addAll(aDependeeIndirectAssignments);¬∂					¬∂				}¬∂			}¬∂		} else {¬∂			for (SNode aChild: anSNode.getChildren()) {¬∂				processIndirectAssignments(aChild);¬∂			}¬∂		}¬∂		¬∂	}¬∂	¬∂//	public static void fillIndirectAssignments (SNode anSNode, Set<AssignmentSNode> retVal ) {¬∂//		¬∂//	}¬∂	¬∂¬∂//	public static void main(String[] args) {¬∂//		List<MethodCall> aTokens = callsIn("foo(bar, hgf)/foo2()*foo3(b, a c,)");¬∂//		System.out.println(aTokens);¬∂//		¬∂//		¬∂////		List<String> aTokens = identifiersIn("a[i] + b*2/3");¬∂////		System.out.println(aTokens);¬∂////		aTokens = numbersIn("a[i] + b*2/3");¬∂////		System.out.println(aTokens);¬∂////		aTokens = operatorsIn("a[i] + b*2/3");¬∂////		System.out.println(aTokens);¬∂////¬∂////		System.out.println(StringUtils.substringBetween("a", "[", "]"));¬∂//	}¬∂¬∂}¬∂")]]]></diff>
  </Command>
  <Command __id="218218" _type="RunCommand" date="Fri Jan 10 10:29:48 EST 2020" kind="StepInto" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="2003683616" type="Run" />
  <Command __id="222038" _type="RunCommand" date="Fri Jan 10 14:08:39 EST 2020" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="2016814382" type="Run" />
  <Command __id="222039" _type="EclipseCommand" commandID="" date="Fri Jan 10 14:08:39 EST 2020" starttimestamp="1576666505112" timestamp="2016814486" />
  <Command __id="222040" _type="EclipseCommand" commandID="" date="Fri Jan 10 14:08:40 EST 2020" starttimestamp="1576666505112" timestamp="2016815170" />
  <Command __id="222041" _type="EclipseCommand" commandID="" date="Fri Jan 10 14:08:40 EST 2020" starttimestamp="1576666505112" timestamp="2016815170" />
  <Command __id="222042" _type="EclipseCommand" commandID="" date="Fri Jan 10 14:08:40 EST 2020" starttimestamp="1576666505112" timestamp="2016815210" />
  <Command __id="222043" _type="ShellCommand" date="Fri Jan 10 14:11:16 EST 2020" starttimestamp="1576666505112" timestamp="2016971013" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="222044" _type="ShellCommand" date="Fri Jan 10 14:11:16 EST 2020" starttimestamp="1576666505112" timestamp="2016971441" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="222045" _type="ShellCommand" date="Fri Jan 10 14:11:16 EST 2020" starttimestamp="1576666505112" timestamp="2016971731" type="ECLIPSE_LOST_FOCUS" />
  <DocumentChange __id="221833" _type="Insert" date="Fri Jan 10 11:21:50 EST 2020" docASTNodeCount="5347" docActiveCodeLength="39504" docExpressionCount="3297" docLength="45623" length="7" offset="33854" starttimestamp="1576666505112" timestamp="2006805479">
    <text><![CDATA[
					]]></text>
  </DocumentChange>
  <DocumentChange __id="221840" _type="Replace" date="Fri Jan 10 11:22:03 EST 2020" docASTNodeCount="5353" docActiveCodeLength="39594" docExpressionCount="3302" docLength="45713" endLine="913" insertionLength="95" int_docASTNodeCount="5347" int_docActiveCodeLength="39499" int_docExpressionCount="3297" int_docLength="45618" length="5" offset="33856" startLine="913" starttimestamp="1576666505112" timestamp="2006818153">
    <deletedText><![CDATA[					]]></deletedText>
    <insertedText><![CDATA[					fillDirectAssignmentsOfVariableAliases(aDeclaringMethodSNode, aFormalParameter, retVal);
]]></insertedText>
  </DocumentChange>
  <DocumentChange __id="221847" _type="Replace" date="Fri Jan 10 11:22:12 EST 2020" docASTNodeCount="5353" docActiveCodeLength="39591" docExpressionCount="3302" docLength="45710" endLine="913" insertionLength="18" int_docASTNodeCount="5352" int_docActiveCodeLength="39573" int_docExpressionCount="3301" int_docLength="45692" length="21" offset="33900" startLine="913" starttimestamp="1576666505112" timestamp="2006827708">
    <deletedText><![CDATA[aDeclaringMethodSNode]]></deletedText>
    <insertedText><![CDATA[aCallerMethodSNode]]></insertedText>
  </DocumentChange>
  <DocumentChange __id="221854" _type="Replace" date="Fri Jan 10 11:22:25 EST 2020" docASTNodeCount="5353" docActiveCodeLength="39582" docExpressionCount="3302" docLength="45701" endLine="913" insertionLength="7" int_docASTNodeCount="5352" int_docActiveCodeLength="39575" int_docExpressionCount="3301" int_docLength="45694" length="16" offset="33920" startLine="913" starttimestamp="1576666505112" timestamp="2006840010">
    <deletedText><![CDATA[aFormalParameter]]></deletedText>
    <insertedText><![CDATA[anAlias]]></insertedText>
  </DocumentChange>
  <Command __id="221924" _type="DiffBasedFileOpenCommand" date="Fri Jan 10 11:22:59 EST 2020" docASTNodeCount="314" docActiveCodeLength="2264" docExpressionCount="187" docLength="2422" projectName="GraderBasics" starttimestamp="1576666505112" timestamp="2006874383">
    <filePath><![CDATA[D:\dewan_backup\Java\GraderBasics\src\gradingTools\shared\testcases\openmp\scannedTree\ADeclarationSNode.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package gradingTools.shared.testcases.openmp.scannedTree;¬∂¬∂import java.util.ArrayList;¬∂import java.util.HashSet;¬∂import java.util.List;¬∂import java.util.Set;¬∂¬∂public class ADeclarationSNode extends AnSNode implements DeclarationSNode {¬∂	String variableName;¬∂	¬∂	String typeName;¬∂	List<String> operators;¬∂	¬∂¬∂	String variableIdentifier;¬∂	String typeIdentifier;¬∂	Set<AssignmentSNode> assignmentsToDeclaredVariable = new HashSet();¬∂	Set<AssignmentSNode> assignmentsEffectingDeclaredIdentifier;¬∂¬∂	¬∂	¬∂	public ADeclarationSNode(int aLineNumber, String aTypeName, String aVariableName) {¬∂		super(aLineNumber);¬∂		typeName = aTypeName;¬∂		variableName = aVariableName;¬∂		operators = OMPSNodeUtils.operatorsIn(typeName);¬∂		operators.addAll(OMPSNodeUtils.operatorsIn(typeName));¬∂		variableIdentifier = OMPSNodeUtils.identifiersIn(variableName).get(0);¬∂		typeIdentifier =  OMPSNodeUtils.identifiersIn(typeName).get(0);¬∂	}¬∂	@Override¬∂	public String getTypeName() {¬∂		return typeName;¬∂	}¬∂	@Override¬∂	public void setTypeName(String typeName) {¬∂		this.typeName = typeName;¬∂	}¬∂	@Override¬∂	public String getVariableName() {¬∂		return variableName;¬∂	}¬∂	@Override¬∂	public void setParent(SNode anSNode) {¬∂		super.setParent(anSNode);¬∂		if (!anSNode.getVariableDeclarations().contains(this)) {¬∂		anSNode.getVariableDeclarations().add(this);¬∂//		anSNode.getLocalVariables().add(variableName);¬∂		anSNode.getLocalVariableIdentifiers().add(variableIdentifier);¬∂		}¬∂¬∂	}¬∂	public String toString() {¬∂		return typeName + " " + variableName;¬∂	}¬∂	@Override¬∂	public String getVariableIdentifier() {¬∂		return variableIdentifier;¬∂	}¬∂	¬∂	@Override¬∂	public String getTypeIdentifier() {¬∂		return typeIdentifier;¬∂	}¬∂	@Override¬∂	public List<String> getOperators() {¬∂		return operators;¬∂	}¬∂	@Override¬∂	public Set<AssignmentSNode> getAssignmentsToDeclaredVariable() {¬∂		return assignmentsToDeclaredVariable;¬∂	}¬∂//	@Override¬∂//¬∂//	public void setVariableName(String variableName) {¬∂//		this.variableName = variableName;¬∂//	}¬∂	@Override¬∂	public Set<AssignmentSNode> getAssignmentsEffectingDeclaredIdentifier() {¬∂		return assignmentsEffectingDeclaredIdentifier;¬∂	}¬∂	@Override¬∂	public void setAssignmentsEffectingDeclaredIdentifier(Set<AssignmentSNode> assignmentsEffectingDeclaredIdentifier) {¬∂		this.assignmentsEffectingDeclaredIdentifier = assignmentsEffectingDeclaredIdentifier;¬∂	}¬∂}¬∂")]]]></diff>
  </Command>
  <Command __id="221930" _type="DiffBasedFileOpenCommand" date="Fri Jan 10 11:23:05 EST 2020" docASTNodeCount="5353" docActiveCodeLength="39582" docExpressionCount="3302" docLength="45701" projectName="GraderBasics" starttimestamp="1576666505112" timestamp="2006880713">
    <filePath><![CDATA[D:\dewan_backup\Java\GraderBasics\src\gradingTools\shared\testcases\openmp\scannedTree\OMPSNodeUtils.java]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"package gradingTools.shared.testcases.openmp.scannedTree;¬∂¬∂import java.util.ArrayList;¬∂import java.util.Arrays;¬∂import java.util.HashMap;¬∂import java.util.HashSet;¬∂import java.util.List;¬∂import java.util.Map;¬∂import java.util.Set;¬∂import java.util.Stack;¬∂import java.util.regex.Matcher;¬∂import java.util.regex.Pattern;¬∂¬∂import org.apache.commons.lang.StringUtils;¬∂¬∂import grader.basics.project.source.ABasicTextManager;¬∂import gradingTools.shared.testcases.openmp.OpenMPKeywordEnum;¬∂import gradingTools.shared.testcases.openmp.OpenMPParallelPragma;¬∂import gradingTools.shared.testcases.openmp.OpenMPUtils;¬∂import gradingTools.shared.testcases.openmp.scannedTree.ADeclarationSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.ADeclaringAssignmentSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.AForSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.ATextSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.AnAssignmentSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.AnOMPCriticalSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.AnOMPForSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.AnOMPParallelSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.AnOMPSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.AnSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.AssignmentSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.DeclarationSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.DeclaringAssignmentSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.ForSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.OMPForSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.OMPSNode;¬∂import gradingTools.shared.testcases.openmp.scannedTree.SNode;¬∂¬∂public class OMPSNodeUtils extends OpenMPUtils {¬∂¬∂	public static RootOfFileSNode getSNode(String aFileName, StringBuffer aFileBuffer) {¬∂		String[] aFileLines = aFileBuffer.toString().split("\n");¬∂		return getSNode(aFileName, aFileLines);¬∂	}¬∂¬∂	public static AssignmentSNode getAssignmentSNode(int aLineNumber, String aString) {¬∂		if (aString == null) {¬∂			return null;¬∂		}¬∂		String[] aTokens = aString.split("=");¬∂		if (aTokens.length == 1) {¬∂			return new AnAssignmentSNode(aLineNumber, aTokens[0], null);¬∂		} else {¬∂		return new AnAssignmentSNode(aLineNumber, aTokens[0], aTokens[1]);¬∂		}¬∂	}¬∂¬∂	public static DeclarationSNode getDeclarationSNode(int aLineNumber, String aString) {¬∂		String[] aTokens = aString.split(" ");¬∂		return new ADeclarationSNode(aLineNumber, aTokens[0], aTokens[1]);¬∂	}¬∂¬∂	public static DeclaringAssignmentSNode getDeclaringAssignmentSNode(int aLineNumber, String aString) {¬∂		String[] anLHSAndRHS = aString.split("=");¬∂		String[] aTypeAndVariable = anLHSAndRHS[0].split(" ");¬∂		return new ADeclaringAssignmentSNode(aLineNumber, aTypeAndVariable[0], aTypeAndVariable[1], anLHSAndRHS[1]);¬∂	}¬∂	public static ConstDeclarationSNode getConstDeclarationSNode(int aLineNumber, String aString) {¬∂		String anAssignmentString = aString.substring(CONST.length()).trim();¬∂		String[] anLHSAndRHS = anAssignmentString.split("=");¬∂		String[] aTypeAndVariable = anLHSAndRHS[0].split(" ");¬∂		return new AConstDeclarationSNode(aLineNumber, aTypeAndVariable[0], aTypeAndVariable[1], anLHSAndRHS[1]);¬∂	}¬∂¬∂	public static boolean isDeclaringAssignment(String aFileLine) {¬∂		return startsWithTypeName(aFileLine) && aFileLine.contains("=");¬∂	}¬∂	public static boolean isConstDeclaration(String aFileLine) {¬∂		return aFileLine.startsWith(CONST);¬∂	}¬∂	public static boolean isMethodDeclaration(String aFileLine) {¬∂		return startsWithTypeName(aFileLine) && ¬∂				aFileLine.contains("(") &&¬∂				!aFileLine.contains("=");¬∂	}¬∂	public static boolean isExternalMethodDeclaration(String aFileLine) {¬∂		return isMethodDeclaration(aFileLine) && aFileLine.endsWith(";");¬∂	}¬∂¬∂¬∂	public static boolean isVariableDeclaration(String aFileLine) {¬∂¬∂		return startsWithTypeName(aFileLine) && !aFileLine.contains("(");¬∂	}¬∂¬∂	public static boolean isAssignment(String aFileLine) {¬∂		return aFileLine.contains("=") && !aFileLine.contains("==");¬∂	}¬∂¬∂	public static boolean isForNode(String aFileLine) {¬∂		return aFileLine.startsWith("for");¬∂	}¬∂¬∂	public static ForSNode getForSNode(int aLineNumber, String aFileLine) {¬∂¬∂		int aLeftParenIndex = aFileLine.indexOf("(");¬∂		int aRightParenIndex = aFileLine.indexOf(")");¬∂		if (aLeftParenIndex < 0 || aRightParenIndex < 0) {¬∂			return null;¬∂		}¬∂		String aHeaderString = aFileLine.substring(aLeftParenIndex + 1, aRightParenIndex);¬∂		String[] aForComponents = aHeaderString.split(";");¬∂		AssignmentSNode anAssignmentSNode = null;¬∂		String aForInitializaton = aForComponents[0];¬∂		if (!aForInitializaton.isEmpty() && aForInitializaton.contains("=")) {¬∂			if (isDeclaringAssignment(aForInitializaton)) {¬∂				anAssignmentSNode = getDeclaringAssignmentSNode(aLineNumber, aForInitializaton);¬∂			} else {¬∂				anAssignmentSNode = getAssignmentSNode(aLineNumber, aForInitializaton);¬∂			}¬∂¬∂		}		¬∂		return new AForSNode(aLineNumber, anAssignmentSNode, aForComponents[1], getAssignmentSNode(aLineNumber, aForComponents[2]));¬∂	}¬∂	static String[] emptyArray = {};¬∂	public static MethodSNode getMethodSNode(int aLineNumber, String aFileLine, boolean isInternal) {¬∂¬∂		int aLeftParenIndex = aFileLine.indexOf("(");¬∂		int aRightParenIndex = aFileLine.indexOf(")");¬∂		if (aLeftParenIndex < 0 || aRightParenIndex < 0) {¬∂			return null;¬∂		}¬∂		String aMethodNameAndType = aFileLine.substring(0, aLeftParenIndex);¬∂		String[] aMethodNameAndTypeTokens = aMethodNameAndType.split("\\s+"); ¬∂		¬∂		String aMethodParameters = aFileLine.substring(aLeftParenIndex +1 , aRightParenIndex);¬∂		String[] aMethodParameterTokens = aMethodParameters.isEmpty()?emptyArray:¬∂		 aMethodParameters.split(",");¬∂		¬∂//		String[] aMethodParameterTypes = new String[aMethodParameterTokens.length];¬∂//		String[] aMethodParameterNames = new String[aMethodParameterTokens.length];¬∂		List<DeclarationSNode> aDeclarationSNodeList = new ArrayList();¬∂		for (int i = 0; i < aMethodParameterTokens.length; i++ ) {¬∂			String[] aTypeAndName = aMethodParameterTokens[i].trim().split("\\s+");¬∂			if (aTypeAndName.length < 2) {¬∂				continue;¬∂			}¬∂			aDeclarationSNodeList.add(new ADeclarationSNode(aLineNumber, aTypeAndName[0].trim(), aTypeAndName[1].trim()));¬∂//			aMethodParameterTypes[i] = aTypeAndName[0].trim();¬∂//			aMethodParameterNames[i] = aTypeAndName[1].trim();¬∂		}¬∂		if (isInternal)¬∂//		return new AMethodSNode(aLineNumber, aMethodNameAndTypeTokens[0], aMethodNameAndTypeTokens[1], aMethodParameterTypes,aMethodParameterNames );¬∂			return new AMethodSNode(aLineNumber, aMethodNameAndTypeTokens[0], aMethodNameAndTypeTokens[1], aDeclarationSNodeList );¬∂		else¬∂			return new AnExternalMethodSNode(aLineNumber, aMethodNameAndTypeTokens[0], aMethodNameAndTypeTokens[1], aDeclarationSNodeList );¬∂	}¬∂¬∂	public static void setReductionData(OMPForSNode lastChild, String aStoredToken, int aLeftParenIndex,¬∂			int aRightParenIndex) {¬∂		int aColonIndex = aStoredToken.indexOf(":");¬∂		if (aLeftParenIndex != -1 && aRightParenIndex != -1 && aColonIndex != -1) {¬∂			String anOperationString = aStoredToken.substring(aLeftParenIndex + 1, aColonIndex).trim();¬∂			String aVariableString = aStoredToken.substring(aColonIndex + 1, aRightParenIndex).trim();¬∂			((OMPForSNode) lastChild).setReductionVariable(aVariableString);¬∂			((OMPForSNode) lastChild).setReductionOperation(anOperationString);¬∂		}¬∂	}¬∂¬∂	public static void setSharedOrPrivateData(OMPSNode lastChild, String aStoredToken, int aLeftParenIndex,¬∂			int aRightParenIndex, boolean isShared) {¬∂//		int aColonIndex = aStoredToken.indexOf(":");¬∂		if (aLeftParenIndex != -1 && aRightParenIndex != -1) {¬∂			String aVariableDeclarations = aStoredToken.substring(aLeftParenIndex + 1, aRightParenIndex);¬∂			String[] aVariables = aVariableDeclarations.split(",");¬∂			if (isShared) {¬∂				lastChild.setSharedVariables(aVariables);¬∂			} else {¬∂				lastChild.setPrivateVariables(aVariables);¬∂			}¬∂		}¬∂	}¬∂¬∂	public static RootOfFileSNode getSNode(String aFileName, String[] aFileLines) {¬∂		Stack<SNode> anSNodes = new Stack();¬∂¬∂		RootOfFileSNode retVal = new ARootOfFileSNode(aFileName);¬∂		anSNodes.add(retVal);¬∂		SNode previousHeaderNode = null;¬∂		for (int i = 0; i < aFileLines.length; i++) {¬∂			String aFileLine = aFileLines[i].trim();¬∂			if (!isCodeLine(aFileLine)) {¬∂				continue;¬∂			}¬∂			if (isForNode(aFileLine)) {¬∂				ForSNode aForSNode = getForSNode(i, aFileLine);¬∂				SNode aParent = previousHeaderNode != null?previousHeaderNode:anSNodes.peek();¬∂				aForSNode.setParent(anSNodes.peek());¬∂				aForSNode.setParent(aParent);¬∂¬∂//				anSNodes.push(aForSNode);¬∂				previousHeaderNode = aForSNode;¬∂				if (aFileLine.endsWith(")")) {¬∂					continue;¬∂				}¬∂			}¬∂			if (isExternalMethodDeclaration(aFileLine)) {¬∂				MethodSNode aMethodSNode = getMethodSNode(i, aFileLine, false);¬∂				aMethodSNode.setParent(anSNodes.peek());¬∂//				anSNodes.push(aForSNode);¬∂				previousHeaderNode = aMethodSNode;¬∂				if (aFileLine.endsWith(")")) {¬∂					continue;¬∂				}¬∂			}¬∂			if (isMethodDeclaration(aFileLine)) {¬∂				MethodSNode aMethodSNode = getMethodSNode(i, aFileLine, true);¬∂				aMethodSNode.setParent(anSNodes.peek());¬∂//				anSNodes.push(aForSNode);¬∂				previousHeaderNode = aMethodSNode;¬∂				if (aFileLine.endsWith(")")) {¬∂					continue;¬∂				}¬∂			}¬∂			if (isPragmaStart(aFileLine)) {¬∂				OMPSNode anOMPSNode = getOMPSNode(i, anSNodes.peek(), aFileLine);¬∂//				anSNodes.push(anOMPSNode);¬∂				previousHeaderNode = anOMPSNode;¬∂				continue;¬∂			}¬∂			if (isBlockStart(aFileLine)) {¬∂				SNode aBlockSNode = new ABlockSNode(i);¬∂				if (previousHeaderNode != null) {¬∂					aBlockSNode.setParent(previousHeaderNode);¬∂				} else {¬∂					aBlockSNode.setParent(anSNodes.peek());¬∂				}¬∂				anSNodes.push(aBlockSNode);¬∂				previousHeaderNode = null;¬∂				continue;¬∂			}¬∂//			} else ¬∂			if (isBlockEnd(aFileLine)) {¬∂				anSNodes.pop();¬∂				continue;¬∂			}¬∂			SNode aNewLeafNode = null;¬∂			if (isConstDeclaration(aFileLine)) {¬∂				aNewLeafNode = getConstDeclarationSNode(i, aFileLine);¬∂¬∂			} else if (isDeclaringAssignment(aFileLine)) {¬∂				aNewLeafNode = getDeclaringAssignmentSNode(i, aFileLine);¬∂¬∂			} else if (isAssignment(aFileLine)) {¬∂				aNewLeafNode = getAssignmentSNode(i, aFileLine);¬∂			} else if (isVariableDeclaration(aFileLine)) {¬∂				aNewLeafNode = getDeclarationSNode(i, aFileLine);¬∂			} else {¬∂				List<MethodCall> aCalls = callsIn(i, aFileLine, null); // parent will be assigned below¬∂				if (aCalls != null && aCalls.size() == 1) {¬∂					aNewLeafNode = aCalls.get(0);¬∂				} else {¬∂					aNewLeafNode = new ATextSNode(i, aFileLine);¬∂				}¬∂			}¬∂//			else {¬∂//				aNewLeafNode = new ATextSNode(i, aFileLine);¬∂//			}¬∂			if (previousHeaderNode != null) {¬∂				aNewLeafNode.setParent(previousHeaderNode);¬∂			} else {¬∂				aNewLeafNode.setParent(anSNodes.peek());¬∂			}¬∂¬∂		}¬∂¬∂		return retVal;¬∂	}¬∂¬∂	public static OMPSNode getOMPSNode(int aLineIndex, SNode aParentNode, String aFileLine) {¬∂		String[] aTokens = aFileLine.split("\\s+");¬∂		if (aTokens.length <= 2) {¬∂			return null;¬∂		}¬∂		if (!aTokens[1].equals("omp")) {¬∂			return null;¬∂		}¬∂		if (aTokens.length < 3) {¬∂			return null;¬∂		}¬∂		String aFirstToken = aTokens[2];¬∂		OpenMPKeywordEnum anOpenMPKeyword = stringToOpenMPKeyword.get(aFirstToken);¬∂//		List<OpenMPPragma> retVal = new ArrayList();¬∂		OMPSNode lastChild = null;¬∂		int aStartIndex = 2;¬∂		OMPSNode aNewNode = null;¬∂		OMPForSNode aForChild = null;¬∂		switch (anOpenMPKeyword) {¬∂		case PARALLEL:¬∂			aNewNode = new AnOMPParallelSNode(aLineIndex);¬∂¬∂			if (aTokens.length > 3 && aTokens[3].equals("for")) {¬∂				aForChild = new AnOMPForSNode(aLineIndex);¬∂				aForChild.setParent(aNewNode);¬∂¬∂				aStartIndex++;¬∂			}¬∂			break;¬∂		case FOR:¬∂			aNewNode = new AnOMPForSNode(aLineIndex);¬∂			;¬∂			break;¬∂		case CRITICAL:¬∂			aNewNode = new AnOMPCriticalSNode(aLineIndex);¬∂//			retVal.add (lastChild);¬∂			break;¬∂		default:¬∂			aNewNode = new AnOMPSNode(aLineIndex);¬∂¬∂		}¬∂¬∂		if (lastChild != null) {¬∂			aNewNode.setParent(lastChild);¬∂		} else {¬∂			aNewNode.setParent(aParentNode);¬∂		}¬∂		lastChild = aForChild == null ? aNewNode : aForChild;¬∂¬∂		for (int i = aStartIndex; i < aTokens.length; i++) {¬∂			String aStoredToken = aTokens[i].trim();¬∂			if (aStoredToken.isEmpty()) {¬∂				continue;¬∂			}¬∂			if (aStoredToken.startsWith("reduction") || aStoredToken.startsWith("shared")¬∂					|| aStoredToken.startsWith("private")) {¬∂				// combine all tokens until ")" into one for normalization¬∂				while (!aStoredToken.endsWith(")")) {¬∂					i++;¬∂					if (i >= aTokens.length) {¬∂						break;¬∂					}¬∂					String aNewToken = aTokens[i].trim();¬∂					aStoredToken += aNewToken;¬∂				}¬∂				int aLeftParenIndex = aStoredToken.indexOf("(");¬∂				int aRightParenIndex = aStoredToken.indexOf(")");¬∂				if (aStoredToken.startsWith("reduction")) {¬∂					setReductionData((OMPForSNode) lastChild, aStoredToken, aLeftParenIndex, aRightParenIndex);¬∂				} else if (aStoredToken.startsWith("private")) {¬∂					setSharedOrPrivateData((OMPSNode) lastChild, aStoredToken, aLeftParenIndex, aRightParenIndex,¬∂							false);¬∂¬∂				} else if (aStoredToken.startsWith("shared")) {¬∂					setSharedOrPrivateData(lastChild, aStoredToken, aLeftParenIndex, aRightParenIndex, true);¬∂¬∂				}¬∂¬∂			}¬∂¬∂			lastChild.getOpenMPTokens().add(aStoredToken);¬∂		}¬∂¬∂		return lastChild;¬∂¬∂	}¬∂¬∂	public static boolean hasParallelAncestor(SNode anSNode) {¬∂		if (anSNode == null) {¬∂			return false;¬∂		}¬∂		if (anSNode instanceof OMPParallelSNode) {¬∂			return true;¬∂		}¬∂		return hasParallelAncestor(anSNode.getParent());¬∂	}¬∂	public static boolean hasCriticalAncestor(SNode anSNode) {¬∂		if (anSNode == null) {¬∂			return false;¬∂		}¬∂		if (anSNode instanceof OMPCriticalSNode) {¬∂			return true;¬∂		}¬∂		return hasCriticalAncestor(anSNode.getParent());¬∂	}¬∂¬∂¬∂	public static Boolean isDeclaredShared(OMPSNode anOMPSNode, String anLHS) {¬∂		if (Arrays.asList(anOMPSNode.getSharedVariables()).contains(anLHS)) {¬∂			return true;¬∂		}¬∂		if (Arrays.asList(anOMPSNode.getPrivateVariables()).contains(anLHS)) {¬∂			return false;¬∂		}¬∂		return null;¬∂¬∂	}¬∂¬∂	public static boolean isSharedVariable(SNode anSNode, String anLHS) {¬∂		if (anSNode == null) {¬∂			return false;¬∂		}¬∂		if (anSNode.getLocalVariableIdentifiers().contains(anLHS)) {¬∂			if (!(anSNode instanceof OMPSNode)) { // no shared and private declarations¬∂				return !hasParallelAncestor(anSNode); // shared if not inParallel¬∂			}¬∂			OMPSNode anOMPSNode = (OMPSNode) anSNode;¬∂			return (Arrays.asList(anOMPSNode.getSharedVariables()).contains(anLHS)); // private unless declared shared¬∂		}¬∂		if (anSNode instanceof OMPSNode) {¬∂			OMPSNode anOMPSNode = (OMPSNode) anSNode;¬∂			// the variable is global to this scope, check if it has have been made shared¬∂			// or private by this scope¬∂			Boolean isDeclaredShared = isDeclaredShared(anOMPSNode, anLHS);¬∂			if (isDeclaredShared != null) {¬∂				return isDeclaredShared;¬∂			}¬∂		}¬∂		// check the parent¬∂		return isSharedVariable(anSNode.getParent(), anLHS);¬∂	}¬∂¬∂	public static List<SNode> getAllLeafNodes(SNode aTopNode) {¬∂		List<SNode> retVal = new ArrayList();¬∂		addLeafNodes(aTopNode, retVal);¬∂		return retVal;¬∂	}¬∂¬∂	public static void addLeafNodes(SNode aTopNode, List<SNode> retVal) {¬∂		for (SNode aChild : aTopNode.getChildren()) {¬∂			if (aChild.isLeaf()) {¬∂				retVal.add(aChild);¬∂			} else {¬∂				addLeafNodes(aChild, retVal);¬∂			}¬∂		}¬∂	}¬∂¬∂	public static List<SNode> getNonParallelLeafNodes(SNode aTopNode) {¬∂		List<SNode> retVal = new ArrayList();¬∂		addNonParallelLeafNodes(aTopNode, retVal);¬∂		return retVal;¬∂	}¬∂¬∂	public static void addNonParallelLeafNodes(SNode aTopNode, List<SNode> retVal) {¬∂		if (aTopNode.isInParallel()) {¬∂			return;¬∂		}¬∂		for (SNode aChild : aTopNode.getChildren()) {¬∂			if (aChild.isLeaf()) {¬∂				retVal.add(aChild);¬∂			} else {¬∂				addLeafNodes(aChild, retVal);¬∂			}¬∂		}¬∂	}¬∂	static String callRegex = "([a-zA-Z_$][a-zA-Z_$0-9]*)\\(.*?\\)";¬∂	static Pattern callPattern = Pattern.compile(callRegex);¬∂¬∂	static String identifierRegex = "[a-zA-Z_$][a-zA-Z_$0-9]*";¬∂	static Pattern identifierPattern = Pattern.compile(identifierRegex);¬∂	public static List<String> identifiersIn(String aString) {¬∂		if (aString == null)¬∂			return null;¬∂//		Pattern mypattern = Pattern.compile("[a-zA-Z_$][a-zA-Z_$0-9]*");¬∂//		Matcher mymatcher = mypattern.matcher(aString);¬∂		Matcher mymatcher = identifierPattern.matcher(aString);¬∂		List<String> retVal = new ArrayList();¬∂		while (mymatcher.find()) {¬∂			String find = mymatcher.group(0);¬∂			retVal.add(find);¬∂		}¬∂		return retVal;¬∂	}¬∂	public static List<MethodCall> callsIn(int aLineNumber, String aString, SNode aParent) {¬∂		if (aString == null)¬∂			return emptyList;¬∂		if (isMethodDeclaration(aString)) {¬∂			return emptyList;¬∂		}¬∂//		Pattern mypattern = Pattern.compile("[a-zA-Z_$][a-zA-Z_$0-9]*");¬∂//		Matcher mymatcher = mypattern.matcher(aString);¬∂		Matcher mymatcher = callPattern.matcher(aString);¬∂		List<MethodCall> retVal = new ArrayList();¬∂		while (mymatcher.find()) {¬∂			String find = mymatcher.group(0);¬∂			int aLeftParenIndex = find.indexOf("(");¬∂			int aRightParenIndex = find.indexOf(")");¬∂			String aMethodName = find.substring(0, aLeftParenIndex).trim();¬∂			String aParameters = find.substring(aLeftParenIndex + 1, aRightParenIndex);¬∂			List<String> aParameterList = new ArrayList();¬∂			String[] aParameterTokens = aParameters.split(",");¬∂			for (String aParameter:aParameterTokens) {¬∂				String aParameterTrimmed = aParameter.trim();¬∂				if (!aParameterTrimmed.isEmpty())¬∂				aParameterList.add(aParameterTrimmed);¬∂			}¬∂			retVal.add(new AMethodCall(aLineNumber, aMethodName, aParameterList, aParent));¬∂¬∂//			aCallStrings.add(find);¬∂		}¬∂		return retVal;¬∂	}¬∂	static String numberRegex = "(\\d+\\.\\d+)|(\\d+)";¬∂	static Pattern numberPattern = Pattern.compile(numberRegex);¬∂	public static List<String> numbersIn(String aString) {¬∂		if (aString == null)¬∂			return null;¬∂//		String regex = "(\\d+\\.\\d+)|(\\d+)";¬∂//¬∂//		Matcher m = Pattern.compile(regex).matcher(aString);¬∂		Matcher m =numberPattern.matcher(aString);¬∂¬∂¬∂		List<String> retVal = new ArrayList();¬∂¬∂		while (m.find()) {¬∂			retVal.add(m.group());¬∂		}¬∂		return retVal;¬∂	}¬∂¬∂	public static String subscriptIn(String aString) {¬∂		if (aString == null)¬∂			return null;¬∂		return StringUtils.substringBetween(aString, "[", "]");¬∂	}¬∂	static String[] emptyStringArray = {};¬∂	static List emptyList = new ArrayList();¬∂¬∂	public static String[] subscriptsIn(String aString) {¬∂		if (aString == null)¬∂			return emptyStringArray;¬∂		return StringUtils.substringsBetween(aString, "[", "]");¬∂	}¬∂	static  String operatorRegex = "([+-/*///^])|([/(/)])";¬∂	static Pattern operatorPattern = Pattern.compile(operatorRegex);¬∂¬∂	public static List<String> operatorsIn(String aString) {¬∂		if (aString == null)¬∂			return null;¬∂//		String operatorRegex = "([+-/*///^])|([/(/)])";¬∂//¬∂//		Matcher m = Pattern.compile(operatorRegex).matcher(aString);¬∂		¬∂		Matcher m = operatorPattern.matcher(aString);¬∂¬∂¬∂		List<String> retVal = new ArrayList();¬∂¬∂		while (m.find()) {¬∂			retVal.add(m.group());¬∂		}¬∂		return retVal;¬∂	}¬∂	¬∂	public static int numberOfNestingFors (SNode anSNode) {¬∂		if (anSNode == null) {¬∂			return 0;¬∂		}¬∂		int retVal = anSNode.getNumberOfNestingFors();¬∂		if ( retVal >= 0) {¬∂			return retVal;¬∂		}¬∂		retVal = numberOfNestingFors (anSNode.getParent()) ;¬∂¬∂		if (anSNode instanceof ForSNode) {¬∂			retVal++;¬∂		} else if (anSNode instanceof MethodSNode) {¬∂			List<MethodCall> aMethodCalls = ((MethodSNode) anSNode).getCalls();¬∂			int aMaxNestingLevel = 0;¬∂			for (MethodCall aMethodCall:aMethodCalls) {¬∂				MethodSNode aCallerMethodSNode = getDeclarationOfCalledMethod(anSNode, aMethodCall);¬∂				int aCallerNumberOfNestingFors = numberOfNestingFors(aCallerMethodSNode);¬∂				aMaxNestingLevel = Math.max(aCallerNumberOfNestingFors, aMaxNestingLevel);				¬∂			}¬∂			return retVal + aMaxNestingLevel;¬∂		}¬∂		return retVal;¬∂	}¬∂	public static boolean hasOperator (SNode anSNode, String anOperator) {¬∂		boolean retVal = false;¬∂		if (anSNode instanceof AssignmentSNode) {¬∂			AssignmentSNode anAssignmentSNode = (AssignmentSNode) anSNode;¬∂			 retVal = (anAssignmentSNode.getLhsOperators().contains(anOperator) || ¬∂					anAssignmentSNode.getRhsOperators().contains(anOperator)) ;¬∂			if (retVal) {¬∂				return retVal;¬∂			} else {¬∂				List<MethodCall> aMethodCalls = anAssignmentSNode.getRhsCalls();¬∂				for (MethodCall aMethodCall:aMethodCalls) {¬∂					MethodSNode aMethodSNode = getDeclarationOfCalledMethod(anSNode, aMethodCall);¬∂					retVal = hasOperator(aMethodSNode, anOperator);¬∂					if (retVal) {¬∂						return retVal;¬∂					}¬∂					¬∂				}¬∂				return false;¬∂			}¬∂			¬∂		}¬∂		for (SNode aChild:anSNode.getChildren()) {¬∂			retVal = hasOperator(aChild, anOperator);¬∂			if (retVal) {¬∂				return retVal;¬∂			}¬∂		}¬∂		return false;¬∂	}¬∂	public static boolean hasMethodCall (SNode anSNode, String anOperator) {¬∂		boolean retVal = false;¬∂		if (anSNode instanceof AssignmentSNode) {¬∂			AssignmentSNode anAssignmentSNode = (AssignmentSNode) anSNode;¬∂			 retVal = (anAssignmentSNode.getLhsOperators().contains(anOperator) || ¬∂					anAssignmentSNode.getRhsOperators().contains(anOperator)) ;¬∂			if (retVal) {¬∂				return retVal;¬∂			} else {¬∂				List<MethodCall> aMethodCalls = anAssignmentSNode.getRhsCalls();¬∂				for (MethodCall aMethodCall:aMethodCalls) {¬∂					MethodSNode aMethodSNode = getDeclarationOfCalledMethod(anSNode, aMethodCall);¬∂					retVal = hasOperator(aMethodSNode, anOperator);¬∂					if (retVal) {¬∂						return retVal;¬∂					}¬∂					¬∂				}¬∂				return false;¬∂			}¬∂			¬∂		}¬∂		for (SNode aChild:anSNode.getChildren()) {¬∂			retVal = hasOperator(aChild, anOperator);¬∂			if (retVal) {¬∂				return retVal;¬∂			}¬∂		}¬∂		return false;¬∂	}¬∂	public static boolean dependsOn (AssignmentSNode anAssignmentSNode, String aVariable, String aCallIdentifier) {¬∂		// This assignment does not change aVariable¬∂		if (!aVariable.equals(anAssignmentSNode.getLhsFirstIdentifier())) {¬∂			return false;¬∂		}¬∂		return dependsOn(anAssignmentSNode.getExpressionSNode(), aCallIdentifier);¬∂//		List<String> aCallIdentifiers = anAssignmentSNode.getRhsCallIdentifiers();¬∂//		boolean retVal = false;¬∂//		if (aCallIdentifiers != null && aCallIdentifiers.contains(aCallIdentifier)) {¬∂//			return true; // this assignment has aCallIdentifier in the rhs¬∂//		}¬∂//		// check if some referenced rhs variable depends on aCallIdentifier¬∂//		List<String> aReferencedVariableIdentifiers = anAssignmentSNode.getRhsVariableIdentifiers();¬∂//		SNode anAssignmentParent = anAssignmentSNode.getParent();¬∂//		if (anAssignmentParent == null) { // should never be trye¬∂//			return false;¬∂//		}¬∂//		int aLineNumber = anAssignmentSNode.getLineNumber();¬∂//		for (String aReferencedVariableIdentifier:aReferencedVariableIdentifiers ) {¬∂//			if (dependsOn (anAssignmentParent, aLineNumber, aReferencedVariableIdentifier, aCallIdentifier)) {¬∂//				return true;¬∂//			}¬∂//		}¬∂//		return false;¬∂	}¬∂	public static boolean dependsOn (ExpressionSNode anExpressionSNode, String aCallIdentifier) {¬∂		// This assignment does not change aVariable¬∂		¬∂		List<String> aCallIdentifiers = anExpressionSNode.getRhsCallIdentifiers();¬∂		boolean retVal = false;¬∂		if (aCallIdentifiers != null && aCallIdentifiers.contains(aCallIdentifier)) {¬∂			return true; // this assignment has aCallIdentifier in the rhs¬∂		}¬∂		// check if some referenced rhs variable depends on aCallIdentifier¬∂		List<String> aReferencedVariableIdentifiers = anExpressionSNode.getRhsVariableIdentifiers();¬∂		SNode anAssignmentParent = anExpressionSNode.getParent().getParent();¬∂		if (anAssignmentParent == null) { // should never be trye¬∂			return false;¬∂		}¬∂		int aLineNumber = anExpressionSNode.getLineNumber();¬∂		for (String aReferencedVariableIdentifier:aReferencedVariableIdentifiers ) {¬∂			if (dependsOn (anAssignmentParent, aLineNumber, aReferencedVariableIdentifier, aCallIdentifier)) {¬∂				return true;¬∂			}¬∂		}¬∂		return false;¬∂	}¬∂	public static Set<AssignmentSNode> assignmentsToSharedVariables(SNode anSNode) {¬∂		Set<AssignmentSNode> retVal =  new HashSet();¬∂		fillAssignmentsToShared(anSNode, retVal);¬∂		return retVal;¬∂		¬∂	}¬∂	public static Set<AssignmentSNode> assignmentsToSharedArrays(SNode anSNode) {¬∂		Set<AssignmentSNode> anAllSharedAssignments =  assignmentsToSharedVariables(anSNode);¬∂		Set<AssignmentSNode> aRetVal = new HashSet();¬∂		for (AssignmentSNode anAssignmentSNode:anAllSharedAssignments) {¬∂			if (anAssignmentSNode.getLhsSubscripts().length > 0) {¬∂				aRetVal.add(anAssignmentSNode);¬∂			}¬∂		}¬∂		return aRetVal;¬∂		¬∂	}¬∂	public static Set<AssignmentSNode> assignmentsToParallelCriticalSharedVariables(SNode anSNode) {¬∂		Set<AssignmentSNode> anAllSharedAssignments =  assignmentsToSharedVariables(anSNode);¬∂		Set<AssignmentSNode> aRetVal = new HashSet();¬∂		for (AssignmentSNode anAssignmentSNode:anAllSharedAssignments) {¬∂			if (anAssignmentSNode.isInParallel() &&¬∂					anAssignmentSNode.isInCritical()) {¬∂				aRetVal.add(anAssignmentSNode);¬∂			}¬∂		}¬∂		return aRetVal;¬∂		¬∂	}¬∂	public static Set<AssignmentSNode> assignmentsToNonParallelCriticalSharedVariables(SNode anSNode) {¬∂		Set<AssignmentSNode> anAllSharedAssignments =  assignmentsToSharedVariables(anSNode);¬∂		Set<AssignmentSNode> aRetVal = new HashSet();¬∂		for (AssignmentSNode anAssignmentSNode:anAllSharedAssignments) {¬∂			if (!anAssignmentSNode.isInParallel() &&¬∂					anAssignmentSNode.isInCritical()) {¬∂				aRetVal.add(anAssignmentSNode);¬∂			}¬∂		}¬∂		return aRetVal;¬∂		¬∂	}¬∂	public static Set<AssignmentSNode> assignmentsToParallelNonCriticalSharedVariables(SNode anSNode) {¬∂		Set<AssignmentSNode> anAllSharedAssignments =  assignmentsToSharedVariables(anSNode);¬∂		Set<AssignmentSNode> aRetVal = new HashSet();¬∂		for (AssignmentSNode anAssignmentSNode:anAllSharedAssignments) {¬∂			if (anAssignmentSNode.isInParallel() &&¬∂					!anAssignmentSNode.isInCritical()) {¬∂				aRetVal.add(anAssignmentSNode);¬∂			}¬∂		}¬∂		return aRetVal;¬∂		¬∂	}¬∂    public static void fillAssignmentsToShared(SNode anSNode, Set<AssignmentSNode> retVal) {¬∂    	if (anSNode instanceof AssignmentSNode) {¬∂			AssignmentSNode anAssignmentSNode = (AssignmentSNode) anSNode;¬∂			String anLHS = anAssignmentSNode.getLhsFirstIdentifier();¬∂			if (isSharedVariable(anSNode, anLHS)) {¬∂				retVal.add(anAssignmentSNode);¬∂				return;¬∂			}¬∂		}¬∂    	for (SNode aChild:anSNode.getChildren()) {¬∂    		fillAssignmentsToShared(aChild, retVal);¬∂    	}¬∂		¬∂	}¬∂    public static void fillInstancesOfNodeType(Class<? extends SNode> aNodeType, SNode anSNode, Set<SNode> retVal) {¬∂    	if (aNodeType.isAssignableFrom(anSNode.getClass())) {¬∂			¬∂				retVal.add(anSNode);¬∂				return;¬∂			}¬∂		¬∂    	for (SNode aChild:anSNode.getChildren()) {¬∂    		fillInstancesOfNodeType(aNodeType, aChild, retVal);¬∂    	}¬∂		¬∂	}¬∂    public static Set<AssignmentSNode>  assignmentSNodes(SNode anSNode) {¬∂    	Set retVal = new HashSet();    	¬∂    	fillInstancesOfNodeType(AssignmentSNode.class, anSNode, retVal );¬∂    	return retVal;¬∂	}¬∂   ¬∂    ¬∂    public static Set<OMPParallelSNode>  ompParallelSNodes(SNode anSNode) {¬∂    	Set retVal = new HashSet();    	¬∂    	fillInstancesOfNodeType(OMPParallelSNode.class, anSNode, retVal );¬∂    	return retVal;¬∂	}¬∂//    public static void fillOMPParallelSNodes(SNode anSNode, Set<OMPParallelSNode> retVal) {¬∂//    	if (anSNode instanceof OMPParallelSNode) {¬∂//    		retVal.add((OMPParallelSNode) anSNode);¬∂//		}¬∂//    	for (SNode aChild:anSNode.getChildren()) {¬∂//    		fillOMPParallelSNodes(aChild, retVal);¬∂//    	}		¬∂//	}¬∂    public static Set<ForSNode>  forSNodes(SNode anSNode) {¬∂    	Set retVal = new HashSet();    	¬∂    	fillInstancesOfNodeType(ForSNode.class, anSNode, retVal );¬∂    	return retVal;¬∂	}¬∂//    public static void fillForSNodes(SNode anSNode, Set<ForSNode> retVal) {¬∂//    	if (anSNode instanceof ForSNode) {¬∂//    		retVal.add((ForSNode) anSNode);¬∂//		}¬∂//    	for (SNode aChild:anSNode.getChildren()) {¬∂//    		fillForSNodes(aChild, retVal);¬∂//    	}		¬∂//	}¬∂    public static Set<OMPForSNode>  ompForSNodes(SNode anSNode) {¬∂    	Set retVal = new HashSet();    	¬∂    	fillInstancesOfNodeType(OMPForSNode.class, anSNode, retVal );¬∂    	return retVal;¬∂	}¬∂//    public static void fillOMPForSNodes(SNode anSNode, Set<OMPForSNode> retVal) {¬∂//    	if (anSNode instanceof OMPForSNode) {¬∂//    		retVal.add((OMPForSNode) anSNode);¬∂//		}¬∂//    	for (SNode aChild:anSNode.getChildren()) {¬∂//    		fillOMPForSNodes(aChild, retVal);¬∂//    	}		¬∂//	}¬∂    public static Set<OMPForSNode> ompReducingForNodes(SNode anSNode) {¬∂		Set<OMPForSNode> anAllOMPForSNodes =  ompForSNodes(anSNode);¬∂		Set<OMPForSNode> aRetVal = new HashSet();¬∂		for (OMPForSNode anOMPForSNode:anAllOMPForSNodes) {¬∂			if (anOMPForSNode.getReductionOperation() != null) {¬∂				aRetVal.add(anOMPForSNode);¬∂			}¬∂		}¬∂		return aRetVal;		¬∂	}¬∂    public static Set<AssignmentSNode> assignmentsToOMPReducingForNode(OMPForSNode anOMPForSNode) {¬∂    	String aReductionVariable = anOMPForSNode.getReductionVariable();¬∂    	return directAssignmentsOfVariableAndItsAliases(anOMPForSNode, aReductionVariable)	;¬∂    	¬∂    }¬∂	public static boolean dependsOn (SNode anSNode, int aVariableLineNumber, String aVariable, String aCallIdentifier) {¬∂		List<SNode> aListSNodes = anSNode.getChildren();¬∂		boolean retVal = false;¬∂		/*¬∂		 * Should probably ignore line number as it assumes straight line code¬∂		 */¬∂		for (int i = aVariableLineNumber; i >= 0; i--) {¬∂			SNode anSNodeChild = aListSNodes.get(i);¬∂			if (anSNodeChild instanceof AssignmentSNode) {¬∂				// does this statement in anSNode directly invoke aCallIdentifier ¬∂				if (dependsOn((AssignmentSNode) anSNodeChild, aVariable, aCallIdentifier))¬∂					return true;¬∂			} else if (!anSNode.isLeaf()) {¬∂					// child is overriding the variable so forget checking its assignment statements¬∂					if (anSNodeChild.getLocalVariableIdentifiers().contains(aVariable)) {¬∂						continue;¬∂					}¬∂					// some subblock of anSNode that has access to aVariable changes variable¬∂¬∂					if (dependsOn(anSNodeChild, anSNodeChild.getChildren().size() - 1, aVariable, aCallIdentifier)) {¬∂						return true;¬∂					}¬∂			}¬∂			¬∂		}¬∂		// none of the statements in anSNode or its descendents  have the required call¬∂		// is the variable a  method parameter ¬∂		if (anSNode instanceof MethodSNode) {¬∂			MethodSNode aMethodSNode = (MethodSNode) anSNode;¬∂			¬∂			int aParameterNumber = aMethodSNode.getLocalVariableIdentifiers().indexOf(aVariable);¬∂			if (aParameterNumber != -1) {¬∂				List <MethodCall> aCalls = aMethodSNode.getCalls();¬∂				for (MethodCall aCall:aCalls) {¬∂//					if (!aCall.getMethodActuals().contains(aVariable))¬∂//						continue;¬∂//					¬∂					MethodSNode aCallerSNode = getDeclarationOfCalledMethod(aMethodSNode, aCall);¬∂					if (dependsOn(aMethodSNode, aCallerSNode.getLineNumber(), aCallerSNode.getLocalVariableIdentifiers().get(aParameterNumber), aCallIdentifier));¬∂//				    if (aCallerDepends) {¬∂				    	return true;¬∂//				    }¬∂				}¬∂				return false;¬∂				// need to find all callers of method and see if any of the aliases for the variable in these¬∂				// calls depend on aCallIndentifier¬∂			}			¬∂			¬∂		} else if (anSNode.getLocalVariableIdentifiers().contains(aVariable)) {¬∂			// before going to the parent node, let us see if aVariable is declared here as a non  parameter ¬∂¬∂			return false; // no point going to parent¬∂		}¬∂		// not a local variable (parameter or declarated variable)¬∂		SNode anSNodeParent = anSNode.getParent() ;¬∂		if (anSNodeParent == null)  {¬∂			return false;¬∂		}¬∂		int anSNodeLineNumber = anSNodeParent.getChildren().indexOf(anSNode);¬∂		return dependsOn(anSNodeParent, anSNodeLineNumber, aVariable, aCallIdentifier);¬∂		¬∂	}¬∂	public static Set<AssignmentSNode> assignmentsOfVariableAliases (SNode anSNode,  String aVariable) {¬∂		Set<AssignmentSNode> retVal = new HashSet();¬∂		fillDirectAssignmentsOfVariableAliases(anSNode, aVariable, retVal);¬∂		return retVal;¬∂	}¬∂	public static void fillDirectAssignmentsOfVariableAliases (SNode anSNode,  String aVariable, Set<AssignmentSNode> retVal) {¬∂		if (anSNode instanceof MethodCall) {¬∂			MethodCall aMethodCall = (MethodCall) anSNode;¬∂			int aParameterNumber = aMethodCall.getMethodActualIdentifiers().indexOf(aVariable);¬∂			if (aParameterNumber < 0) {¬∂				return;¬∂			}¬∂			MethodSNode aDeclaringMethodSNode = getDeclarationOfCalledMethod(anSNode, aMethodCall);¬∂			String aFormalParameter = aDeclaringMethodSNode.getLocalVariableIdentifiers().get(aParameterNumber);¬∂//			Set<AssignmentSNode> aCallAssignments = ;¬∂			fillDirectAssignmentsOfVariableAliases(aDeclaringMethodSNode, aFormalParameter, retVal);¬∂		} else if (anSNode instanceof MethodSNode)	{¬∂			MethodSNode aMethodSNode = (MethodSNode) anSNode;¬∂			int aParameterNumber = aMethodSNode.getLocalVariableIdentifiers().indexOf(aVariable);¬∂			if (aParameterNumber < 0)¬∂				return;¬∂			List<MethodCall> aCalls = aMethodSNode.getCalls();¬∂			for (MethodCall a"), Diff(INSERT,"Method"), Diff(EQUAL,"Call:aCalls) {¬∂				"), Diff(DELETE,"aCall.get"), Diff(INSERT,"MethodSNode aCallerMethodSNode = getDeclarationOfCalledMethod(anSNode, aMethodCall);¬∂				if (aCallerMethodSNode != null) {¬∂					String anAlias = aCallerMethodSNode.getLocalVariableIdentifiers().get(aParameterNumber);¬∂					fillDirectAssignmentsOfVariableAliases(aCallerMethodSNode, anAlias, retVal);¬∂¬∂				}¬∂"), Diff(EQUAL,"¬∂			}¬∂		}¬∂		¬∂		else {¬∂			List<SNode> aChildren = anSNode.getChildren();¬∂			for (SNode aChild:aChildren) {¬∂				fillDirectAssignmentsOfVariableAliases(aChild, aVariable, retVal);¬∂			}¬∂		} 	¬∂		¬∂	}¬∂	¬∂	/*¬∂	 * will not consider assignments to variables in the RHS of these assignments¬∂	 */¬∂	public static Set<AssignmentSNode> directAssignmentsOfVariableAndItsAliases (SNode anSNode,  String aVariable) {¬∂		Set<AssignmentSNode> retVal = new HashSet();¬∂		fillDirectAssignmentsOfVariableAndItsAliases(anSNode, aVariable, retVal);¬∂		return retVal;¬∂	}¬∂	¬∂//	public static Set<AssignmentSNode> assignmentsEffectingVariableAndItsAliases (SNode anSNode,  String aVariable) {¬∂//		Set<AssignmentSNode> retVal = directAssignmentsOfVariableAndItsAliases(anSNode, aVariable);¬∂//		¬∂//	}¬∂	public static void fillDirectAssignmentsOfVariableAndItsAliases (SNode anSNode,  String aVariable, Set<AssignmentSNode> retVal) {¬∂		if (anSNode instanceof AssignmentSNode) {¬∂			AssignmentSNode anAssignmentSNode = (AssignmentSNode) anSNode;¬∂			if (anAssignmentSNode.getLhsFirstIdentifier().equals(aVariable)) {¬∂				retVal.add(anAssignmentSNode);¬∂			}¬∂		}¬∂		¬∂		else if (anSNode instanceof MethodCall) {¬∂			MethodCall aMethodCall = (MethodCall) anSNode;¬∂			int aParameterNumber = aMethodCall.getMethodActualIdentifiers().indexOf(aVariable);¬∂			if (aParameterNumber < 0) {¬∂				return;¬∂			}¬∂			MethodSNode aDeclaringMethodSNode = getDeclarationOfCalledMethod(anSNode, aMethodCall);¬∂			String aFormalParameter = aDeclaringMethodSNode.getLocalVariableIdentifiers().get(aParameterNumber);¬∂//			Set<AssignmentSNode> aCallAssignments = ;¬∂			fillDirectAssignmentsOfVariableAndItsAliases(aDeclaringMethodSNode, aFormalParameter, retVal);¬∂		} else {¬∂			List<SNode> aChildren = anSNode.getChildren();¬∂			for (SNode aChild:aChildren) {¬∂				fillDirectAssignmentsOfVariableAndItsAliases(aChild, aVariable, retVal);¬∂			}¬∂		}		¬∂		¬∂	}¬∂	¬∂	public static RootOfFileSNode getRootOfFileNode(SNode aCurrentSNode ) {¬∂		if (aCurrentSNode instanceof RootOfFileSNode) {¬∂			return (RootOfFileSNode) aCurrentSNode;¬∂		}¬∂		SNode aParentSNode = aCurrentSNode.getParent() ;¬∂		¬∂		if (aParentSNode == null) {¬∂			return null;¬∂		}¬∂		¬∂		return getRootOfFileNode(aParentSNode);¬∂		¬∂	}¬∂	public static boolean match (MethodSNode aMethodSNode, MethodCall aMethodCall) {¬∂		return aMethodSNode.getMethodName().equals(aMethodCall.getMethodName()) ¬∂				&& aMethodSNode.getLocalVariableIdentifiers().size() == aMethodCall.getMethodActuals().size();¬∂	}¬∂	public static DeclarationSNode getDeclarationOfVariableIdentifier(SNode aCurrentSNode, String anIdentifier) {¬∂		if (aCurrentSNode == null) {¬∂			return null;¬∂		}¬∂		¬∂		¬∂		int anIndex = aCurrentSNode.getLocalVariableIdentifiers().indexOf(anIdentifier);¬∂		if (anIndex < 0) {¬∂			return getDeclarationOfVariableIdentifier(aCurrentSNode.getParent(), anIdentifier);¬∂		}¬∂		DeclarationSNode retVal = aCurrentSNode.getVariableDeclarations().get(anIndex);¬∂//		retVal.getAssignmentsToDeclaredVariable().add(anAssignmentSNode);¬∂//		anAssignmentSNode.setLhsFirstIdentifierDeclaration(retVal);¬∂		return retVal;¬∂	}¬∂	¬∂	public static DeclarationSNode getDeclarationOfAssignedVariable(SNode aCurrentSNode, AssignmentSNode anAssignmentSNode) {¬∂		if (aCurrentSNode == null) {¬∂			return null;¬∂		}¬∂		if (anAssignmentSNode instanceof ADeclaringAssignmentSNode) {¬∂			return (ADeclaringAssignmentSNode) anAssignmentSNode;¬∂		}¬∂		int anIndex = aCurrentSNode.getLocalVariableIdentifiers().indexOf(anAssignmentSNode.getLhsFirstIdentifier());¬∂		if (anIndex < 0) {¬∂			return getDeclarationOfAssignedVariable(aCurrentSNode.getParent(), anAssignmentSNode);¬∂		}¬∂		DeclarationSNode retVal = aCurrentSNode.getVariableDeclarations().get(anIndex);¬∂//		retVal.getAssignmentsToDeclaredVariable().add(anAssignmentSNode);¬∂//		anAssignmentSNode.setLhsFirstIdentifierDeclaration(retVal);¬∂		return retVal;¬∂	}¬∂	¬∂	public static MethodSNode getDeclarationOfCalledMethod(SNode aCurrentSNode, MethodCall aMethodCall ) {¬∂		SNode aRootNode = getRootOfFileNode(aCurrentSNode);¬∂		for (SNode aChild:aRootNode.getChildren()) {¬∂			if (aChild instanceof MethodSNode) {¬∂				MethodSNode aMethodSNode = (MethodSNode) aChild;¬∂				if (match (aMethodSNode, aMethodCall)) {¬∂					return aMethodSNode;¬∂				}¬∂			}¬∂		}¬∂		return null; // this should never happen;¬∂	}¬∂	¬∂	public static RootOfProgramSNode getRootOfProgramSNode(String aSource) {¬∂		RootOfProgramSNode retVal = new ARootOfProgramSNode();¬∂		Map<String, StringBuffer> aFileNameToContents = ABasicTextManager.extractFileContents(aSource);¬∂		for (String aFileName:aFileNameToContents.keySet()) {¬∂			StringBuffer aFileContents = aFileNameToContents.get(aFileName);¬∂//			List<OpenMPPragma> anOpenMPPragmas = OpenMPUtils.getOpemMPPragmas(aFileContents);¬∂			RootOfFileSNode anSNode = OMPSNodeUtils.getSNode(aFileName, aFileContents);¬∂			retVal.getFileNameToSNode().put(aFileName, anSNode);¬∂			anSNode.setParent(retVal);¬∂//			System.out.println("file name:" + aFileName);¬∂//			System.out.println("pragmas:" + anSNode);¬∂		}¬∂		processExternalMethodSNodes(retVal);¬∂		setParentOfParameterDeclarations(retVal);¬∂		processIndirectAssignments(retVal);¬∂		return retVal;¬∂	}¬∂//	public static void processIndirectAssignments (S aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode) {¬∂//		for (SNode anSNode:aRootOfFileSNode.getChildren()) {¬∂//			-----¬∂//		}¬∂//	}¬∂	public static void setParentOfParameterDeclarations(RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode) {¬∂		for (SNode anSNode:aRootOfFileSNode.getChildren()) {¬∂			if (anSNode instanceof MethodSNode) {¬∂				setParentOfParameterDeclarations(aRootOfProgramSNode, aRootOfFileSNode, (MethodSNode) anSNode);¬∂			}¬∂		}¬∂	}¬∂	public static void setParentOfParameterDeclarations (RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode, MethodSNode aMethodSNode) {¬∂		List<DeclarationSNode> aDeclarations = aMethodSNode.getVariableDeclarations();¬∂		for (DeclarationSNode aDeclaration:aDeclarations) {¬∂			if (aDeclaration.getParent() == null) {¬∂				aDeclaration.setParent(aMethodSNode);¬∂			}¬∂		}¬∂	}¬∂	public static void setParentOfParameterDeclarations (RootOfProgramSNode aRootOfProgramSNode) {¬∂		for (String aFileName:aRootOfProgramSNode.getFileNameToSNode().keySet()) {¬∂			RootOfFileSNode aRootOfFileSNode = aRootOfProgramSNode.getFileNameToSNode().get(aFileName);¬∂			setParentOfParameterDeclarations(aRootOfProgramSNode, aRootOfFileSNode);¬∂			¬∂		}¬∂¬∂	}¬∂	public static void processExternalMethodSNodes (RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode) {¬∂		for (SNode anSNode:aRootOfFileSNode.getChildren()) {¬∂			if (anSNode instanceof ExternalMethodSNode) {¬∂				processExternalMethodSNode(aRootOfProgramSNode, aRootOfFileSNode, (ExternalMethodSNode) anSNode);¬∂			}¬∂		}¬∂	}¬∂¬∂	public static void processExternalMethodSNode (RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode, ExternalMethodSNode anExternalMethodSNode) {¬∂		MethodSNode aMethodSNode = aRootOfProgramSNode.getExternalToInternalMethod().get(anExternalMethodSNode.toString());¬∂		if (aMethodSNode == null) {¬∂			aMethodSNode = findMethodSNode(aRootOfProgramSNode, aRootOfFileSNode, anExternalMethodSNode);¬∂			if (aMethodSNode != null) {¬∂				aRootOfProgramSNode.getExternalToInternalMethod().put(anExternalMethodSNode.toString(),aMethodSNode );¬∂			}¬∂		}¬∂		if (aMethodSNode != null) {¬∂			anExternalMethodSNode.setActualMethodSNode(aMethodSNode);¬∂			aMethodSNode.getCalls().addAll(anExternalMethodSNode.getLocalCalls());¬∂		}¬∂	}¬∂	¬∂	public static MethodSNode findMethodSNode (RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode, ExternalMethodSNode anExternalMethodSNode) {¬∂//		MethodSNode foundMethodSNode = null;¬∂		for (String aFileName:aRootOfProgramSNode.getFileNameToSNode().keySet()) {¬∂			if (aFileName.equals(aRootOfFileSNode.getFileName()))¬∂				continue;¬∂			¬∂			RootOfFileSNode aSearchedRootOfFileSNode = aRootOfProgramSNode.getFileNameToSNode().get(aFileName);¬∂			 for (SNode anSNode:aSearchedRootOfFileSNode.getChildren()) {¬∂				if (anSNode instanceof MethodSNode && !(anSNode instanceof ExternalMethodSNode)) {¬∂					if (anSNode.toString().equals(anExternalMethodSNode.toString())) {¬∂						return (MethodSNode) anSNode;¬∂						¬∂					}¬∂//					processExternalMethodSNode(aRootOfProgramSNode, aRootOfFileSNode, (ExternalMethodSNode) anSNode);¬∂				}¬∂			}¬∂		}¬∂		return null;¬∂	}¬∂	public static void processExternalMethodSNodes (RootOfProgramSNode aRootOfProgramSNode) {¬∂		for (String aFileName:aRootOfProgramSNode.getFileNameToSNode().keySet()) {¬∂			RootOfFileSNode aRootOfFileSNode = aRootOfProgramSNode.getFileNameToSNode().get(aFileName);¬∂			processExternalMethodSNodes(aRootOfProgramSNode, aRootOfFileSNode);¬∂			aRootOfFileSNode.getOmp_get_num_threads_SNode().¬∂				setActualMethodSNode(aRootOfProgramSNode.getOmp_get_num_threads_SNode());¬∂			aRootOfFileSNode.getOmp_get_thread_num_SNode().¬∂				setActualMethodSNode(aRootOfProgramSNode.getOmp_get_thread_num_SNode());¬∂			aRootOfFileSNode.getOmp_get_wtime_SNode().¬∂			setActualMethodSNode(aRootOfProgramSNode.getOmp_get_wtime_SNode());¬∂		}¬∂¬∂	}¬∂	public static void processIndirectAssignments (SNode anSNode) {¬∂		if (anSNode instanceof ConstDeclarationSNode) {¬∂			return;¬∂		}¬∂		if (anSNode instanceof DeclarationSNode) {¬∂			DeclarationSNode aDeclarationSNode = (DeclarationSNode) anSNode;¬∂			Set<AssignmentSNode> anIndirectAssignments = aDeclarationSNode.getAssignmentsEffectingDeclaredIdentifier();¬∂			if (anIndirectAssignments != null) {¬∂				return; // already assigned¬∂			}¬∂			anIndirectAssignments = new HashSet<>();¬∂			aDeclarationSNode.setAssignmentsEffectingDeclaredIdentifier(anIndirectAssignments);¬∂			Set<AssignmentSNode> aDirectAssignments = aDeclarationSNode.getAssignmentsToDeclaredVariable();¬∂			anIndirectAssignments.addAll(aDirectAssignments);¬∂			Set<AssignmentSNode> anAliasAssignments = assignmentsOfVariableAliases(aDeclarationSNode.getParent(), aDeclarationSNode.getVariableName());¬∂			anIndirectAssignments.addAll(anAliasAssignments);¬∂			for (AssignmentSNode aDirectAssignment:aDirectAssignments) {¬∂				List<String> aVariableIdentifiers = aDirectAssignment.getRhsVariableIdentifiers();¬∂				¬∂				for (String aVariableIdentifier:aVariableIdentifiers) {¬∂					DeclarationSNode aDependeeDeclarationSNode = getDeclarationOfVariableIdentifier(aDirectAssignment, aVariableIdentifier);¬∂					if (aDependeeDeclarationSNode == null) {¬∂						System.err.println("Could not find declaration of:" + aVariableIdentifier + " referenced in:" + aDirectAssignment );¬∂						continue;¬∂					}¬∂					processIndirectAssignments(aDependeeDeclarationSNode);¬∂					Set<AssignmentSNode> aDependeeIndirectAssignments = aDeclarationSNode.getAssignmentsEffectingDeclaredIdentifier();¬∂					anIndirectAssignments.addAll(aDependeeIndirectAssignments);¬∂					¬∂				}¬∂			}¬∂		} else {¬∂			for (SNode aChild: anSNode.getChildren()) {¬∂				processIndirectAssignments(aChild);¬∂			}¬∂		}¬∂		¬∂	}¬∂	¬∂//	public static void fillIndirectAssignments (SNode anSNode, Set<AssignmentSNode> retVal ) {¬∂//		¬∂//	}¬∂	¬∂¬∂//	public static void main(String[] args) {¬∂//		List<MethodCall> aTokens = callsIn("foo(bar, hgf)/foo2()*foo3(b, a c,)");¬∂//		System.out.println(aTokens);¬∂//		¬∂//		¬∂////		List<String> aTokens = identifiersIn("a[i] + b*2/3");¬∂////		System.out.println(aTokens);¬∂////		aTokens = numbersIn("a[i] + b*2/3");¬∂////		System.out.println(aTokens);¬∂////		aTokens = operatorsIn("a[i] + b*2/3");¬∂////		System.out.println(aTokens);¬∂////¬∂////		System.out.println(StringUtils.substringBetween("a", "[", "]"));¬∂//	}¬∂¬∂}¬∂")]]]></diff>
    <snapshot><![CDATA[package gradingTools.shared.testcases.openmp.scannedTree;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Stack;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.apache.commons.lang.StringUtils;

import grader.basics.project.source.ABasicTextManager;
import gradingTools.shared.testcases.openmp.OpenMPKeywordEnum;
import gradingTools.shared.testcases.openmp.OpenMPParallelPragma;
import gradingTools.shared.testcases.openmp.OpenMPUtils;
import gradingTools.shared.testcases.openmp.scannedTree.ADeclarationSNode;
import gradingTools.shared.testcases.openmp.scannedTree.ADeclaringAssignmentSNode;
import gradingTools.shared.testcases.openmp.scannedTree.AForSNode;
import gradingTools.shared.testcases.openmp.scannedTree.ATextSNode;
import gradingTools.shared.testcases.openmp.scannedTree.AnAssignmentSNode;
import gradingTools.shared.testcases.openmp.scannedTree.AnOMPCriticalSNode;
import gradingTools.shared.testcases.openmp.scannedTree.AnOMPForSNode;
import gradingTools.shared.testcases.openmp.scannedTree.AnOMPParallelSNode;
import gradingTools.shared.testcases.openmp.scannedTree.AnOMPSNode;
import gradingTools.shared.testcases.openmp.scannedTree.AnSNode;
import gradingTools.shared.testcases.openmp.scannedTree.AssignmentSNode;
import gradingTools.shared.testcases.openmp.scannedTree.DeclarationSNode;
import gradingTools.shared.testcases.openmp.scannedTree.DeclaringAssignmentSNode;
import gradingTools.shared.testcases.openmp.scannedTree.ForSNode;
import gradingTools.shared.testcases.openmp.scannedTree.OMPForSNode;
import gradingTools.shared.testcases.openmp.scannedTree.OMPSNode;
import gradingTools.shared.testcases.openmp.scannedTree.SNode;

public class OMPSNodeUtils extends OpenMPUtils {

	public static RootOfFileSNode getSNode(String aFileName, StringBuffer aFileBuffer) {
		String[] aFileLines = aFileBuffer.toString().split("\n");
		return getSNode(aFileName, aFileLines);
	}

	public static AssignmentSNode getAssignmentSNode(int aLineNumber, String aString) {
		if (aString == null) {
			return null;
		}
		String[] aTokens = aString.split("=");
		if (aTokens.length == 1) {
			return new AnAssignmentSNode(aLineNumber, aTokens[0], null);
		} else {
		return new AnAssignmentSNode(aLineNumber, aTokens[0], aTokens[1]);
		}
	}

	public static DeclarationSNode getDeclarationSNode(int aLineNumber, String aString) {
		String[] aTokens = aString.split(" ");
		return new ADeclarationSNode(aLineNumber, aTokens[0], aTokens[1]);
	}

	public static DeclaringAssignmentSNode getDeclaringAssignmentSNode(int aLineNumber, String aString) {
		String[] anLHSAndRHS = aString.split("=");
		String[] aTypeAndVariable = anLHSAndRHS[0].split(" ");
		return new ADeclaringAssignmentSNode(aLineNumber, aTypeAndVariable[0], aTypeAndVariable[1], anLHSAndRHS[1]);
	}
	public static ConstDeclarationSNode getConstDeclarationSNode(int aLineNumber, String aString) {
		String anAssignmentString = aString.substring(CONST.length()).trim();
		String[] anLHSAndRHS = anAssignmentString.split("=");
		String[] aTypeAndVariable = anLHSAndRHS[0].split(" ");
		return new AConstDeclarationSNode(aLineNumber, aTypeAndVariable[0], aTypeAndVariable[1], anLHSAndRHS[1]);
	}

	public static boolean isDeclaringAssignment(String aFileLine) {
		return startsWithTypeName(aFileLine) && aFileLine.contains("=");
	}
	public static boolean isConstDeclaration(String aFileLine) {
		return aFileLine.startsWith(CONST);
	}
	public static boolean isMethodDeclaration(String aFileLine) {
		return startsWithTypeName(aFileLine) && 
				aFileLine.contains("(") &&
				!aFileLine.contains("=");
	}
	public static boolean isExternalMethodDeclaration(String aFileLine) {
		return isMethodDeclaration(aFileLine) && aFileLine.endsWith(";");
	}


	public static boolean isVariableDeclaration(String aFileLine) {

		return startsWithTypeName(aFileLine) && !aFileLine.contains("(");
	}

	public static boolean isAssignment(String aFileLine) {
		return aFileLine.contains("=") && !aFileLine.contains("==");
	}

	public static boolean isForNode(String aFileLine) {
		return aFileLine.startsWith("for");
	}

	public static ForSNode getForSNode(int aLineNumber, String aFileLine) {

		int aLeftParenIndex = aFileLine.indexOf("(");
		int aRightParenIndex = aFileLine.indexOf(")");
		if (aLeftParenIndex < 0 || aRightParenIndex < 0) {
			return null;
		}
		String aHeaderString = aFileLine.substring(aLeftParenIndex + 1, aRightParenIndex);
		String[] aForComponents = aHeaderString.split(";");
		AssignmentSNode anAssignmentSNode = null;
		String aForInitializaton = aForComponents[0];
		if (!aForInitializaton.isEmpty() && aForInitializaton.contains("=")) {
			if (isDeclaringAssignment(aForInitializaton)) {
				anAssignmentSNode = getDeclaringAssignmentSNode(aLineNumber, aForInitializaton);
			} else {
				anAssignmentSNode = getAssignmentSNode(aLineNumber, aForInitializaton);
			}

		}		
		return new AForSNode(aLineNumber, anAssignmentSNode, aForComponents[1], getAssignmentSNode(aLineNumber, aForComponents[2]));
	}
	static String[] emptyArray = {};
	public static MethodSNode getMethodSNode(int aLineNumber, String aFileLine, boolean isInternal) {

		int aLeftParenIndex = aFileLine.indexOf("(");
		int aRightParenIndex = aFileLine.indexOf(")");
		if (aLeftParenIndex < 0 || aRightParenIndex < 0) {
			return null;
		}
		String aMethodNameAndType = aFileLine.substring(0, aLeftParenIndex);
		String[] aMethodNameAndTypeTokens = aMethodNameAndType.split("\\s+"); 
		
		String aMethodParameters = aFileLine.substring(aLeftParenIndex +1 , aRightParenIndex);
		String[] aMethodParameterTokens = aMethodParameters.isEmpty()?emptyArray:
		 aMethodParameters.split(",");
		
//		String[] aMethodParameterTypes = new String[aMethodParameterTokens.length];
//		String[] aMethodParameterNames = new String[aMethodParameterTokens.length];
		List<DeclarationSNode> aDeclarationSNodeList = new ArrayList();
		for (int i = 0; i < aMethodParameterTokens.length; i++ ) {
			String[] aTypeAndName = aMethodParameterTokens[i].trim().split("\\s+");
			if (aTypeAndName.length < 2) {
				continue;
			}
			aDeclarationSNodeList.add(new ADeclarationSNode(aLineNumber, aTypeAndName[0].trim(), aTypeAndName[1].trim()));
//			aMethodParameterTypes[i] = aTypeAndName[0].trim();
//			aMethodParameterNames[i] = aTypeAndName[1].trim();
		}
		if (isInternal)
//		return new AMethodSNode(aLineNumber, aMethodNameAndTypeTokens[0], aMethodNameAndTypeTokens[1], aMethodParameterTypes,aMethodParameterNames );
			return new AMethodSNode(aLineNumber, aMethodNameAndTypeTokens[0], aMethodNameAndTypeTokens[1], aDeclarationSNodeList );
		else
			return new AnExternalMethodSNode(aLineNumber, aMethodNameAndTypeTokens[0], aMethodNameAndTypeTokens[1], aDeclarationSNodeList );
	}

	public static void setReductionData(OMPForSNode lastChild, String aStoredToken, int aLeftParenIndex,
			int aRightParenIndex) {
		int aColonIndex = aStoredToken.indexOf(":");
		if (aLeftParenIndex != -1 && aRightParenIndex != -1 && aColonIndex != -1) {
			String anOperationString = aStoredToken.substring(aLeftParenIndex + 1, aColonIndex).trim();
			String aVariableString = aStoredToken.substring(aColonIndex + 1, aRightParenIndex).trim();
			((OMPForSNode) lastChild).setReductionVariable(aVariableString);
			((OMPForSNode) lastChild).setReductionOperation(anOperationString);
		}
	}

	public static void setSharedOrPrivateData(OMPSNode lastChild, String aStoredToken, int aLeftParenIndex,
			int aRightParenIndex, boolean isShared) {
//		int aColonIndex = aStoredToken.indexOf(":");
		if (aLeftParenIndex != -1 && aRightParenIndex != -1) {
			String aVariableDeclarations = aStoredToken.substring(aLeftParenIndex + 1, aRightParenIndex);
			String[] aVariables = aVariableDeclarations.split(",");
			if (isShared) {
				lastChild.setSharedVariables(aVariables);
			} else {
				lastChild.setPrivateVariables(aVariables);
			}
		}
	}

	public static RootOfFileSNode getSNode(String aFileName, String[] aFileLines) {
		Stack<SNode> anSNodes = new Stack();

		RootOfFileSNode retVal = new ARootOfFileSNode(aFileName);
		anSNodes.add(retVal);
		SNode previousHeaderNode = null;
		for (int i = 0; i < aFileLines.length; i++) {
			String aFileLine = aFileLines[i].trim();
			if (!isCodeLine(aFileLine)) {
				continue;
			}
			if (isForNode(aFileLine)) {
				ForSNode aForSNode = getForSNode(i, aFileLine);
				SNode aParent = previousHeaderNode != null?previousHeaderNode:anSNodes.peek();
				aForSNode.setParent(anSNodes.peek());
				aForSNode.setParent(aParent);

//				anSNodes.push(aForSNode);
				previousHeaderNode = aForSNode;
				if (aFileLine.endsWith(")")) {
					continue;
				}
			}
			if (isExternalMethodDeclaration(aFileLine)) {
				MethodSNode aMethodSNode = getMethodSNode(i, aFileLine, false);
				aMethodSNode.setParent(anSNodes.peek());
//				anSNodes.push(aForSNode);
				previousHeaderNode = aMethodSNode;
				if (aFileLine.endsWith(")")) {
					continue;
				}
			}
			if (isMethodDeclaration(aFileLine)) {
				MethodSNode aMethodSNode = getMethodSNode(i, aFileLine, true);
				aMethodSNode.setParent(anSNodes.peek());
//				anSNodes.push(aForSNode);
				previousHeaderNode = aMethodSNode;
				if (aFileLine.endsWith(")")) {
					continue;
				}
			}
			if (isPragmaStart(aFileLine)) {
				OMPSNode anOMPSNode = getOMPSNode(i, anSNodes.peek(), aFileLine);
//				anSNodes.push(anOMPSNode);
				previousHeaderNode = anOMPSNode;
				continue;
			}
			if (isBlockStart(aFileLine)) {
				SNode aBlockSNode = new ABlockSNode(i);
				if (previousHeaderNode != null) {
					aBlockSNode.setParent(previousHeaderNode);
				} else {
					aBlockSNode.setParent(anSNodes.peek());
				}
				anSNodes.push(aBlockSNode);
				previousHeaderNode = null;
				continue;
			}
//			} else 
			if (isBlockEnd(aFileLine)) {
				anSNodes.pop();
				continue;
			}
			SNode aNewLeafNode = null;
			if (isConstDeclaration(aFileLine)) {
				aNewLeafNode = getConstDeclarationSNode(i, aFileLine);

			} else if (isDeclaringAssignment(aFileLine)) {
				aNewLeafNode = getDeclaringAssignmentSNode(i, aFileLine);

			} else if (isAssignment(aFileLine)) {
				aNewLeafNode = getAssignmentSNode(i, aFileLine);
			} else if (isVariableDeclaration(aFileLine)) {
				aNewLeafNode = getDeclarationSNode(i, aFileLine);
			} else {
				List<MethodCall> aCalls = callsIn(i, aFileLine, null); // parent will be assigned below
				if (aCalls != null && aCalls.size() == 1) {
					aNewLeafNode = aCalls.get(0);
				} else {
					aNewLeafNode = new ATextSNode(i, aFileLine);
				}
			}
//			else {
//				aNewLeafNode = new ATextSNode(i, aFileLine);
//			}
			if (previousHeaderNode != null) {
				aNewLeafNode.setParent(previousHeaderNode);
			} else {
				aNewLeafNode.setParent(anSNodes.peek());
			}

		}

		return retVal;
	}

	public static OMPSNode getOMPSNode(int aLineIndex, SNode aParentNode, String aFileLine) {
		String[] aTokens = aFileLine.split("\\s+");
		if (aTokens.length <= 2) {
			return null;
		}
		if (!aTokens[1].equals("omp")) {
			return null;
		}
		if (aTokens.length < 3) {
			return null;
		}
		String aFirstToken = aTokens[2];
		OpenMPKeywordEnum anOpenMPKeyword = stringToOpenMPKeyword.get(aFirstToken);
//		List<OpenMPPragma> retVal = new ArrayList();
		OMPSNode lastChild = null;
		int aStartIndex = 2;
		OMPSNode aNewNode = null;
		OMPForSNode aForChild = null;
		switch (anOpenMPKeyword) {
		case PARALLEL:
			aNewNode = new AnOMPParallelSNode(aLineIndex);

			if (aTokens.length > 3 && aTokens[3].equals("for")) {
				aForChild = new AnOMPForSNode(aLineIndex);
				aForChild.setParent(aNewNode);

				aStartIndex++;
			}
			break;
		case FOR:
			aNewNode = new AnOMPForSNode(aLineIndex);
			;
			break;
		case CRITICAL:
			aNewNode = new AnOMPCriticalSNode(aLineIndex);
//			retVal.add (lastChild);
			break;
		default:
			aNewNode = new AnOMPSNode(aLineIndex);

		}

		if (lastChild != null) {
			aNewNode.setParent(lastChild);
		} else {
			aNewNode.setParent(aParentNode);
		}
		lastChild = aForChild == null ? aNewNode : aForChild;

		for (int i = aStartIndex; i < aTokens.length; i++) {
			String aStoredToken = aTokens[i].trim();
			if (aStoredToken.isEmpty()) {
				continue;
			}
			if (aStoredToken.startsWith("reduction") || aStoredToken.startsWith("shared")
					|| aStoredToken.startsWith("private")) {
				// combine all tokens until ")" into one for normalization
				while (!aStoredToken.endsWith(")")) {
					i++;
					if (i >= aTokens.length) {
						break;
					}
					String aNewToken = aTokens[i].trim();
					aStoredToken += aNewToken;
				}
				int aLeftParenIndex = aStoredToken.indexOf("(");
				int aRightParenIndex = aStoredToken.indexOf(")");
				if (aStoredToken.startsWith("reduction")) {
					setReductionData((OMPForSNode) lastChild, aStoredToken, aLeftParenIndex, aRightParenIndex);
				} else if (aStoredToken.startsWith("private")) {
					setSharedOrPrivateData((OMPSNode) lastChild, aStoredToken, aLeftParenIndex, aRightParenIndex,
							false);

				} else if (aStoredToken.startsWith("shared")) {
					setSharedOrPrivateData(lastChild, aStoredToken, aLeftParenIndex, aRightParenIndex, true);

				}

			}

			lastChild.getOpenMPTokens().add(aStoredToken);
		}

		return lastChild;

	}

	public static boolean hasParallelAncestor(SNode anSNode) {
		if (anSNode == null) {
			return false;
		}
		if (anSNode instanceof OMPParallelSNode) {
			return true;
		}
		return hasParallelAncestor(anSNode.getParent());
	}
	public static boolean hasCriticalAncestor(SNode anSNode) {
		if (anSNode == null) {
			return false;
		}
		if (anSNode instanceof OMPCriticalSNode) {
			return true;
		}
		return hasCriticalAncestor(anSNode.getParent());
	}


	public static Boolean isDeclaredShared(OMPSNode anOMPSNode, String anLHS) {
		if (Arrays.asList(anOMPSNode.getSharedVariables()).contains(anLHS)) {
			return true;
		}
		if (Arrays.asList(anOMPSNode.getPrivateVariables()).contains(anLHS)) {
			return false;
		}
		return null;

	}

	public static boolean isSharedVariable(SNode anSNode, String anLHS) {
		if (anSNode == null) {
			return false;
		}
		if (anSNode.getLocalVariableIdentifiers().contains(anLHS)) {
			if (!(anSNode instanceof OMPSNode)) { // no shared and private declarations
				return !hasParallelAncestor(anSNode); // shared if not inParallel
			}
			OMPSNode anOMPSNode = (OMPSNode) anSNode;
			return (Arrays.asList(anOMPSNode.getSharedVariables()).contains(anLHS)); // private unless declared shared
		}
		if (anSNode instanceof OMPSNode) {
			OMPSNode anOMPSNode = (OMPSNode) anSNode;
			// the variable is global to this scope, check if it has have been made shared
			// or private by this scope
			Boolean isDeclaredShared = isDeclaredShared(anOMPSNode, anLHS);
			if (isDeclaredShared != null) {
				return isDeclaredShared;
			}
		}
		// check the parent
		return isSharedVariable(anSNode.getParent(), anLHS);
	}

	public static List<SNode> getAllLeafNodes(SNode aTopNode) {
		List<SNode> retVal = new ArrayList();
		addLeafNodes(aTopNode, retVal);
		return retVal;
	}

	public static void addLeafNodes(SNode aTopNode, List<SNode> retVal) {
		for (SNode aChild : aTopNode.getChildren()) {
			if (aChild.isLeaf()) {
				retVal.add(aChild);
			} else {
				addLeafNodes(aChild, retVal);
			}
		}
	}

	public static List<SNode> getNonParallelLeafNodes(SNode aTopNode) {
		List<SNode> retVal = new ArrayList();
		addNonParallelLeafNodes(aTopNode, retVal);
		return retVal;
	}

	public static void addNonParallelLeafNodes(SNode aTopNode, List<SNode> retVal) {
		if (aTopNode.isInParallel()) {
			return;
		}
		for (SNode aChild : aTopNode.getChildren()) {
			if (aChild.isLeaf()) {
				retVal.add(aChild);
			} else {
				addLeafNodes(aChild, retVal);
			}
		}
	}
	static String callRegex = "([a-zA-Z_$][a-zA-Z_$0-9]*)\\(.*?\\)";
	static Pattern callPattern = Pattern.compile(callRegex);

	static String identifierRegex = "[a-zA-Z_$][a-zA-Z_$0-9]*";
	static Pattern identifierPattern = Pattern.compile(identifierRegex);
	public static List<String> identifiersIn(String aString) {
		if (aString == null)
			return null;
//		Pattern mypattern = Pattern.compile("[a-zA-Z_$][a-zA-Z_$0-9]*");
//		Matcher mymatcher = mypattern.matcher(aString);
		Matcher mymatcher = identifierPattern.matcher(aString);
		List<String> retVal = new ArrayList();
		while (mymatcher.find()) {
			String find = mymatcher.group(0);
			retVal.add(find);
		}
		return retVal;
	}
	public static List<MethodCall> callsIn(int aLineNumber, String aString, SNode aParent) {
		if (aString == null)
			return emptyList;
		if (isMethodDeclaration(aString)) {
			return emptyList;
		}
//		Pattern mypattern = Pattern.compile("[a-zA-Z_$][a-zA-Z_$0-9]*");
//		Matcher mymatcher = mypattern.matcher(aString);
		Matcher mymatcher = callPattern.matcher(aString);
		List<MethodCall> retVal = new ArrayList();
		while (mymatcher.find()) {
			String find = mymatcher.group(0);
			int aLeftParenIndex = find.indexOf("(");
			int aRightParenIndex = find.indexOf(")");
			String aMethodName = find.substring(0, aLeftParenIndex).trim();
			String aParameters = find.substring(aLeftParenIndex + 1, aRightParenIndex);
			List<String> aParameterList = new ArrayList();
			String[] aParameterTokens = aParameters.split(",");
			for (String aParameter:aParameterTokens) {
				String aParameterTrimmed = aParameter.trim();
				if (!aParameterTrimmed.isEmpty())
				aParameterList.add(aParameterTrimmed);
			}
			retVal.add(new AMethodCall(aLineNumber, aMethodName, aParameterList, aParent));

//			aCallStrings.add(find);
		}
		return retVal;
	}
	static String numberRegex = "(\\d+\\.\\d+)|(\\d+)";
	static Pattern numberPattern = Pattern.compile(numberRegex);
	public static List<String> numbersIn(String aString) {
		if (aString == null)
			return null;
//		String regex = "(\\d+\\.\\d+)|(\\d+)";
//
//		Matcher m = Pattern.compile(regex).matcher(aString);
		Matcher m =numberPattern.matcher(aString);


		List<String> retVal = new ArrayList();

		while (m.find()) {
			retVal.add(m.group());
		}
		return retVal;
	}

	public static String subscriptIn(String aString) {
		if (aString == null)
			return null;
		return StringUtils.substringBetween(aString, "[", "]");
	}
	static String[] emptyStringArray = {};
	static List emptyList = new ArrayList();

	public static String[] subscriptsIn(String aString) {
		if (aString == null)
			return emptyStringArray;
		return StringUtils.substringsBetween(aString, "[", "]");
	}
	static  String operatorRegex = "([+-/*///^])|([/(/)])";
	static Pattern operatorPattern = Pattern.compile(operatorRegex);

	public static List<String> operatorsIn(String aString) {
		if (aString == null)
			return null;
//		String operatorRegex = "([+-/*///^])|([/(/)])";
//
//		Matcher m = Pattern.compile(operatorRegex).matcher(aString);
		
		Matcher m = operatorPattern.matcher(aString);


		List<String> retVal = new ArrayList();

		while (m.find()) {
			retVal.add(m.group());
		}
		return retVal;
	}
	
	public static int numberOfNestingFors (SNode anSNode) {
		if (anSNode == null) {
			return 0;
		}
		int retVal = anSNode.getNumberOfNestingFors();
		if ( retVal >= 0) {
			return retVal;
		}
		retVal = numberOfNestingFors (anSNode.getParent()) ;

		if (anSNode instanceof ForSNode) {
			retVal++;
		} else if (anSNode instanceof MethodSNode) {
			List<MethodCall> aMethodCalls = ((MethodSNode) anSNode).getCalls();
			int aMaxNestingLevel = 0;
			for (MethodCall aMethodCall:aMethodCalls) {
				MethodSNode aCallerMethodSNode = getDeclarationOfCalledMethod(anSNode, aMethodCall);
				int aCallerNumberOfNestingFors = numberOfNestingFors(aCallerMethodSNode);
				aMaxNestingLevel = Math.max(aCallerNumberOfNestingFors, aMaxNestingLevel);				
			}
			return retVal + aMaxNestingLevel;
		}
		return retVal;
	}
	public static boolean hasOperator (SNode anSNode, String anOperator) {
		boolean retVal = false;
		if (anSNode instanceof AssignmentSNode) {
			AssignmentSNode anAssignmentSNode = (AssignmentSNode) anSNode;
			 retVal = (anAssignmentSNode.getLhsOperators().contains(anOperator) || 
					anAssignmentSNode.getRhsOperators().contains(anOperator)) ;
			if (retVal) {
				return retVal;
			} else {
				List<MethodCall> aMethodCalls = anAssignmentSNode.getRhsCalls();
				for (MethodCall aMethodCall:aMethodCalls) {
					MethodSNode aMethodSNode = getDeclarationOfCalledMethod(anSNode, aMethodCall);
					retVal = hasOperator(aMethodSNode, anOperator);
					if (retVal) {
						return retVal;
					}
					
				}
				return false;
			}
			
		}
		for (SNode aChild:anSNode.getChildren()) {
			retVal = hasOperator(aChild, anOperator);
			if (retVal) {
				return retVal;
			}
		}
		return false;
	}
	public static boolean hasMethodCall (SNode anSNode, String anOperator) {
		boolean retVal = false;
		if (anSNode instanceof AssignmentSNode) {
			AssignmentSNode anAssignmentSNode = (AssignmentSNode) anSNode;
			 retVal = (anAssignmentSNode.getLhsOperators().contains(anOperator) || 
					anAssignmentSNode.getRhsOperators().contains(anOperator)) ;
			if (retVal) {
				return retVal;
			} else {
				List<MethodCall> aMethodCalls = anAssignmentSNode.getRhsCalls();
				for (MethodCall aMethodCall:aMethodCalls) {
					MethodSNode aMethodSNode = getDeclarationOfCalledMethod(anSNode, aMethodCall);
					retVal = hasOperator(aMethodSNode, anOperator);
					if (retVal) {
						return retVal;
					}
					
				}
				return false;
			}
			
		}
		for (SNode aChild:anSNode.getChildren()) {
			retVal = hasOperator(aChild, anOperator);
			if (retVal) {
				return retVal;
			}
		}
		return false;
	}
	public static boolean dependsOn (AssignmentSNode anAssignmentSNode, String aVariable, String aCallIdentifier) {
		// This assignment does not change aVariable
		if (!aVariable.equals(anAssignmentSNode.getLhsFirstIdentifier())) {
			return false;
		}
		return dependsOn(anAssignmentSNode.getExpressionSNode(), aCallIdentifier);
//		List<String> aCallIdentifiers = anAssignmentSNode.getRhsCallIdentifiers();
//		boolean retVal = false;
//		if (aCallIdentifiers != null && aCallIdentifiers.contains(aCallIdentifier)) {
//			return true; // this assignment has aCallIdentifier in the rhs
//		}
//		// check if some referenced rhs variable depends on aCallIdentifier
//		List<String> aReferencedVariableIdentifiers = anAssignmentSNode.getRhsVariableIdentifiers();
//		SNode anAssignmentParent = anAssignmentSNode.getParent();
//		if (anAssignmentParent == null) { // should never be trye
//			return false;
//		}
//		int aLineNumber = anAssignmentSNode.getLineNumber();
//		for (String aReferencedVariableIdentifier:aReferencedVariableIdentifiers ) {
//			if (dependsOn (anAssignmentParent, aLineNumber, aReferencedVariableIdentifier, aCallIdentifier)) {
//				return true;
//			}
//		}
//		return false;
	}
	public static boolean dependsOn (ExpressionSNode anExpressionSNode, String aCallIdentifier) {
		// This assignment does not change aVariable
		
		List<String> aCallIdentifiers = anExpressionSNode.getRhsCallIdentifiers();
		boolean retVal = false;
		if (aCallIdentifiers != null && aCallIdentifiers.contains(aCallIdentifier)) {
			return true; // this assignment has aCallIdentifier in the rhs
		}
		// check if some referenced rhs variable depends on aCallIdentifier
		List<String> aReferencedVariableIdentifiers = anExpressionSNode.getRhsVariableIdentifiers();
		SNode anAssignmentParent = anExpressionSNode.getParent().getParent();
		if (anAssignmentParent == null) { // should never be trye
			return false;
		}
		int aLineNumber = anExpressionSNode.getLineNumber();
		for (String aReferencedVariableIdentifier:aReferencedVariableIdentifiers ) {
			if (dependsOn (anAssignmentParent, aLineNumber, aReferencedVariableIdentifier, aCallIdentifier)) {
				return true;
			}
		}
		return false;
	}
	public static Set<AssignmentSNode> assignmentsToSharedVariables(SNode anSNode) {
		Set<AssignmentSNode> retVal =  new HashSet();
		fillAssignmentsToShared(anSNode, retVal);
		return retVal;
		
	}
	public static Set<AssignmentSNode> assignmentsToSharedArrays(SNode anSNode) {
		Set<AssignmentSNode> anAllSharedAssignments =  assignmentsToSharedVariables(anSNode);
		Set<AssignmentSNode> aRetVal = new HashSet();
		for (AssignmentSNode anAssignmentSNode:anAllSharedAssignments) {
			if (anAssignmentSNode.getLhsSubscripts().length > 0) {
				aRetVal.add(anAssignmentSNode);
			}
		}
		return aRetVal;
		
	}
	public static Set<AssignmentSNode> assignmentsToParallelCriticalSharedVariables(SNode anSNode) {
		Set<AssignmentSNode> anAllSharedAssignments =  assignmentsToSharedVariables(anSNode);
		Set<AssignmentSNode> aRetVal = new HashSet();
		for (AssignmentSNode anAssignmentSNode:anAllSharedAssignments) {
			if (anAssignmentSNode.isInParallel() &&
					anAssignmentSNode.isInCritical()) {
				aRetVal.add(anAssignmentSNode);
			}
		}
		return aRetVal;
		
	}
	public static Set<AssignmentSNode> assignmentsToNonParallelCriticalSharedVariables(SNode anSNode) {
		Set<AssignmentSNode> anAllSharedAssignments =  assignmentsToSharedVariables(anSNode);
		Set<AssignmentSNode> aRetVal = new HashSet();
		for (AssignmentSNode anAssignmentSNode:anAllSharedAssignments) {
			if (!anAssignmentSNode.isInParallel() &&
					anAssignmentSNode.isInCritical()) {
				aRetVal.add(anAssignmentSNode);
			}
		}
		return aRetVal;
		
	}
	public static Set<AssignmentSNode> assignmentsToParallelNonCriticalSharedVariables(SNode anSNode) {
		Set<AssignmentSNode> anAllSharedAssignments =  assignmentsToSharedVariables(anSNode);
		Set<AssignmentSNode> aRetVal = new HashSet();
		for (AssignmentSNode anAssignmentSNode:anAllSharedAssignments) {
			if (anAssignmentSNode.isInParallel() &&
					!anAssignmentSNode.isInCritical()) {
				aRetVal.add(anAssignmentSNode);
			}
		}
		return aRetVal;
		
	}
    public static void fillAssignmentsToShared(SNode anSNode, Set<AssignmentSNode> retVal) {
    	if (anSNode instanceof AssignmentSNode) {
			AssignmentSNode anAssignmentSNode = (AssignmentSNode) anSNode;
			String anLHS = anAssignmentSNode.getLhsFirstIdentifier();
			if (isSharedVariable(anSNode, anLHS)) {
				retVal.add(anAssignmentSNode);
				return;
			}
		}
    	for (SNode aChild:anSNode.getChildren()) {
    		fillAssignmentsToShared(aChild, retVal);
    	}
		
	}
    public static void fillInstancesOfNodeType(Class<? extends SNode> aNodeType, SNode anSNode, Set<SNode> retVal) {
    	if (aNodeType.isAssignableFrom(anSNode.getClass())) {
			
				retVal.add(anSNode);
				return;
			}
		
    	for (SNode aChild:anSNode.getChildren()) {
    		fillInstancesOfNodeType(aNodeType, aChild, retVal);
    	}
		
	}
    public static Set<AssignmentSNode>  assignmentSNodes(SNode anSNode) {
    	Set retVal = new HashSet();    	
    	fillInstancesOfNodeType(AssignmentSNode.class, anSNode, retVal );
    	return retVal;
	}
   
    
    public static Set<OMPParallelSNode>  ompParallelSNodes(SNode anSNode) {
    	Set retVal = new HashSet();    	
    	fillInstancesOfNodeType(OMPParallelSNode.class, anSNode, retVal );
    	return retVal;
	}
//    public static void fillOMPParallelSNodes(SNode anSNode, Set<OMPParallelSNode> retVal) {
//    	if (anSNode instanceof OMPParallelSNode) {
//    		retVal.add((OMPParallelSNode) anSNode);
//		}
//    	for (SNode aChild:anSNode.getChildren()) {
//    		fillOMPParallelSNodes(aChild, retVal);
//    	}		
//	}
    public static Set<ForSNode>  forSNodes(SNode anSNode) {
    	Set retVal = new HashSet();    	
    	fillInstancesOfNodeType(ForSNode.class, anSNode, retVal );
    	return retVal;
	}
//    public static void fillForSNodes(SNode anSNode, Set<ForSNode> retVal) {
//    	if (anSNode instanceof ForSNode) {
//    		retVal.add((ForSNode) anSNode);
//		}
//    	for (SNode aChild:anSNode.getChildren()) {
//    		fillForSNodes(aChild, retVal);
//    	}		
//	}
    public static Set<OMPForSNode>  ompForSNodes(SNode anSNode) {
    	Set retVal = new HashSet();    	
    	fillInstancesOfNodeType(OMPForSNode.class, anSNode, retVal );
    	return retVal;
	}
//    public static void fillOMPForSNodes(SNode anSNode, Set<OMPForSNode> retVal) {
//    	if (anSNode instanceof OMPForSNode) {
//    		retVal.add((OMPForSNode) anSNode);
//		}
//    	for (SNode aChild:anSNode.getChildren()) {
//    		fillOMPForSNodes(aChild, retVal);
//    	}		
//	}
    public static Set<OMPForSNode> ompReducingForNodes(SNode anSNode) {
		Set<OMPForSNode> anAllOMPForSNodes =  ompForSNodes(anSNode);
		Set<OMPForSNode> aRetVal = new HashSet();
		for (OMPForSNode anOMPForSNode:anAllOMPForSNodes) {
			if (anOMPForSNode.getReductionOperation() != null) {
				aRetVal.add(anOMPForSNode);
			}
		}
		return aRetVal;		
	}
    public static Set<AssignmentSNode> assignmentsToOMPReducingForNode(OMPForSNode anOMPForSNode) {
    	String aReductionVariable = anOMPForSNode.getReductionVariable();
    	return directAssignmentsOfVariableAndItsAliases(anOMPForSNode, aReductionVariable)	;
    	
    }
	public static boolean dependsOn (SNode anSNode, int aVariableLineNumber, String aVariable, String aCallIdentifier) {
		List<SNode> aListSNodes = anSNode.getChildren();
		boolean retVal = false;
		/*
		 * Should probably ignore line number as it assumes straight line code
		 */
		for (int i = aVariableLineNumber; i >= 0; i--) {
			SNode anSNodeChild = aListSNodes.get(i);
			if (anSNodeChild instanceof AssignmentSNode) {
				// does this statement in anSNode directly invoke aCallIdentifier 
				if (dependsOn((AssignmentSNode) anSNodeChild, aVariable, aCallIdentifier))
					return true;
			} else if (!anSNode.isLeaf()) {
					// child is overriding the variable so forget checking its assignment statements
					if (anSNodeChild.getLocalVariableIdentifiers().contains(aVariable)) {
						continue;
					}
					// some subblock of anSNode that has access to aVariable changes variable

					if (dependsOn(anSNodeChild, anSNodeChild.getChildren().size() - 1, aVariable, aCallIdentifier)) {
						return true;
					}
			}
			
		}
		// none of the statements in anSNode or its descendents  have the required call
		// is the variable a  method parameter 
		if (anSNode instanceof MethodSNode) {
			MethodSNode aMethodSNode = (MethodSNode) anSNode;
			
			int aParameterNumber = aMethodSNode.getLocalVariableIdentifiers().indexOf(aVariable);
			if (aParameterNumber != -1) {
				List <MethodCall> aCalls = aMethodSNode.getCalls();
				for (MethodCall aCall:aCalls) {
//					if (!aCall.getMethodActuals().contains(aVariable))
//						continue;
//					
					MethodSNode aCallerSNode = getDeclarationOfCalledMethod(aMethodSNode, aCall);
					if (dependsOn(aMethodSNode, aCallerSNode.getLineNumber(), aCallerSNode.getLocalVariableIdentifiers().get(aParameterNumber), aCallIdentifier));
//				    if (aCallerDepends) {
				    	return true;
//				    }
				}
				return false;
				// need to find all callers of method and see if any of the aliases for the variable in these
				// calls depend on aCallIndentifier
			}			
			
		} else if (anSNode.getLocalVariableIdentifiers().contains(aVariable)) {
			// before going to the parent node, let us see if aVariable is declared here as a non  parameter 

			return false; // no point going to parent
		}
		// not a local variable (parameter or declarated variable)
		SNode anSNodeParent = anSNode.getParent() ;
		if (anSNodeParent == null)  {
			return false;
		}
		int anSNodeLineNumber = anSNodeParent.getChildren().indexOf(anSNode);
		return dependsOn(anSNodeParent, anSNodeLineNumber, aVariable, aCallIdentifier);
		
	}
	public static Set<AssignmentSNode> assignmentsOfVariableAliases (SNode anSNode,  String aVariable) {
		Set<AssignmentSNode> retVal = new HashSet();
		fillDirectAssignmentsOfVariableAliases(anSNode, aVariable, retVal);
		return retVal;
	}
	public static void fillDirectAssignmentsOfVariableAliases (SNode anSNode,  String aVariable, Set<AssignmentSNode> retVal) {
		if (anSNode instanceof MethodCall) {
			MethodCall aMethodCall = (MethodCall) anSNode;
			int aParameterNumber = aMethodCall.getMethodActualIdentifiers().indexOf(aVariable);
			if (aParameterNumber < 0) {
				return;
			}
			MethodSNode aDeclaringMethodSNode = getDeclarationOfCalledMethod(anSNode, aMethodCall);
			String aFormalParameter = aDeclaringMethodSNode.getLocalVariableIdentifiers().get(aParameterNumber);
//			Set<AssignmentSNode> aCallAssignments = ;
			fillDirectAssignmentsOfVariableAliases(aDeclaringMethodSNode, aFormalParameter, retVal);
		} else if (anSNode instanceof MethodSNode)	{
			MethodSNode aMethodSNode = (MethodSNode) anSNode;
			int aParameterNumber = aMethodSNode.getLocalVariableIdentifiers().indexOf(aVariable);
			if (aParameterNumber < 0)
				return;
			List<MethodCall> aCalls = aMethodSNode.getCalls();
			for (MethodCall aMethodCall:aCalls) {
				MethodSNode aCallerMethodSNode = getDeclarationOfCalledMethod(anSNode, aMethodCall);
				if (aCallerMethodSNode != null) {
					String anAlias = aCallerMethodSNode.getLocalVariableIdentifiers().get(aParameterNumber);
					fillDirectAssignmentsOfVariableAliases(aCallerMethodSNode, anAlias, retVal);

				}

			}
		}
		
		else {
			List<SNode> aChildren = anSNode.getChildren();
			for (SNode aChild:aChildren) {
				fillDirectAssignmentsOfVariableAliases(aChild, aVariable, retVal);
			}
		} 	
		
	}
	
	/*
	 * will not consider assignments to variables in the RHS of these assignments
	 */
	public static Set<AssignmentSNode> directAssignmentsOfVariableAndItsAliases (SNode anSNode,  String aVariable) {
		Set<AssignmentSNode> retVal = new HashSet();
		fillDirectAssignmentsOfVariableAndItsAliases(anSNode, aVariable, retVal);
		return retVal;
	}
	
//	public static Set<AssignmentSNode> assignmentsEffectingVariableAndItsAliases (SNode anSNode,  String aVariable) {
//		Set<AssignmentSNode> retVal = directAssignmentsOfVariableAndItsAliases(anSNode, aVariable);
//		
//	}
	public static void fillDirectAssignmentsOfVariableAndItsAliases (SNode anSNode,  String aVariable, Set<AssignmentSNode> retVal) {
		if (anSNode instanceof AssignmentSNode) {
			AssignmentSNode anAssignmentSNode = (AssignmentSNode) anSNode;
			if (anAssignmentSNode.getLhsFirstIdentifier().equals(aVariable)) {
				retVal.add(anAssignmentSNode);
			}
		}
		
		else if (anSNode instanceof MethodCall) {
			MethodCall aMethodCall = (MethodCall) anSNode;
			int aParameterNumber = aMethodCall.getMethodActualIdentifiers().indexOf(aVariable);
			if (aParameterNumber < 0) {
				return;
			}
			MethodSNode aDeclaringMethodSNode = getDeclarationOfCalledMethod(anSNode, aMethodCall);
			String aFormalParameter = aDeclaringMethodSNode.getLocalVariableIdentifiers().get(aParameterNumber);
//			Set<AssignmentSNode> aCallAssignments = ;
			fillDirectAssignmentsOfVariableAndItsAliases(aDeclaringMethodSNode, aFormalParameter, retVal);
		} else {
			List<SNode> aChildren = anSNode.getChildren();
			for (SNode aChild:aChildren) {
				fillDirectAssignmentsOfVariableAndItsAliases(aChild, aVariable, retVal);
			}
		}		
		
	}
	
	public static RootOfFileSNode getRootOfFileNode(SNode aCurrentSNode ) {
		if (aCurrentSNode instanceof RootOfFileSNode) {
			return (RootOfFileSNode) aCurrentSNode;
		}
		SNode aParentSNode = aCurrentSNode.getParent() ;
		
		if (aParentSNode == null) {
			return null;
		}
		
		return getRootOfFileNode(aParentSNode);
		
	}
	public static boolean match (MethodSNode aMethodSNode, MethodCall aMethodCall) {
		return aMethodSNode.getMethodName().equals(aMethodCall.getMethodName()) 
				&& aMethodSNode.getLocalVariableIdentifiers().size() == aMethodCall.getMethodActuals().size();
	}
	public static DeclarationSNode getDeclarationOfVariableIdentifier(SNode aCurrentSNode, String anIdentifier) {
		if (aCurrentSNode == null) {
			return null;
		}
		
		
		int anIndex = aCurrentSNode.getLocalVariableIdentifiers().indexOf(anIdentifier);
		if (anIndex < 0) {
			return getDeclarationOfVariableIdentifier(aCurrentSNode.getParent(), anIdentifier);
		}
		DeclarationSNode retVal = aCurrentSNode.getVariableDeclarations().get(anIndex);
//		retVal.getAssignmentsToDeclaredVariable().add(anAssignmentSNode);
//		anAssignmentSNode.setLhsFirstIdentifierDeclaration(retVal);
		return retVal;
	}
	
	public static DeclarationSNode getDeclarationOfAssignedVariable(SNode aCurrentSNode, AssignmentSNode anAssignmentSNode) {
		if (aCurrentSNode == null) {
			return null;
		}
		if (anAssignmentSNode instanceof ADeclaringAssignmentSNode) {
			return (ADeclaringAssignmentSNode) anAssignmentSNode;
		}
		int anIndex = aCurrentSNode.getLocalVariableIdentifiers().indexOf(anAssignmentSNode.getLhsFirstIdentifier());
		if (anIndex < 0) {
			return getDeclarationOfAssignedVariable(aCurrentSNode.getParent(), anAssignmentSNode);
		}
		DeclarationSNode retVal = aCurrentSNode.getVariableDeclarations().get(anIndex);
//		retVal.getAssignmentsToDeclaredVariable().add(anAssignmentSNode);
//		anAssignmentSNode.setLhsFirstIdentifierDeclaration(retVal);
		return retVal;
	}
	
	public static MethodSNode getDeclarationOfCalledMethod(SNode aCurrentSNode, MethodCall aMethodCall ) {
		SNode aRootNode = getRootOfFileNode(aCurrentSNode);
		for (SNode aChild:aRootNode.getChildren()) {
			if (aChild instanceof MethodSNode) {
				MethodSNode aMethodSNode = (MethodSNode) aChild;
				if (match (aMethodSNode, aMethodCall)) {
					return aMethodSNode;
				}
			}
		}
		return null; // this should never happen;
	}
	
	public static RootOfProgramSNode getRootOfProgramSNode(String aSource) {
		RootOfProgramSNode retVal = new ARootOfProgramSNode();
		Map<String, StringBuffer> aFileNameToContents = ABasicTextManager.extractFileContents(aSource);
		for (String aFileName:aFileNameToContents.keySet()) {
			StringBuffer aFileContents = aFileNameToContents.get(aFileName);
//			List<OpenMPPragma> anOpenMPPragmas = OpenMPUtils.getOpemMPPragmas(aFileContents);
			RootOfFileSNode anSNode = OMPSNodeUtils.getSNode(aFileName, aFileContents);
			retVal.getFileNameToSNode().put(aFileName, anSNode);
			anSNode.setParent(retVal);
//			System.out.println("file name:" + aFileName);
//			System.out.println("pragmas:" + anSNode);
		}
		processExternalMethodSNodes(retVal);
		setParentOfParameterDeclarations(retVal);
		processIndirectAssignments(retVal);
		return retVal;
	}
//	public static void processIndirectAssignments (S aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode) {
//		for (SNode anSNode:aRootOfFileSNode.getChildren()) {
//			-----
//		}
//	}
	public static void setParentOfParameterDeclarations(RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode) {
		for (SNode anSNode:aRootOfFileSNode.getChildren()) {
			if (anSNode instanceof MethodSNode) {
				setParentOfParameterDeclarations(aRootOfProgramSNode, aRootOfFileSNode, (MethodSNode) anSNode);
			}
		}
	}
	public static void setParentOfParameterDeclarations (RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode, MethodSNode aMethodSNode) {
		List<DeclarationSNode> aDeclarations = aMethodSNode.getVariableDeclarations();
		for (DeclarationSNode aDeclaration:aDeclarations) {
			if (aDeclaration.getParent() == null) {
				aDeclaration.setParent(aMethodSNode);
			}
		}
	}
	public static void setParentOfParameterDeclarations (RootOfProgramSNode aRootOfProgramSNode) {
		for (String aFileName:aRootOfProgramSNode.getFileNameToSNode().keySet()) {
			RootOfFileSNode aRootOfFileSNode = aRootOfProgramSNode.getFileNameToSNode().get(aFileName);
			setParentOfParameterDeclarations(aRootOfProgramSNode, aRootOfFileSNode);
			
		}

	}
	public static void processExternalMethodSNodes (RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode) {
		for (SNode anSNode:aRootOfFileSNode.getChildren()) {
			if (anSNode instanceof ExternalMethodSNode) {
				processExternalMethodSNode(aRootOfProgramSNode, aRootOfFileSNode, (ExternalMethodSNode) anSNode);
			}
		}
	}

	public static void processExternalMethodSNode (RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode, ExternalMethodSNode anExternalMethodSNode) {
		MethodSNode aMethodSNode = aRootOfProgramSNode.getExternalToInternalMethod().get(anExternalMethodSNode.toString());
		if (aMethodSNode == null) {
			aMethodSNode = findMethodSNode(aRootOfProgramSNode, aRootOfFileSNode, anExternalMethodSNode);
			if (aMethodSNode != null) {
				aRootOfProgramSNode.getExternalToInternalMethod().put(anExternalMethodSNode.toString(),aMethodSNode );
			}
		}
		if (aMethodSNode != null) {
			anExternalMethodSNode.setActualMethodSNode(aMethodSNode);
			aMethodSNode.getCalls().addAll(anExternalMethodSNode.getLocalCalls());
		}
	}
	
	public static MethodSNode findMethodSNode (RootOfProgramSNode aRootOfProgramSNode, RootOfFileSNode aRootOfFileSNode, ExternalMethodSNode anExternalMethodSNode) {
//		MethodSNode foundMethodSNode = null;
		for (String aFileName:aRootOfProgramSNode.getFileNameToSNode().keySet()) {
			if (aFileName.equals(aRootOfFileSNode.getFileName()))
				continue;
			
			RootOfFileSNode aSearchedRootOfFileSNode = aRootOfProgramSNode.getFileNameToSNode().get(aFileName);
			 for (SNode anSNode:aSearchedRootOfFileSNode.getChildren()) {
				if (anSNode instanceof MethodSNode && !(anSNode instanceof ExternalMethodSNode)) {
					if (anSNode.toString().equals(anExternalMethodSNode.toString())) {
						return (MethodSNode) anSNode;
						
					}
//					processExternalMethodSNode(aRootOfProgramSNode, aRootOfFileSNode, (ExternalMethodSNode) anSNode);
				}
			}
		}
		return null;
	}
	public static void processExternalMethodSNodes (RootOfProgramSNode aRootOfProgramSNode) {
		for (String aFileName:aRootOfProgramSNode.getFileNameToSNode().keySet()) {
			RootOfFileSNode aRootOfFileSNode = aRootOfProgramSNode.getFileNameToSNode().get(aFileName);
			processExternalMethodSNodes(aRootOfProgramSNode, aRootOfFileSNode);
			aRootOfFileSNode.getOmp_get_num_threads_SNode().
				setActualMethodSNode(aRootOfProgramSNode.getOmp_get_num_threads_SNode());
			aRootOfFileSNode.getOmp_get_thread_num_SNode().
				setActualMethodSNode(aRootOfProgramSNode.getOmp_get_thread_num_SNode());
			aRootOfFileSNode.getOmp_get_wtime_SNode().
			setActualMethodSNode(aRootOfProgramSNode.getOmp_get_wtime_SNode());
		}

	}
	public static void processIndirectAssignments (SNode anSNode) {
		if (anSNode instanceof ConstDeclarationSNode) {
			return;
		}
		if (anSNode instanceof DeclarationSNode) {
			DeclarationSNode aDeclarationSNode = (DeclarationSNode) anSNode;
			Set<AssignmentSNode> anIndirectAssignments = aDeclarationSNode.getAssignmentsEffectingDeclaredIdentifier();
			if (anIndirectAssignments != null) {
				return; // already assigned
			}
			anIndirectAssignments = new HashSet<>();
			aDeclarationSNode.setAssignmentsEffectingDeclaredIdentifier(anIndirectAssignments);
			Set<AssignmentSNode> aDirectAssignments = aDeclarationSNode.getAssignmentsToDeclaredVariable();
			anIndirectAssignments.addAll(aDirectAssignments);
			Set<AssignmentSNode> anAliasAssignments = assignmentsOfVariableAliases(aDeclarationSNode.getParent(), aDeclarationSNode.getVariableName());
			anIndirectAssignments.addAll(anAliasAssignments);
			for (AssignmentSNode aDirectAssignment:aDirectAssignments) {
				List<String> aVariableIdentifiers = aDirectAssignment.getRhsVariableIdentifiers();
				
				for (String aVariableIdentifier:aVariableIdentifiers) {
					DeclarationSNode aDependeeDeclarationSNode = getDeclarationOfVariableIdentifier(aDirectAssignment, aVariableIdentifier);
					if (aDependeeDeclarationSNode == null) {
						System.err.println("Could not find declaration of:" + aVariableIdentifier + " referenced in:" + aDirectAssignment );
						continue;
					}
					processIndirectAssignments(aDependeeDeclarationSNode);
					Set<AssignmentSNode> aDependeeIndirectAssignments = aDeclarationSNode.getAssignmentsEffectingDeclaredIdentifier();
					anIndirectAssignments.addAll(aDependeeIndirectAssignments);
					
				}
			}
		} else {
			for (SNode aChild: anSNode.getChildren()) {
				processIndirectAssignments(aChild);
			}
		}
		
	}
	
//	public static void fillIndirectAssignments (SNode anSNode, Set<AssignmentSNode> retVal ) {
//		
//	}
	

//	public static void main(String[] args) {
//		List<MethodCall> aTokens = callsIn("foo(bar, hgf)/foo2()*foo3(b, a c,)");
//		System.out.println(aTokens);
//		
//		
////		List<String> aTokens = identifiersIn("a[i] + b*2/3");
////		System.out.println(aTokens);
////		aTokens = numbersIn("a[i] + b*2/3");
////		System.out.println(aTokens);
////		aTokens = operatorsIn("a[i] + b*2/3");
////		System.out.println(aTokens);
////
////		System.out.println(StringUtils.substringBetween("a", "[", "]"));
//	}

}
]]></snapshot>
  </Command>
  <DocumentChange __id="221998" _type="Insert" date="Fri Jan 10 14:08:34 EST 2020" docASTNodeCount="5337" docActiveCodeLength="39440" docExpressionCount="3291" docLength="45703" length="2" offset="43939" starttimestamp="1576666505112" timestamp="2016809463">
    <text><![CDATA[//]]></text>
  </DocumentChange>
  <DocumentChange __id="221999" _type="Insert" date="Fri Jan 10 14:08:34 EST 2020" docASTNodeCount="5332" docActiveCodeLength="39388" docExpressionCount="3287" docLength="45705" length="2" offset="44085" starttimestamp="1576666505112" timestamp="2016809479">
    <text><![CDATA[//]]></text>
  </DocumentChange>
  <Command __id="222048" _type="RunCommand" date="Fri Jan 10 14:11:26 EST 2020" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="2016981138" type="Run" />
  <Command __id="222049" _type="RunCommand" date="Fri Jan 10 14:11:26 EST 2020" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="2016981203" type="Debug" />
  <Command __id="222050" _type="RunCommand" date="Fri Jan 10 14:11:26 EST 2020" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="2016981207" type="Run" />
  <Command __id="222051" _type="RunCommand" date="Fri Jan 10 14:11:26 EST 2020" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="2016981211" type="Debug" />
  <Command __id="222052" _type="RunCommand" date="Fri Jan 10 14:11:26 EST 2020" kind="HitBreakPoint" projectName="(Unknown)" starttimestamp="1576666505112" timestamp="2016981214" type="Run" />
  <Command __id="222053" _type="EHExceptionCommand" date="Fri Jan 10 14:11:26 EST 2020" starttimestamp="1576666505112" timestamp="2016981602" type="Exception">
    <outputString><![CDATA[sum_sequential
Sum: 499500
Took: 0
thread:0 lastIndex:999
_____________________________
sum_parallel_for_reduction
Sum: 499500
Took: 0
thread:0 lastIndex:124
thread:1 lastIndex:249
thread:2 lastIndex:374
thread:3 lastIndex:499
thread:4 lastIndex:624
thread:5 lastIndex:749
thread:6 lastIndex:874
thread:7 lastIndex:999
_____________________________
sum_parallel_for_local_var
Sum: 499500
Took: 0
thread:0 lastIndex:124
thread:1 lastIndex:249
thread:2 lastIndex:374
thread:3 lastIndex:499
thread:4 lastIndex:624
thread:5 lastIndex:749
thread:6 lastIndex:874
thread:7 lastIndex:999
_____________________________
sum_parallel
Sum: 499500
Took: 0
_____________________________
]]></outputString>
  </Command>
  <Command __id="222054" _type="DiffBasedFileOpenCommand" date="Fri Jan 10 14:11:36 EST 2020" docASTNodeCount="1" docActiveCodeLength="1642" docExpressionCount="0" docLength="1924" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="2016991786">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\my_sum_main.cpp]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"#include <iostream>¬∂#include <omp.h>¬∂¬∂using namespace std;¬∂//need to declare headers of external functions called¬∂void sum_sequential(double* array, int size);¬∂void sum_parallel_for_reduction(double* array, int size);¬∂void sum_parallel(double* array, int size);¬∂void sum_parallel_for_local_var(double* array, int size);¬∂¬∂// if this main is used to call functions to do other computations¬∂// then those headers should also be declared here¬∂¬∂const int SIZE = 1000;¬∂void initArray (double* array, int size ) {¬∂	for(int i = 0; i < size; i++)¬∂			array[i]=i;¬∂}¬∂/**¬∂ * Called by each of the summing alternatives¬∂ */¬∂void printSumWithTimes (int sum, int start, int end) {¬∂	cout << "Sum: " << sum << endl;¬∂	cout << "Took: " << end - start << endl;¬∂}¬∂void printNumThreads() {¬∂	cout << "threads:" << omp_get_num_threads() << endl;¬∂}¬∂/**¬∂ * an array to learn how much concurrency occcurred¬∂ */¬∂int MAX_THREADS = 100;¬∂double* threadsLastIndex = new double[MAX_THREADS];¬∂int numThreads;¬∂¬∂¬∂void recordThreadIndex(int index) {¬∂	int thread =  omp_get_thread_num();¬∂	if (thread >= MAX_THREADS) {¬∂		return;¬∂	}¬∂	threadsLastIndex[thread] = index;¬∂	numThreads = omp_get_num_threads();¬∂}¬∂void initThreadRecording() {¬∂	numThreads = 0;¬∂	for (int i = 0; i < MAX_THREADS; i++) {¬∂		threadsLastIndex[i] = -1;¬∂	}¬∂}¬∂¬∂void printThreadLastIndex() {¬∂	for (int i = 0; i < numThreads; i++) {¬∂		cout << "thread:" << i << " lastIndex:" << threadsLastIndex[i] << endl;¬∂	}¬∂	cout << "_____________________________" << endl;¬∂}¬∂¬∂¬∂int main()¬∂{¬∂	double* array = new double[SIZE];¬∂	initArray(array, SIZE);¬∂	initThreadRecording();¬∂	sum_sequential(array, SIZE);¬∂	printThreadLastIndex();¬∂	initThreadRecording();¬∂	sum_parallel_for_reduction(array, SIZE);¬∂	printThreadLastIndex();¬∂	initThreadRecording();¬∂	sum_parallel_for_local_var(array, SIZE);¬∂	printThreadLastIndex();¬∂	initThreadRecording();¬∂	sum_parallel(array, SIZE);¬∂	printThreadLastIndex();¬∂	initThreadRecording();¬∂}¬∂")]]]></diff>
  </Command>
  <Command __id="222055" _type="MoveCaretCommand" caretOffset="1500" date="Fri Jan 10 14:11:37 EST 2020" docOffset="1500" starttimestamp="1576666505112" timestamp="2016992321" />
  <Command __id="222056" _type="DiffBasedFileOpenCommand" date="Fri Jan 10 14:11:53 EST 2020" docASTNodeCount="1" docActiveCodeLength="659" docExpressionCount="0" docLength="747" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="2017008726">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\my_sum_parallel_for_local_var.cpp]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"#include <iostream>¬∂#include <omp.h>¬∂¬∂using namespace std;¬∂¬∂void printSumWithTimes (int sum, int start, int end);¬∂void printNumThreads();¬∂void recordThreadIndex(int index);¬∂void sum_parallel_for_local_var(double* array, int size)¬∂{¬∂	cout << "sum_parallel_for_local_var\n";¬∂¬∂	double start = omp_get_wtime();¬∂¬∂	double sum = 0;¬∂¬∂	int a, b;¬∂//¬∂//	for (int i = 0; i < size; i++) {¬∂//			sum += array[i];¬∂//			recordThreadIndex(i);¬∂//	}¬∂¬∂    #pragma omp parallel shared (sum, start) private (a, b)¬∂	{¬∂		double local_sum = 0;¬∂¬∂		#pragma omp for¬∂		for(int i = 0; i < size; i++) {¬∂			local_sum += array[i];¬∂			recordThreadIndex(i);¬∂		}¬∂¬∂		#pragma omp critical¬∂		sum += local_sum;¬∂	}¬∂¬∂	double end = omp_get_wtime();¬∂¬∂	printSumWithTimes(sum, start, end);¬∂	¬∂}¬∂")]]]></diff>
  </Command>
  <Command __id="222057" _type="MoveCaretCommand" caretOffset="621" date="Fri Jan 10 14:11:54 EST 2020" docOffset="621" starttimestamp="1576666505112" timestamp="2017009098" />
  <Command __id="222058" _type="DiffBasedFileOpenCommand" date="Fri Jan 10 14:12:54 EST 2020" docASTNodeCount="1" docActiveCodeLength="602" docExpressionCount="0" docLength="709" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="2017069579">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\my_sum_parallel_for_reduction.cpp]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"#include <iostream>¬∂#include <omp.h>¬∂¬∂using namespace std;¬∂¬∂//const int SIZE = 1000;¬∂void printSumWithTimes(int sum, int start, int end);¬∂void printNumThreads();¬∂void recordThreadIndex(int index);¬∂"), Diff(INSERT,"void add(double *p, int anIncrement) {¬∂	*p += anIncrement;¬∂}¬∂"), Diff(EQUAL,"void sum_parallel_for_reduction(double* array, int size) {¬∂	cout << "sum_parallel_for_reduction\n";¬∂¬∂	double start = omp_get_wtime();¬∂¬∂	double sum = 0;¬∂    #pragma omp  parallel for reduction ( + : sum )¬∂//    #pragma omp  for reduction ( + : sum )¬∂¬∂//	#pragma omp  for¬∂¬∂	for (int i = 0; i < size; i++) {¬∂"), Diff(INSERT,"//"), Diff(EQUAL,"		sum += array[i];¬∂"), Diff(INSERT,"		add(& sum, array[i] );"), Diff(EQUAL,"¬∂		recordThreadIndex(i);¬∂	}¬∂¬∂	double end = omp_get_wtime();¬∂¬∂	printSumWithTimes(sum, start, end);¬∂¬∂}¬∂")]]]></diff>
    <snapshot><![CDATA[#include <iostream>
#include <omp.h>

using namespace std;

//const int SIZE = 1000;
void printSumWithTimes(int sum, int start, int end);
void printNumThreads();
void recordThreadIndex(int index);
void add(double *p, int anIncrement) {
	*p += anIncrement;
}
void sum_parallel_for_reduction(double* array, int size) {
	cout << "sum_parallel_for_reduction\n";

	double start = omp_get_wtime();

	double sum = 0;
    #pragma omp  parallel for reduction ( + : sum )
//    #pragma omp  for reduction ( + : sum )

//	#pragma omp  for

	for (int i = 0; i < size; i++) {
//		sum += array[i];
		add(& sum, array[i] );
		recordThreadIndex(i);
	}

	double end = omp_get_wtime();

	printSumWithTimes(sum, start, end);

}
]]></snapshot>
  </Command>
  <Command __id="222059" _type="MoveCaretCommand" caretOffset="506" date="Fri Jan 10 14:12:54 EST 2020" docOffset="506" starttimestamp="1576666505112" timestamp="2017069881" />
  <Command __id="222060" _type="DiffBasedFileOpenCommand" date="Fri Jan 10 14:13:22 EST 2020" docASTNodeCount="1" docActiveCodeLength="795" docExpressionCount="0" docLength="795" projectName="MyOpenMPTraining" starttimestamp="1576666505112" timestamp="2017097204">
    <filePath><![CDATA[D:\dewan_backup\C\MyOpenMPTraining\src\my_sum_parallel.cpp]]></filePath>
    <diff><![CDATA[[Diff(EQUAL,"#include <iostream>¬∂#include <omp.h>¬∂¬∂using namespace std;¬∂¬∂void printSumWithTimes(int sum, int start, int end);¬∂void printNumThreads();¬∂void recordThreadIndex(int index);¬∂void sum_parallel(double* array, int size) {¬∂	cout << "sum_parallel\n";¬∂¬∂	double start = omp_get_wtime();¬∂¬∂	double sum = 0;¬∂¬∂¬∂    #pragma omp critical¬∂	{¬∂	double sum = 0;¬∂	}¬∂    #pragma omp parallel¬∂	{¬∂		double local_sum = 0;¬∂¬∂		int rank = omp_get_thread_num();¬∂		int threads = omp_get_num_threads();¬∂¬∂		int start_index = (size/threads)*rank;¬∂		int end_index = (size/threads)*(rank+1);¬∂¬∂		if(rank==threads-1)¬∂			end_index=size;¬∂¬∂		for(int i = start_index; i < end_index; i++)¬∂			local_sum += array[i];¬∂¬∂		#pragma omp critical¬∂		sum += local_sum;¬∂	}¬∂¬∂	double end = omp_get_wtime();¬∂¬∂	printSumWithTimes(sum, start, end);¬∂¬∂¬∂}¬∂")]]]></diff>
  </Command>
  <Command __id="222061" _type="MoveCaretCommand" caretOffset="297" date="Fri Jan 10 14:13:22 EST 2020" docOffset="297" starttimestamp="1576666505112" timestamp="2017097628" />
  <Command __id="222063" _type="SelectTextCommand" caretOffset="280" date="Fri Jan 10 14:13:45 EST 2020" end="280" start="265" starttimestamp="1576666505112" timestamp="2017120711" />
</Events>
